Compiling Program: \\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\WebApp.src
Memory Available: 945152000
1>Use AllWebAppClasses.pkg
Using pre-compiled package ALLWEBAPPCLASSES.PKG
Including file: AllWebAppClasses.pkd    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\AllWebAppClasses.pkd)
22058>Use cWebMenuItemLoadView.pkg
22058>Use cWqWebApp.pkg
Including file: cWqWebApp.pkg    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\cWqWebApp.pkg)
22058>>>Use cWebApp.pkg
22058>>>
22058>>>Define C_nwMenuBar    for "menubar"
22058>>>Define C_nwScrollBars for "scrollbars"
22058>>>Define C_nwStatusBar  for "status"
22058>>>Define C_nwTitleBar   for "titlebar"
22058>>>Define C_nwToolBar    for "toolbar"
22058>>>Define C_nwResizable  for "resizable"
22058>>>
22058>>>Class cWqWebApp is a cWebApp
22059>>>    
22059>>>    Procedure Construct_Object
22061>>>        Forward Send Construct_Object
22063>>>        
22063>>>        Property String[] pasNewWindowOptions
22064>>>    End_Procedure
22065>>>    
22065>>>    Procedure Set NewWindowOption String sOption Boolean bOn
22067>>>        String[] asOpts
22068>>>        Integer  i iPos
22068>>>        
22068>>>        Get pasNewWindowOptions to asOpts
22069>>>        Move (SizeOfArray(asOpts)) to iPos
22070>>>        
22070>>>        For i from 0 to (SizeOfArray(asOpts) - 1)
22076>>>>
22076>>>            If (Left(asOpts[i], (Pos("=", asOpts[i]) - 1)) = sOption) Move i to iPos
22079>>>        Loop
22080>>>>
22080>>>        
22080>>>        Move (sOption + "=" + If(bOn, "yes", "no")) to asOpts[iPos]
22081>>>        Set pasNewWindowOptions to asOpts
22082>>>    End_Procedure
22083>>>    
22083>>>    Procedure ClearWindowOptions
22085>>>        String[] asEmpty
22086>>>        
22086>>>        Set pasNewWindowOptions to asEmpty
22087>>>    End_Procedure
22088>>>    
22088>>>    Procedure NavigateNewWindow String sUrl Integer iWidth Integer iHeight
22090>>>        String[] aParams asOpts
22092>>>        String   sOpts
22092>>>        Integer  i
22092>>>        
22092>>>        Move sURL               to aParams[0]
22093>>>        Move iWidth             to aParams[1]
22094>>>        Move iHeight            to aParams[2]
22095>>>        
22095>>>        Get pasNewWindowOptions to asOpts
22096>>>        
22096>>>        For i from 0 to (SizeOfArray(asOpts) - 1)
22102>>>>
22102>>>            Move (sOpts + ", " + asOpts[i]) to sOpts
22103>>>        Loop
22104>>>>
22104>>>        
22104>>>        Move sOpts              to aParams[3]
22105>>>        
22105>>>        Send ClientAction "navigateNewWindow" aParams
22106>>>    End_Procedure
22107>>>    
22107>>>End_Class
22108>
22108>Register_Function PublicPath   Returns String
22108>Register_Function piUserRights Returns Integer
22108>
22108>Object oApplication is a cApplication
22110>End_Object
22111>
22111>Object oWebApp is a cWqWebApp
22113>    Set psTheme to "Df_Web_Creme"
22114>    Set peLoginMode to lmLoginSupported
22115>    Set psDateFormat to "dd/mm/yyyy"
22116>    
22116>    Object oCommandbar is a cWebCommandBar                
22118>        Object oMenuBar is a cWebMenuBar
22120>            Object oFileMenu is a cWebMenuItem
22122>                Set psCaption to C_$File
22123>                
22123>                Object oClearMenuItem is a cWebMenuClear
22125>                End_Object  
22126>                             
22126>                Object oClearAllMenuItem is a cWebMenuClearAll
22128>                End_Object  
22129>                
22129>                Object oPromptMenuItem is a cWebMenuPrompt
22131>                    Set pbBeginGroup to True
22132>                End_Object  
22133>                               
22133>                Object oFindMenuItem is a cWebMenuFind
22135>                End_Object  
22136>
22136>                Object oNextMenuItem is a cWebMenuFindNext
22138>                End_Object  
22139>
22139>                Object oPreviousMenuItem is a cWebMenuFindPrevious
22141>                End_Object  
22142>                
22142>                Object oLastMenuItem is a cWebMenuFindLast
22144>                End_Object                
22145>                                
22145>                Object oFirstMenuItem is a cWebMenuFindFirst
22147>                End_Object  
22148>                
22148>                Object oSaveMenuItem is a cWebMenuSave
22150>                    Set pbBeginGroup to True
22151>                End_Object  
22152>                
22152>                Object oDeleteMenuItem is a cWebMenuDelete
22154>                End_Object  
22155>                
22155>                Object oLoginMenuItem is a cWebMenuItem
22157>                    Set psCaption to C_$LogIn
22158>                    Set pbBeginGroup to True
22159>                    Set psCSSClass to "WebLoginMenuItem"
22160>
22160>                    Procedure OnClick
22163>                        Send RequestLogin to ghoWebSessionManager
22164>                    End_Procedure
22165>                    
22165>                    Procedure OnLoad
22168>                        Integer eLoginMode
22168>                        Handle hoLogin
22168>                        Get phoLoginView to hoLogin
22169>                        Get peLoginMode to eLoginMode
22170>                        WebSet pbRender to  (hoLogin and eLoginMode<>lmLoginNone)
22171>                    End_Procedure  // OnLoad
22172>                    
22172>                End_Object  
22173>
22173>                Object oLogoutMenuItem is a cWebMenuItem
22175>                    Set psCaption to C_$LogOut
22176>                    Set psCSSClass to "WebLogoutMenuItem"
22177>
22177>                    Procedure OnClick
22180>                        Send RequestLogOut of ghoWebSessionManager
22181>                    End_Procedure
22182>
22182>                    Procedure OnLoad
22185>                        Integer eLoginMode
22185>                        Handle hoLogin
22185>                        Get phoLoginView to hoLogin
22186>                        Get peLoginMode to eLoginMode
22187>                        WebSet pbRender to  (hoLogin and eLoginMode<>lmLoginNone)
22188>                    End_Procedure
22189>                End_Object  
22190>            End_Object  
22191>    
22191>            Object oViewMenu is a cWebMenuItem
22193>                Set psCaption to C_$View
22194>
22194>                Object oIntroviewMenuItem1 is a cWebMenuItemLoadView
22196>                    Set psCaption to "Introduction"
22197>                    Set psLoadViewOnClick to "oIntroduction"
22198>                    Set psImage to "Images/Information.png"
22199>                End_Object
22200>                
22200>                Object oWebQueryDefinitionMenuItem1 is a cWebMenuItemLoadView
22202>                    Set psCaption to "WebQuery Definition"
22203>                    Set psLoadViewOnClick to "oWebQuery"
22204>                    Set psImage to "Custom/report.png"
22205>                    
22205>                    Procedure OnChangeRights
22208>                        WebSet pbEnabled to (IsLoggedIn(ghoWebSessionManager))
22209>                    End_Procedure
22210>                    
22210>                End_Object
22211>
22211>            End_Object  
22212>            
22212>            Object oReportMenu is a cWebMenuItem
22214>                Set psCaption to "Reports"
22215>                
22215>                Object oUsersListReport is a cWebMenuItem
22217>                    Set psCaption to "Users List (new tab)"
22218>                    Set psImage to "Custom/report.png"
22219>                    
22219>                    Procedure OnClick
22222>                        Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Users List.wqr")
22223>                    End_Procedure
22224>                    
22224>                End_Object
22225>                
22225>                Object oCustomerListReport is a cWebMenuItem
22227>                    Set psCaption to "Customer List (download)"
22228>                    Set psImage to "Custom/report.png"
22229>                    
22229>                    Procedure OnClick
22232>                        Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Customer List.wqr")
22233>                    End_Procedure
22234>                    
22234>                End_Object
22235>                
22235>                Object oSalesPListReport is a cWebMenuItem
22237>                    Set psCaption to "Sales Person List (popup)"
22238>                    Set psImage to "Custom/report.png"
22239>                    
22239>                    Procedure OnClick
22242>                        Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Sales People.wqr")
22243>                    End_Procedure
22244>                    
22244>                    Procedure OnChangeRights
22247>                        WebSet pbRender to (IsLoggedIn(ghoWebSessionManager) and ;                                            (piUserRights(ghoWebSessionManager) > 1))
22248>                    End_Procedure
22249>                    
22249>                End_Object
22250>                
22250>                Object oSalesPPictures is a cWebMenuItem
22252>                    Set psCaption to "Sales Person Pictures"
22253>                    Set psImage to "Custom/report.png"
22254>                    
22254>                    Procedure OnClick
22257>                        Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Sales People Pictures.wqr")
22258>                    End_Procedure
22259>                    
22259>                    Procedure OnChangeRights
22262>                        WebSet pbRender to (IsLoggedIn(ghoWebSessionManager))
22263>                    End_Procedure
22264>                    
22264>                End_Object
22265>                
22265>                Object oOrderDetsRep is a cWebMenuItem
22267>                    Set psCaption to "Order Details 2012 (slow)"
22268>                    Set psImage to "Custom/report.png"
22269>                    
22269>                    Procedure OnClick
22272>                        Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Order Details Report (2012).wqr")
22273>                    End_Procedure
22274>                    
22274>                    Procedure OnChangeRights
22277>                        WebSet pbRender to (IsLoggedIn(ghoWebSessionManager) and ;                                            (piUserRights(ghoWebSessionManager) > 2))
22278>                    End_Procedure
22279>                    
22279>                End_Object
22280>                
22280>                Object oVendorList is a cWebMenuItem
22282>                    Set psCaption  to "Vendor list with image"
22283>                    Set psImage to "Custom/report.png"
22284>                    
22284>                    
22284>                    Procedure OnClick
22287>                        Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Vendor List with Image.wqr")
22288>                    End_Procedure
22289>                    
22289>                    Procedure OnChangeRights
22292>                        WebSet pbRender to (IsLoggedIn(ghoWebSessionManager))
22293>                    End_Procedure
22294>                    
22294>                End_Object
22295>                
22295>                Object oSalesReports is a cWebMenuItem
22297>                    Set pbBeginGroup to True
22298>                    Set psCaption to "Sales Reports"
22299>
22299>                    Procedure OnChangeRights
22302>                        WebSet pbRender to (IsLoggedIn(ghoWebSessionManager) and ;                                            (piUserRights(ghoWebSessionManager) > 2))
22303>                    End_Procedure
22304>                    
22304>                    Object oSalesTotals is a cWebMenuItem
22306>                        Set psCaption to "Sales Totals"
22307>                        Set psImage to "Custom/report.png"
22308>                        
22308>                        Procedure OnClick
22311>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Sales Totals.wqr")
22312>                        End_Procedure
22313>                        
22313>                    End_Object
22314>                    
22314>                    Object oSales2012 is a cWebMenuItem
22316>                        Set psCaption to "Sales in 2012"
22317>                        Set psImage to "Custom/report.png"
22318>                        
22318>                        Procedure OnClick
22321>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Sales in 2012.wqr")
22322>                        End_Procedure
22323>                        
22323>                    End_Object
22324>                    
22324>                End_Object
22325>                
22325>                Object oStockReports is a cWebMenuItem
22327>                    Set psCaption to "Stock Reports"
22328>                    
22328>                    Procedure OnChangeRights
22331>                        WebSet pbRender to (IsLoggedIn(ghoWebSessionManager))
22332>                    End_Procedure
22333>                    
22333>                    Object oStockList is a cWebMenuItem
22335>                        Set psCaption to "Stock List (text)"
22336>                        Set psImage to "Custom/report.png"
22337>                        
22337>                        Procedure OnClick
22340>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Stock List.wqr")
22341>                        End_Procedure
22342>                        
22342>                    End_Object
22343>                    
22343>                    Object oReorderListV is a cWebMenuItem
22345>                        Set psCaption to "Reorder List (view)"
22346>                        Set psImage to "Custom/report.png"
22347>                        
22347>                        Procedure OnClick
22350>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Reorder List (view).wqr")
22351>                        End_Procedure
22352>                        
22352>                    End_Object
22353>                    
22353>                    Object oReorderListT is a cWebMenuItem
22355>                        Set psCaption to "Reorder List (text)"
22356>                        Set psImage to "Custom/report.png"
22357>                        
22357>                        Procedure OnClick
22360>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Reorder List (text).wqr")
22361>                        End_Procedure
22362>                        
22362>                    End_Object
22363>                    
22363>                    Object oReorderListX is a cWebMenuItem
22365>                        Set psCaption to "Reorder List (XML)"
22366>                        Set psImage to "Custom/report.png"
22367>                        
22367>                        Procedure OnClick
22370>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Reorder List (XML).wqr")
22371>                        End_Procedure
22372>                        
22372>                    End_Object
22373>                    
22373>                End_Object
22374>                
22374>                Object oAccoutReports is a cWebMenuItem
22376>                    Set psCaption to "Account Reports"
22377>
22377>                    Procedure OnChangeRights
22380>                        WebSet pbRender to (IsLoggedIn(ghoWebSessionManager) and ;                                            (piUserRights(ghoWebSessionManager) > 3))
22381>                    End_Procedure
22382>                    
22382>                    Object oLargeBalances is a cWebMenuItem
22384>                        Set psCaption to "Large Balances"
22385>                        Set psImage to "Custom/report.png"
22386>                        
22386>                        Procedure OnClick
22389>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Large Balances.wqr")
22390>                        End_Procedure
22391>                        
22391>                    End_Object
22392>                    
22392>                    Object oOverCredit is a cWebMenuItem
22394>                        Set psCaption to "Over Credit Limit (hidden!)"
22395>                        Set psImage to "Custom/report.png"
22396>                        
22396>                        Procedure OnClick
22399>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\..\Over Credit Limit.wqr")
22400>                        End_Procedure
22401>                        
22401>                        Procedure OnChangeRights
22404>                            WebSet pbRender to (IsLoggedIn(ghoWebSessionManager) and ;                                                (piUserRights(ghoWebSessionManager) > 4))
22405>                        End_Procedure
22406>                    
22406>                    End_Object
22407>                    
22407>                    Object oBestCustomers is a cWebMenuItem
22409>                        Set psCaption to "Best Customers (new tab)"
22410>                        Set psImage to "Custom/report.png"
22411>                        
22411>                        Procedure OnClick
22414>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Best Customers.wqr")
22415>                        End_Procedure
22416>                        
22416>                    End_Object
22417>                    
22417>                    Object oBalancesCSV is a cWebMenuItem
22419>                        Set psCaption to "Balances CSV Download"
22420>                        Set psImage to "Custom/report.png"
22421>                        
22421>                        Procedure OnClick
22424>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Balances CSV Download.wqr")
22425>                        End_Procedure
22426>                        
22426>                    End_Object
22427>                    
22427>                End_Object
22428>                
22428>            End_Object            
22429>            
22429>            Object oThemesMenu is a cWebMenuItem
22431>                Set psCaption to "Themes"
22432>
22432>                Object oModernSky is a cWebMenuItem
22434>                    Set psCaption to "Modern Sky"
22435>                    
22435>                    Procedure OnClick 
22438>                        //  Change the theme at runtime
22438>                        WebSet psTheme of oWebApp to "Df_Modern_Sky"
22439>                        
22439>                        //  Update menu
22439>                        Send UpdateSelectedTheme
22440>                    End_Procedure
22441>                End_Object
22442>                                    
22442>                Object oWindowsLike is a cWebMenuItem
22444>                    Set psCaption to "Windows Like"
22445>                    
22445>                    Procedure OnClick 
22448>                        //  Change the theme at runtime
22448>                        WebSet psTheme of oWebApp to "Df_Windows_Like"
22449>                        
22449>                        //  Update menu
22449>                        Send UpdateSelectedTheme
22450>                    End_Procedure
22451>                End_Object
22452>                                                
22452>                Object oHighContrast is a cWebMenuItem
22454>                    Set psCaption to "High Contrast"
22455>                    
22455>                    Procedure OnClick 
22458>                        //  Change the theme at runtime
22458>                        WebSet psTheme of oWebApp to "Df_High_Contrast"
22459>                        
22459>                        //  Update menu
22459>                        Send UpdateSelectedTheme
22460>                    End_Procedure
22461>                End_Object
22462>                
22462>                Object oWebCremeItem is a cWebMenuItem
22464>                    Set psCaption to "Web Creme"
22465>                    Set pbEnabled to False
22466>                    
22466>                    Procedure OnClick
22469>                        //   Change the theme at runtime
22469>                        WebSet psTheme of oWebApp to "Df_Web_Creme"
22470>                        
22470>                        //  Update menu
22470>                        Send UpdateSelectedTheme
22471>                    End_Procedure
22472>                End_Object
22473>                
22473>                Procedure UpdateSelectedTheme
22476>                    String sTheme
22476>                    
22476>                    //  Determine theme
22476>                    WebGet psTheme of oWebApp to sTheme
22477>
22477>                    //  Set enabled state
22477>                    WebSet pbEnabled of (oModernSky)    to (sTheme <> "Df_Modern_Sky")
22478>                    WebSet pbEnabled of (oWindowsLike)  to (sTheme <> "Df_Windows_Like")
22479>                    WebSet pbEnabled of (oHighContrast) to (sTheme <> "Df_High_Contrast")
22480>                    WebSet pbEnabled of (oWebCremeItem) to (sTheme <> "Df_Web_Creme")
22481>                End_Procedure
22482>                
22482>                Procedure OnLoad
22485>                    Send UpdateSelectedTheme
22486>                End_Procedure
22487>                
22487>            End_Object
22488>            
22488>        End_Object  
22489>        
22489>        Object oFindToolBar is a cWebToolBar
22491>            Object oFirstMenuItem is a cWebMenuFindFirst
22493>            End_Object  
22494>    
22494>            Object oPreviousMenuItem is a cWebMenuFindPrevious
22496>            End_Object  
22497>
22497>            Object oFindMenuItem is a cWebMenuFind
22499>            End_Object  
22500>
22500>            Object oNextMenuItem is a cWebMenuFindNext
22502>            End_Object  
22503>            
22503>            Object oLastMenuItem is a cWebMenuFindLast
22505>            End_Object
22506>                           
22506>            Object oPromptMenuItem is a cWebMenuPrompt
22508>            End_Object 
22509>        End_Object
22510>        
22510>        Object oFileToolBar is a cWebToolBar
22512>            Set pbShowCaption to True
22513>            
22513>            Object oClearMenuItem is a cWebMenuClear
22515>            End_Object              
22516>             
22516>            Object oClearAllMenuItem is a cWebMenuClearAll
22518>            End_Object   
22519>                        
22519>            Object oSaveMenuItem is a cWebMenuSave
22521>            End_Object  
22522>            
22522>            Object oDeleteMenuItem is a cWebMenuDelete
22524>            End_Object 
22525>        End_Object
22526>    End_Object
22527>
22527>    Use SessionManager.wo
Including file: SessionManager.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\SessionManager.wo)
22527>>>Use cWebSessionManagerStandard.pkg
Including file: cWebSessionManagerStandard.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\cWebSessionManagerStandard.pkg)
22527>>>>>Use cWebSessionManager.pkg
22527>>>>>Use cWebAppSessionDataDictionary.dd
Including file: cWebAppSessionDataDictionary.dd    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\cWebAppSessionDataDictionary.dd)
22527>>>>>>>Use DataDict.pkg
22527>>>>>>>
22527>>>>>>>Open WebAppSession
Including file: WebAppSession.fd    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\DDSrc\WebAppSession.fd)
22529>>>>>>>Open WebAppUser
Including file: WebAppUser.fd    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\DDSrc\WebAppUser.fd)
22531>>>>>>>
22531>>>>>>>Class cWebAppSessionDataDictionary is a DataDictionary
22532>>>>>>>    
22532>>>>>>>    Procedure Construct_Object
22534>>>>>>>        Forward Send Construct_Object
22536>>>>>>>        Set Main_File to WebAppSession.File_Number
22537>>>>>>>
22537>>>>>>>        Set Add_Server_File to WebAppUser.File_Number
22538>>>>>>>
22538>>>>>>>        Set ParentNullAllowed WebAppUser.File_Number to True
22539>>>>>>>
22539>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
22540>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
22541>>>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
22542>>>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
22543>>>>>>>
22543>>>>>>>        Set Field_Option Field WebAppSession.Active DD_RETAIN to True
22544>>>>>>>        Set Field_Checkbox_Values Field WebAppSession.Active to "Y" "N"
22545>>>>>>>        Set Field_Error Field WebAppSession.Active to 500 "Invalid WebAppSession Active State"
22546>>>>>>>
22546>>>>>>>    End_Procedure
22547>>>>>>>
22547>>>>>>>    Procedure Creating
22549>>>>>>>        DateTime dtCurrentDateTime
22549>>>>>>>        
22549>>>>>>>        Forward Send Creating
22551>>>>>>>        
22551>>>>>>>        //  Init usecounter
22551>>>>>>>        Move 0 to WebAppSession.UseCount
22552>>>>>>>        
22552>>>>>>>        //  Set the creation and access time to the current time
22552>>>>>>>        Move (CurrentDateTime()) to dtCurrentDateTime
22553>>>>>>>    
22553>>>>>>>        Get TimeToString dtCurrentDateTime to WebAppSession.CreateTime
22554>>>>>>>        Get TimeToString dtCurrentDateTime to WebAppSession.LastAccessTime
22555>>>>>>>        
22555>>>>>>>        Move dtCurrentDateTime to WebAppSession.CreateDate
22556>>>>>>>        Move dtCurrentDateTime to WebAppSession.LastAccessDate
22557>>>>>>>    End_Procedure
22558>>>>>>>    
22558>>>>>>>    
22558>>>>>>>    
22558>>>>>>>    //
22558>>>>>>>    //  Converts the given time to an string that can be saved in the database.
22558>>>>>>>    //
22558>>>>>>>    //  Params:
22558>>>>>>>    //      dtTime  Time to convert
22558>>>>>>>    //  Returns:
22558>>>>>>>    //      String with "HH:MM:SS" format
22558>>>>>>>    //
22558>>>>>>>    Function TimeToString DateTime dtTime Returns String
22560>>>>>>>        String sHours sMinutes sSeconds
22560>>>>>>>        
22560>>>>>>>        //  Extract parts
22560>>>>>>>        Move (String(DateGetHour(dtTime))) to sHours
22561>>>>>>>        Move (String(DateGetMinute(dtTime))) to sMinutes
22562>>>>>>>        Move (String(DateGetSecond(dtTime))) to sSeconds
22563>>>>>>>        
22563>>>>>>>        //  Fill out with 0
22563>>>>>>>        If (Length(sHours) = 1) Move ("0" + sHours) to sHours
22566>>>>>>>        If (Length(sMinutes) = 1) Move ("0" + sMinutes) to sMinutes
22569>>>>>>>        If (Length(sSeconds) = 1) Move ("0" + sSeconds) to sSeconds
22572>>>>>>>        
22572>>>>>>>        Function_Return (sHours + ":" + sMinutes + ":" + sSeconds)
22573>>>>>>>    End_Function
22574>>>>>>>    
22574>>>>>>>    //
22574>>>>>>>    //  Sets the time of the datetime variable to the time in the string.
22574>>>>>>>    //
22574>>>>>>>    //  Params:
22574>>>>>>>    //      dtTime  Datetime variable to add time to
22574>>>>>>>    //      sTimeString String with time in the format "HH:MM:SS"
22574>>>>>>>    //  Returns:
22574>>>>>>>    //      dtDateTime with the loaded time
22574>>>>>>>    //
22574>>>>>>>    Function StringToTime DateTime dtTime String sTimeString Returns DateTime
22576>>>>>>>        String sHours sMinutes sSeconds
22576>>>>>>>        
22576>>>>>>>        //  Extract parts
22576>>>>>>>        Move (Mid(sTimeString, 2, 1)) to sHours
22577>>>>>>>        Move (Mid(sTimeString, 2, 4)) to sMinutes
22578>>>>>>>        Move (Mid(sTimeString, 2, 7)) to sSeconds
22579>>>>>>>        
22579>>>>>>>        //  Set to DateTime
22579>>>>>>>        Move (DateSetHour(dtTime, (Integer(sHours)))) to dtTime
22580>>>>>>>        Move (DateSetMinute(dtTime, (Integer(sMinutes)))) to dtTime
22581>>>>>>>        Move (DateSetSecond(dtTime, (Integer(sSeconds)))) to dtTime
22582>>>>>>>        
22582>>>>>>>        Function_Return dtTime
22583>>>>>>>    End_Function
22584>>>>>>>
22584>>>>>>>End_Class
22585>>>>>Use cWebAppUserDataDictionary.dd
Including file: cWebAppUserDataDictionary.dd    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\cWebAppUserDataDictionary.dd)
22585>>>>>>>Use DataDict.pkg
22585>>>>>>>Use cWebResourceManager.pkg
22585>>>>>>>
22585>>>>>>>Open WebAppUser
22587>>>>>>>Open WebAppSession
22589>>>>>>>
22589>>>>>>>Class cWebAppUserDataDictionary is a DataDictionary
22590>>>>>>>    
22590>>>>>>>    Procedure Construct_Object
22592>>>>>>>        Forward Send Construct_Object
22594>>>>>>>        Set Main_File to WebAppUser.File_Number
22595>>>>>>>
22595>>>>>>>        Set Add_Client_File to WebAppSession.File_Number
22596>>>>>>>
22596>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
22597>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
22598>>>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
22599>>>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
22600>>>>>>>    End_Procedure
22601>>>>>>>
22601>>>>>>>End_Class
22602>>>>>
22602>>>>>Class cWebSessionManagerStandard is a cWebSessionManager
22603>>>>>    
22603>>>>>    Procedure Construct_Object
22605>>>>>        Handle hoUserDD hoSessionDD
22605>>>>>        
22605>>>>>        Forward Send Construct_Object
22607>>>>>        
22607>>>>>        Property Handle phoUserDD 0      // Handle to the WebAppUser DDO
22608>>>>>        Property Handle phoSessionDD 0   // Handle to the WebAppSession DDO        
22609>>>>>        
22609>>>>>        Get Create (RefClass(cWebAppUserDataDictionary)) to hoUserDD
22610>>>>>        Get Create (RefClass(cWebAppSessionDataDictionary)) to hoSessionDD
22611>>>>>        Set DDO_Server of hoSessionDD to hoUserDD
22612>>>>>
22612>>>>>        Set phoUserDD to hoUserDD
22613>>>>>        Set phoSessionDD to hoSessionDD
22614>>>>>        Property Boolean pbCreatingNewSession False
22615>>>>>        Property Integer piSessionTimeout 480        
22616>>>>>        Property String psLoginName
22617>>>>>        Property String psUserName ""
22618>>>>>        Property Integer piUserRights 0
22619>>>>>    End_Procedure
22620>>>>>    
22620>>>>>    Function CreateSession String sRemoteAddress Returns String
22622>>>>>        String sSessionKey
22622>>>>>        Integer iErr
22622>>>>>        Boolean bLogWebSession
22622>>>>>        Handle hoSessionDD       
22622>>>>>        Get phoSessionDD to hoSessionDD
22623>>>>>        
22623>>>>>        //  Get session key
22623>>>>>        Forward Get CreateSession sRemoteAddress to sSessionKey
22625>>>>>        
22625>>>>>        Get pbLogWebSession to bLogWebSession
22626>>>>>        If not bLogWebSession Begin
22628>>>>>            Function_Return sSessionKey        
22629>>>>>        End
22629>>>>>>
22629>>>>>
22629>>>>>        //  Store session
22629>>>>>        Send Clear of hoSessionDD
22630>>>>>        Set Field_Changed_Value of hoSessionDD Field WebAppSession.SessionKey to sSessionKey
22631>>>>>        Set Field_Changed_Value of hoSessionDD Field WebAppSession.RemoteAddress to sRemoteAddress
22632>>>>>        Set Field_Changed_Value of hoSessionDD Field WebAppSession.Active to "Y"
22633>>>>>        Get Request_Validate of hoSessionDD to iErr
22634>>>>>        If (iErr) Begin
22636>>>>>            // this should not happen. If it does its a programming error
22636>>>>>            Error DFERR_PROGRAM C_$WebAppSesionValidateFailed
22637>>>>>>
22637>>>>>            Function_Return ""
22638>>>>>        End
22638>>>>>>
22638>>>>>        Send Request_Save of hoSessionDD
22639>>>>>       
22639>>>>>        Function_Return sSessionKey        
22640>>>>>    End_Function
22641>>>>>    
22641>>>>>    
22641>>>>>    Function ValidateSession String sSessionKey Returns Boolean
22643>>>>>        DateTime dtLastAccess dtCurrent
22643>>>>>        TimeSpan tsDiff
22643>>>>>        Integer iErr iSessionTimeout iSpanMinutes
22643>>>>>        Boolean bResult bCreatingNewSession
22643>>>>>        Boolean bLogWebSession bLoadWebApp 
22643>>>>>        Integer eLoginMode
22643>>>>>        String sTime
22643>>>>>        Handle hoSessionDD hoUserDD       
22643>>>>>        
22643>>>>>        Get phoSessionDD to hoSessionDD
22644>>>>>        Get phoUserDD to hoUserDD
22645>>>>>        
22645>>>>>        Get pbLogWebSession to bLogWebSession
22646>>>>>        Get pbLoadWebAppValidateSession of ghoWebApp to bLoadWebApp
22647>>>>>        Get peLoginMode to eLoginMode
22648>>>>>        
22648>>>>>        // for this object, you can only disable logging if login completely is disabled
22648>>>>>        If (not(bLogWebSession) and (eLoginMode<>lmLoginNone)) Begin
22650>>>>>            Error DFERR_PROGRAM C_$WebSessionLoggingMustBeEnabled
22651>>>>>>
22651>>>>>            Function_Return False
22652>>>>>        End
22652>>>>>>
22652>>>>>
22652>>>>>        //  Clear session properties
22652>>>>>        Set psUsername to ""
22653>>>>>        Set psLoginName to ""
22654>>>>>        Set piUserrights to 0
22655>>>>>        
22655>>>>>        If not bLogWebSession Begin
22657>>>>>            Forward Get ValidateSession sSessionKey to bResult
22659>>>>>            Function_Return bResult
22660>>>>>        End        
22660>>>>>>
22660>>>>>        
22660>>>>>        Move False to bResult
22661>>>>>        Get piSessionTimeout to iSessionTimeout 
22662>>>>>        
22662>>>>>        //  Check if session exists
22662>>>>>        Send Clear of hoSessionDD
22663>>>>>        Move sSessionKey to WebAppSession.SessionKey
22664>>>>>        Send Find of hoSessionDD EQ Index.1
22665>>>>>            
22665>>>>>        If (Found) Begin
22667>>>>>            //  Calculate timespan between now and last access time
22667>>>>>            Move (CurrentDateTime()) to dtCurrent
22668>>>>>            Move WebAppSession.LastAccessDate to dtLastAccess
22669>>>>>            Get StringToTime of hoSessionDD dtLastAccess WebAppSession.LastAccessTime to dtLastAccess
22670>>>>>            Move (dtCurrent - dtLastAccess) to tsDiff
22671>>>>>            Move (SpanTotalMinutes(tsDiff)) to iSpanMinutes
22672>>>>>            
22672>>>>>            //  Check if session didn't time out
22672>>>>>            If ((iSessionTimeout <= 0 or (iSpanMinutes < iSessionTimeout)) and WebAppSession.Active = "Y") Begin
22674>>>>>                Forward Get ValidateSession sSessionKey to bResult
22676>>>>>                   
22676>>>>>                If (bResult) Begin
22678>>>>>                    //  Update session record
22678>>>>>                    Get TimeToString of hoSessionDD dtCurrent to sTime 
22679>>>>>                    Set Field_Changed_Value of hoSessionDD Field WebAppSession.LastAccessDate to dtCurrent
22680>>>>>                    Set Field_Changed_Value of hoSessionDD Field WebAppSession.LastAccessTime to sTime
22681>>>>>                    Set Field_Changed_Value of hoSessionDD Field WebAppSession.UseCount to (WebAppSession.UseCount + 1)
22682>>>>>                    Get Request_Validate of hoSessionDD to iErr
22683>>>>>                    If (iErr) Begin
22685>>>>>                        // this should not happen. If it does its a programming error
22685>>>>>                        Error DFERR_PROGRAM C_$WebAppSesionValidateFailed
22686>>>>>>
22686>>>>>                        Function_Return False
22687>>>>>                    End
22687>>>>>>
22687>>>>>                    Send Request_Save of hoSessionDD
22688>>>>>                    
22688>>>>>                    //  Update user properties
22688>>>>>                    If (HasRecord(hoUserDD)) Begin
22690>>>>>                        Set psUsername to WebAppUser.FullName
22691>>>>>                        Set psLoginName to WebAppUser.LoginName
22692>>>>>                        Set piUserRights to WebAppUser.Rights
22693>>>>>                    End
22693>>>>>>
22693>>>>>                End
22693>>>>>>
22693>>>>>            End
22693>>>>>>
22693>>>>>            Else Begin
22694>>>>>                // Test the Creating New Session Flag to protect against infinite recursion....
22694>>>>>                Get pbCreatingNewSession to bCreatingNewSession
22695>>>>>                
22695>>>>>                If (not(bCreatingNewSession) and not(bLoadWebApp)) Begin
22697>>>>>                    Set pbCreatingNewSession to True                    
22698>>>>>                    Send RecreateSession to ghoWebApp
22699>>>>>                    Send NavigateRefresh of ghoWebApp          // refresh the WebApp at the client (triggers a login)
22700>>>>>                    Error 950 "Your application session has timed out or is inactive, please login again."
22701>>>>>>
22701>>>>>                    Set pbCreatingNewSession to False
22702>>>>>                End
22702>>>>>>
22702>>>>>            End
22702>>>>>>
22702>>>>>        End
22702>>>>>>
22702>>>>>        Else If (not(bLoadWebApp)) Begin
22705>>>>>            Error 951 "Session key not known (reload page to recreate session)"
22706>>>>>>
22706>>>>>        End
22706>>>>>>
22706>>>>>        
22706>>>>>        Function_Return bResult
22707>>>>>    End_Function
22708>>>>>    
22708>>>>>    Function UserLogin String sLoginName String sPassword Returns Boolean
22710>>>>>        String sSessionKey sUserPassword
22710>>>>>        Handle hoSessionDD hoUserDD       
22710>>>>>        
22710>>>>>        Get phoSessionDD to hoSessionDD
22711>>>>>        Get phoUserDD to hoUserDD
22712>>>>>        Integer iErr eLoginMode
22712>>>>>        
22712>>>>>        // Refind session record
22712>>>>>        Get psSessionKey to sSessionKey
22713>>>>>        Send Clear of hoSessionDD
22714>>>>>        Move sSessionKey to WebAppSession.SessionKey
22715>>>>>        Send Find of hoSessionDD EQ Index.1
22716>>>>>        
22716>>>>>        If (Found and WebAppSession.SessionKey = sSessionKey) Begin
22718>>>>>            Get peLoginMode to eLoginMode
22719>>>>>            
22719>>>>>            // if login is not required, we will allow for a blank name and password, which gives you access to whatever
22719>>>>>            // your have access to with not being logged in. We consider this to be a success, even if you are not logged in.
22719>>>>>            If (eLoginMode <> lmLoginRequired and Trim(sLoginName) = "" and Trim(sPassword) = "") Begin
22721>>>>>                Set psUsername to ""
22722>>>>>                Set psLoginName to ""
22723>>>>>                Set piUserrights to 0
22724>>>>>                Send NotifyChangeRights
22725>>>>>                Function_Return True
22726>>>>>            End
22726>>>>>>
22726>>>>>            
22726>>>>>            //  Find the user
22726>>>>>            Move sLoginName to WebAppUser.LoginName
22727>>>>>            Send Find of hoUserDD EQ Index.1
22728>>>>>            
22728>>>>>            // Check username and password
22728>>>>>            Get Field_Current_Value of hoUserDD Field WebAppUser.Password to sUserPassword
22729>>>>>            
22729>>>>>            If (Found and (Lowercase(sLoginName) = Lowercase(Trim(WebAppUser.LoginName))) and Trim(sUserPassword) = Trim(sPassword)) Begin
22731>>>>>                // Store the login
22731>>>>>                Set Field_Changed_Value of hoUserDD Field WebAppUser.LastLogin to (CurrentDateTime())
22732>>>>>                Get Request_Validate of hoSessionDD to iErr
22733>>>>>                If (iErr) Begin
22735>>>>>                    // this should not happen. If it does its a programming error
22735>>>>>                    Error DFERR_PROGRAM C_$WebAppSesionValidateFailed
22736>>>>>>
22736>>>>>                    Function_Return False
22737>>>>>                End
22737>>>>>>
22737>>>>>                
22737>>>>>                Send Request_Save of hoSessionDD
22738>>>>>                
22738>>>>>                // Update session properties
22738>>>>>                Set psUsername to WebAppUser.FullName
22739>>>>>                Set psLoginName to WebAppUser.LoginName
22740>>>>>                Set piUserrights to WebAppUser.Rights
22741>>>>>                Send NotifyChangeRights
22742>>>>>                Function_Return True
22743>>>>>            End
22743>>>>>>
22743>>>>>        End
22743>>>>>>
22743>>>>>          
22743>>>>>        Function_Return False
22744>>>>>    End_Function
22745>>>>>    
22745>>>>>    Function IsLoggedIn Returns Boolean
22747>>>>>        String sLoginName
22747>>>>>        Boolean bLogWebSession bLoggedIn
22747>>>>>        
22747>>>>>        Get pbLogWebSession to bLogWebSession
22748>>>>>        If not bLogWebSession Begin
22750>>>>>            Forward Get IsLoggedIn to bLoggedIn
22752>>>>>            Function_Return bLoggedIn
22753>>>>>        End
22753>>>>>>
22753>>>>>        
22753>>>>>        Get psLoginName to sLoginName
22754>>>>>        
22754>>>>>        Function_Return (sLoginName <> "")
22755>>>>>    End_Function
22756>>>>>    
22756>>>>>    
22756>>>>>    Procedure EndSession
22758>>>>>        Integer iErr
22758>>>>>        Boolean bLogWebSession
22758>>>>>        Handle hoSessionDD       
22758>>>>>        
22758>>>>>        Get phoSessionDD to hoSessionDD
22759>>>>>        Get pbLogWebSession to bLogWebSession
22760>>>>>        If not bLogWebSession Begin
22762>>>>>            Forward Send EndSession
22764>>>>>            Procedure_Return
22765>>>>>        End
22765>>>>>>
22765>>>>>            
22765>>>>>        //  Check if session exists
22765>>>>>        Send Clear of hoSessionDD
22766>>>>>        Get psSessionKey to WebAppSession.SessionKey
22767>>>>>        
22767>>>>>        Send Find of hoSessionDD EQ Index.1
22768>>>>>        If (Found) Begin
22770>>>>>            Set Field_Changed_Value of hoSessionDD Field WebAppSession.Active to "N"
22771>>>>>            Get Request_Validate of hoSessionDD to iErr
22772>>>>>            If (iErr) Begin
22774>>>>>                // this should not happen. If it does its a programming error
22774>>>>>                Error DFERR_PROGRAM C_$WebAppSesionValidateFailed
22775>>>>>>
22775>>>>>                Procedure_Return
22776>>>>>            End
22776>>>>>>
22776>>>>>            Send Request_Save of hoSessionDD
22777>>>>>        End
22777>>>>>>
22777>>>>>    End_Procedure
22778>>>>>
22778>>>>>End_Class
22779>>>>>
22779>>>
22779>>>Object oSessionManager is a cWebSessionManagerStandard
22781>>>End_Object
22782>>>
22782>    Use LoginDialog.wo
Including file: LoginDialog.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\LoginDialog.wo)
22782>>>Use cWebModalDialog.pkg
22782>>>Use cWebForm.pkg
22782>>>Use cWebButton.pkg
22782>>>Use cWebPanel.pkg
22782>>>Use cWebLabel.pkg
22782>>>
22782>>>Object oLoginDialog is a cWebModalDialog
22784>>>    Set piMinWidth to 370
22785>>>    Set piMinHeight to 220
22786>>>    Set psCaption to "Login"
22787>>>    Set pbShowClose to (peLoginMode(oWebApp) <> lmLoginRequired)
22788>>>    
22788>>>    Delegate Set phoLoginView to Self
22790>>>    
22790>>>    Object oTopPanel is a cWebPanel
22792>>>        Set peRegion to prTop
22793>>>        Set piHeight to 55       
22794>>>        
22794>>>        Object oDescription is a cWebLabel
22796>>>            Set psCaption to "Please enter your username and password to login."
22797>>>            Set peAlign to alignCenter
22798>>>        End_Object
22799>>>    End_Object
22800>>>    
22800>>>    Object oRightPanel is a cWebPanel
22802>>>        Set peRegion to prRight
22803>>>        Set piWidth to 20       
22804>>>    End_Object
22805>>>    
22805>>>    Object oMainPanel is a cWebPanel
22807>>>        Set peRegion to prCenter
22808>>>        
22808>>>        Object oLoginName is a cWebForm
22810>>>            Set psLabel to "Login Name:"
22811>>>            Set peLabelPosition to C_WebDefault
22812>>>            Set peLabelAlign to alignRight
22813>>>            Set piMaxLength to 20
22814>>>        End_Object
22815>>>        
22815>>>        Object oPassword is a cWebForm
22817>>>            Set psLabel to "Password:"
22818>>>            Set pbPassword to True
22819>>>            Set peLabelAlign to alignRight
22820>>>            Set piMaxLength to 20
22821>>>        End_Object   
22822>>>        
22822>>>        Object oWarning is a cWebLabel
22824>>>            Set pbVisible to False
22825>>>            Set psCaption to "Invalid loginname or password."
22826>>>            Set psCSSClass to "Warning"
22827>>>            Set peAlign to alignCenter
22828>>>        End_Object
22829>>>    End_Object
22830>>>    
22830>>>    Object oButtonPanel is a cWebPanel
22832>>>        Set peRegion to prBottom
22833>>>        Set piColumnCount to 3
22834>>>        Set piMinHeight to 40
22835>>>
22835>>>        Object oLoginButton is a cWebButton
22837>>>            Set pbShowLabel to False
22838>>>            Set piColumnIndex to 2
22839>>>            Set psCaption to "Login"
22840>>>            Set pbServerOnClick to True
22841>>>                        
22841>>>            Procedure OnClick
22844>>>                Send DoLogin
22845>>>            End_Procedure
22846>>>            
22846>>>        End_Object
22847>>>        
22847>>>    End_Object
22848>>>    
22848>>>    Procedure DoLogin
22851>>>        String sLoginName sPassword
22851>>>        Boolean bResult
22851>>>        Handle hoDefaultView
22851>>>        
22851>>>        WebGet psValue of oLoginName to sLoginName
22852>>>        WebGet psValue of oPassword to sPassword
22853>>>        
22853>>>        Get UserLogin of ghoWebSessionManager sLoginName sPassword to bResult
22854>>>        
22854>>>        If (bResult) Begin
22856>>>            Send Hide of oLoginDialog
22857>>>            Get phoDefaultView to hoDefaultView
22858>>>            If (hoDefaultView > 0) Begin
22860>>>                Send Show of hoDefaultView
22861>>>            End
22861>>>>
22861>>>            
22861>>>            // clear the login values. we don't want to return the login id & password as synchronized properties....
22861>>>            WebSet psValue of oLoginName to ""
22862>>>            WebSet psValue of oPassword  to ""
22863>>>            WebSet pbVisible of oWarning to False
22864>>>        End
22864>>>>
22864>>>        Else Begin
22865>>>            WebSet pbVisible of oWarning to True
22866>>>        End
22866>>>>
22866>>>    End_Procedure
22867>>>    
22867>>>    
22867>>>    Set pbServerOnSubmit to True
22868>>>    Procedure OnSubmit
22871>>>         Send DoLogin
22872>>>    End_Procedure
22873>>>End_Object
22874>    Use WebResourceManager.wo
Including file: WebResourceManager.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\WebResourceManager.wo)
22874>>>Use cWebResourceManager.pkg
22874>>>
22874>>>Object oWebResourceManager is a cWebResourceManager
22876>>>End_Object
22877>    Use Introduction.wo
Including file: Introduction.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\Introduction.wo)
22877>>>Use cWebView.pkg
22877>>>Use cWebPanel.pkg
22877>>>Use cWebForm.pkg 
22877>>>Use cWebHtmlBox.pkg
22877>>>Use cWebTabContainer.pkg
22877>>>Use cWebTabPage.pkg
22877>>>
22877>>>Register_Object oWebQuery
22877>>>
22877>>>Object oIntroduction is a cWebView
22879>>>    Set piWidth to 800
22880>>>    Set psCaption to "Introduction to WebQuery"
22881>>>    
22881>>>    Delegate Set phoDefaultView to Self
22883>>>
22883>>>    Object oWebMainPanel is a cWebPanel
22885>>>        Set pbFillHeight to True
22886>>>        
22886>>>        Object oWebTabContainer1 is a cWebTabContainer
22888>>>            
22888>>>            Object oIntroPage is a cWebTabPage
22890>>>                Set psCaption to "Introduction"
22891>>>                Set pbFillHeight to True
22892>>>                
22892>>>                Object oIntro is a cWebIFrame
22894>>>                    Set pbFillHeight to True
22895>>>                    Set psUrl to "WebQueryIntro.html"
22896>>>                End_Object
22897>>>                
22897>>>            End_Object
22898>>>            
22898>>>            Object oFeaturePage is a cWebTabPage
22900>>>                Set psCaption to "Features"
22901>>>                Set pbFillHeight to True
22902>>>                
22902>>>                Object oFeatures is a cWebIFrame
22904>>>                    Set pbFillHeight to True
22905>>>                    Set psUrl to "WebQueryfeatures.html"
22906>>>                End_Object
22907>>>                
22907>>>            End_Object
22908>>>            
22908>>>            Object oUsagePage is a cWebTabPage
22910>>>                Set psCaption to "Usage"
22911>>>                
22911>>>                Object oUsage is a cWebIFrame
22913>>>                    Set psUrl        to "WebQueryUsage.html"
22914>>>                    Set pbFillHeight to True
22915>>>                End_Object                
22916>>>                
22916>>>            End_Object
22917>>>            
22917>>>            Object oAPIPage is a cWebTabPage
22919>>>                Set psCaption    to "API"
22920>>>                Set pbFillHeight to True
22921>>>                
22921>>>                Object oAPI is a cWebIFrame
22923>>>                    Set psUrl        to "WebQueryAPI.html"
22924>>>                    Set pbFillHeight to True
22925>>>                End_Object
22926>>>        
22926>>>            End_Object
22927>>>                    
22927>>>            Object oHelpPage is a cWebTabPage
22929>>>                Set psCaption to "Help"
22930>>>                
22930>>>                Object oHelp is a cWebIFrame
22932>>>                    Set pbFillHeight to True
22933>>>                    Set psUrl        to "WebQueryHelp.html"
22934>>>                End_Object
22935>>>                
22935>>>            End_Object
22936>>>            
22936>>>            Object oOtherPage is a cWebTabPage
22938>>>                Set psCaption to "Other"
22939>>>                
22939>>>                Object oOther is a cWebIFrame
22941>>>                    Set pbFillHeight to True
22942>>>                    Set psUrl        to "WebQueryOther.html"
22943>>>                End_Object
22944>>>                
22944>>>            End_Object
22945>>>            
22945>>>            Object oBugsPage is a cWebTabPage
22947>>>                Set psCaption to "Bug List"
22948>>>                
22948>>>                Object oBugList is a cWebIFrame
22950>>>                    Set psUrl        to "http://ec2-54-200-89-112.us-west-2.compute.amazonaws.com/WebQueryBugList.html"
22951>>>                    Set pbFillHeight to True
22952>>>                End_Object
22953>>>                
22953>>>            End_Object
22954>>>            
22954>>>            Object oReadMePage is a cWebTabPage
22956>>>                Set psCaption to "Read Me"
22957>>>                
22957>>>                Object oReadMe is a cWebIFrame
22959>>>                    Set psUrl        to "ReadMe.html"
22960>>>                    Set pbFillHeight to True
22961>>>                End_Object
22962>>>                
22962>>>            End_Object
22963>>>            
22963>>>            Object oReleasePage is a cWebTabPage
22965>>>                Set psCaption to "History"
22966>>>                
22966>>>                Object oRelHist is a cWebIFrame
22968>>>                    Set psUrl        to "WebQueryReleaseHistory.html"
22969>>>                    Set pbFillHeight to True
22970>>>                End_Object
22971>>>                
22971>>>            End_Object
22972>>>            
22972>>>            Object oLicencePage is a cWebTabPage
22974>>>                Set psCaption to "Licence"
22975>>>                
22975>>>                Object oRelHist is a cWebIFrame
22977>>>                    Set psUrl        to "WebQueryLicence.html"
22978>>>                    Set pbFillHeight to True
22979>>>                End_Object
22980>>>                
22980>>>            End_Object
22981>>>            
22981>>>        End_Object
22982>>>
22982>>>    End_Object 
22983>>>
22983>>>End_Object
22984>    Use WebQuery.wo
Including file: WebQuery.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\WebQuery.wo)
22984>>>//==============================================================================
22984>>>// WebQuery: An ad-hoc query tool designed tio be built into applications
22984>>>//           (most probably as a "Report" option).
22984>>>//
22984>>>//           It REQUIRES Sture Andersen's "StureApsPublicLib" (20131023 or
22984>>>//           later) - you can find it at:
22984>>>//              ftp://ftp.stureaps.dk/software/visualdataflex/stureapspubliclib/
22984>>>//
22984>>>// See the ReadMe.txt file in AppHTML for usage details.
22984>>>//
22984>>>// Author: Mike Peat; copyright (c) Unicorn InterGlobal, 2013
22984>>>//
22984>>>//==============================================================================
22984>>>
22984>>>//==============================================================================
22984>>>// Use statements
22984>>>//==============================================================================
22984>>>
22984>>>// Framework packages
22984>>>Use cWebView.pkg
22984>>>Use cWebPanel.pkg
22984>>>Use cWebForm.pkg 
22984>>>Use cWebCombo.pkg
22984>>>Use cWebButton.pkg
22984>>>Use cWebTabContainer.pkg
22984>>>Use cWebTabPage.pkg
22984>>>Use cWebGrid.pkg
22984>>>Use cWebColumn.pkg
22984>>>Use cWebList.pkg
22984>>>Use cWebHtmlBox.pkg
22984>>>Use cWebLabel.pkg
22984>>>Use cWebEdit.pkg
22984>>>Use cWebSpacer.pkg
22984>>>Use cWebColumnCheckbox.pkg
22984>>>Use cWebCheckBox.pkg
22984>>>Use cWebRadio.pkg
22984>>>
22984>>>// Web Query packages
22984>>>Use cWebQueryFunctions.pkg
Including file: cWebQueryFunctions.pkg    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\cWebQueryFunctions.pkg)
22984>>>>>Use UI
22984>>>>>Use seq_chnl.pkg
22984>>>>>
22984>>>>>// Strure's packages:
22984>>>>>Use StringFunctions.pkg
Including file: StringFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\StringFunctions.pkg)
22984>>>>>>>// String functions encapsulated in oStringFunctions (SturesPublicLibrary)
22984>>>>>>>
22984>>>>>>>//> The oStringFunctions.pkg package defines an object called oStringFunctions that encapsulates a number of
22984>>>>>>>//> general purpose string functions.
22984>>>>>>>//>
22984>>>>>>>//> For example, to call the function NumberToString the syntax is therefore
22984>>>>>>>//>
22984>>>>>>>//>     get NumberToString of oStringFunctions 3.1415926 3 to sResult
22984>>>>>>>//>
22984>>>>>>>//> or on expressional form
22984>>>>>>>//>
22984>>>>>>>//>     move (NumberToString(oStringFunctions,3.1415926,3)) to sResult
22984>>>>>>>//>
22984>>>>>>>//> (both of the above examples places the result "3.142" in string variable sResult)
22984>>>>>>>//>
22984>>>>>>>//> Since quite a number of functions in this package are concerned with formatting numbers
22984>>>>>>>//> a general note is in its place. Converting numbers to strings was never very difficult
22984>>>>>>>//> in VDF. Simply move a number to a string, end of conversion. However, that type of conversion
22984>>>>>>>//> leaves you no control over the number of decimals in the resulting string.
22984>>>>>>>//>
22984>>>>>>>//>     String sValue
22984>>>>>>>//>     Move 2.500 to sValue
22984>>>>>>>//>
22984>>>>>>>//> places the value "2.5" in the string variable because a number moved to a string variable
22984>>>>>>>//> gets truncated at the least significant digit that is non-zero (after the decimal point). The
22984>>>>>>>//> NumberToString function mentioned just above, or one of its cousins, helps you overcome this.
22984>>>>>>>//>
22984>>>>>>>//> pkg.doc.end
22984>>>>>>>
22984>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
22984>>>>>>>
22984>>>>>>>// Internally for use with wildcard* functions
22984>>>>>>>Enum_List
22984>>>>>>>    Define _WILDC_THE_HARD_WAY         //>
22984>>>>>>>    Define _WILDC_ALWAYS_TRUE          //> *
22984>>>>>>>    Define _WILDC_EQUAL                //> Sture
22984>>>>>>>    Define _WILDC_LEFT_MATCH           //> Sture*
22984>>>>>>>    Define _WILDC_RIGHT_MATCH          //> *Andersen
22984>>>>>>>    Define _WILDC_LEFT_AND_RIGHT_MATCH //> Sture*Andersen
22984>>>>>>>    Define _WILDC_CONTAINS             //> *B*
22984>>>>>>>    Define _WILDC_CONTAINS_WORDONLY
22984>>>>>>>End_Enum_List
22984>>>>>>>
22984>>>>>>>Enum_List
22984>>>>>>>    Define _WILDC_CONSTANT
22984>>>>>>>    Define _WILDC_QUESTIONMARK
22984>>>>>>>    Define _WILDC_ASTERISK
22984>>>>>>>End_Enum_List
22984>>>>>>>
22984>>>>>>>Struct tWildCardEvalSequenceItem
22984>>>>>>>    Integer iType // 0=constant 1=? 2=*
22984>>>>>>>    String sValue // Only relevant when iType is 0
22984>>>>>>>End_Struct
22984>>>>>>>
22984>>>>>>>//> A value of this type describes a series of string comparisons to perform
22984>>>>>>>//> in order to validate a string against a particular mask. The WildCard* functions
22984>>>>>>>//> defined in the cStringFunctions class uses this.
22984>>>>>>>Struct tWildCardEvalSequence
22984>>>>>>>    // The properties defined here are used only to try to optimize
22984>>>>>>>    // the evaluation sequence.
22984>>>>>>>    Integer iAltStrategy
22984>>>>>>>    // If an alternative strategy is active, can we use it to accept a
22984>>>>>>>    // value (bAltStrategyRejectOnly=TRUE) or must we run it the hard
22984>>>>>>>    // way afterwards (bAltStrategyRejectOnly=FALSE)?
22984>>>>>>>    Boolean bAltStrategyRejectOnly
22984>>>>>>>    String  sAltStrategyLeftValue
22984>>>>>>>    String  sAltStrategyRightValue
22984>>>>>>>    tWildCardEvalSequenceItem[] aSequence
22984>>>>>>>    tWildCardEvalSequenceItem[] aSequence
22984>>>>>>>End_Struct
22984>>>>>>>
22984>>>>>>>String gStr$ReversedCollateString 255
22984>>>>>>>
22984>>>>>>>Struct _tsfMaxArgSize
22984>>>>>>>    Integer iSize
22984>>>>>>>    Boolean bSet
22984>>>>>>>End_Struct
22984>>>>>>>
22984>>>>>>>Global_Variable _tsfMaxArgSize[] _gasfMAS
22984>>>>>>>
22984>>>>>>>//> The oStringFunctions object is based on the cStringFunctions class.
22984>>>>>>>Class cStringFunctions is a cObject
22985>>>>>>>    
22985>>>>>>>    Procedure Construct_Object
22987>>>>>>>        Integer iAscii
22987>>>>>>>        Forward Send Construct_Object
22989>>>>>>>        //> The coolest little property
22989>>>>>>>        Property String psDecimalSeparator
22990>>>>>>>        Property Boolean _pbInsertThousandsSeparators False
22991>>>>>>>
22991>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iAscii
22994>>>>>>>        Set psDecimalSeparator to (Character(iAscii))
22995>>>>>>>        
22995>>>>>>>        Property String psWildCardWordCharacters "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_#0123456789"
22996>>>>>>>        
22996>>>>>>>        Property String _psCurrentCollateString ""
22997>>>>>>>    End_Procedure
22998>>>>>>>
22998>>>>>>>    //> 
22998>>>>>>>    Procedure MaxArgumentSizeAdjust Integer iSize Boolean bDownsizeIfPossible
23000>>>>>>>        Integer iCurrentSize iIndex
23000>>>>>>>        Boolean bSet
23000>>>>>>>        Move (SizeOfArray(_gasfMAS)) to iIndex
23001>>>>>>>        Get_Argument_Size to iCurrentSize
23002>>>>>>>        Move (iSize>iCurrentSize or bDownsizeIfPossible) to bSet
23003>>>>>>>        If (bSet) Begin
23005>>>>>>>            Set_Argument_Size iSize
23006>>>>>>>>
23006>>>>>>>            Move iCurrentSize to _gasfMAS[iIndex].iSize
23007>>>>>>>        End
23007>>>>>>>>
23007>>>>>>>        Move bSet to _gasfMAS[iIndex].bSet
23008>>>>>>>    End_Procedure
23009>>>>>>>    
23009>>>>>>>    //> See: Class:cStringFunctions,Procedure:MaxArgumentSizeAdjust
23009>>>>>>>    Procedure MaxArgumentSizeRestore
23011>>>>>>>        Integer iIndex iSize
23011>>>>>>>        Move (SizeOfArray(_gasfMAS)-1) to iIndex
23012>>>>>>>        If (iIndex>=0) Begin
23014>>>>>>>            If (_gasfMAS[iIndex].bSet) Begin
23016>>>>>>>                Move _gasfMAS[iIndex].iSize to iSize
23017>>>>>>>                Set_Argument_Size iSize
23018>>>>>>>>
23018>>>>>>>            End
23018>>>>>>>>
23018>>>>>>>            Move (ResizeArray(_gasfMAS,iIndex)) to _gasfMAS
23019>>>>>>>        End
23019>>>>>>>>
23019>>>>>>>        Else Begin
23020>>>>>>>            Error 666 "Unbalanced argument size push/pop (StringFunctions.pkg)"
23021>>>>>>>>
23021>>>>>>>        End
23021>>>>>>>>
23021>>>>>>>    End_Procedure
23022>>>>>>>    
23022>>>>>>>    Function MaxArgumentSize Returns Integer
23024>>>>>>>        Integer iCurrentSize
23024>>>>>>>        Get_Argument_Size to iCurrentSize
23025>>>>>>>        Function_Return iCurrentSize
23026>>>>>>>    End_Function
23027>>>>>>>
23027>>>>>>>    Function CurrentCollateString Returns String
23029>>>>>>>        Integer iChar iItem iMax hArr
23029>>>>>>>        String sValue
23029>>>>>>>        If (_psCurrentCollateString(Self)="") Begin
23031>>>>>>>            Get Create U_Array to hArr
23032>>>>>>>            Send Delete_Data of hArr
23033>>>>>>>            For iChar from 32 to 255
23039>>>>>>>>
23039>>>>>>>                Set Value of hArr (iChar-32) to (Character(iChar))
23040>>>>>>>            Loop
23041>>>>>>>>
23041>>>>>>>            Send Sort_Items of hArr Ascending // This reveals the true sorting of the current runtime.
23042>>>>>>>            Get Item_Count of hArr to iMax
23043>>>>>>>            Decrement iMax
23044>>>>>>>            Move "" to sValue
23045>>>>>>>            For iItem from 0 to iMax
23051>>>>>>>>
23051>>>>>>>                Move (sValue+Value(hArr,iItem)) to sValue
23052>>>>>>>            Loop
23053>>>>>>>>
23053>>>>>>>            Send Destroy of hArr
23054>>>>>>>            Set _psCurrentCollateString to sValue
23055>>>>>>>        End
23055>>>>>>>>
23055>>>>>>>        Function_Return (_psCurrentCollateString(Self))
23056>>>>>>>    End_Function
23057>>>>>>>    
23057>>>>>>>    //> Flip string
23057>>>>>>>    Function ReverseString String sValue Returns String
23059>>>>>>>        Integer iLen iPos
23059>>>>>>>        String sRval sChar
23059>>>>>>>        Move "" to sRval
23060>>>>>>>        Move (Length(sValue)) to iLen
23061>>>>>>>        For iPos from 1 to iLen 
23067>>>>>>>>
23067>>>>>>>            Move (Mid(sValue,1,iPos)+sRval) to sRval
23068>>>>>>>        Loop
23069>>>>>>>>
23069>>>>>>>        Function_Return sRval
23070>>>>>>>    End_Function
23071>>>>>>>    
23071>>>>>>>    //> Negate value so that sorting it as a string will reverse the direction of the original value
23071>>>>>>>    Function NegateString String sValue Returns String
23073>>>>>>>        Integer iPos iLen
23073>>>>>>>        String sRval sChar
23073>>>>>>>        Move (length(sValue)) to iLen
23074>>>>>>>        Move "" to sRval
23075>>>>>>>        For iPos from 1 to iLen
23081>>>>>>>>
23081>>>>>>>            Move (Mid(sValue,1,iPos)) to sChar
23082>>>>>>>            Move (sRval+Mid(gStr$ReversedCollateString,1,Ascii(sChar))) to sRval
23083>>>>>>>        Loop
23084>>>>>>>>
23084>>>>>>>        Function_Return sRval
23085>>>>>>>    End_Function
23086>>>>>>>    
23086>>>>>>>        Function _CurrentCollateStringReversed Returns String
23088>>>>>>>            Function_Return (ReverseString(Self,CurrentCollateString(Self)))
23089>>>>>>>        End_Function
23090>>>>>>>        
23090>>>>>>>    //> Function rPos returns the position of the last occurance of sSubString in sHostString. If
23090>>>>>>>    //> there are no occurances, 0 will be returned.
23090>>>>>>>    //>
23090>>>>>>>    //> Parameters:
23090>>>>>>>    //>     sSubString: The sequence of characters to be searched for.
23090>>>>>>>    //>     sHostString: The string in which to search for the 'sub string'.
23090>>>>>>>    //>
23090>>>>>>>    //>     returns: The highest position at which the 'sub string' was found. 0 if it wasn't.
23090>>>>>>>    //>
23090>>>>>>>    //> Examples:
23090>>>>>>>    //>
23090>>>>>>>    //>     get rPos of oStringFunctions "be" "tobeornottobe" to iPos // returns 12 to iPos
23090>>>>>>>    //>
23090>>>>>>>    Function rPos String sSubString String sHostString Returns Integer
23092>>>>>>>        Integer iPos iSubLen
23092>>>>>>>        If (Length(sSubString)=0) Function_Return 0
23095>>>>>>>        Move (Length(sHostString)-Length(sSubString)+1) to iPos
23096>>>>>>>        Move (Length(sSubString)) to iSubLen
23097>>>>>>>        While (iPos>0)
23101>>>>>>>            If (Mid(sHostString,iSubLen,iPos)=sSubString) Function_Return iPos
23104>>>>>>>            Decrement iPos
23105>>>>>>>        End
23106>>>>>>>>
23106>>>>>>>        Function_Return 0 // not found
23107>>>>>>>    End_Function
23108>>>>>>>
23108>>>>>>>    //> Function rRemove removes iNumChars characters from the right end of sValue.
23108>>>>>>>    Function rRemove String sValue Integer iNumChars Returns String
23110>>>>>>>        Function_Return (Left(sValue,Length(sValue)-iNumChars))
23111>>>>>>>    End_Function
23112>>>>>>>
23112>>>>>>>//  //> Function RightFromPos returns the right part of the string starting at position iPos.
23112>>>>>>>//  Function RightFromPos String sValue Integer iPos Returns String
23112>>>>>>>//      Function_Return (remove(sValue,1,iPos-1))
23112>>>>>>>//  End_Function
23112>>>>>>>
23112>>>>>>>    Function BeginsWith String sHostString String sLeadInCharacters Returns Boolean
23114>>>>>>>        If (Length(sLeadInCharacters)>Length(sHostString)) Function_Return False
23117>>>>>>>        Function_Return (Left(sHostString,Length(sLeadInCharacters))=sLeadInCharacters)
23118>>>>>>>    End_Function
23119>>>>>>>
23119>>>>>>>    Function EndsWith String sHostString String sTrailingCharacters Returns Boolean
23121>>>>>>>        If (Length(sTrailingCharacters)>Length(sHostString)) Function_Return False
23124>>>>>>>        Function_Return (Right(sHostString,Length(sTrailingCharacters))=sTrailingCharacters)
23125>>>>>>>    End_Function
23126>>>>>>>
23126>>>>>>>    Function SearchPos String sSubString String sHostString Integer iStartPos Returns Integer
23128>>>>>>>        Integer iRval
23128>>>>>>>        Move (Pos(sSubString,Remove(sHostString,1,iStartPos-1))) to iRval
23129>>>>>>>        If (iRval) Move (iRval+iStartPos-1) to iRval
23132>>>>>>>        Function_Return iRval
23133>>>>>>>    End_Function
23134>>>>>>>
23134>>>>>>>    Function psThousandsSeparator Returns String
23136>>>>>>>        If (psDecimalSeparator(Self)=",") Function_Return "." // Dot
23139>>>>>>>        Function_Return "," // Comma
23140>>>>>>>    End_Function
23141>>>>>>>
23141>>>>>>>    //> The string sValue is returned right justified in a string of length iLen
23141>>>>>>>    Function RightAdjust String sValue Integer iLen Returns String
23143>>>>>>>        Move (Trim(sValue)) to sValue
23144>>>>>>>        Move (Repeat(" ", 0 max (iLen-length(sValue)))+sValue) to sValue
23145>>>>>>>        Function_Return sValue
23146>>>>>>>    End_Function
23147>>>>>>>
23147>>>>>>>    //> Inserts thousands separators into the number passed.
23147>>>>>>>    Function InsertThousandsSeparators String sValue Returns String
23149>>>>>>>        Integer iPos
23149>>>>>>>        Boolean bNegative
23149>>>>>>>        String sDecimalSeparator sThousandsSeparator
23149>>>>>>>
23149>>>>>>>        Move (Trim(sValue)) to sValue
23150>>>>>>>        Move (Left(sValue,1)="-") to bNegative
23151>>>>>>>
23151>>>>>>>        If (bNegative) Move (Remove(sValue,1,1)) to sValue // if (lbNegative) get StringRightBut sValue 1 to sValue
23154>>>>>>>
23154>>>>>>>        Get psDecimalSeparator to sDecimalSeparator
23155>>>>>>>        Move (Pos(sDecimalSeparator,sValue)) to iPos
23156>>>>>>>        If (iPos=0) Move (Length(sValue)+1) to iPos
23159>>>>>>> 
23159>>>>>>>        Get psThousandsSeparator to sThousandsSeparator
23160>>>>>>>
23160>>>>>>>        While (iPos>4)
23164>>>>>>>            Move (iPos-3) to iPos
23165>>>>>>>            Move (Insert(sThousandsSeparator,sValue,iPos)) to sValue
23166>>>>>>>        Loop
23167>>>>>>>>
23167>>>>>>>        If (bNegative) Move ("-"+sValue) to sValue
23170>>>>>>>        Function_Return sValue
23171>>>>>>>    End_Function
23172>>>>>>>
23172>>>>>>>    //> Removes thousands separators from the string passed and dares comvert it into a number.
23172>>>>>>>    Function RemoveThousandsSeparators String sValue Returns Number
23174>>>>>>>        Move (Replaces(psThousandsSeparator(Self),sValue,"")) to sValue
23175>>>>>>>        Function_Return (Number(sValue))
23176>>>>>>>    End_Function
23177>>>>>>>
23177>>>>>>>    //> Calling the function below will convert the number passed in nNumber to a
23177>>>>>>>    //> string containing iDecimals decimals rounding excess decimals. Parameter iDecimals
23177>>>>>>>    //> may be negative. The expression (NumberToString(oStringFunctions,1789,-3)) will evaluate to "2000".
23177>>>>>>>    //> The function handles a maximum of 8 decimals.
23177>>>>>>>    Function NumberToString Number nValue Integer iDecimals Returns String
23179>>>>>>>        Integer iPos iAscii
23179>>>>>>>        Number nCorr
23179>>>>>>>        String sRval sDecimalSeparator
23179>>>>>>>        If (iDecimals<0) Function_Return (NumberToString(Self,nValue*(10^iDecimals),0)+left("00000000",-iDecimals))
23182>>>>>>>        Move (0.5/(10^iDecimals)) to nCorr
23183>>>>>>>        If (nValue>=0) Move (nCorr+nValue) to nValue
23186>>>>>>>        Else Move (nValue-nCorr) to nValue
23188>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iAscii
23191>>>>>>>        Move (Character(iAscii)) to sDecimalSeparator
23192>>>>>>>        Move nValue to sRval
23193>>>>>>>        If (not(Pos(sDecimalSeparator,sRval))) Move (sRval+sDecimalSeparator) to sRval
23196>>>>>>>        Move (sRval+"00000000") to sRval
23197>>>>>>>        Move (Pos(sDecimalSeparator,sRval)) to iPos
23198>>>>>>>        If (iDecimals=0) Decrement iPos
23201>>>>>>>        Move (Left(sRval,iPos+iDecimals)) to sRval
23202>>>>>>>        If (_pbInsertThousandsSeparators(Self)) Get InsertThousandsSeparators sRval to sRval
23205>>>>>>>        Function_Return sRval
23206>>>>>>>    End_Function
23207>>>>>>>
23207>>>>>>>    //> This function is the same as NumberToString except that you have to specify
23207>>>>>>>    //> the length of the return value (iLen). The number will be right
23207>>>>>>>    //> justified accordingly. Post-fix `R' means right adjust.
23207>>>>>>>    Function NumberToStringR Number nValue Integer iDecimals Integer iLen Returns String
23209>>>>>>>        Function_Return (RightAdjust(Self,NumberToString(Self,nValue,iDecimals),iLen))
23210>>>>>>>    End_Function
23211>>>>>>>
23211>>>>>>>    //> Function NumberToStringTS is the same as NumberToString except that thousands
23211>>>>>>>    //> separators are inserted. (TS=Thousands Separator)
23211>>>>>>>    Function NumberToStringTS Number nValue Integer iDecimals Returns String
23213>>>>>>>        String sRval
23213>>>>>>>        Set _pbInsertThousandsSeparators to True
23214>>>>>>>        Get NumberToString nValue iDecimals to sRval
23215>>>>>>>        Set _pbInsertThousandsSeparators to False
23216>>>>>>>        Function_Return sRval
23217>>>>>>>    End_Function
23218>>>>>>>
23218>>>>>>>    //> This function is identical to NumberToStringTS except that you have to specify
23218>>>>>>>    //> the length of the return value (iLen). The return value will be right
23218>>>>>>>    //> justified accordingly.
23218>>>>>>>    Function NumberToStringRTS Number nValue Integer iDecimals Integer iLen Returns String
23220>>>>>>>        String sRval
23220>>>>>>>        Get NumberToStringTS nValue iDecimals to sRval
23221>>>>>>>        Get RightAdjust sRval iLen to sRval
23222>>>>>>>        Function_Return sRval
23223>>>>>>>    End_Function
23224>>>>>>>
23224>>>>>>>    //> The number nValue is rounded to 0 decimals and returned right justified in a string of
23224>>>>>>>    //> length iLen. Lead in blanks are substituted for zeros (zf=zero fill).
23224>>>>>>>    Function IntegerToStringRzf Number nValue Integer iLen Returns String
23226>>>>>>>        String sRval
23226>>>>>>>        Get NumberToStringR nValue 0 iLen to sRval
23227>>>>>>>        Function_Return (replaces(" ",sRval,"0"))
23228>>>>>>>    End_Function
23229>>>>>>>    
23229>>>>>>>    Function StringToNumber String sValue Returns Number
23231>>>>>>>        String sDec sNotDec
23231>>>>>>>        Number nValue
23231>>>>>>>        Get psDecimalSeparator to sDec
23232>>>>>>>        Get psThousandsSeparator to sNotDec
23233>>>>>>>        Move (Replace(sNotDec,sValue,sDec)) to sValue
23234>>>>>>>        Move sValue to nValue
23235>>>>>>>        Function_Return nValue
23236>>>>>>>    End_Function
23237>>>>>>>
23237>>>>>>>    //> Use this function to obtain the number of the least significant "non zero
23237>>>>>>>    //> decimal in nValue. 0.702 will return 3 while 100 will return -2.
23237>>>>>>>    Function NumberOfDecimals Number nValue Returns Integer
23239>>>>>>>        Integer iCount
23239>>>>>>>        String sNumber sDecimalSeparator
23239>>>>>>>
23239>>>>>>>        If (nValue=0) Function_Return 0 // Special case
23242>>>>>>>        Move nValue to sNumber // This removes superflous decimals
23243>>>>>>>
23243>>>>>>>        Get psDecimalSeparator to sDecimalSeparator
23244>>>>>>>        If (pos(sDecimalSeparator,sNumber)) Function_Return (length(sNumber)-pos(sDecimalSeparator,sNumber))
23247>>>>>>>
23247>>>>>>>        Move 0 to iCount
23248>>>>>>>        While (right(sNumber,1)="0")
23252>>>>>>>            Move (left(sNumber,length(sNumber)-1)) to sNumber
23253>>>>>>>            Decrement iCount
23254>>>>>>>        End
23255>>>>>>>>
23255>>>>>>>        Function_Return iCount
23256>>>>>>>    End_Function
23257>>>>>>>
23257>>>>>>>    //> IsInteger returns True if the value held by the sValue parameter is an integer (the function does not handle thousand seps).
23257>>>>>>>    //> Note that even if this function returns True it may still not be possible to 'Move' the value to an integer variable. This will
23257>>>>>>>    //> be the case if the value falls outside of the integer value range (-2147483648 to 2147483647)
23257>>>>>>>    Function IsInteger String sValue Returns Boolean
23259>>>>>>>        Integer iPos iLen
23259>>>>>>>        Move (Trim(sValue)) to sValue
23260>>>>>>>        If (Left(sValue,1)="-") Move (Replace("-",sValue,"")) to sValue
23263>>>>>>>        Move (Length(sValue)) to iLen
23264>>>>>>>        For iPos from 1 to iLen
23270>>>>>>>>
23270>>>>>>>            If (not(Pos(Mid(sValue,1,iPos),"0123456789"))) begin
23272>>>>>>>                Function_Return False
23273>>>>>>>            End
23273>>>>>>>>
23273>>>>>>>        Loop
23274>>>>>>>>
23274>>>>>>>        Function_Return True
23275>>>>>>>    End_Function
23276>>>>>>>
23276>>>>>>>    //> This function returns True if sValue is a number or an integer (the function does not handle thousand seps)
23276>>>>>>>    //> Note that even if this function returns True it may still not be possible to 'Move' the value to a number variable. This will
23276>>>>>>>    //> be the case if the value falls outside of the number value range (+/-99999999999999.99999999)
23276>>>>>>>    Function IsNumber String sValue String sDecimalSeparator Returns Boolean
23278>>>>>>>        Integer iLen iPos iAscii
23278>>>>>>>        Boolean bDecSepFound
23278>>>>>>>        String sChar sSep
23278>>>>>>>        Move False to bDecSepFound
23279>>>>>>>        Move (Trim(sValue)) to sValue
23280>>>>>>>        If (Left(sValue,1)="-") Begin
23282>>>>>>>            Move (Replace("-",sValue,"")) to sValue
23283>>>>>>>        End
23283>>>>>>>>
23283>>>>>>>        If (num_arguments>1) Begin
23285>>>>>>>            Move sDecimalSeparator to sSep
23286>>>>>>>            If (not(",." contains sSep)) Begin // This error check may be removed in january 1st 2013
23288>>>>>>>                Error 666 "Decimal separator must be ',' or '.'"
23289>>>>>>>>
23289>>>>>>>            End
23289>>>>>>>>
23289>>>>>>>        End
23289>>>>>>>>
23289>>>>>>>        Else Begin
23290>>>>>>>            Get_Attribute DF_DECIMAL_SEPARATOR to iAscii
23293>>>>>>>            Move (Character(iAscii)) to sSep
23294>>>>>>>        End
23294>>>>>>>>
23294>>>>>>>        Move (Length(sValue)) to iLen
23295>>>>>>>        For iPos from 1 to iLen
23301>>>>>>>>
23301>>>>>>>            Move (Mid(sValue,1,iPos)) to sChar
23302>>>>>>>            If (sChar=sSep) Begin
23304>>>>>>>                If bDecSepFound Function_Return False
23307>>>>>>>                Move True to bDecSepFound
23308>>>>>>>            End
23308>>>>>>>>
23308>>>>>>>            Else If (not("0123456789" contains sChar)) Begin 
23311>>>>>>>                Function_Return False
23312>>>>>>>            End
23312>>>>>>>>
23312>>>>>>>        Loop
23313>>>>>>>>
23313>>>>>>>        Function_Return True
23314>>>>>>>    End_Function
23315>>>>>>>    
23315>>>>>>>    //> Convert a byte value (0-255) to its hex equivalent. Passing for example 27 makes it return "1B".
23315>>>>>>>    Function ByteToHex Integer iByte Returns String
23317>>>>>>>        Function_Return (Mid("0123456789ABCDEF",1,iByte/16+1)+Mid("0123456789ABCDEF",1,(iByte iand 15)+1))
23318>>>>>>>    End_Function
23319>>>>>>>
23319>>>>>>>    //> Convert a hexadecimal value to its byte equivalent: Passing "FF" for example makes it return 255.
23319>>>>>>>    Function HexToByte String sHex Returns Integer
23321>>>>>>>        Move (Uppercase(sHex)) to sHex
23322>>>>>>>        Function_Return (Pos(Left(sHex,1),"0123456789ABCDEF")-1*16+Pos(Right(sHex,1),"0123456789ABCDEF")-1)
23323>>>>>>>    End_Function
23324>>>>>>>    
23324>>>>>>>    Function IsHex String sHex Returns Boolean
23326>>>>>>>        Integer iLen iPos
23326>>>>>>>        String sChar
23326>>>>>>>        Move (Length(sHex)) to iLen
23327>>>>>>>        If (((iLen/2)*2)<>iLen) Function_Return False // Must be an equal number of characters
23330>>>>>>>        Move (Uppercase(sHex)) to sHex
23331>>>>>>>        For iPos from 1 to iLen
23337>>>>>>>>
23337>>>>>>>            Move (Mid(sHex,1,iPos)) to sChar
23338>>>>>>>            If not ("0123456789ABCDEF" contains sChar) Function_Return False
23341>>>>>>>        Loop
23342>>>>>>>>
23342>>>>>>>        Function_Return True
23343>>>>>>>    End_Function
23344>>>>>>>
23344>>>>>>>    //> Convert a string of characters to a string of hexadecimal values.
23344>>>>>>>    Function StringToHex String sValue Returns String
23346>>>>>>>        Integer iLen iPos
23346>>>>>>>        String sRval
23346>>>>>>>        Move (Length(sValue)) to iLen
23347>>>>>>>        Move "" to sRval
23348>>>>>>>        For iPos from 1 to iLen
23354>>>>>>>>
23354>>>>>>>            Move (String(sRval)+String(ByteToHex(Self,Ascii(Mid(sValue,1,iPos))))) to sRval
23355>>>>>>>        Loop
23356>>>>>>>>
23356>>>>>>>        Function_Return sRval
23357>>>>>>>    End_Function
23358>>>>>>>
23358>>>>>>>    //> Convert a string of hexadecimal values to a string of characters.
23358>>>>>>>    Function HexToString String sValue Returns String
23360>>>>>>>        Integer iLen iPos
23360>>>>>>>        String sRval
23360>>>>>>>        Move (Length(sValue)/2) to iLen
23361>>>>>>>        Move "" to sRval
23362>>>>>>>        For iPos from 1 to iLen
23368>>>>>>>>
23368>>>>>>>            Move (String(sRval)+Character(HexToByte(Self,Mid(sValue,2,iPos*2-1)))) to sRval
23369>>>>>>>        Loop
23370>>>>>>>>
23370>>>>>>>        Function_Return sRval
23371>>>>>>>    End_Function
23372>>>>>>>
23372>>>>>>>                    Function _iEncryptXor.iii Integer iXval Integer iYval Integer iBitCount Returns Integer // Private
23374>>>>>>>                        Integer iRval iBit iXbit iYbit iBitExp
23374>>>>>>>                        Move 0 to iRval
23375>>>>>>>                        For iBit from 0 to (iBitCount-1)
23381>>>>>>>>
23381>>>>>>>                            Move (2^iBit) to iBitExp
23382>>>>>>>                            Move ((iXval/iBitExp)-(((iXval/iBitExp)/2)*2)) to iXbit
23383>>>>>>>                            Move ((iYval/iBitExp)-(((iYval/iBitExp)/2)*2)) to iYbit
23384>>>>>>>                            If (iXbit<>iYbit) Move (iRval+iBitExp) to iRval
23387>>>>>>>                        Loop
23388>>>>>>>>
23388>>>>>>>                        Function_Return iRval
23389>>>>>>>                    End_Function
23390>>>>>>>
23390>>>>>>>    // The same function (Encrypt) is used to encrypt and decrypt a string:
23390>>>>>>>    //
23390>>>>>>>    //          Encrypt(string,code)
23390>>>>>>>    //                  |  Encrypt(encrypted_string,key)
23390>>>>>>>    //                  |                      |
23390>>>>>>>    //                  v                      v
23390>>>>>>>    //        <string> --> <encrypted string> --> <string>
23390>>>>>>>    //
23390>>>>>>>    // The code used to encrypt a string may be any integer value and must
23390>>>>>>>    // be the same when decrypting.
23390>>>>>>>    //
23390>>>>>>>    // Note that this is a very very weak encryption that can be decoded 
23390>>>>>>>    // easily. It only obscures the content from poeple that do not want
23390>>>>>>>    // to know.
23390>>>>>>>
23390>>>>>>>    Function Encrypt String sInput Integer iKey Integer iLen Returns String
23392>>>>>>>        Integer iPos
23392>>>>>>>        String sRval
23392>>>>>>>        Move "" to sRval
23393>>>>>>>        For iPos from 1 to iLen
23399>>>>>>>>
23399>>>>>>>            Move (sRval+character(_iEncryptXor.iii(Self,ascii(mid(pad(sInput,iLen),1,iPos)),((iKey+(iPos*7)) iand 31),8))) to sRval
23400>>>>>>>        Loop
23401>>>>>>>>
23401>>>>>>>        Function_Return sRval
23402>>>>>>>    End_Function
23403>>>>>>>
23403>>>>>>>    //> The SplitString procedure splits the value in sValue into a number of items based on the character in the sSeparatorChar
23403>>>>>>>    //> parameter. These items are returned (by reference) in the aValues parameter.
23403>>>>>>>    //>
23403>>>>>>>    //> Parameters:
23403>>>>>>>    //>     sValue: The string to be divided into items.
23403>>>>>>>    //>
23403>>>>>>>    //>     sSeparatorChar:  determines which character(s) is considered a "dividing" character.
23403>>>>>>>    //>     bIgnoreDoubleSeparators: if two or more separater characters are encountered in immediate
23403>>>>>>>    //>                      succession, this parameter decides whether they should be considered
23403>>>>>>>    //>                      as one divider or as a number of separate dividers.
23403>>>>>>>    //>     bProtectQuotes:  if this is true, strings in quotes (single or double) will not be
23403>>>>>>>    //>                      scanned for separating characters.
23403>>>>>>>    //>     aValues:         The result. Any values present at the time of calling are removed as
23403>>>>>>>    //>                      part of the procedure initialization.
23403>>>>>>>    //>
23403>>>>>>>    Procedure SplitString String sValue String sSeparatorChar Boolean bIgnoreDoubleSeparators Boolean bProtectQuotes String[] ByRef aValues
23405>>>>>>>        Integer iLen       // Length of the string we are parsing
23405>>>>>>>        Integer iItem      // Pointer to the next available index in the target array (aValues)
23405>>>>>>>        Integer iStartItem // Number of items originally in the target array
23405>>>>>>>        Integer iPos       // The current position in the string (sValue) we are parsing
23405>>>>>>>
23405>>>>>>>        String  sChar      // The character currently being examined by the loop
23405>>>>>>>        String  sItem      // The value of the next item as it is being built
23405>>>>>>>        String  sQuoteChar // If " or ', we are currently in a quoted section of the string
23405>>>>>>>        String  sQuotes    // Quotation characters: "'
23405>>>>>>>
23405>>>>>>>        Move "" to sQuoteChar
23406>>>>>>>
23406>>>>>>>        Move (ResizeArray(aValues,0)) to aValues
23407>>>>>>>        Move 0 to iStartItem
23408>>>>>>>
23408>>>>>>>        Move iStartItem to iItem
23409>>>>>>>        Move (length(sValue)) to iLen
23410>>>>>>>        Move "" to sItem
23411>>>>>>>        Move ("'"+'"') to sQuotes
23412>>>>>>>
23412>>>>>>>        Move 1 to iPos
23413>>>>>>>        If (bIgnoreDoubleSeparators) Begin // Leadin separating characters are to be disregarded, we advance the position accordingly
23415>>>>>>>            While (iPos<=iLen and sSeparatorChar contains mid(sValue,1,iPos))
23419>>>>>>>              Increment iPos
23420>>>>>>>            End
23421>>>>>>>>
23421>>>>>>>        End
23421>>>>>>>>
23421>>>>>>>        While (iPos<=iLen)
23425>>>>>>>            Move (mid(sValue,1,iPos)) to sChar
23426>>>>>>>            Increment iPos
23427>>>>>>>
23427>>>>>>>            If (sQuoteChar<>"") Begin
23429>>>>>>>                If (sChar=sQuoteChar) Begin
23431>>>>>>>                    Move "" to sQuoteChar
23432>>>>>>>                End
23432>>>>>>>>
23432>>>>>>>                Move (sItem+sChar) to sItem
23433>>>>>>>            End
23433>>>>>>>>
23433>>>>>>>            Else Begin // We're not in a quote
23434>>>>>>>                If (sSeparatorChar contains sChar) Begin
23436>>>>>>>                    Move sItem to aValues[iItem]
23437>>>>>>>                    Increment iItem
23438>>>>>>>                    Move "" to sItem
23439>>>>>>>
23439>>>>>>>                    If (bIgnoreDoubleSeparators) Begin // succeeding separating characters are to be considered as one, we advance the position accordingly
23441>>>>>>>                        While (iPos<=iLen and sSeparatorChar contains mid(sValue,1,iPos))
23445>>>>>>>                          Increment iPos
23446>>>>>>>                        End
23447>>>>>>>>
23447>>>>>>>                    End
23447>>>>>>>>
23447>>>>>>>                End
23447>>>>>>>>
23447>>>>>>>                Else If (bProtectQuotes<>0 and sQuotes contains sChar and Trim(sItem)="") Begin
23450>>>>>>>                    Move sChar to sQuoteChar
23451>>>>>>>                    Move (sItem+sChar) to sItem
23452>>>>>>>                End
23452>>>>>>>>
23452>>>>>>>                Else Begin
23453>>>>>>>                    Move (sItem+sChar) to sItem
23454>>>>>>>                End
23454>>>>>>>>
23454>>>>>>>            End
23454>>>>>>>>
23454>>>>>>>        End
23455>>>>>>>>
23455>>>>>>>
23455>>>>>>>        // Added "or not(bIgnoreDoubleSeparators)" to the below statement to add the last item, even if it's blank
23455>>>>>>>        If (sItem<>"" or not(bIgnoreDoubleSeparators)) Begin
23457>>>>>>>            Move sItem to aValues[iItem]
23458>>>>>>>            Increment iItem
23459>>>>>>>        End
23459>>>>>>>>
23459>>>>>>>    End_Procedure // SplitString
23460>>>>>>>    
23460>>>>>>>            Function _SplitStringReverse String[] aValues String sSeparator Integer iMinIndex Integer iMaxIndex Returns String
23462>>>>>>>                Integer iIndex
23462>>>>>>>                String sRval
23462>>>>>>>                String sValue
23462>>>>>>>                         
23462>>>>>>>                Move (iMaxIndex min (SizeOfArray(aValues)-1)) to iMaxIndex
23463>>>>>>>                Move (iMinIndex max 0) to iMinIndex
23464>>>>>>>                
23464>>>>>>>                Move "" to sRval
23465>>>>>>>                For iIndex from iMinIndex to iMaxIndex
23471>>>>>>>>
23471>>>>>>>                    Move aValues[iIndex] to sValue
23472>>>>>>>                    Move (sRval+sValue) to sRval
23473>>>>>>>                    If (iIndex<>iMaxIndex) Begin
23475>>>>>>>                        Move (sRval+sSeparator) to sRval
23476>>>>>>>                    End
23476>>>>>>>>
23476>>>>>>>                Loop
23477>>>>>>>>
23477>>>>>>>                Function_Return sRval
23478>>>>>>>            End_Function
23479>>>>>>>    
23479>>>>>>>    Function JoinString String[] aValues String sSeparator Integer iSkipHead Integer iSkipTail Returns String 
23481>>>>>>>        Integer iMax
23481>>>>>>>        Move (SizeOfArray(aValues)-1) to iMax
23482>>>>>>>        Function_Return (_SplitStringReverse(Self,aValues,sSeparator,iSkipHead,iMax-iSkipTail))
23483>>>>>>>    End_Function
23484>>>>>>>    
23484>>>>>>>//    Function SplitStringHead String sValue String sSeparatorChar Integer bIgnoreDoubleSeparators Integer bProtectQuotes Returns String
23484>>>>>>>//        String[] aValues
23484>>>>>>>//        Send SplitString sValue sSeparatorChar bIgnoreDoubleSeparators bProtectQuotes (&aValues)
23484>>>>>>>//        If (SizeOfArray(aValues)) Function_Return aValues[0]
23484>>>>>>>//        Function_Return ""
23484>>>>>>>//    End_Function
23484>>>>>>>//    
23484>>>>>>>//    Procedure SplitStringTail String sValue String sSeparatorChar Integer bIgnoreDoubleSeparators Integer bProtectQuotes String[] ByRef aValues
23484>>>>>>>//        Integer iSize
23484>>>>>>>//        Send SplitString sValue sSeparatorChar bIgnoreDoubleSeparators bProtectQuotes (&aValues)
23484>>>>>>>//        Move (SizeOfArray(aValues)) to iSize
23484>>>>>>>//        If (iSize>1) Move (CopyArray(aValues,1,iSize-1)) to aValues
23484>>>>>>>//        Else Move (ResizeArray(aValues,0)) to aValues
23484>>>>>>>//    End_Procedure
23484>>>>>>>    
23484>>>>>>>            Procedure _WildCardAddItem tWildCardEvalSequence ByRef sSequence Integer iType String sValue // Private
23486>>>>>>>                Integer iSize
23486>>>>>>>                Move (SizeOfArray(sSequence.aSequence)) to iSize
23487>>>>>>>                Move iType to sSequence.aSequence[iSize].iType
23488>>>>>>>                Move sValue to sSequence.aSequence[iSize].sValue
23489>>>>>>>            End_Procedure
23490>>>>>>>
23490>>>>>>>            Procedure _WildCardOptimizeSequence tWildCardEvalSequence ByRef sSequence // Private
23492>>>>>>>                Integer iSize
23492>>>>>>>
23492>>>>>>>                Move (SizeOfArray(sSequence.aSequence)) to iSize
23493>>>>>>>                Move _WILDC_THE_HARD_WAY to sSequence.iAltStrategy
23494>>>>>>>                Move False to sSequence.bAltStrategyRejectOnly
23495>>>>>>>                If (iSize=1) Begin
23497>>>>>>>                    If (sSequence.aSequence[0].iType=_WILDC_ASTERISK) Move _WILDC_ALWAYS_TRUE to sSequence.iAltStrategy
23500>>>>>>>                    If (sSequence.aSequence[0].iType=_WILDC_CONSTANT) Begin
23502>>>>>>>                        Move _WILDC_EQUAL to sSequence.iAltStrategy
23503>>>>>>>                        Move sSequence.aSequence[0].sValue to sSequence.sAltStrategyLeftValue
23504>>>>>>>                    End
23504>>>>>>>>
23504>>>>>>>                End
23504>>>>>>>>
23504>>>>>>>                Else if (iSize>0) Begin
23507>>>>>>>                    If (sSequence.aSequence[0].iType=_WILDC_CONSTANT) Begin // If leftmost is a constant
23509>>>>>>>                        If (sSequence.aSequence[iSize-1].iType=_WILDC_CONSTANT) Begin // if rightmost is also a constant
23511>>>>>>>                            If (iSize=3 and sSequence.aSequence[1].iType=_WILDC_ASTERISK) Begin
23513>>>>>>>                                Move _WILDC_LEFT_AND_RIGHT_MATCH to sSequence.iAltStrategy
23514>>>>>>>                                Move sSequence.aSequence[0].sValue to sSequence.sAltStrategyLeftValue
23515>>>>>>>                                Move sSequence.aSequence[iSize-1].sValue to sSequence.sAltStrategyRightValue
23516>>>>>>>                            End
23516>>>>>>>>
23516>>>>>>>                            Else Begin
23517>>>>>>>                                Move _WILDC_LEFT_AND_RIGHT_MATCH to sSequence.iAltStrategy
23518>>>>>>>                                Move sSequence.aSequence[0].sValue to sSequence.sAltStrategyLeftValue
23519>>>>>>>                                Move sSequence.aSequence[iSize-1].sValue to sSequence.sAltStrategyRightValue
23520>>>>>>>                                Move True to sSequence.bAltStrategyRejectOnly
23521>>>>>>>                            End
23521>>>>>>>>
23521>>>>>>>                        End
23521>>>>>>>>
23521>>>>>>>                        Else Begin
23522>>>>>>>                            If (iSize=2 and sSequence.aSequence[1].iType=_WILDC_ASTERISK) Begin
23524>>>>>>>                                Move _WILDC_LEFT_MATCH to sSequence.iAltStrategy
23525>>>>>>>                                Move sSequence.aSequence[0].sValue to sSequence.sAltStrategyLeftValue
23526>>>>>>>                            End
23526>>>>>>>>
23526>>>>>>>                            Else Begin
23527>>>>>>>                                Move _WILDC_LEFT_MATCH to sSequence.iAltStrategy
23528>>>>>>>                                Move sSequence.aSequence[0].sValue to sSequence.sAltStrategyLeftValue
23529>>>>>>>                                Move True to sSequence.bAltStrategyRejectOnly
23530>>>>>>>                            End
23530>>>>>>>>
23530>>>>>>>                        End
23530>>>>>>>>
23530>>>>>>>                    End
23530>>>>>>>>
23530>>>>>>>                    Else Begin
23531>>>>>>>                        If (sSequence.aSequence[iSize-1].iType=_WILDC_CONSTANT) Begin // If rightmost is a constant
23533>>>>>>>                            If (iSize=2 and sSequence.aSequence[0].iType=_WILDC_ASTERISK) Begin
23535>>>>>>>                                Move _WILDC_RIGHT_MATCH to sSequence.iAltStrategy
23536>>>>>>>                                Move sSequence.aSequence[iSize-1].sValue to sSequence.sAltStrategyRightValue
23537>>>>>>>                            End
23537>>>>>>>>
23537>>>>>>>                            Else Begin
23538>>>>>>>                                Move _WILDC_RIGHT_MATCH to sSequence.iAltStrategy
23539>>>>>>>                                Move sSequence.aSequence[iSize-1].sValue to sSequence.sAltStrategyRightValue
23540>>>>>>>                                Move True to sSequence.bAltStrategyRejectOnly
23541>>>>>>>                            End
23541>>>>>>>>
23541>>>>>>>                        End
23541>>>>>>>>
23541>>>>>>>                        Else Begin // Now we check if first and last are asterisks
23542>>>>>>>                            If (iSize=3 and sSequence.aSequence[0].iType=_WILDC_ASTERISK and sSequence.aSequence[1].iType=_WILDC_CONSTANT and sSequence.aSequence[2].iType=_WILDC_ASTERISK) Begin
23544>>>>>>>                                Move _WILDC_CONTAINS to sSequence.iAltStrategy
23545>>>>>>>                                Move sSequence.aSequence[1].sValue to sSequence.sAltStrategyLeftValue
23546>>>>>>>                            End
23546>>>>>>>>
23546>>>>>>>                        End
23546>>>>>>>>
23546>>>>>>>                    End
23546>>>>>>>>
23546>>>>>>>                End
23546>>>>>>>>
23546>>>>>>>            End_Procedure
23547>>>>>>>
23547>>>>>>>    Function WildCardEvalSequence String sMask Returns tWildCardEvalSequence
23549>>>>>>>        Integer iLen iPos
23549>>>>>>>        String sItem sChar
23549>>>>>>>        tWildCardEvalSequence sSequence
23549>>>>>>>        tWildCardEvalSequence sSequence
23549>>>>>>>        Move _WILDC_THE_HARD_WAY to sSequence.iAltStrategy
23550>>>>>>>        Move (Replaces("**",sMask,"*")) to sMask // Simple reduction
23551>>>>>>>        Move (Length(sMask)) to iLen
23552>>>>>>>        Move "" to sItem
23553>>>>>>>        For iPos from 1 to iLen
23559>>>>>>>>
23559>>>>>>>            Move (Mid(sMask,1,iPos)) to sChar
23560>>>>>>>            If (sChar="*") Begin
23562>>>>>>>                If (sItem<>"") Begin
23564>>>>>>>                    Send _WildCardAddItem (&sSequence) _WILDC_CONSTANT sItem
23565>>>>>>>                    Move "" to sItem
23566>>>>>>>                End
23566>>>>>>>>
23566>>>>>>>                Send _WildCardAddItem (&sSequence) _WILDC_ASTERISK ""
23567>>>>>>>            End
23567>>>>>>>>
23567>>>>>>>            Else If (sChar="?") Begin
23570>>>>>>>                If (sItem<>"") Begin
23572>>>>>>>                    Send _WildCardAddItem (&sSequence) _WILDC_CONSTANT sItem
23573>>>>>>>                    Move "" to sItem
23574>>>>>>>                End
23574>>>>>>>>
23574>>>>>>>                Send _WildCardAddItem (&sSequence) _WILDC_QUESTIONMARK ""
23575>>>>>>>            End
23575>>>>>>>>
23575>>>>>>>            Else Move (sItem+sChar) to sItem
23577>>>>>>>        Loop
23578>>>>>>>>
23578>>>>>>>        If (sItem<>"") Send _WildCardAddItem (&sSequence) _WILDC_CONSTANT sItem
23581>>>>>>>        Send _WildCardOptimizeSequence (&sSequence)
23582>>>>>>>        Function_Return sSequence
23583>>>>>>>    End_Function
23584>>>>>>>    
23584>>>>>>>    Function WildCardEvalSequences String[] aMasks Returns tWildCardEvalSequence[]
23586>>>>>>>        Integer iItem iMax
23586>>>>>>>        tWildCardEvalSequence[] aSeq
23586>>>>>>>        tWildCardEvalSequence[] aSeq
23587>>>>>>>        Move (SizeOfArray(aMasks)-1) to iMax
23588>>>>>>>        For iItem from 0 to iMax
23594>>>>>>>>
23594>>>>>>>            Get WildCardEvalSequence aMasks[iItem] to aSeq[iItem]
23595>>>>>>>        Loop
23596>>>>>>>>
23596>>>>>>>        Function_Return aSeq
23597>>>>>>>    End_Function
23598>>>>>>>    
23598>>>>>>>    Procedure AddWildCardEvalSequence String sMask tWildCardEvalSequence[] ByRef aEvalSequences
23600>>>>>>>        Integer iIndex
23600>>>>>>>        Move (SizeOfArray(aEvalSequences)) to iIndex
23601>>>>>>>        Get WildCardEvalSequence sMask to aEvalSequences[iIndex]
23602>>>>>>>    End_Procedure
23603>>>>>>>
23603>>>>>>>    Procedure AddWildCardEvalSequences String[] aMasks tWildCardEvalSequence[] ByRef aEvalSequences
23605>>>>>>>        Integer iIndex iMax
23605>>>>>>>        Move (SizeOfArray(aMasks)-1) to iMax
23606>>>>>>>        For iIndex from 0 to iMax
23612>>>>>>>>
23612>>>>>>>            Send AddWildCardEvalSequence aMasks[iIndex] (&aEvalSequences)
23613>>>>>>>        Loop
23614>>>>>>>>
23614>>>>>>>    End_Procedure
23615>>>>>>>
23615>>>>>>>            Function _WildCardMatchRecursive Integer iItem String sValue tWildCardEvalSequence ByRef sSequence Returns Boolean // Private
23617>>>>>>>                Integer iMax iType iLen iPos
23617>>>>>>>                String sItem
23617>>>>>>>                Move (SizeOfArray(sSequence.aSequence)) to iMax
23618>>>>>>>                If (iItem>=iMax) Begin
23620>>>>>>>                    If (sValue="") Function_Return True
23623>>>>>>>                    Function_Return False
23624>>>>>>>                End
23624>>>>>>>>
23624>>>>>>>                Move sSequence.aSequence[iItem].iType to iType
23625>>>>>>>                If (iType=_WILDC_CONSTANT) Begin // constant
23627>>>>>>>                    If (length(sValue)=0) Function_Return False
23630>>>>>>>                    Move sSequence.aSequence[iItem].sValue to sItem
23631>>>>>>>                    Move (length(sItem)) to iLen
23632>>>>>>>                  //If (sItem=left(sValue,iLen)) Function_Return (_WildCardMatchRecursive(Self,iItem+1,RightFromPos(Self,sValue,iLen+1),&sSequence))
23632>>>>>>>                    If (sItem=left(sValue,iLen)) Function_Return (_WildCardMatchRecursive(Self,iItem+1,Remove(sValue,1,iLen),&sSequence))
23635>>>>>>>                    Function_Return 0
23636>>>>>>>                End
23636>>>>>>>>
23636>>>>>>>                If (iType=_WILDC_QUESTIONMARK) Begin // ?
23638>>>>>>>                    If (length(sValue)=0) Function_Return False
23641>>>>>>>                  //Function_Return (_WildCardMatchRecursive(Self,iItem+1,RightFromPos(Self,sValue,2),&sSequence))
23641>>>>>>>                    Function_Return (_WildCardMatchRecursive(Self,iItem+1,Remove(sValue,1,1),&sSequence))
23642>>>>>>>                End
23642>>>>>>>>
23642>>>>>>>                If (iType=_WILDC_ASTERISK) Begin // *
23644>>>>>>>                    If (iItem=(iMax-1)) Function_Return True
23647>>>>>>>                    Move (length(sValue)) to iLen
23648>>>>>>>                    For iPos from 0 to iLen
23654>>>>>>>>
23654>>>>>>>                      //If (_WildCardMatchRecursive(Self,iItem+1,RightFromPos(Self,sValue,iPos+1),&sSequence)) Function_Return True
23654>>>>>>>                        If (_WildCardMatchRecursive(Self,iItem+1,Remove(sValue,1,iPos),&sSequence)) Function_Return True
23657>>>>>>>                    Loop
23658>>>>>>>>
23658>>>>>>>                End
23658>>>>>>>>
23658>>>>>>>                Function_Return False
23659>>>>>>>            End_Function
23660>>>>>>>            
23660>>>>>>>    Function WildCardMatch String sValue tWildCardEvalSequence sSequence Returns Boolean
23662>>>>>>>        Integer iPos iPosEnd
23662>>>>>>>        String sWordCharacters
23662>>>>>>>        If (sSequence.iAltStrategy=_WILDC_ALWAYS_TRUE) Function_Return True
23665>>>>>>>        If (sSequence.iAltStrategy=_WILDC_EQUAL) Function_Return (sValue=sSequence.sAltStrategyLeftValue)
23668>>>>>>>        If (sSequence.iAltStrategy=_WILDC_LEFT_MATCH) Begin
23670>>>>>>>            If (sSequence.bAltStrategyRejectOnly) Begin
23672>>>>>>>                If (not(BeginsWith(Self,sValue,sSequence.sAltStrategyLeftValue))) Begin
23674>>>>>>>                    Function_Return False
23675>>>>>>>                End
23675>>>>>>>>
23675>>>>>>>            End
23675>>>>>>>>
23675>>>>>>>            Else Function_Return (BeginsWith(Self,sValue,sSequence.sAltStrategyLeftValue))
23677>>>>>>>        End
23677>>>>>>>>
23677>>>>>>>        If (sSequence.iAltStrategy=_WILDC_RIGHT_MATCH) Begin
23679>>>>>>>            If (sSequence.bAltStrategyRejectOnly) Begin
23681>>>>>>>                If (not(EndsWith(Self,sValue,sSequence.sAltStrategyRightValue))) Begin
23683>>>>>>>                    Function_Return False
23684>>>>>>>                End
23684>>>>>>>>
23684>>>>>>>            End
23684>>>>>>>>
23684>>>>>>>            Else Function_Return (EndsWith(Self,sValue,sSequence.sAltStrategyRightValue))
23686>>>>>>>        End
23686>>>>>>>>
23686>>>>>>>        If (sSequence.iAltStrategy=_WILDC_LEFT_AND_RIGHT_MATCH) Begin
23688>>>>>>>            If (sSequence.bAltStrategyRejectOnly) Begin
23690>>>>>>>                If (not(BeginsWith(Self,sValue,sSequence.sAltStrategyLeftValue) and EndsWith(Self,sValue,sSequence.sAltStrategyRightValue))) Begin
23692>>>>>>>                    Function_Return False
23693>>>>>>>                End
23693>>>>>>>>
23693>>>>>>>            End
23693>>>>>>>>
23693>>>>>>>            Else Function_Return (BeginsWith(Self,sValue,sSequence.sAltStrategyLeftValue) and EndsWith(Self,sValue,sSequence.sAltStrategyRightValue))
23695>>>>>>>        End
23695>>>>>>>>
23695>>>>>>>        If (sSequence.iAltStrategy=_WILDC_CONTAINS) Begin
23697>>>>>>>            Function_Return (sValue contains sSequence.sAltStrategyLeftValue)
23698>>>>>>>        End
23698>>>>>>>>
23698>>>>>>>        If (sSequence.iAltStrategy=_WILDC_CONTAINS_WORDONLY) Begin
23700>>>>>>>            Move 1 to iPos
23701>>>>>>>            Get psWildCardWordCharacters to sWordCharacters
23702>>>>>>>            While (iPos>0)
23706>>>>>>>                Move (Pos(sSequence.sAltStrategyLeftValue,sValue,iPos)) to iPos
23707>>>>>>>                If (iPos>0) Begin
23709>>>>>>>                    If (iPos=1 or not(sWordCharacters contains Mid(sValue,1,iPos-1))) Begin
23711>>>>>>>                        Move (iPos+Length(sSequence.sAltStrategyLeftValue)) to iPosEnd
23712>>>>>>>                        If (iPosEnd>Length(sValue) or not(sWordCharacters contains Mid(sValue,1,iPosEnd))) Begin
23714>>>>>>>                            Function_Return True
23715>>>>>>>                        End
23715>>>>>>>>
23715>>>>>>>                    End
23715>>>>>>>>
23715>>>>>>>                    Increment iPos
23716>>>>>>>                End
23716>>>>>>>>
23716>>>>>>>            Loop
23717>>>>>>>>
23717>>>>>>>            Function_Return False
23718>>>>>>>        End
23718>>>>>>>>
23718>>>>>>>        Function_Return (_WildCardMatchRecursive(Self,0,sValue,&sSequence))
23719>>>>>>>    End_Function
23720>>>>>>>
23720>>>>>>>    Function WildCardMatchAny String sValue tWildCardEvalSequence[] aSequences Returns Boolean
23722>>>>>>>        Integer iItm iMax
23722>>>>>>>        Move (SizeOfArray(aSequences)) to iMax
23723>>>>>>>        Decrement iMax
23724>>>>>>>        For iItm from 0 to iMax
23730>>>>>>>>
23730>>>>>>>            If (WildCardMatch(Self,sValue,aSequences[iItm])) Function_Return True
23733>>>>>>>        Loop
23734>>>>>>>>
23734>>>>>>>        Function_Return False
23735>>>>>>>    End_Function
23736>>>>>>>
23736>>>>>>>    Function WildCardMatchAll String sValue tWildCardEvalSequence[] aSequences Returns Boolean
23738>>>>>>>        Integer iItm iMax
23738>>>>>>>        Move (SizeOfArray(aSequences)) to iMax
23739>>>>>>>        Decrement iMax
23740>>>>>>>        For iItm from 0 to iMax
23746>>>>>>>>
23746>>>>>>>            If not (WildCardMatch(Self,sValue,aSequences[iItm])) Function_Return False
23749>>>>>>>        Loop
23750>>>>>>>>
23750>>>>>>>        Function_Return True
23751>>>>>>>    End_Function
23752>>>>>>>
23752>>>>>>>    Function UppercaseFirstLetters String sValue Returns String
23754>>>>>>>        Boolean bInWord
23754>>>>>>>        Integer iLen iPos
23754>>>>>>>        String sRval sChar
23754>>>>>>>        Move (Lowercase(sValue)) to sValue
23755>>>>>>>        Move (Length(sValue)) to iLen
23756>>>>>>>        Move 0 to bInWord
23757>>>>>>>        For iPos from 1 to iLen
23763>>>>>>>>
23763>>>>>>>            Move (Mid(sValue,1,iPos)) to sChar
23764>>>>>>>            If (sChar="") Move False to bInWord
23767>>>>>>>            Else Begin
23768>>>>>>>                If (not(bInWord)) Begin
23770>>>>>>>                    Move (Uppercase(sChar)) to sChar
23771>>>>>>>                    Move True to bInWord
23772>>>>>>>                End
23772>>>>>>>>
23772>>>>>>>            End
23772>>>>>>>>
23772>>>>>>>            Move (sRval+sChar) to sRval
23773>>>>>>>        Loop
23774>>>>>>>>
23774>>>>>>>        Function_Return sRval
23775>>>>>>>    End_Function
23776>>>>>>>
23776>>>>>>>    // Knut Sparhell pointed to this address for a thorough explanation: http://www.merriampark.com/ld.htm
23776>>>>>>>    Function LongestCommonSequence String sWord1 String sWord2 Returns Integer
23778>>>>>>>        Integer iLen1 iLen2
23778>>>>>>>        Integer iPos1 iPos2
23778>>>>>>>        Integer[][] aArray
23779>>>>>>>        Move (length(sWord1)) to iLen1
23780>>>>>>>        Move (length(sWord2)) to iLen2
23781>>>>>>>        If (iLen1=0 or iLen2=0) Function_Return 0
23784>>>>>>>        For iPos1 from 1 to iLen1
23790>>>>>>>>
23790>>>>>>>            Move 0 to aArray[iPos1][0]
23791>>>>>>>            For iPos2 from 1 to iLen2
23797>>>>>>>>
23797>>>>>>>                If (iPos1=1) Move 0 to aArray[0][iPos2]
23800>>>>>>>                If (mid(sWord1,1,iPos1)=mid(sWord2,1,iPos2)) Begin
23802>>>>>>>                    Move (aArray[iPos1-1][iPos2-1]+1) to aArray[iPos1][iPos2]
23803>>>>>>>                End
23803>>>>>>>>
23803>>>>>>>                Else If (aArray[iPos1-1][iPos2]>=aArray[iPos1][iPos2-1]) Begin
23806>>>>>>>                    Move aArray[iPos1-1][iPos2] to aArray[iPos1][iPos2]
23807>>>>>>>                End
23807>>>>>>>>
23807>>>>>>>                Else Begin
23808>>>>>>>                    Move aArray[iPos1][iPos2-1] to aArray[iPos1][iPos2]
23809>>>>>>>                End
23809>>>>>>>>
23809>>>>>>>            Loop
23810>>>>>>>>
23810>>>>>>>        Loop
23811>>>>>>>>
23811>>>>>>>        Function_Return aArray[iLen1][iLen2]
23812>>>>>>>    End_Function
23813>>>>>>>
23813>>>>>>>    //> Returns the number of faulty keystrokes needed for sWord1 to accidentally become sWord2 (called the "Levenshtein distance")
23813>>>>>>>    Function SpellingDistance String sWord1 String sWord2 Returns Integer
23815>>>>>>>        Integer iLCS iMaxLen
23815>>>>>>>        Move (length(sWord1) max length(sWord2)) to iMaxLen
23816>>>>>>>        Get LongestCommonSequence sWord1 sWord2 to iLCS
23817>>>>>>>        Function_Return (iMaxLen-iLCS)
23818>>>>>>>        Function_Return (Length(sWord1)+Length(sWord2)-iLCS-iLCS)
23819>>>>>>>    End_Function
23820>>>>>>>
23820>>>>>>>    Define GPW_VOCALS     for "aeiouy"
23820>>>>>>>    Define GPW_CONSONANTS for "bcdfghjklmnpqrstvwxz"
23820>>>>>>>
23820>>>>>>>    //> This function generates a password composed from a number of random syllables (consonant+vocal). The iLen
23820>>>>>>>    //> parameter specifues the number of syllables (and therefore half the length of the return value measured in characters)
23820>>>>>>>    Function GenerateRandomPassword Integer iLen Returns String
23822>>>>>>>        Integer iPos iPosV iPosC iLenV iLenC
23822>>>>>>>        String sRval
23822>>>>>>>        Move (Length(GPW_CONSONANTS)) to iLenC
23823>>>>>>>        Move (Length(GPW_VOCALS)) to iLenV
23824>>>>>>>        For iPos from 1 to iLen
23830>>>>>>>>
23830>>>>>>>            Move (Random(iLenC)) to iPosC
23831>>>>>>>            Move (Random(iLenV)) to iPosV
23832>>>>>>>            Move (sRval+Mid(GPW_CONSONANTS,1,iPosC+1)+Mid(GPW_VOCALS,1,iPosV+1)) to sRval
23833>>>>>>>        Loop
23834>>>>>>>>
23834>>>>>>>        Function_Return sRval
23835>>>>>>>    End_Function
23836>>>>>>>
23836>>>>>>>    Function QuickHtmlEncode String sValue Returns String
23838>>>>>>>        Integer iLen iPos
23838>>>>>>>        String sRval sChar
23838>>>>>>>        Move (Length(sValue)) to iLen
23839>>>>>>>        For iPos from 1 to iLen
23845>>>>>>>>
23845>>>>>>>            Move (Mid(sValue,1,iPos)) to sChar
23846>>>>>>>            If (sChar='"') Move (sRval+"&quot;") to sRval
23849>>>>>>>            Else If (sChar="&") Move (sRval+"&amp;") to sRval
23853>>>>>>>            Else If (sChar="<") Move (sRval+"&lt;") to sRval
23857>>>>>>>            Else If (sChar=">") Move (sRval+"&gt;") to sRval
23861>>>>>>>            Else Move (sRval+sChar) to sRval
23863>>>>>>>        Loop
23864>>>>>>>>
23864>>>>>>>        Function_Return sRval
23865>>>>>>>    End_Function
23866>>>>>>>    
23866>>>>>>>    Function MakeColumnNameNice String sLabel Returns String
23868>>>>>>>        Integer iPos iLen
23868>>>>>>>        String sRval sChar
23868>>>>>>>        If (sLabel=Uppercase(sLabel)) Begin
23870>>>>>>>            Move (Lowercase(sLabel)) to sLabel
23871>>>>>>>        End
23871>>>>>>>>
23871>>>>>>>        Move (Replaces("_",sLabel," ")) to sLabel
23872>>>>>>>        Move (Length(sLabel)) to iLen
23873>>>>>>>        Move (Left(sLabel,1)) to sRval
23874>>>>>>>        For iPos from 2 to iLen
23880>>>>>>>>
23880>>>>>>>            Move (Mid(sLabel,1,iPos)) to sChar
23881>>>>>>>            If (sChar=Uppercase(sChar)) Begin
23883>>>>>>>                Move (sRval+" ") to sRval
23884>>>>>>>            End
23884>>>>>>>>
23884>>>>>>>            Move (sRval+sChar) to sRval
23885>>>>>>>        Loop
23886>>>>>>>>
23886>>>>>>>        Move (Replaces("  ",sRval," ")) to sRval
23887>>>>>>>        Function_Return (UppercaseFirstLetters(Self,sRval))
23888>>>>>>>    End_Function
23889>>>>>>>    
23889>>>>>>>    Procedure StripQuotes String ByRef sValue
23891>>>>>>>        Integer iLen
23891>>>>>>>        String sFirst sLast
23891>>>>>>>        Move (Length(sValue)) to iLen
23892>>>>>>>        If (iLen>1) Begin
23894>>>>>>>            Move (Left(sValue,1)) to sFirst
23895>>>>>>>            Move (Right(sValue,1)) to sLast
23896>>>>>>>            If (("'"+'"') contains sFirst and sFirst=sLast) Begin
23898>>>>>>>                Move (Mid(sValue,iLen-2,2)) to sValue
23899>>>>>>>            End
23899>>>>>>>>
23899>>>>>>>        End
23899>>>>>>>>
23899>>>>>>>    End_Procedure
23900>>>>>>>    
23900>>>>>>>    Function AddQuotes String ByRef sValue String sQuoteToCharacterPreferred Returns Boolean
23902>>>>>>>        If (sQuoteToCharacterPreferred="") Begin
23904>>>>>>>            Move '"' to sQuoteToCharacterPreferred
23905>>>>>>>        End                           
23905>>>>>>>>
23905>>>>>>>        
23905>>>>>>>        If (Pos(sQuoteToCharacterPreferred,sValue)>0) Begin
23907>>>>>>>            Move (If(sQuoteToCharacterPreferred="'",'"',"'")) to sQuoteToCharacterPreferred
23908>>>>>>>        End
23908>>>>>>>>
23908>>>>>>>        If (Pos(sQuoteToCharacterPreferred,sValue)=0) Begin
23910>>>>>>>            Move (sQuoteToCharacterPreferred+sValue+sQuoteToCharacterPreferred) to sValue
23911>>>>>>>            Function_Return True
23912>>>>>>>        End
23912>>>>>>>>
23912>>>>>>>        Function_Return False
23913>>>>>>>    End_Function
23914>>>>>>>    
23914>>>>>>>End_Class
23915>>>>>>>
23915>>>>>>>Global_Variable Integer oStringFunctions
23915>>>>>>>
23915>>>>>>>Object _oStringFunctions is a cStringFunctions 
23917>>>>>>>    Move Self to oStringFunctions
23918>>>>>>>    // This only needs to be done once in the lifetime of the app. 
23918>>>>>>>    Get _CurrentCollateStringReversed to gStr$ReversedCollateString
23919>>>>>>>    Move (Repeat(" ",31)+gStr$ReversedCollateString) to gStr$ReversedCollateString
23920>>>>>>>End_Object
23921>>>>>Use StructFunctions.pkg
Including file: StructFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\StructFunctions.pkg)
23921>>>>>>>//> StructFunction.pkg can be used to serialize structs into strings:
23921>>>>>>>//>
23921>>>>>>>//>    Function TableQueryToString tTableQuery strQ Returns String
23921>>>>>>>//>        String sTQ
23921>>>>>>>//>        Get VariantToString of oStructFunctions strQ to sTQ
23921>>>>>>>//>        Function_Return sTQ
23921>>>>>>>//>    End_Function
23921>>>>>>>//>
23921>>>>>>>//> Deserializing takes one extra step:
23921>>>>>>>//>
23921>>>>>>>//>    Function StringToTableQuery String sTQ Returns tTableQuery
23921>>>>>>>//>        tTableQuery strQ
23921>>>>>>>//>        tValueTree strValueTree
23921>>>>>>>//>        Get StringToValueTree of oStructFunctions sTQ to strValueTree
23921>>>>>>>//>        ValueTreeDeserializeParameter strValueTree to strQ
23921>>>>>>>//>        Function_Return strQ
23921>>>>>>>//>    End_Function
23921>>>>>>>//>
23921>>>>>>>//> If your purpose is to read and write structs to sequential files you
23921>>>>>>>//> may do it like this:
23921>>>>>>>//>
23921>>>>>>>//>    Send WriteVariant of oStructFunctions iChannel strQ
23921>>>>>>>//>
23921>>>>>>>//> And again, on the way back there is one extra step:
23921>>>>>>>//>
23921>>>>>>>//>    Function ReadTableQuery Integer iChannel Returns tTableQuery
23921>>>>>>>//>        tValueTree strValueTree
23921>>>>>>>//>        tTableQuery strQ
23921>>>>>>>//>        Send ReadValueTree of oStructFunctions iChannel (&strValueTree)
23921>>>>>>>//>        ValueTreeDeserializeParameter strValueTree to strQ
23921>>>>>>>//>        Function_Return strQ
23921>>>>>>>//>    End_Function
23921>>>>>>>//>
23921>>>>>>>//>
23921>>>>>>>//> NOTE:
23921>>>>>>>//>   1. these functions perform no checking on the string input. Things will go
23921>>>>>>>//>      wrong if values are deserialized into non-conformant structs.
23921>>>>>>>//>   2. not all simple member types can be handled this way. RowID for example
23921>>>>>>>//>      will not serialize.
23921>>>>>>>//>   3. when serializing to/from string max_argument_size must be taken into 
23921>>>>>>>//>      account. The read/write version does not have that issue.
23921>>>>>>>//>
23921>>>>>>>Use cClientWebService.pkg // Struct tValueTree is defined in here
Including file: cClientWebService.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\cClientWebService.pkg)
23921>>>>>>>>>Use Flexml.pkg
23921>>>>>>>>>Use cXmlHttpTransfer.pkg
Including file: cXmlHttpTransfer.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\cXmlHttpTransfer.pkg)
23921>>>>>>>>>>>//*************************************************************************
23921>>>>>>>>>>>//*
23921>>>>>>>>>>>//*  Copyright (c) 2001 Data Access Corporation, Miami Florida,
23921>>>>>>>>>>>//*  All rights reserved.
23921>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.
23921>>>>>>>>>>>//*
23921>>>>>>>>>>>//*************************************************************************
23921>>>>>>>>>>>//*
23921>>>>>>>>>>>//*  Module Name:
23921>>>>>>>>>>>//*      cXmlHttpTransfer.pkg
23921>>>>>>>>>>>//*
23921>>>>>>>>>>>//*  Creator:
23921>>>>>>>>>>>//*      JJT
23921>>>>>>>>>>>//*
23921>>>>>>>>>>>//*
23921>>>>>>>>>>>//*  Purpose:
23921>>>>>>>>>>>//*      VDF XML internet transfer class definitions.
23921>>>>>>>>>>>//*
23921>>>>>>>>>>>//*************************************************************************
23921>>>>>>>>>>>
23921>>>>>>>>>>>Use cHttpTransfer.pkg
Including file: cHttpTransfer.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\cHttpTransfer.pkg)
23921>>>>>>>>>>>>>//*************************************************************************
23921>>>>>>>>>>>>>//*
23921>>>>>>>>>>>>>//*  Copyright (c) 2001 Data Access Corporation, Miami Florida,
23921>>>>>>>>>>>>>//*  All rights reserved.
23921>>>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.
23921>>>>>>>>>>>>>//*
23921>>>>>>>>>>>>>//*************************************************************************
23921>>>>>>>>>>>>>//*
23921>>>>>>>>>>>>>//*  Module Name:
23921>>>>>>>>>>>>>//*      cHttpTransfer.plg
23921>>>>>>>>>>>>>//*
23921>>>>>>>>>>>>>//*  Creator:
23921>>>>>>>>>>>>>//*      SF
23921>>>>>>>>>>>>>//*  Purpose:
23921>>>>>>>>>>>>>//*      Http Xfer class for VDF
23921>>>>>>>>>>>>>//*
23921>>>>>>>>>>>>>//* In VDF7 this was a base class defined in InetTransfer.pkg. That class
23921>>>>>>>>>>>>>//* has been renamed cBaseHttpTransfer and a sub-class is now use for this
23921>>>>>>>>>>>>>//* purpose. This occurred because the Post and Put runtime messages were
23921>>>>>>>>>>>>>//* changed to use addresses. We now create the string based put and post
23921>>>>>>>>>>>>>//* messages here.
23921>>>>>>>>>>>>>//*************************************************************************
23921>>>>>>>>>>>>>
23921>>>>>>>>>>>>>use VDFBase.pkg
23921>>>>>>>>>>>>>
23921>>>>>>>>>>>>>Class cHttpTransfer is a cBaseHttpTransfer
23922>>>>>>>>>>>>>
23922>>>>>>>>>>>>>    Function HttpPostRequest String sFilePath String sData Integer bDataIsFile Returns Integer
23924>>>>>>>>>>>>>         integer bStat
23924>>>>>>>>>>>>>         Get HttpPostAddrRequest sFilePath (AddressOf(sData)) (Length(sData)) bDataIsfile to bStat
23925>>>>>>>>>>>>>         Function_return bStat
23926>>>>>>>>>>>>>    end_function
23927>>>>>>>>>>>>>
23927>>>>>>>>>>>>>    Function HttpPutRequest String sFilePath String sData Integer bDataIsFile Returns Integer
23929>>>>>>>>>>>>>         integer bStat
23929>>>>>>>>>>>>>         Get HttpPutAddrRequest sFilePath (AddressOf(sData)) (Length(sData)) bDataIsfile to bStat
23930>>>>>>>>>>>>>         Function_return bStat
23931>>>>>>>>>>>>>    end_function
23932>>>>>>>>>>>>>
23932>>>>>>>>>>>>>end_class
23933>>>>>>>>>>>>>
23933>>>>>>>>>>>Use CharTranslate.pkg
Including file: CharTranslate.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\CharTranslate.pkg)
23933>>>>>>>>>>>>>//*************************************************************************
23933>>>>>>>>>>>>>//*
23933>>>>>>>>>>>>>//*  Copyright (c) 2001 Data Access Corporation, Miami Florida,
23933>>>>>>>>>>>>>//*  All rights reserved.
23933>>>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.
23933>>>>>>>>>>>>>//*
23933>>>>>>>>>>>>>//*************************************************************************
23933>>>>>>>>>>>>>//*
23933>>>>>>>>>>>>>//*  Module Name:
23933>>>>>>>>>>>>>//*      CharTranslate.pkg
23933>>>>>>>>>>>>>//*
23933>>>>>>>>>>>>>//*  Creator:
23933>>>>>>>>>>>>>//*      SF
23933>>>>>>>>>>>>>//*
23933>>>>>>>>>>>>>//*
23933>>>>>>>>>>>>>//*  Purpose:
23933>>>>>>>>>>>>>//*      Various global functions to translate OEM to UTF.
23933>>>>>>>>>>>>>//*
23933>>>>>>>>>>>>>//*************************************************************************
23933>>>>>>>>>>>>>
23933>>>>>>>>>>>>>Use Windows.pkg
23933>>>>>>>>>>>>>
23933>>>>>>>>>>>>>
23933>>>>>>>>>>>>>External_Function32 MultiByteToWideChar "MultiByteToWideChar" kernel32.dll;    DWORD dwCodePage;    DWORD dwFlags;    Pointer pMultiByteStr;    Integer cbMultiByte;    Pointer pWideStr;    Integer cchWideChar;    Returns Integer
23934>>>>>>>>>>>>>
23934>>>>>>>>>>>>>External_Function32 WideCharToMultiByte "WideCharToMultiByte" kernel32.dll;    DWORD dwCodePage;    DWORD dwFlags;    Pointer pWideStr;    Integer cchWideChar;    Pointer pMultiByteStr;    Integer cbMultiByte;    Pointer pDefaultChar;    Pointer pUsedDefaultChar;    Returns Integer
23935>>>>>>>>>>>>>
23935>>>>>>>>>>>>>//dwCodePage = Multi Byte Code Page to convert from
23935>>>>>>>>>>>>>//pMultiBuf  = Pointer to Multi Byte string
23935>>>>>>>>>>>>>//iLen       = Length in bytes of Multi Byte string
23935>>>>>>>>>>>>>//ppWideBuf  = Contents of ppWideBuf contains a pointer to the destination buffer on return
23935>>>>>>>>>>>>>Function MultiToWideBuffer Global DWORD dwCodePage Address pMultiBuf Integer iLen Address ppWideBuf Returns Integer
23937>>>>>>>>>>>>>    Integer iWideSize
23937>>>>>>>>>>>>>    Integer iVoid
23937>>>>>>>>>>>>>    Address pWideBuf
23937>>>>>>>>>>>>>    Move (MultiByteToWideChar(dwCodePage,0,pMultiBuf,iLen,0,0)) to iWideSize
23938>>>>>>>>>>>>>    If (iWideSize=0);        Function_Return 0
23941>>>>>>>>>>>>>    Move (Alloc((iWideSize+1)*2)) to pWideBuf
23942>>>>>>>>>>>>>    If (pWideBuf=0);        Function_Return 0
23945>>>>>>>>>>>>>    Move (MultiByteToWideChar(dwCodePage,0,pMultiBuf,iLen,pWideBuf,iWideSize)) to iWideSize
23946>>>>>>>>>>>>>    If (iWideSize=0) ;        Move (Free(pWideBuf)) to iVoid
23949>>>>>>>>>>>>>    else begin
23950>>>>>>>>>>>>>        Move (StoreW(pWideBuf,(iWideSize*2),0)) to iVoid
23951>>>>>>>>>>>>>        Move (StoreDW(ppWideBuf,0,pWideBuf)) to iVoid
23952>>>>>>>>>>>>>    end
23952>>>>>>>>>>>>>>
23952>>>>>>>>>>>>>    Function_Return iWideSize
23953>>>>>>>>>>>>>End_Function
23954>>>>>>>>>>>>>
23954>>>>>>>>>>>>>//dwCodePage = Multi Byte Code Page to convert to
23954>>>>>>>>>>>>>//pWideBuf   = Pointer to Wide Character string
23954>>>>>>>>>>>>>//iLen       = Length in characters of Wide Character string
23954>>>>>>>>>>>>>//ppMultiBuf = Contents of ppMultiBuf contains a pointer to the destination buffer on return
23954>>>>>>>>>>>>>Function WideToMultiBuffer Global DWORD dwCodePage Address pWideBuf Integer iLen Address ppMultiBuf Returns Integer
23956>>>>>>>>>>>>>    Integer iMultiSize
23956>>>>>>>>>>>>>    Address pMultiBuf
23956>>>>>>>>>>>>>    Integer iVoid
23956>>>>>>>>>>>>>    Move (WideCharToMultiByte(dwCodePage,0,pWideBuf,iLen,0,0,0,0)) to iMultiSize
23957>>>>>>>>>>>>>    If (iMultiSize=0);        Function_Return 0
23960>>>>>>>>>>>>>    Move (Alloc(iMultiSize+1)) to pMultiBuf
23961>>>>>>>>>>>>>    If (pMultiBuf=0);        Function_Return 0
23964>>>>>>>>>>>>>    Move (WideCharToMultiByte(dwCodePage,0,pWideBuf,iLen,pMultiBuf,iMultiSize,0,0)) to iMultiSize
23965>>>>>>>>>>>>>    If (iMultiSize=0) ;        Move (Free(pMultiBuf)) to iVoid
23968>>>>>>>>>>>>>    else begin
23969>>>>>>>>>>>>>        Move (StoreC(pMultiBuf,iMultiSize,0)) to iVoid
23970>>>>>>>>>>>>>        Move (StoreDW(ppMultiBuf,0,pMultiBuf)) to iVoid
23971>>>>>>>>>>>>>    end
23971>>>>>>>>>>>>>>
23971>>>>>>>>>>>>>    Function_Return iMultiSize
23972>>>>>>>>>>>>>End_Function
23973>>>>>>>>>>>>>
23973>>>>>>>>>>>>>//Converts a UTF-8 string to OEM
23973>>>>>>>>>>>>>//pUtf8Buf   = Pointer to UTF-8 string
23973>>>>>>>>>>>>>//iLen       = Length of UTF-8 string in bytes
23973>>>>>>>>>>>>>//Returns pointer to OEM string, use free() to deallocate buffer when it's no longer needed
23973>>>>>>>>>>>>>Function Utf8ToOemBuffer Global Address pUtf8Buf Integer iLen Returns Address
23975>>>>>>>>>>>>>    Address pWideBuf
23975>>>>>>>>>>>>>    Address pOemBuf
23975>>>>>>>>>>>>>    Integer iWideBufLen
23975>>>>>>>>>>>>>    Integer iMultiBufLen
23975>>>>>>>>>>>>>    Integer iVoid
23975>>>>>>>>>>>>>    Move 0 to pWideBuf
23976>>>>>>>>>>>>>    Move 0 to pOemBuf
23977>>>>>>>>>>>>>    Move (MultiToWideBuffer(CP_UTF8,pUtf8Buf,iLen,AddressOf(pWideBuf))) to iWideBufLen
23978>>>>>>>>>>>>>    If (iWideBufLen=0);        Function_Return 0
23981>>>>>>>>>>>>>    Move (WideToMultiBuffer(CP_OEMCP,pWideBuf,iWideBufLen,AddressOf(pOemBuf))) to iMultiBufLen
23982>>>>>>>>>>>>>    Move (Free(pWideBuf)) to iVoid
23983>>>>>>>>>>>>>    Function_Return pOemBuf
23984>>>>>>>>>>>>>End_Function
23985>>>>>>>>>>>>>
23985>>>>>>>>>>>>>//Converts a OEM string to UTF-8
23985>>>>>>>>>>>>>//pOemBuf    = Pointer to OEM string
23985>>>>>>>>>>>>>//iLen       = Length of OEM string in bytes
23985>>>>>>>>>>>>>//Returns pointer to UTF-8 string, use free() to deallocate buffer when it's no longer needed
23985>>>>>>>>>>>>>Function OemToUtf8Buffer Global Address pOemBuf Integer iLen Returns Address
23987>>>>>>>>>>>>>    Address pWideBuf
23987>>>>>>>>>>>>>    Address pUtf8Buf
23987>>>>>>>>>>>>>    Integer iWideBufLen
23987>>>>>>>>>>>>>    Integer iMultiBufLen
23987>>>>>>>>>>>>>    Integer iVoid
23987>>>>>>>>>>>>>    Move 0 to pWideBuf
23988>>>>>>>>>>>>>    Move 0 to pUtf8Buf
23989>>>>>>>>>>>>>    Move (MultiToWideBuffer(CP_OEMCP,pOemBuf,iLen,AddressOf(pWideBuf))) to iWideBufLen
23990>>>>>>>>>>>>>    If (iWideBufLen=0);        Function_Return 0
23993>>>>>>>>>>>>>    Move (WideToMultiBuffer(CP_UTF8,pWideBuf,iWideBufLen,AddressOf(pUtf8Buf))) to iMultiBufLen
23994>>>>>>>>>>>>>    Move (Free(pWideBuf)) to iVoid
23995>>>>>>>>>>>>>    Function_Return pUtf8Buf
23996>>>>>>>>>>>>>End_Function
23997>>>>>>>>>>>>>
23997>>>>>>>>>>>>>
23997>>>>>>>>>>>>>//Converts a OEM string to UTF-16
23997>>>>>>>>>>>>>//pOemBuf    = Pointer to OEM string
23997>>>>>>>>>>>>>//iLen       = Length of OEM string in bytes
23997>>>>>>>>>>>>>//Returns pointer to UTF-16 string, use free() to deallocate buffer when it's no longer needed
23997>>>>>>>>>>>>>Function OemToUtf16Buffer Global Address pOemBuf Integer iLen Returns Address
23999>>>>>>>>>>>>>    Address pWideBuf
23999>>>>>>>>>>>>>    Integer iWideBufLen
23999>>>>>>>>>>>>>    Move 0 to pWideBuf
24000>>>>>>>>>>>>>    Move (MultiToWideBuffer(CP_OEMCP,pOemBuf,iLen,AddressOf(pWideBuf))) to iWideBufLen
24001>>>>>>>>>>>>>    If (iWideBufLen=0) Begin
24003>>>>>>>>>>>>>        Function_Return 0
24004>>>>>>>>>>>>>    End
24004>>>>>>>>>>>>>>
24004>>>>>>>>>>>>>    Function_Return pWideBuf
24005>>>>>>>>>>>>>End_Function
24006>>>>>>>>>>>>>
24006>>>>>>>>>>>>>//Converts a UTF-16 string to OEM
24006>>>>>>>>>>>>>//pWideBuf     = Pointer to UTF-16 string
24006>>>>>>>>>>>>>//iWideBufLen  = Length of UTF-16 in characters
24006>>>>>>>>>>>>>//Returns pointer to OEM string, use free() to deallocate buffer when it's no longer needed
24006>>>>>>>>>>>>>Function Utf16ToOemBuffer Global Address pWideBuf Integer iWideBufLen Returns Address
24008>>>>>>>>>>>>>    Address pOemBuf
24008>>>>>>>>>>>>>    Integer iMultiBufLen
24008>>>>>>>>>>>>>    Move 0 to pOemBuf
24009>>>>>>>>>>>>>    Move (WideToMultiBuffer(CP_OEMCP,pWideBuf,iWideBufLen,AddressOf(pOemBuf))) to iMultiBufLen
24010>>>>>>>>>>>>>    If (iMultiBufLen=0) Begin
24012>>>>>>>>>>>>>        Function_Return 0
24013>>>>>>>>>>>>>    End
24013>>>>>>>>>>>>>>
24013>>>>>>>>>>>>>    Function_Return pOemBuf
24014>>>>>>>>>>>>>End_Function
24015>>>>>>>>>>>>>
24015>>>>>>>>>>>Use Flexml.pkg
24015>>>>>>>>>>>Use RegistryAPI.pkg
24015>>>>>>>>>>>// Xml Translate modes
24015>>>>>>>>>>>//
24015>>>>>>>>>>>Enum_list
24015>>>>>>>>>>>    Define xtNoTranslate    // no translation
24015>>>>>>>>>>>    Define xtUtf8toOem      // from UTF-8 to OEM
24015>>>>>>>>>>>    Define xtOemtoUtf8      // from OEM to UTF-8
24015>>>>>>>>>>>End_Enum_list
24015>>>>>>>>>>>
24015>>>>>>>>>>>// these define the three characters that define BOM for utf8.
24015>>>>>>>>>>>// These serve no purpos and are rarely used. If used they must be removed 
24015>>>>>>>>>>>Define C_BOM1 for |CI$EF
24015>>>>>>>>>>>Define C_BOM2 for |CI$BB
24015>>>>>>>>>>>Define C_BOM3 for |CI$BF
24015>>>>>>>>>>>
24015>>>>>>>>>>>
24015>>>>>>>>>>>
24015>>>>>>>>>>>// define Xml transfer status codes used by peXmlTransferStatus
24015>>>>>>>>>>>Enum_list
24015>>>>>>>>>>>    define xtsOk                 // ok
24015>>>>>>>>>>>    define xtsHttpRequestFailed  // the post/get http request returned an error
24015>>>>>>>>>>>    define xtsBadRequest         // Request data is bad or missing
24015>>>>>>>>>>>    define xtsInvalidContentType // response content type not xml
24015>>>>>>>>>>>    define xtsNoData             // return has no data
24015>>>>>>>>>>>    define xtsNotXml             // return value not XML (could not load in object)
24015>>>>>>>>>>>    define xtsError              // unspecified return error
24015>>>>>>>>>>>end_enum_list
24015>>>>>>>>>>>
24015>>>>>>>>>>>
24015>>>>>>>>>>>Class cXmlHttpTransfer is a cHttpTransfer
24016>>>>>>>>>>>
24016>>>>>>>>>>>   Procedure Construct_Object
24018>>>>>>>>>>>      Forward send Construct_object
24020>>>>>>>>>>>
24020>>>>>>>>>>>      Property Integer peTranslateSent     xtOemtoUtf8  // translation mode for sent posted data
24021>>>>>>>>>>>
24021>>>>>>>>>>>      Property Integer peTranslateReceived xtUtf8toOem  // tranlation mode for received data
24022>>>>>>>>>>>
24022>>>>>>>>>>>      Property String  psContentTypeSent "text/xml; charset=utf-8"     // default content type for posted data
24023>>>>>>>>>>>
24023>>>>>>>>>>>      Property Boolean pbClearHeaders      True         // should headers always be cleared before a post
24024>>>>>>>>>>>
24024>>>>>>>>>>>      property address paDataReceived 0                 // maintained by object
24025>>>>>>>>>>>
24025>>>>>>>>>>>      property integer piDataReceivedLength 0           // maintained by object
24026>>>>>>>>>>>
24026>>>>>>>>>>>      Property String  psContentTypeReceived ''         // content type received
24027>>>>>>>>>>>
24027>>>>>>>>>>>      Property String  psContentTypeExpected 'text/xml' // content type received - expected value should be contained in here.
24028>>>>>>>>>>>
24028>>>>>>>>>>>      Property Boolean pbDataRequiredSent True
24029>>>>>>>>>>>      Property Boolean pbDataRequiredReceived True
24030>>>>>>>>>>>      Property Integer peXmlTransferStatus xtsOk
24031>>>>>>>>>>>   end_procedure
24032>>>>>>>>>>>
24032>>>>>>>>>>>   // private helper function. Convert data passed by pointer to an XML document.
24032>>>>>>>>>>>   // return 0, if error
24032>>>>>>>>>>>   //
24032>>>>>>>>>>>   Function DatatoXml address aXml returns handle
24034>>>>>>>>>>>       integer iVoid bOk
24034>>>>>>>>>>>       Handle hoXml
24034>>>>>>>>>>>       Move 0 to hoXml
24035>>>>>>>>>>>       // Create the XML dom object at the desktop level so it does not get destroyed
24035>>>>>>>>>>>       // when this cXmlHttpTransfer object is destroyed.
24035>>>>>>>>>>>       Get Create of desktop U_cXmlDomDocument to hoXml
24036>>>>>>>>>>>       Get LoadXmlFromAddress of hoXml aXml to bOk
24037>>>>>>>>>>>       If not bOk Begin
24039>>>>>>>>>>>           Send Destroy of hoXml
24040>>>>>>>>>>>           Move 0 to hoXml
24041>>>>>>>>>>>       end
24041>>>>>>>>>>>>
24041>>>>>>>>>>>       Function_return hoXml
24042>>>>>>>>>>>   end_function
24043>>>>>>>>>>>
24043>>>>>>>>>>>   // Translate data. pass: Data and translation mode.
24043>>>>>>>>>>>   //     returns pointer to new translated data 0 if no translate needed.
24043>>>>>>>>>>>   //     Passed data is not changed.
24043>>>>>>>>>>>   // Currently we support: xtUtf8toOem, xtOemtoUtf8 and xtNoTranslate
24043>>>>>>>>>>>   // This is an excellent candidate for augmentation to add more modes
24043>>>>>>>>>>>   //
24043>>>>>>>>>>>   Function TranslateData integer eXlt address aData integer iDataLen returns address
24045>>>>>>>>>>>       address aDataXlt
24045>>>>>>>>>>>       Case Begin
24045>>>>>>>>>>>          Case (eXlt=xtUtf8toOem)
24047>>>>>>>>>>>              Move (Utf8toOemBuffer(aData,iDataLen)) to aDataXlt
24048>>>>>>>>>>>              case Break
24049>>>>>>>>>>>          Case (eXlt=xtOemtoUtf8)
24052>>>>>>>>>>>              Move (OemToUtf8Buffer(aData,iDataLen)) to aDataXlt
24053>>>>>>>>>>>              case Break
24054>>>>>>>>>>>          case else
24054>>>>>>>>>>>              Move 0 to aDataXlt
24055>>>>>>>>>>>       Case End
24055>>>>>>>>>>>       Function_return aDataXlt
24056>>>>>>>>>>>   End_function
24057>>>>>>>>>>>
24057>>>>>>>>>>>   // Clear paDataReceived and free any memory associated w/ pointer
24057>>>>>>>>>>>   //
24057>>>>>>>>>>>   Procedure ClearDataReceived
24059>>>>>>>>>>>        address aDataReceived
24059>>>>>>>>>>>        integer iVoid
24059>>>>>>>>>>>        Get paDataReceived to aDataReceived
24060>>>>>>>>>>>        If (aDataReceived<>0) ;            Move (Free(aDataReceived)) to iVoid
24063>>>>>>>>>>>        Set paDataReceived to 0
24064>>>>>>>>>>>        Set piDataReceivedLength to 0
24065>>>>>>>>>>>   End_procedure
24066>>>>>>>>>>>
24066>>>>>>>>>>>   // augment to release any memory in paDataReceived
24066>>>>>>>>>>>   //
24066>>>>>>>>>>>   procedure Destroy_Object
24068>>>>>>>>>>>       Send ClearDataReceived
24069>>>>>>>>>>>       forward send Destroy_object
24071>>>>>>>>>>>   end_procedure
24072>>>>>>>>>>>
24072>>>>>>>>>>>   // translate data in paReveived based on peTranslateReceived property.
24072>>>>>>>>>>>   // This clears the data received buffer and returns zero terminated memory pointer
24072>>>>>>>>>>>   // you create invalid translations
24072>>>>>>>>>>>   //
24072>>>>>>>>>>>   Function TranslateDataReceived returns Address
24074>>>>>>>>>>>       address aDataReceived aDataReceivedXlt
24074>>>>>>>>>>>       Get paDataReceived to aDataReceived
24075>>>>>>>>>>>       Get TranslateData (peTranslateReceived(self)) aDataReceived (piDataReceivedLength(self)) to aDataReceivedXlt
24076>>>>>>>>>>>       if (aDataReceivedXLT<>0) ;  // if translation occurred,          Send ClearDataReceived   // clear out the original received data
24079>>>>>>>>>>>       else Begin
24080>>>>>>>>>>>          Move aDataReceived to aDataReceivedXlt // if no translation, just point to the existing data
24081>>>>>>>>>>>          Set paDataReceived to 0                // and remove the object's access to that data
24082>>>>>>>>>>>          Set piDataReceivedLength to 0
24083>>>>>>>>>>>       end
24083>>>>>>>>>>>>
24083>>>>>>>>>>>       Function_Return aDataReceivedXlt
24084>>>>>>>>>>>   end_function
24085>>>>>>>>>>>
24085>>>>>>>>>>>   // called during http transfer. Take passed data and append to paDataReceived.
24085>>>>>>>>>>>   // If new transfer save contenttype.
24085>>>>>>>>>>>   //
24085>>>>>>>>>>>   Procedure OnDataReceived string sContentType string sData
24087>>>>>>>>>>>        integer bOk iVoid
24087>>>>>>>>>>>        address aOldData
24087>>>>>>>>>>>        address aNewData
24087>>>>>>>>>>>        integer iOldDataLen
24087>>>>>>>>>>>        integer iDataLen
24087>>>>>>>>>>>        integer iNewLen
24087>>>>>>>>>>>        Move (length(sData)) to iDataLen
24088>>>>>>>>>>>        If (iDatalen>0) Begin // if passed data is empty--do nothing
24090>>>>>>>>>>>            Get paDataReceived to aOldData
24091>>>>>>>>>>>            If (aOldData=0) Begin                           // first time called, new data
24093>>>>>>>>>>>
24093>>>>>>>>>>>                // check for BOM (Byte Order Marker) at the start of the file.
24093>>>>>>>>>>>                // if found remove it as it serves no purpose and messes up the translate logic.                
24093>>>>>>>>>>>                If (iDataLen>3 and Ascii(Left(sData,1))=C_BOM1 and Ascii(Mid(sData,1,2))=C_BOM2 and Ascii(Mid(sData,1,3))=C_BOM3) Begin
24095>>>>>>>>>>>                    Move (Remove(sData,1,3)) to sData
24096>>>>>>>>>>>                    Move (iDataLen-3) to iDataLen
24097>>>>>>>>>>>                End
24097>>>>>>>>>>>>
24097>>>>>>>>>>>                
24097>>>>>>>>>>>                Set psContentTypeReceived to sContentType   // store content type
24098>>>>>>>>>>>                Move (Alloc(iDataLen+1)) to aNewData  // alloc extra byte for zero termination...just in case.
24099>>>>>>>>>>>                Move 0 to iOldDataLen
24100>>>>>>>>>>>                Move iDataLen to iNewLen
24101>>>>>>>>>>>            end
24101>>>>>>>>>>>>
24101>>>>>>>>>>>            Else Begin
24102>>>>>>>>>>>                Get piDataReceivedLength to iOldDataLen
24103>>>>>>>>>>>                Move (iOldDataLen+iDataLen) to iNewLen
24104>>>>>>>>>>>                Move (ReAlloc(aOldData,iNewLen+1)) to aNewData // note extra byte at end
24105>>>>>>>>>>>            end
24105>>>>>>>>>>>>
24105>>>>>>>>>>>            Move (memcopy(aNewData+iOldDataLen, AddressOf(sData), iDataLen)) to bOk // copy on top of term zero
24106>>>>>>>>>>>            Move (StoreC(aNewData,iNewLen,0)) to iVoid // add terminating zero at end.
24107>>>>>>>>>>>            Set paDataReceived to aNewData
24108>>>>>>>>>>>            set piDataReceivedLength to iNewLen // length does not include term zero
24109>>>>>>>>>>>        End
24109>>>>>>>>>>>>
24109>>>>>>>>>>>   end_procedure
24110>>>>>>>>>>>
24110>>>>>>>>>>>   // Post and Receive XML data via node. Returns 0 if failure (could not xfer, bad data, etc.)
24110>>>>>>>>>>>   //
24110>>>>>>>>>>>   Function HttpPostXmlNode  string sHost string sFilePath handle  hoXmlNode returns handle
24112>>>>>>>>>>>       address aXmlNode aXml
24112>>>>>>>>>>>       integer iVoid iLen
24112>>>>>>>>>>>       handle hoXml
24112>>>>>>>>>>>
24112>>>>>>>>>>>       Move 0 to aXmlNode
24113>>>>>>>>>>>       Move 0 to iLen
24114>>>>>>>>>>>       // if the node is zero, this might be an error. We will test for this later
24114>>>>>>>>>>>       // by seeing if the address point is 0 or the length is 0
24114>>>>>>>>>>>       If (hoXmlNode<>0) Begin
24116>>>>>>>>>>>           Get paXml of hoXmlNode to aXmlNode
24117>>>>>>>>>>>           if (aXmlNode<>0) ;              Move (CStringLength(aXmlNode)) to iLen // we assume data from paXml is always zero terminated
24120>>>>>>>>>>>              //Move (Length(aXmlNode)) to iLen // we assume data from paXml is always zero terminated
24120>>>>>>>>>>>       end
24120>>>>>>>>>>>>
24120>>>>>>>>>>>       Get HttpPostXmlAddr sHost sFilePath aXmlNode iLen to aXml
24121>>>>>>>>>>>       If aXmlNode ;           Move (free(aXmlNode)) to iVoid
24124>>>>>>>>>>>
24124>>>>>>>>>>>       // if data is returned (aXML) it is non-zero and content type is correct.
24124>>>>>>>>>>>       // if no data, an error has been registered or no data is an ok condition
24124>>>>>>>>>>>       If (aXml<>0) Begin
24126>>>>>>>>>>>           Get DatatoXml aXml to hoXml
24127>>>>>>>>>>>           If (hoXml=0) Begin
24129>>>>>>>>>>>               // this indicates that data was returned but it could not be loaded as XML
24129>>>>>>>>>>>               Set peXmlTransferStatus to xtsNotXml
24130>>>>>>>>>>>               // store the bad data for debugging purposes
24130>>>>>>>>>>>               Set paDataReceived to aXml
24131>>>>>>>>>>>               Set piDataReceivedLength to (CStringLength(aXml))
24132>>>>>>>>>>>               //Set piDataReceivedLength to (Length(aXml))
24132>>>>>>>>>>>           end
24132>>>>>>>>>>>>
24132>>>>>>>>>>>           Else Begin
24133>>>>>>>>>>>               Move (Free(aXml)) to iVoid
24134>>>>>>>>>>>           end
24134>>>>>>>>>>>>
24134>>>>>>>>>>>       end
24134>>>>>>>>>>>>
24134>>>>>>>>>>>       else begin
24135>>>>>>>>>>>          Move 0 to hoXml
24136>>>>>>>>>>>       end
24136>>>>>>>>>>>>
24136>>>>>>>>>>>       Function_return hoXml
24137>>>>>>>>>>>   end_function
24138>>>>>>>>>>>
24138>>>>>>>>>>>   Function HttpPostXmlString string sHost string sFilePath string  sXml returns string
24140>>>>>>>>>>>       Address aXml
24140>>>>>>>>>>>       integer iVoid
24140>>>>>>>>>>>       Get HttpPostXmlAddr sHost sFilePath (AddressOf(sXml)) (Length(sXml)) to aXml
24141>>>>>>>>>>>       If (aXml<>0) Begin
24143>>>>>>>>>>>          Move aXml to sXml           // if data returned, assign to string
24144>>>>>>>>>>>          Move (Free(aXml)) to iVoid  // and free data
24145>>>>>>>>>>>       end
24145>>>>>>>>>>>>
24145>>>>>>>>>>>       Else ;          Move '' to sXml
24147>>>>>>>>>>>       function_return sXml
24148>>>>>>>>>>>   End_function
24149>>>>>>>>>>>
24149>>>>>>>>>>>   Function HttpPostXmlAddr  string sHost string sFilePath address aXml integer iLen returns Address
24151>>>>>>>>>>>        integer bOk iVoid
24151>>>>>>>>>>>        address aXmlXlt
24151>>>>>>>>>>>        address aDataReceived
24151>>>>>>>>>>>        Boolean bDataRequiredSent bDataRequiredReceived
24151>>>>>>>>>>>        string sContentTypeReceived sContentTypeExpected
24151>>>>>>>>>>>
24151>>>>>>>>>>>        Get pbDataRequiredSent     to bDataRequiredSent
24152>>>>>>>>>>>        Get pbDataRequiredReceived to bDataRequiredReceived
24153>>>>>>>>>>>
24153>>>>>>>>>>>
24153>>>>>>>>>>>        // This checks that data exists. If it exists, we assume it is XML format which
24153>>>>>>>>>>>        // will always be true when you use HttpXmlNode
24153>>>>>>>>>>>        If (bDataRequiredSent and (aXML=0 or iLen=0)) Begin
24155>>>>>>>>>>>            Set peXmlTransferStatus to xtsBadRequest
24156>>>>>>>>>>>            Function_return 0
24157>>>>>>>>>>>        end
24157>>>>>>>>>>>>
24157>>>>>>>>>>>
24157>>>>>>>>>>>        // translate data if needed, returns 0 if no translation
24157>>>>>>>>>>>        If (aXML<>0) Begin
24159>>>>>>>>>>>            Get TranslateData (peTranslateSent(self)) aXml iLen to aXmlXlt
24160>>>>>>>>>>>        end
24160>>>>>>>>>>>>
24160>>>>>>>>>>>        If (aXmlXlt<>0) begin
24162>>>>>>>>>>>            Move (CStringLength(aXmlXlt)) to iLen // if translated...assume zero termination at end
24163>>>>>>>>>>>            //Move (Length(aXmlXlt)) to iLen // if translated...assume zero termination at end
24163>>>>>>>>>>>            Get HttpPostXmlAddrNoXlt sHost sFilepath aXmlXlt iLen to bOk
24164>>>>>>>>>>>            Move (Free(aXmlXlt)) to iVoid // no longer need tranlsated data
24165>>>>>>>>>>>        end
24165>>>>>>>>>>>>
24165>>>>>>>>>>>        Else ;            Get HttpPostXmlAddrNoXlt sHost sFilepath aXml iLen to bOk
24167>>>>>>>>>>>
24167>>>>>>>>>>>        If bOk Begin
24169>>>>>>>>>>>           Set peXmlTransferStatus to xtsOk
24170>>>>>>>>>>>           Get TranslateDataReceived to aDataReceived   // current pointer to data (is returned)
24171>>>>>>>>>>>        end
24171>>>>>>>>>>>>
24171>>>>>>>>>>>        else Begin
24172>>>>>>>>>>>            Set peXmlTransferStatus to xtsHttpRequestFailed
24173>>>>>>>>>>>            Send ClearDataReceived               // if error, clear data
24174>>>>>>>>>>>            Move 0 to aDataReceived              // and return 0
24175>>>>>>>>>>>            Function_return 0
24176>>>>>>>>>>>        End
24176>>>>>>>>>>>>
24176>>>>>>>>>>>
24176>>>>>>>>>>>        // I am not sure this could ever happen. But if length is 0, we have no data
24176>>>>>>>>>>>        //If (aDataReceived and Length(aDataReceived)=0) Begin
24176>>>>>>>>>>>        If (aDataReceived and CStringLength(aDataReceived)=0) Begin
24178>>>>>>>>>>>            Move (Free(aDataReceived)) to iVoid
24179>>>>>>>>>>>            Move 0 to aDataReceived
24180>>>>>>>>>>>        end
24180>>>>>>>>>>>>
24180>>>>>>>>>>>
24180>>>>>>>>>>>        If aDataReceived Begin
24182>>>>>>>>>>>            // we have data, check that the content type is ok. This is as far
24182>>>>>>>>>>>            // as we can go here.
24182>>>>>>>>>>>            Get psContentTypeReceived to sContentTypeReceived
24183>>>>>>>>>>>            Get psContentTypeExpected to sContentTypeExpected
24184>>>>>>>>>>>            // If contentType expected is empty, we allow anything
24184>>>>>>>>>>>            If (sContentTypeExpected<>"" And pos(sContentTypeExpected,sContentTypeReceived)=0) Begin
24186>>>>>>>>>>>                 Set peXmlTransferStatus to xtsInvalidContentType
24187>>>>>>>>>>>                 // store the bad data for debugging purposes
24187>>>>>>>>>>>                 Set paDataReceived to aDataReceived
24188>>>>>>>>>>>                 Set piDataReceivedLength to (CStringLength(aDataReceived))
24189>>>>>>>>>>>                 //Set piDataReceivedLength to (Length(aDataReceived))
24189>>>>>>>>>>>                 Move 0 to aDataReceived
24190>>>>>>>>>>>            end
24190>>>>>>>>>>>>
24190>>>>>>>>>>>        end
24190>>>>>>>>>>>>
24190>>>>>>>>>>>        Else if (bDataRequiredReceived) Begin // data is zero but required
24193>>>>>>>>>>>            Set peXmlTransferStatus to xtsNodata
24194>>>>>>>>>>>        end
24194>>>>>>>>>>>>
24194>>>>>>>>>>>        Function_return aDataReceived
24195>>>>>>>>>>>   End_Procedure
24196>>>>>>>>>>>
24196>>>>>>>>>>>   Function HttpPostXmlAddrNoXlt  string sHost string sFilePath address aXml integer iLen returns integer
24198>>>>>>>>>>>        Boolean bOk
24198>>>>>>>>>>>        Integer iError
24198>>>>>>>>>>>        Send ClearDataReceived  // this should be zero, just in case it is not
24199>>>>>>>>>>>        Set psRemoteHost to sHost
24200>>>>>>>>>>>        // You need to clear headers between posts. If you need to set custom headers you should
24200>>>>>>>>>>>        // set pbClearHeaders to false and then manually send ClearHeaders and AddHeaders in your code
24200>>>>>>>>>>>        If (pbClearHeaders(self)) ;            Send ClearHeaders
24203>>>>>>>>>>>        Get AddHeader "CONTENT-TYPE" (psContentTypeSent(self)) to bok
24204>>>>>>>>>>>        Get HttpPostAddrRequest sFilePath aXml iLen False to bOK
24205>>>>>>>>>>>        function_return bOk
24206>>>>>>>>>>>   End_Procedure
24207>>>>>>>>>>>
24207>>>>>>>>>>>
24207>>>>>>>>>>>   Function HttpGetXmlNode  string sHost string sFilePath returns handle
24209>>>>>>>>>>>       address aXml
24209>>>>>>>>>>>       integer iVoid
24209>>>>>>>>>>>       Handle hoXml
24209>>>>>>>>>>>       Get HttpGetXmlAddr sHost sFilePath to aXml
24210>>>>>>>>>>>       // if data is returned (aXML) it is non-zero and content type is correct.
24210>>>>>>>>>>>       // if no data, an error has been registered or no data is an ok condition
24210>>>>>>>>>>>       If (aXml<>0) Begin
24212>>>>>>>>>>>           Get DatatoXml aXml to hoXml
24213>>>>>>>>>>>           If (hoXml=0) Begin
24215>>>>>>>>>>>               // this indicates that data was returned but it could not be loaded as XML
24215>>>>>>>>>>>               Set peXmlTransferStatus to xtsNotXml
24216>>>>>>>>>>>               // store the bad data for debugging purposes
24216>>>>>>>>>>>               Set paDataReceived to aXml
24217>>>>>>>>>>>               Set piDataReceivedLength to (CStringLength(aXml))
24218>>>>>>>>>>>               //Set piDataReceivedLength to (Length(aXml))
24218>>>>>>>>>>>           end
24218>>>>>>>>>>>>
24218>>>>>>>>>>>           Else Begin
24219>>>>>>>>>>>               Move (Free(aXml)) to iVoid
24220>>>>>>>>>>>           end
24220>>>>>>>>>>>>
24220>>>>>>>>>>>       end
24220>>>>>>>>>>>>
24220>>>>>>>>>>>       else begin
24221>>>>>>>>>>>          Move 0 to hoXml
24222>>>>>>>>>>>       end
24222>>>>>>>>>>>>
24222>>>>>>>>>>>       Function_return hoXml
24223>>>>>>>>>>>   end_function
24224>>>>>>>>>>>
24224>>>>>>>>>>>   Function HttpGetXmlString string sHost string sFilePath returns string
24226>>>>>>>>>>>       Address aXml
24226>>>>>>>>>>>       string  sXml
24226>>>>>>>>>>>       integer iVoid
24226>>>>>>>>>>>       Get HttpGetXmlAddr sHost sFilePath to aXml
24227>>>>>>>>>>>       If (aXml<>0) Begin
24229>>>>>>>>>>>          Move aXml to sXml           // if data returned, assign to string
24230>>>>>>>>>>>          Move (Free(aXml)) to iVoid  // and free data
24231>>>>>>>>>>>       end
24231>>>>>>>>>>>>
24231>>>>>>>>>>>       else ;          Move '' to sXml
24233>>>>>>>>>>>       function_return sXml
24234>>>>>>>>>>>   End_function
24235>>>>>>>>>>>
24235>>>>>>>>>>>   Function HttpGetXmlAddr  string sHost string sFilePath returns Address
24237>>>>>>>>>>>        integer bOk iVoid
24237>>>>>>>>>>>        address aDataReceived
24237>>>>>>>>>>>        Boolean bDataRequiredReceived
24237>>>>>>>>>>>        string sContentTypeReceived sContentTypeExpected
24237>>>>>>>>>>>
24237>>>>>>>>>>>        Get pbDataRequiredReceived to bDataRequiredReceived
24238>>>>>>>>>>>
24238>>>>>>>>>>>        Get HttpGetXmlNoXlt sHost sFilepath to bOk
24239>>>>>>>>>>>        If bOk Begin
24241>>>>>>>>>>>           Set peXmlTransferStatus to xtsOk
24242>>>>>>>>>>>           Get TranslateDataReceived to aDataReceived   // current pointer to data (is returned)
24243>>>>>>>>>>>        end
24243>>>>>>>>>>>>
24243>>>>>>>>>>>        else Begin
24244>>>>>>>>>>>            Set peXmlTransferStatus to xtsHttpRequestFailed
24245>>>>>>>>>>>            Send ClearDataReceived               // if error, clear data
24246>>>>>>>>>>>            Move 0 to aDataReceived              // and return 0
24247>>>>>>>>>>>            Function_return 0
24248>>>>>>>>>>>        End
24248>>>>>>>>>>>>
24248>>>>>>>>>>>
24248>>>>>>>>>>>        // I am not sure this could ever happen. But if length is 0, we have no data
24248>>>>>>>>>>>        //If (aDataReceived and Length(aDataReceived)=0) Begin
24248>>>>>>>>>>>        If (aDataReceived and CStringLength(aDataReceived)=0) Begin
24250>>>>>>>>>>>            Move (Free(aDataReceived)) to iVoid
24251>>>>>>>>>>>            Move 0 to aDataReceived
24252>>>>>>>>>>>        end
24252>>>>>>>>>>>>
24252>>>>>>>>>>>
24252>>>>>>>>>>>        If aDataReceived Begin
24254>>>>>>>>>>>            // we have data, check that the content type is ok. This is as far
24254>>>>>>>>>>>            // as we can go here.
24254>>>>>>>>>>>            Get psContentTypeReceived to sContentTypeReceived
24255>>>>>>>>>>>            Get psContentTypeExpected to sContentTypeExpected
24256>>>>>>>>>>>            // If contentType expected is empty, we allow anything
24256>>>>>>>>>>>            If (sContentTypeExpected<>"" And pos(sContentTypeExpected,sContentTypeReceived)=0) Begin
24258>>>>>>>>>>>                 Set peXmlTransferStatus to xtsInvalidContentType
24259>>>>>>>>>>>                 // store the bad data for debugging purposes
24259>>>>>>>>>>>                 Set paDataReceived to aDataReceived
24260>>>>>>>>>>>                 Set piDataReceivedLength to (CStringLength(aDataReceived))
24261>>>>>>>>>>>                 //Set piDataReceivedLength to (Length(aDataReceived))
24261>>>>>>>>>>>                 Move 0 to aDataReceived
24262>>>>>>>>>>>            end
24262>>>>>>>>>>>>
24262>>>>>>>>>>>        end
24262>>>>>>>>>>>>
24262>>>>>>>>>>>        Else if (bDataRequiredReceived) Begin // data is zero but required
24265>>>>>>>>>>>            Set peXmlTransferStatus to xtsNodata
24266>>>>>>>>>>>        end
24266>>>>>>>>>>>>
24266>>>>>>>>>>>        Function_return aDataReceived
24267>>>>>>>>>>>   End_Procedure
24268>>>>>>>>>>>
24268>>>>>>>>>>>   // low level get - no translation of data. returns received data in paDataReceived
24268>>>>>>>>>>>   //
24268>>>>>>>>>>>   Function HttpGetXmlNoXlt  string sHost string sFilePath returns Integer
24270>>>>>>>>>>>        Integer bOk
24270>>>>>>>>>>>        Send ClearDataReceived  // this should be zero, just in case it is not
24271>>>>>>>>>>>        Set psRemoteHost to sHost
24272>>>>>>>>>>>        Get HttpGetRequest sFilePath to bOK
24273>>>>>>>>>>>        Function_return bOk
24274>>>>>>>>>>>   End_Procedure
24275>>>>>>>>>>>
24275>>>>>>>>>>>   // After an XML xfer request this message can be sent to display an error message if one occurred.
24275>>>>>>>>>>>   // Normally you would first check peXmlTransferStatus to see if it is not xtsOk. If not, send
24275>>>>>>>>>>>   // LastError to see the error
24275>>>>>>>>>>>
24275>>>>>>>>>>>   // return last xml transfer error text
24275>>>>>>>>>>>   Function TransferErrorDescription returns string
24277>>>>>>>>>>>        string  sError sFaultCode sFaultString sText sType
24277>>>>>>>>>>>        integer eXmlTransferStatus
24277>>>>>>>>>>>        Get peXmlTransferStatus to eXmlTransferStatus
24278>>>>>>>>>>>        Case Begin
24278>>>>>>>>>>>            case (eXmlTransferStatus=xtsOk)                 Move ''                             to sError
24281>>>>>>>>>>>            case (eXmlTransferStatus=xtsHttpRequestFailed)  Move C_$HttpRequestFailed           to sError
24285>>>>>>>>>>>            case (eXmlTransferStatus=xtsBadRequest)         Move C_$BadOrMissingDataSent        to sError
24289>>>>>>>>>>>            case (eXmlTransferStatus=xtsInvalidContentType) Move (SFormat(C_$InvalidContentTypeReceived,psContentTypeReceived(self))) to sError
24293>>>>>>>>>>>            case (eXmlTransferStatus=xtsNoData)             Move C_$NoDataWasReceived           to sError
24297>>>>>>>>>>>            case (eXmlTransferStatus=xtsNotXml)             Move C_$ReceivedDataNotInXMLFormat  to sError
24301>>>>>>>>>>>            case else                                       Move C_$ReceivedDataIsBad           to sError
24303>>>>>>>>>>>        Case end
24303>>>>>>>>>>>        Function_return sError
24304>>>>>>>>>>>    end_function
24305>>>>>>>>>>>
24305>>>>>>>>>>>
24305>>>>>>>>>>>   Procedure LastError
24307>>>>>>>>>>>        integer eXmlTransferStatus
24307>>>>>>>>>>>        string sError
24307>>>>>>>>>>>
24307>>>>>>>>>>>        Get peXmlTransferStatus to eXmlTransferStatus
24308>>>>>>>>>>>        If (eXmlTransferStatus<>xtsOk) begin
24310>>>>>>>>>>>            Get TransferErrorDescription to sError
24311>>>>>>>>>>>            error DFERR_XML_HTTP sError
24312>>>>>>>>>>>>
24312>>>>>>>>>>>        end
24312>>>>>>>>>>>>
24312>>>>>>>>>>>   end_Procedure
24313>>>>>>>>>>>
24313>>>>>>>>>>>End_Class
24314>>>>>>>>>Use SoapConstants.pkg
24314>>>>>>>>>Use Variant.pkg
24314>>>>>>>>>
24314>>>>>>>>>Enum_List
24314>>>>>>>>>    Define C_atNone            for 0 // type is a normal struct
24314>>>>>>>>>    Define C_atArray           for 1 // type is used to represent document style array
24314>>>>>>>>>    Define C_atSoapEncArray    for 2 // type is used to represent soap encoded array
24314>>>>>>>>>End_Enum_List
24314>>>>>>>>>
24314>>>>>>>>>Struct tValueTreeEx           // ValueTreeVar uses variant as its value. This is used to shuttle data between our variables and XML soap documents
24314>>>>>>>>>    Variant      sValue        // data value. Value only exists if there are no children. We use Variant/BSTR as the storage type.
24314>>>>>>>>>    tValueTreeEx[] children      // child values. If a struct or array, we have children and no value
24314>>>>>>>>>    tValueTreeEx[] children      // child values. If a struct or array, we have children and no value
24314>>>>>>>>>End_Struct
24314>>>>>>>>>
24314>>>>>>>>>// this is no longer used by this class but it is maintained as is in case a developer is using this for other purposes. This has been
24314>>>>>>>>>// replaced with the tValueTreeEx
24314>>>>>>>>>Struct tValueTree              // The infamous ValueTree. This is used to shuttle data between our variables and XML soap documents
24314>>>>>>>>>    String       sValue        // data value. Value only exists if there are no children
24314>>>>>>>>>    tValueTree[] children      // child values. If a struct or array, we have children and no value
24314>>>>>>>>>    tValueTree[] children      // child values. If a struct or array, we have children and no value
24314>>>>>>>>>End_Struct
24314>>>>>>>>>
24314>>>>>>>>>
24314>>>>>>>>>Struct tSoapParamDef
24314>>>>>>>>>    String           sName      // param name used by xml
24314>>>>>>>>>    String           sNamespace // param namespace URI used by xml
24314>>>>>>>>>    Integer          eType      // including struct & soap-encoded array
24314>>>>>>>>>    Handle           hoStruct   // if Type=xsstruct pointer to object cSoapMetaStruct that defines the struct
24314>>>>>>>>>    Integer          iMin       // min occurs
24314>>>>>>>>>    Integer          iMax       // max occurs
24314>>>>>>>>>    Boolean          bAttribute // is this an attribute
24314>>>>>>>>>    String           sDefaultAttr // if an attribute, the default
24314>>>>>>>>>End_Struct
24314>>>>>>>>>
24314>>>>>>>>>Struct tSoapParameter           // each parameter is defined via this stuct. It contains the data defintion and the acutal value treee data
24314>>>>>>>>>    tSoapParamDef SoapParamDef
24314>>>>>>>>>    tSoapParamDef SoapParamDef
24314>>>>>>>>>    tValueTreeEx    ValueTree
24314>>>>>>>>>    tValueTreeEx    ValueTree
24314>>>>>>>>>End_Struct
24314>>>>>>>>>
24314>>>>>>>>>
24314>>>>>>>>>Enum_List
24314>>>>>>>>>
24314>>>>>>>>>    // define webServiceStatus
24314>>>>>>>>>    Define wssOk
24314>>>>>>>>>
24314>>>>>>>>>    // request related errors
24314>>>>>>>>>    Define wssHttpRequestFailed   // the post/get http request returned an error
24314>>>>>>>>>    Define wssBadRequest          // Request data is bad or missing
24314>>>>>>>>>
24314>>>>>>>>>    // response related errors
24314>>>>>>>>>    Define wssInvalidContentType  // response content type not xml
24314>>>>>>>>>    Define wssNoData              // return has no data
24314>>>>>>>>>    Define wssNotXml              // return value not XML (could not load in object)
24314>>>>>>>>>    Define wssNotSoap             // returned xml data.. but its not correct a correct soap document
24314>>>>>>>>>    Define wssInvalidSoap         // returned xml data.. but its not correct according to wsdl
24314>>>>>>>>>    Define wssSoapFault           // returned xml data.. with a soap fault error
24314>>>>>>>>>    Define wssError               // unspecified
24314>>>>>>>>>    Define wssInvalidDataForType  // Attempt to move data from XML to ValueTree (to Struct) failed.
24314>>>>>>>>>    Define wssCouldNotResolveHRef // we had an href and we could not find the Id data for it
24314>>>>>>>>>End_Enum_List
24314>>>>>>>>>
24314>>>>>>>>>Define C_ChoiceStructNone for -1 // for choice structs that have no selection
24314>>>>>>>>>
24314>>>>>>>>>
24314>>>>>>>>>// used to represent a soap struct. This contains the additional information needed to serialize adn deserialize the xml data.
24314>>>>>>>>>// each datatype object is created once. If a struct uses another struct it is done through a pointer to the new object. This
24314>>>>>>>>>// allows for recursive structures
24314>>>>>>>>>Class cSoapMetaStruct is a cObject
24315>>>>>>>>>
24315>>>>>>>>>    Procedure Construct_object
24317>>>>>>>>>        Forward Send Construct_object
24319>>>>>>>>>        Property String psNameSpace              // we assume all struct members are within this namespace
24320>>>>>>>>>        Property Integer peArrayType C_atNone    // C_atNone C_atArray C_atSoapEncArray
24321>>>>>>>>>        Property Integer pbSchemaAllGroup False  // used to handle the unpleasant case of <all> instead of <sequence>
24322>>>>>>>>>        Property String  psDataType ''           // This is used only by soapencoded arrays.
24323>>>>>>>>>                                                 // If a struct, the name of the schema Struct datatype (without our tWS prefix).
24323>>>>>>>>>                                                 // If an array and a non-struct, name of soap xs datatype (e.g. int)
24323>>>>>>>>>        Property String  psDataTypeNamespace ''  // This is used only by soapencoded arrays. This is the datatype's namespace
24324>>>>>>>>>                                                 // If a struct, the name of the schema Struct namespace.
24324>>>>>>>>>                                                 // If an array and a non-struct, empty (we know its namespace)
24324>>>>>>>>>                                                 // This was added in 14.0 and is generated by that version's class generator
24324>>>>>>>>>        Property Integer piDimensions 0          // if C_atArray or C_atSoapEncArray, this contains number of dimensions
24325>>>>>>>>>        
24325>>>>>>>>>        Property Boolean pbSimpleContent False   // if true the first element is an element value and all other values are attributes
24326>>>>>>>>>        
24326>>>>>>>>>        Property Boolean pbChoice False          // if true this is a choice struct. The first member is the choice (numeric enumeration) and
24327>>>>>>>>>                                                 // the other members are the choice elements. Only one can be chosen
24327>>>>>>>>>        
24327>>>>>>>>>        Property tSoapParamDef[] pSoapParamDefs  // defintion of struct
24328>>>>>>>>>    End_Procedure
24329>>>>>>>>>
24329>>>>>>>>>    Procedure defineParam Integer eType Integer hoStruct Integer iMin Integer iMax String sName String sStypeInfo
24331>>>>>>>>>        tSoapParamDef[] SoapParams
24331>>>>>>>>>        tSoapParamDef[] SoapParams
24332>>>>>>>>>        tSoapParamDef   SoapParam
24332>>>>>>>>>        tSoapParamDef   SoapParam
24332>>>>>>>>>        Integer iCount
24332>>>>>>>>>        Move sName       to SoapParam.sName
24333>>>>>>>>>        Get  psNameSpace to SoapParam.sNameSpace
24334>>>>>>>>>        Move eType       to SoapParam.eType
24335>>>>>>>>>        Move hoStruct    to SoapParam.hoStruct
24336>>>>>>>>>        Move iMin        to SoapParam.iMin
24337>>>>>>>>>        Move iMax        to SoapParam.iMax
24338>>>>>>>>>
24338>>>>>>>>>        Get pSoapParamDefs  to SoapParams
24339>>>>>>>>>        Move (SizeOfArray(SoapParams)) to iCount
24340>>>>>>>>>        Move SoapParam to SoapParams[iCount]
24341>>>>>>>>>        Set pSoapParamDefs to SoapParams
24342>>>>>>>>>    End_Procedure
24343>>>>>>>>>
24343>>>>>>>>>    Procedure defineParameter Integer eType Integer iMin Integer iMax String sName
24345>>>>>>>>>        Send defineParam eType 0 iMin iMax sName ""
24346>>>>>>>>>    End_Procedure
24347>>>>>>>>>
24347>>>>>>>>>    Procedure defineStructParameter Handle hoStruct Integer iMin Integer iMax String sName
24349>>>>>>>>>        Send defineParam xsStruct hoStruct iMin iMax sName ""
24350>>>>>>>>>    End_Procedure
24351>>>>>>>>>
24351>>>>>>>>>    Procedure defineQualParameter Integer eType Integer iMin Integer iMax String sName String sNS
24353>>>>>>>>>        String sOldNS
24353>>>>>>>>>        Get psNamespace to sOldNS
24354>>>>>>>>>        Set psNamespace to sNS
24355>>>>>>>>>        Send defineParam eType 0 iMin iMax sName ""
24356>>>>>>>>>        Set psNamespace to sOldNS
24357>>>>>>>>>    End_Procedure
24358>>>>>>>>>
24358>>>>>>>>>    Procedure defineQualStructParameter Handle hoStruct Integer iMin Integer iMax String sName String sNs
24360>>>>>>>>>        String sOldNS
24360>>>>>>>>>        Get psNamespace to sOldNS
24361>>>>>>>>>        Set psNamespace to sNS
24362>>>>>>>>>        Send defineParam xsStruct hoStruct iMin iMax sName ""
24363>>>>>>>>>        Set psNamespace to sOldNS
24364>>>>>>>>>    End_Procedure
24365>>>>>>>>>
24365>>>>>>>>>    // Used to define attribute parameters (i.e., struct members that are handled as attributes within the xml.
24365>>>>>>>>>    Procedure defineAttributeParameter Integer eType String sDefault String sName String sNS
24367>>>>>>>>>        tSoapParamDef[] SoapParams
24367>>>>>>>>>        tSoapParamDef[] SoapParams
24368>>>>>>>>>        tSoapParamDef   SoapParam
24368>>>>>>>>>        tSoapParamDef   SoapParam
24368>>>>>>>>>        Integer iCount
24368>>>>>>>>>        Move sName       to SoapParam.sName
24369>>>>>>>>>        Move sNS         to SoapParam.sNameSpace
24370>>>>>>>>>        Move eType       to SoapParam.eType
24371>>>>>>>>>        Move sDefault    to SoapParam.sDefaultAttr
24372>>>>>>>>>        Move True        to SoapParam.bAttribute
24373>>>>>>>>>
24373>>>>>>>>>        Get pSoapParamDefs  to SoapParams
24374>>>>>>>>>        Move (SizeOfArray(SoapParams)) to iCount
24375>>>>>>>>>        Move SoapParam to SoapParams[iCount]
24376>>>>>>>>>        Set pSoapParamDefs to SoapParams
24377>>>>>>>>>    End_Procedure
24378>>>>>>>>>
24378>>>>>>>>>
24378>>>>>>>>>End_Class
24379>>>>>>>>>
24379>>>>>>>>>
24379>>>>>>>>>// Generic class that any web-service is based on. Mostly Abstract. Used to
24379>>>>>>>>>// create actual classes but could be used to handle dynamic web-services
24379>>>>>>>>>
24379>>>>>>>>>Class cClientWebService is a cObject
24380>>>>>>>>>
24380>>>>>>>>>    Procedure Construct_Object
24382>>>>>>>>>        
24382>>>>>>>>>        Forward Send Construct_Object
24384>>>>>>>>>        Property String psWSDLLocation         ''
24385>>>>>>>>>        Property String psServiceLocation      ''
24386>>>>>>>>>
24386>>>>>>>>>        // xsd schema types
24386>>>>>>>>>        Property String  psSchemaNSPre         "xs"
24387>>>>>>>>>        Property String  psSchemaNSUri         C_XMLSCHEMAURI
24388>>>>>>>>>
24388>>>>>>>>>        // xsi schema instance
24388>>>>>>>>>        Property String  psSchemaInstanceNSPre "xsi"
24389>>>>>>>>>        Property String  psSchemaInstanceNSUri C_XMLSCHEMAXSIURI
24390>>>>>>>>>
24390>>>>>>>>>        // soap envelope
24390>>>>>>>>>        Property String  psSoapEnvNsPre        "soap"
24391>>>>>>>>>        Property String  psSoapEnvNsUri        C_SOAPENVELOPEURI
24392>>>>>>>>>
24392>>>>>>>>>        // soap encoding
24392>>>>>>>>>        Property String  psSoapEncodingNsPre   "soapenc"
24393>>>>>>>>>        Property String  psSoapEncodingNsUri   C_SOAPENCODINGURI
24394>>>>>>>>>
24394>>>>>>>>>        Property String  psMethodsNsPre        "m"
24395>>>>>>>>>
24395>>>>>>>>>        Property String  psXmlVersion          "1.0"
24396>>>>>>>>>        Property String  psXmlEncoding         "UTF-8"
24397>>>>>>>>>        Property Integer piPort                0 // dflt here is 0, which means it uses default values of http or ssl/http
24398>>>>>>>>>        // This is what most services expect. However, it is possible that this will
24398>>>>>>>>>        // need to be changed.
24398>>>>>>>>>        Property String  psContentType         (C_ContentTypeSOAP + "; charset=UTF-8")
24399>>>>>>>>>        Property String  psContentTypeExpected  C_ContentTypeSOAP
24400>>>>>>>>>        Property String  psHttpUserAgent       "DataFlex/17"
24401>>>>>>>>>
24401>>>>>>>>>        Property String psUserName ''          // passed through to http object
24402>>>>>>>>>        Property String psPassword ''          // passed through to http object
24403>>>>>>>>>
24403>>>>>>>>>        // if client certificate is needed it is defined here.
24403>>>>>>>>>        // The certificate must be installed on the machine. Note that most SSL does not require this.
24403>>>>>>>>>        Property String psCertificateStore   ''
24404>>>>>>>>>        Property String psCertificateSubject ''
24405>>>>>>>>>
24405>>>>>>>>>
24405>>>>>>>>>        // these get set by the methods that are created in the sub-class
24405>>>>>>>>>        Property String  psSOAPAction          ''
24406>>>>>>>>>        Property Integer peSoapStyle           ssDocument // ssDocument|ssRPC
24407>>>>>>>>>
24407>>>>>>>>>        Property String  psRequestNSURI        ''
24408>>>>>>>>>        Property Integer peSoapEncoding        seLiteral  // seLiteral|seEncoded
24409>>>>>>>>>        Property String  psMethodRequest       ''         // e.g. SayHello
24410>>>>>>>>>        Property Boolean pbRequestBare         False      // normally false, if True, document style does not have a wrapper
24411>>>>>>>>>
24411>>>>>>>>>        Property String  psResponseNSURI       ''
24412>>>>>>>>>        Property Integer peResponseSoapEncoding seLiteral // I am not sure we need this
24413>>>>>>>>>        Property String  psMethodResponse      ''         // e.g. SayHelloResponse
24414>>>>>>>>>        Property Boolean pbResponseBare        False      // normally false, if True, document style does not have a wrapper
24415>>>>>>>>>        
24415>>>>>>>>>        Property Boolean pbValidateResponse    True       // safety valve. If turned off, we don't check to see if the return data
24416>>>>>>>>>                                                          // is formatted as expected. This should be a last step to make a service work
24416>>>>>>>>>
24416>>>>>>>>>
24416>>>>>>>>>        Property Integer peTransferStatus      wssOk
24417>>>>>>>>>
24417>>>>>>>>>        Property tSoapParameter[] pspParameters
24418>>>>>>>>>        Property tSoapParameter[] pspReturnParameters // array of return parameters allows support for ByRef variables
24419>>>>>>>>>
24419>>>>>>>>>        // this will do the actual transfer
24419>>>>>>>>>        Object oHTTP is a cXmlHttpTransfer
24421>>>>>>>>>            Set pbClearHeaders to False
24422>>>>>>>>>            Set piBufferSize   to 16000
24423>>>>>>>>>        End_Object
24424>>>>>>>>>
24424>>>>>>>>>        // handle to http object -- exposed for advanced usage and normally never used by developer
24424>>>>>>>>>        Property Handle phoHttp (oHTTP)
24425>>>>>>>>>
24425>>>>>>>>>        Property Handle phoSoapRequest  0
24426>>>>>>>>>        Property Handle phoSoapResponse 0
24427>>>>>>>>>        Property Handle phoSoapHeaderResponse 0 // s/b maintained using SoapHeaderResponseNode
24428>>>>>>>>>        Property Handle phoSoapHeaderRequest 0  // s/b maintained using ClearSoapHeaders and AddSoapHeaderNode and SoapHeaderRequestNode
24429>>>>>>>>>        Property String psFaultCode ''
24430>>>>>>>>>        Property String psFaultString ''
24431>>>>>>>>>
24431>>>>>>>>>
24431>>>>>>>>>        // used and maintained internally for a short time while parsing the return XML
24431>>>>>>>>>        // this points to the body node which will be used to resolve hrefs
24431>>>>>>>>>        Property Handle phoReturnBody 0
24432>>>>>>>>>
24432>>>>>>>>>        // if True errors are not reported in LastError. It then becomes up to the
24432>>>>>>>>>        // developer to test if a web service succeeded by checking peTransferStatus and
24432>>>>>>>>>        // then reporting the error as needed, using WebServiceErrorDescription to get the error message
24432>>>>>>>>>        Property Boolean pbSuppressLastError False
24433>>>>>>>>>
24433>>>>>>>>>        // this is helpful in testing and debugging
24433>>>>>>>>>        Property Handle phoSoapClientHelper 0     // when set message OnSoapReceived is sent to this object
24434>>>>>>>>>
24434>>>>>>>>>        Property Boolean pbRequestOnly False // if true, a one way request only, must be set in per call. 
24435>>>>>>>>>        
24435>>>>>>>>>        Property String psRefToken C_SOAPHREF
24436>>>>>>>>>
24436>>>>>>>>>        // This class only supports 1.1, so version is read-only. This might be changed
24436>>>>>>>>>        // in a superclass that supports SOAP1.2
24436>>>>>>>>>        Property Integer peSOAPVersion svSOAP11
24437>>>>>>>>>        
24437>>>>>>>>>    End_Procedure
24438>>>>>>>>>
24438>>>>>>>>>
24438>>>>>>>>>    // Defines a simple datatype parameter.
24438>>>>>>>>>    Function DefineParameter Integer eDataType Integer iMin Integer iMax String sName String sNS Returns tSoapParamDef
24440>>>>>>>>>        tSoapParamDef spParam
24440>>>>>>>>>        tSoapParamDef spParam
24440>>>>>>>>>        Move sName          to spParam.sName
24441>>>>>>>>>        Move sNS            to spParam.sNamespace
24442>>>>>>>>>        Move eDataType      to spParam.eType
24443>>>>>>>>>        Move iMin           to spParam.iMin
24444>>>>>>>>>        Move iMax           to spParam.iMax
24445>>>>>>>>>        Function_Return spParam
24446>>>>>>>>>    End_Function
24447>>>>>>>>>
24447>>>>>>>>>    Function DefineStructParameter Handle hoStruct Integer iMin Integer iMax String sName String sNS Returns tSoapParamDef
24449>>>>>>>>>        tSoapParamDef spParam
24449>>>>>>>>>        tSoapParamDef spParam
24449>>>>>>>>>        Move sName          to spParam.sName
24450>>>>>>>>>        Move sNS            to spParam.sNamespace
24451>>>>>>>>>        Move xsStruct       to spParam.eType
24452>>>>>>>>>        Move hoStruct       to spParam.hoStruct
24453>>>>>>>>>        Move iMin           to spParam.iMin
24454>>>>>>>>>        Move iMax           to spParam.iMax
24455>>>>>>>>>        Function_Return spParam
24456>>>>>>>>>    End_Function
24457>>>>>>>>>
24457>>>>>>>>>
24457>>>>>>>>>    // Structs are Arrays are created using the above two methods
24457>>>>>>>>>
24457>>>>>>>>>    // reset everything for a new call
24457>>>>>>>>>    Procedure Reset
24459>>>>>>>>>        Handle hoXml
24459>>>>>>>>>        tSoapParameter[] EmptySoapParams
24459>>>>>>>>>        tSoapParameter[] EmptySoapParams
24460>>>>>>>>>
24460>>>>>>>>>        Get phoSoapRequest to hoXml
24461>>>>>>>>>        Set phoSoapRequest to 0
24462>>>>>>>>>        If hoXML Send destroy of hoXml
24465>>>>>>>>>
24465>>>>>>>>>        Get phoSoapResponse to hoXml
24466>>>>>>>>>        Set phoSoapResponse to 0
24467>>>>>>>>>        If hoXML Send destroy of hoXml
24470>>>>>>>>>        
24470>>>>>>>>>        Get phoSoapHeaderResponse to hoXml
24471>>>>>>>>>        Set phoSoapHeaderResponse to 0
24472>>>>>>>>>        If hoXML Send destroy of hoXml
24475>>>>>>>>>        
24475>>>>>>>>>        // note we don't clear soap request headers. A developer must do that manually
24475>>>>>>>>>        // by sending ClearSoapHeaders
24475>>>>>>>>>
24475>>>>>>>>>        Send ClearHeaders of (phoHttp(Self))
24476>>>>>>>>>
24476>>>>>>>>>        Set psRequestNSURI      to ''
24477>>>>>>>>>        Set psSOAPAction        to ''
24478>>>>>>>>>        Set peSoapStyle         to ''
24479>>>>>>>>>        Set psResponseNSURI     to ssDocument
24480>>>>>>>>>        Set peSoapEncoding      to seLiteral
24481>>>>>>>>>        Set peResponseSoapEncoding to seLiteral
24482>>>>>>>>>        Set psMethodRequest     to ''
24483>>>>>>>>>        Set psMethodResponse    to ''
24484>>>>>>>>>        Set peTransferStatus    to wssOk
24485>>>>>>>>>        Set psFaultCode         to ''
24486>>>>>>>>>        Set psFaultString       to ''
24487>>>>>>>>>        Set pspParameters       to EmptySoapParams  // clear input params
24488>>>>>>>>>        Set pspReturnParameters to EmptySoapParams  // clear return params
24489>>>>>>>>>        
24489>>>>>>>>>        Set pbRequestOnly to False // default to normal request/response
24490>>>>>>>>>
24490>>>>>>>>>    End_Procedure
24491>>>>>>>>>    
24491>>>>>>>>>    // Clear all Soap headers. Should be called before invoking a web-service call if the object
24491>>>>>>>>>    // use soap headers.
24491>>>>>>>>>    Procedure ClearSoapHeaders
24493>>>>>>>>>        Handle hoXml
24493>>>>>>>>>        Get phoSoapHeaderRequest to hoXml
24494>>>>>>>>>        If hoXML Send destroy of hoXml
24497>>>>>>>>>        Set phoSoapHeaderRequest to 0
24498>>>>>>>>>    End_Procedure
24499>>>>>>>>>
24499>>>>>>>>>    // Adds a new soap header which gets added to any soap request sent by this object. 
24499>>>>>>>>>    // it is the programmers responsibilty to send a valid element node
24499>>>>>>>>>    // if the data is bad or missing an error is generated and nothing is added.
24499>>>>>>>>>    // such an error would be considered to a programing error  
24499>>>>>>>>>    Procedure AddSoapHeaderNode Handle hoNode
24501>>>>>>>>>        Handle hoHeader hoRoot hoNew hoNew1
24501>>>>>>>>>        String sSoapNs sSoapNSPre
24501>>>>>>>>>        
24501>>>>>>>>>        // if node is not passed or it is not an element, this is an error
24501>>>>>>>>>        If (hoNode=0 or piNodeType(hoNode)<>NODE_ELEMENT) Begin
24503>>>>>>>>>            Error  DFERR_CLIENT_SOAP_TRANSFER C_$CannotAddSOAPRequestHeader
24504>>>>>>>>>>
24504>>>>>>>>>            Procedure_Return
24505>>>>>>>>>        End
24505>>>>>>>>>>
24505>>>>>>>>>
24505>>>>>>>>>        Get phoSoapHeaderRequest to hoHeader
24506>>>>>>>>>        // if no header yet, create it, either wat get the root element
24506>>>>>>>>>        If not hoHeader Begin
24508>>>>>>>>>            Get psSoapEnvNsUri to sSoapNS
24509>>>>>>>>>            Get psSoapEnvNsPre to sSoapNSPre
24510>>>>>>>>>            Get Create U_cXmlDomDocument to hoHeader
24511>>>>>>>>>            Get CreateDocumentElementNS of hoHeader sSoapNS (sSoapNSPre + ":Header") to hoRoot
24512>>>>>>>>>            Set phoSoapHeaderRequest to hoHeader
24513>>>>>>>>>        End
24513>>>>>>>>>>
24513>>>>>>>>>        Else Begin
24514>>>>>>>>>            Get DocumentElement of hoHeader to hoRoot
24515>>>>>>>>>        End
24515>>>>>>>>>>
24515>>>>>>>>>
24515>>>>>>>>>        If hoRoot Begin
24517>>>>>>>>>            Get CloneNode of hoNode True to hoNew
24518>>>>>>>>>            If hoNew Begin
24520>>>>>>>>>                Get AppendNode of hoRoot hoNew to hoNew1 // if hoNew1, the append failed. 
24521>>>>>>>>>                Send Destroy of hoNew
24522>>>>>>>>>            End    
24522>>>>>>>>>>
24522>>>>>>>>>            Send Destroy of hoRoot
24523>>>>>>>>>        End
24523>>>>>>>>>>
24523>>>>>>>>>    End_Procedure
24524>>>>>>>>>    
24524>>>>>>>>>    Function CopyXMLDocument Handle hoXML Returns Handle
24526>>>>>>>>>        Handle hoRoot hoNew
24526>>>>>>>>>        Handle hoNewXml hoNewRoot
24526>>>>>>>>>        Boolean bOk
24526>>>>>>>>>        // passing a 0 handle is allowed. It means there is no document. return 0
24526>>>>>>>>>        If hoXml Begin
24528>>>>>>>>>            // we use desktop so that this object persists
24528>>>>>>>>>            Get Create of desktop U_cXmlDomDocument to hoNewXml  // create new xml at desktop
24529>>>>>>>>>            Get CopyXMLtoXML hoXML hoNewXml to bOk
24530>>>>>>>>>            If not bOk Begin
24532>>>>>>>>>                // this is an error and the append never happened
24532>>>>>>>>>                Send Destroy of hoNewXml // for now return no object at all
24533>>>>>>>>>                Move 0 to hoNewXml
24534>>>>>>>>>            End
24534>>>>>>>>>>
24534>>>>>>>>>        End
24534>>>>>>>>>>
24534>>>>>>>>>        Function_Return hoNewXml
24535>>>>>>>>>    End_Function
24536>>>>>>>>>
24536>>>>>>>>>    // copy from xml to NewXML. hoXML must exist and hoNewXML must exist and be empty
24536>>>>>>>>>    Function CopyXMLToXML Handle hoXML Handle hoNewXml Returns Boolean
24538>>>>>>>>>        Handle hoRoot hoNew
24538>>>>>>>>>        Handle hoNewRoot hoNewRoot1
24538>>>>>>>>>        Get DocumentElement of hoXml to hoRoot
24539>>>>>>>>>        If hoRoot Begin
24541>>>>>>>>>            Get CloneNode of hoRoot True to hoNewRoot         // make a copy at the root 
24542>>>>>>>>>            If hoNewRoot Begin
24544>>>>>>>>>                Get AppendNode of hoNewXml hoNewRoot to hoNewRoot1 // add the copied node to this object
24545>>>>>>>>>                Send Destroy of hoNewRoot
24546>>>>>>>>>            End
24546>>>>>>>>>>
24546>>>>>>>>>            Send Destroy of hoRoot
24547>>>>>>>>>        End
24547>>>>>>>>>>
24547>>>>>>>>>        Else Begin
24548>>>>>>>>>            // this should not happen. We will return false, but it means we have a bad source xml document
24548>>>>>>>>>        End
24548>>>>>>>>>>
24548>>>>>>>>>        Function_Return (hoNewRoot1<>0)
24549>>>>>>>>>    End_Function
24550>>>>>>>>>
24550>>>>>>>>>    // Return an xml document of the soap header from the request. 
24550>>>>>>>>>    // It is the reponsibility of the calling method to dispose of this xml node (i.e., destroy it)
24550>>>>>>>>>    Function SoapHeaderRequestNode Returns Handle
24552>>>>>>>>>        Handle hoHeader hoXmlNode
24552>>>>>>>>>        Get phoSoapHeaderRequest to hoHeader
24553>>>>>>>>>        Get CopyXMLDocument hoHeader to hoXmlNode
24554>>>>>>>>>        Function_Return hoXmlNode
24555>>>>>>>>>    End_Function
24556>>>>>>>>>
24556>>>>>>>>>    // Return an xml document of the soap header from the response. 
24556>>>>>>>>>    // It is the reponsibility of the calling method to dispose of this xml node (i.e., destroy it)
24556>>>>>>>>>    Function SoapHeaderResponseNode Returns Handle
24558>>>>>>>>>        Handle hoHeader hoXmlNode
24558>>>>>>>>>        Get phoSoapHeaderResponse to hoHeader
24559>>>>>>>>>        Get CopyXMLDocument hoHeader to hoXmlNode
24560>>>>>>>>>        Function_Return hoXmlNode
24561>>>>>>>>>    End_Function
24562>>>>>>>>>
24562>>>>>>>>>    Procedure SetSoapAction
24564>>>>>>>>>        String sSOAPAction sContentType
24564>>>>>>>>>        Handle hoHttp
24564>>>>>>>>>        Boolean bOk
24564>>>>>>>>>        Get psSOAPAction to sSOAPAction
24565>>>>>>>>>        // according to soap specs, the SOAPAction should be enclosed in quotes. We assume that the
24565>>>>>>>>>        // quote is not in the property and add them here.
24565>>>>>>>>>        Get phoHttp to hoHttp
24566>>>>>>>>>        Get AddHeader     of hoHttp "SOAPAction" ('"' - sSOAPAction - '"') to bOk
24567>>>>>>>>>    End_Procedure
24568>>>>>>>>>
24568>>>>>>>>>    Function DoInvokeService Returns Integer
24570>>>>>>>>>        Handle hoXml hoXmlResponse hoSoapResponse
24570>>>>>>>>>        Integer eStatus iPort iRemotePort eTransferFlags
24570>>>>>>>>>        Boolean bIsHttps bRequestOnly
24570>>>>>>>>>        String sServiceHost sServiceFilePath sSOAPAction sServiceLocation
24570>>>>>>>>>        String sCertificateStore sCertificateSubject
24570>>>>>>>>>
24570>>>>>>>>>        Integer iPos
24570>>>>>>>>>        Boolean bOk
24570>>>>>>>>>        Handle hoHttp
24570>>>>>>>>>
24570>>>>>>>>>        Get phoHttp to hoHttp
24571>>>>>>>>>        Get pbRequestOnly to bRequestOnly
24572>>>>>>>>>
24572>>>>>>>>>        Get CreateSoapRequest to hoXml
24573>>>>>>>>>        If not hoXML Begin
24575>>>>>>>>>           Set peTransferStatus to wssBadRequest
24576>>>>>>>>>           Send OnSoapReceived
24577>>>>>>>>>           Function_Return wssBadRequest
24578>>>>>>>>>        End
24578>>>>>>>>>>
24578>>>>>>>>>
24578>>>>>>>>>        Set phoSoapRequest to hoXML
24579>>>>>>>>>
24579>>>>>>>>>        Send SetSoapAction
24580>>>>>>>>>
24580>>>>>>>>>        // Set up HTTP object
24580>>>>>>>>>        Set psAcceptTypes of hoHttp to "text/*"
24581>>>>>>>>>        // content type is set by the http object via this property
24581>>>>>>>>>        Set psContentTypeSent of hoHttp to (psContentType(Self))
24582>>>>>>>>>        Set psContentTypeExpected of hoHttp to (psContentTypeExpected(Self))
24583>>>>>>>>>
24583>>>>>>>>>
24583>>>>>>>>>        // Make SOAP call via XMLHTTP POST
24583>>>>>>>>>        Get psServiceLocation to sServiceLocation
24584>>>>>>>>>        //
24584>>>>>>>>>        Send CrackUrl sServiceLocation (&iPort) (&bIsHttps) (&sServiceHost) (&sServiceFilePath)
24585>>>>>>>>>        // for assigning ports. If port is passed in URL, always use it, Else if piPort is set, use it, else
24585>>>>>>>>>        // use dflt http and http/ssl ports
24585>>>>>>>>>        Get piPort to iRemotePort // see if we are forcing a value
24586>>>>>>>>>        If (iRemotePort=0) Begin
24588>>>>>>>>>            Move (If(bIsHttps, rpHttpSSL, rpHttp)) to iRemotePort
24589>>>>>>>>>        End
24589>>>>>>>>>>
24589>>>>>>>>>        Set piRemotePort of hoHttp to (If(iPort=0,iRemotePort,iPort))
24590>>>>>>>>>
24590>>>>>>>>>        // set/clear secure bit in transfer flags. Developer might need to set other flags by setting peTransferFlags in phoHttp.
24590>>>>>>>>>        // For example a client certificate might require IfIgnoreCertDateInvalid + IfIgnoreCertCnInvalid.
24590>>>>>>>>>        Get peTransferFlags of hoHttp to eTransferFlags
24591>>>>>>>>>        If bIsHttps Begin
24593>>>>>>>>>            Set peTransferFlags of hoHttp to  (AddBitValue(ifSecure, eTransferFlags)) // if secure we must set this flag
24594>>>>>>>>>        End
24594>>>>>>>>>>
24594>>>>>>>>>        Else Begin
24595>>>>>>>>>            Set peTransferFlags of hoHttp to  (RemoveBitValue(ifSecure, eTransferFlags)) // if secure we must unset this flag
24596>>>>>>>>>        End
24596>>>>>>>>>>
24596>>>>>>>>>
24596>>>>>>>>>        Set psUserName of hoHttp to (psUserName(Self))
24597>>>>>>>>>        Set psPassword of hoHttp to (psPassword(Self))
24598>>>>>>>>>
24598>>>>>>>>>        Get psCertificateStore   to sCertificateStore
24599>>>>>>>>>        Get psCertificateSubject to sCertificateSubject
24600>>>>>>>>>        If (sCertificateStore<>"" or sCertificateSubject<>"") Begin
24602>>>>>>>>>            Get SelectClientCertificate of hoHttp sCertificateStore sCertificateSubject to bOk
24603>>>>>>>>>        End
24603>>>>>>>>>>
24603>>>>>>>>>
24603>>>>>>>>>        Set pbDataRequiredReceived of hoHttp to (not(bRequestOnly))
24604>>>>>>>>>
24604>>>>>>>>>        Get HttpPostXmlNode of hoHttp sServiceHost sServiceFilePath hoXML to hoXMLResponse
24605>>>>>>>>>        
24605>>>>>>>>>        // we have an error or no response expected, return status code as needed
24605>>>>>>>>>        If (hoXmlResponse=0) Begin
24607>>>>>>>>>            Get peXmlTransferStatus of hoHttp to eStatus
24608>>>>>>>>>            Case Begin
24608>>>>>>>>>
24608>>>>>>>>>                // If Ok and no request needed, we are ok
24608>>>>>>>>>                Case (eStatus=xtsOk and bRequestOnly) Move wssOk to eStatus
24611>>>>>>>>>                
24611>>>>>>>>>                Case (eStatus=xtsHttpRequestFailed)  Move wssHttpRequestFailed to eStatus
24615>>>>>>>>>                Case (eStatus=xtsBadRequest)         Move wssBadRequest to eStatus
24619>>>>>>>>>                Case (eStatus=xtsInvalidContentType) Move wssInvalidContentType to eStatus
24623>>>>>>>>>                Case (eStatus=xtsNoData)             Move wssNoData to eStatus
24627>>>>>>>>>                Case (eStatus=xtsNotXml)             Move wssNotXml to eStatus
24631>>>>>>>>>                Case Else                            Move wssError to eStatus
24633>>>>>>>>>            Case End
24633>>>>>>>>>        End
24633>>>>>>>>>>
24633>>>>>>>>>        Else Begin
24634>>>>>>>>>            // If we have a good response we want to save it in phoSoapRespone.
24634>>>>>>>>>            // The XML response is at the desktop so we must first copy it to
24634>>>>>>>>>            // this object so it will get destroyed if the object is dynamically
24634>>>>>>>>>            // destroyed.
24634>>>>>>>>>            
24634>>>>>>>>>            // If this was a one-way SOAP that had a response we will assume this is a "robust in-only" service where the only
24634>>>>>>>>>            // allowed response is either nothing (and we will not be here) or a fault. Therefore the status should be a fault. Any other
24634>>>>>>>>>            // XML should return some other kind of error. It is not clear if robust in-only is supported in soap1.1, but if it is there
24634>>>>>>>>>            // we can use it. 
24634>>>>>>>>>            
24634>>>>>>>>>            Get Create U_cXmlDomDocument to hoSoapResponse       // create within this object
24635>>>>>>>>>            Get CopyXMLToXML hoXmlResponse hoSoapResponse to bOk // copy to new object
24636>>>>>>>>>            If bOk Begin
24638>>>>>>>>>                // save the new local XML resposne node and process
24638>>>>>>>>>                Set phoSoapResponse to hoSoapResponse
24639>>>>>>>>>                Get DoSetSoapReturn to eStatus
24640>>>>>>>>>            End
24640>>>>>>>>>>
24640>>>>>>>>>            Else Begin
24641>>>>>>>>>                // this should not happen. It means that the returned XML could not
24641>>>>>>>>>                // be copied, which implies it was not XML.
24641>>>>>>>>>                Send Destroy of hoSoapResponse
24642>>>>>>>>>                Move wssNotXml to eStatus
24643>>>>>>>>>            End
24643>>>>>>>>>>
24643>>>>>>>>>        End
24643>>>>>>>>>>
24643>>>>>>>>>        
24643>>>>>>>>>        If hoXmlResponse Begin
24645>>>>>>>>>            // remove the desktop XML node.
24645>>>>>>>>>            Send Destroy of hoXmlResponse
24646>>>>>>>>>        End
24646>>>>>>>>>>
24646>>>>>>>>>        
24646>>>>>>>>>        Set peTransferStatus to eStatus
24647>>>>>>>>>        Send OnSoapReceived
24648>>>>>>>>>        Function_Return eStatus
24649>>>>>>>>>    End_Function
24650>>>>>>>>>
24650>>>>>>>>>    // Take sUrl and move to components
24650>>>>>>>>>    Procedure CrackUrl String sUrl Integer ByRef iPort Boolean ByRef bIsHttps String ByRef sHost String ByRef sFilepath
24652>>>>>>>>>        Integer iPos iPosEnd
24652>>>>>>>>>        String sTemp
24652>>>>>>>>>
24652>>>>>>>>>        Move 0 to iPort
24653>>>>>>>>>        Move False to bIsHttps
24654>>>>>>>>>
24654>>>>>>>>>        Move (trim(sUrl)) to sUrl
24655>>>>>>>>>
24655>>>>>>>>>        Move (lowercase(sUrl)) to sTemp
24656>>>>>>>>>        If (left(sTemp,8)="https://") Begin
24658>>>>>>>>>            Move True to bIsHttps
24659>>>>>>>>>            Move (Remove(sUrl,1,8)) to sUrl
24660>>>>>>>>>        End
24660>>>>>>>>>>
24660>>>>>>>>>        Else If (left(sTemp,7)="http://") Begin
24663>>>>>>>>>            Move (Remove(sUrl,1,7)) to sUrl
24664>>>>>>>>>        End
24664>>>>>>>>>>
24664>>>>>>>>>        // see if port is provded
24664>>>>>>>>>        Move (pos(":",sUrl)) to iPos
24665>>>>>>>>>        If iPos Begin
24667>>>>>>>>>            Move (pos("/",sUrl)) to iPosEnd
24668>>>>>>>>>            If (iPosEnd>iPos) Begin
24670>>>>>>>>>                Move (mid(sUrl,iPosEnd-iPos-1,iPos+1)) to iPort
24671>>>>>>>>>                Move (Remove(sUrl,iPos,iPosEnd-iPos)) to sUrl
24672>>>>>>>>>            End
24672>>>>>>>>>>
24672>>>>>>>>>        End
24672>>>>>>>>>>
24672>>>>>>>>>        Move (pos("/",sUrl)) to iPos
24673>>>>>>>>>        If iPos Begin
24675>>>>>>>>>            Move (left(sUrl,iPos-1)) to sHost
24676>>>>>>>>>            Move (Remove(sUrl,1,iPos)) to sFilePath
24677>>>>>>>>>        End
24677>>>>>>>>>>
24677>>>>>>>>>        Else Begin
24678>>>>>>>>>            Move sUrl to sHost
24679>>>>>>>>>            Move '' to sFilePath
24680>>>>>>>>>        End
24680>>>>>>>>>>
24680>>>>>>>>>    End_Procedure
24681>>>>>>>>>    
24681>>>>>>>>>    Function NextNonCommentNode Handle hoNode Returns Handle
24683>>>>>>>>>        Integer eType
24683>>>>>>>>>        Get NextNode of hoNode to hoNode
24684>>>>>>>>>        While (hoNode)
24688>>>>>>>>>            Get piNodeType of hoNode to eType
24689>>>>>>>>>            If (eType<>NODE_COMMENT) Begin
24691>>>>>>>>>                Function_Return hoNode
24692>>>>>>>>>            End
24692>>>>>>>>>>
24692>>>>>>>>>            Get NextNode of hoNode to hoNode
24693>>>>>>>>>        Loop
24694>>>>>>>>>>
24694>>>>>>>>>        Function_Return 0
24695>>>>>>>>>    End_Function
24696>>>>>>>>>
24696>>>>>>>>>    Function FirstNonCommentChild Handle hoNode Returns Handle
24698>>>>>>>>>        Integer eType
24698>>>>>>>>>        Handle hoChild
24698>>>>>>>>>        Get FirstChild of hoNode to hoChild
24699>>>>>>>>>        If (hoChild) Begin
24701>>>>>>>>>            Get piNodeType of hoChild to eType
24702>>>>>>>>>            If (eType=NODE_COMMENT) Begin
24704>>>>>>>>>                Get NextNonCommentNode hoChild to hoChild
24705>>>>>>>>>            End
24705>>>>>>>>>>
24705>>>>>>>>>        End
24705>>>>>>>>>>
24705>>>>>>>>>        Function_Return hoChild
24706>>>>>>>>>    End_Function
24707>>>>>>>>>
24707>>>>>>>>>    Function DoSetSoapReturn Returns Integer
24709>>>>>>>>>        Handle hoXml hoRoot hoParam hoBody hoParam2 hoParam3 hoReturn
24709>>>>>>>>>        Handle hoHeader hoNewRoot
24709>>>>>>>>>        String sReturn sSoapEnvNSUri sResponseNSURI sMethodResponse sNameSpace
24709>>>>>>>>>        Integer eSoapStyle eStatus iError
24709>>>>>>>>>        Boolean bResponseBare bValidateResponse
24709>>>>>>>>>        tSoapParameter[] ReturnParameters
24709>>>>>>>>>        tSoapParameter[] ReturnParameters
24710>>>>>>>>>        Integer iReturnParameters iParam
24710>>>>>>>>>        // it is possible to have multiple return values in the case of a ByRef web-service. At this level we don't know where
24710>>>>>>>>>        // the return values will get assigned (the sub class does this). We just parse all the return variables and place them
24710>>>>>>>>>        // in the return array.
24710>>>>>>>>>        Get pspReturnParameters to ReturnParameters
24711>>>>>>>>>
24711>>>>>>>>>        Get psSoapEnvNSUri   to sSoapEnvNSUri
24712>>>>>>>>>        Get psResponseNSURI  to sResponseNSURI
24713>>>>>>>>>        Get psMethodResponse to sMethodResponse
24714>>>>>>>>>        Get peSoapStyle      to eSoapStyle
24715>>>>>>>>>        Get pbResponseBare   to bResponseBare
24716>>>>>>>>>        Get pbValidateResponse to bValidateResponse
24717>>>>>>>>>        Move wssNotXml to eStatus
24718>>>>>>>>>
24718>>>>>>>>>        Get phoSoapResponse  to hoXML
24719>>>>>>>>>        If (hoXML=0) Function_Return eStatus
24722>>>>>>>>>
24722>>>>>>>>>        Get DocumentElement of hoXML to hoRoot
24723>>>>>>>>>        If hoRoot Begin // s/b soap:Envelope
24725>>>>>>>>>            If (IsElementNS(hoRoot,sSoapEnvNSUri,"Envelope")) Begin
24727>>>>>>>>>                Get FirstNonCommentChild hoRoot to hoBody // s/b soap:Header or soap:Body
24728>>>>>>>>>
24728>>>>>>>>>                If (hoBody and IsElementNS(hoBody,sSoapEnvNSUri,"Header")) Begin
24730>>>>>>>>>                    
24730>>>>>>>>>                    // handle a soap header response. Just save the soapheader as an xml document
24730>>>>>>>>>                    
24730>>>>>>>>>                    // create a header xml document as child of web-service object
24730>>>>>>>>>                    Get CloneNode of hoBody True to hoNewRoot
24731>>>>>>>>>                    Get Create U_cXmlDomDocument to hoHeader
24732>>>>>>>>>                    Get AppendNode of hoHeader hoNewRoot to hoNewRoot // add the copied node to this object
24733>>>>>>>>>                    Send destroy of hoNewRoot
24734>>>>>>>>>                    Set phoSoapHeaderResponse to hoHeader
24735>>>>>>>>>                    
24735>>>>>>>>>                    Get NextNonCommentNode hoBody to hoBody // and now get the real body   
24736>>>>>>>>>                End
24736>>>>>>>>>>
24736>>>>>>>>>                   
24736>>>>>>>>>                If hoBody Begin
24738>>>>>>>>>                   Set phoReturnBody to hoBody
24739>>>>>>>>>                   If (IsElementNS(hoBody,sSoapEnvNSUri,"Body")) Begin
24741>>>>>>>>>                       Get FirstNonCommentChild hoBody to hoParam // should be ResponseURI:MethodResposne or Soap:Fault
24742>>>>>>>>>                       If hoParam Begin
24744>>>>>>>>>                           If (IsElementNS(hoParam,sSoapEnvNSUri,"Fault")) Begin
24746>>>>>>>>>                               Get HandleSoapFault hoParam to eStatus
24747>>>>>>>>>                           End
24747>>>>>>>>>>
24747>>>>>>>>>                           Else Begin
24748>>>>>>>>>                               Move wssInvalidSoap to eStatus // next most likely error
24749>>>>>>>>>                               // we would expect the return struct and its child return value to adhere to
24749>>>>>>>>>                               // the expected MethodResponse and MethodReturn names as defined in the WSDL.
24749>>>>>>>>>                               // However, if the style is RPC this is not required (the names of these do not
24749>>>>>>>>>                               // matter) and we will allow any element name.
24749>>>>>>>>>                               // We also allow bare style through. It will get error checked further below
24749>>>>>>>>>                               If (eSoapStyle=ssRPC or bResponseBare or not(bValidateResponse) or IsElementNS(hoParam,sResponseNSURI,sMethodResponse)) Begin
24751>>>>>>>>>                                   Move (SizeOfArray(ReturnParameters)) to iReturnParameters
24752>>>>>>>>>                                   If (iReturnParameters=0) Begin
24754>>>>>>>>>                                       // There are no expected return parameters.
24754>>>>>>>>>                                       // If we are this far we've recieved a valid response and we are done
24754>>>>>>>>>                                       Move wssOk to eStatus
24755>>>>>>>>>                                   End
24755>>>>>>>>>>
24755>>>>>>>>>                                   Else Begin
24756>>>>>>>>>
24756>>>>>>>>>                                       // get the first return parameter
24756>>>>>>>>>                                       If bResponseBare Begin
24758>>>>>>>>>                                           // if bare, there is no outer wrapper. So the current element is the inner
24758>>>>>>>>>                                           // wrapper. Create a copy of this and use it.
24758>>>>>>>>>                                           Get CloneNode of hoParam True to hoParam2
24759>>>>>>>>>                                           // if bare we must have only one return parameter
24759>>>>>>>>>                                           Move (If(iReturnParameters<>1,wssSoapFault,0)) to iError
24760>>>>>>>>>                                       End
24760>>>>>>>>>>
24760>>>>>>>>>                                       Else Begin
24761>>>>>>>>>                                           // if wrapped which is the more normal case, hoParam is the wrapper. The first child will be the 1st return param
24761>>>>>>>>>                                           Get FirstNonCommentChild hoParam to hoParam2
24762>>>>>>>>>                                           Move 0 to iError
24763>>>>>>>>>                                       End
24763>>>>>>>>>>
24763>>>>>>>>>
24763>>>>>>>>>                                       // process all return parameters. At the moment we only support multiple return variables if the
24763>>>>>>>>>                                       // schema defined them as <sequence>. We will support minOccurs 0 return values.
24763>>>>>>>>>                                       Move 0 to iParam
24764>>>>>>>>>                                       While ( iError=0 and iParam<iReturnParameters)
24768>>>>>>>>>                                           If hoParam2 Begin
24770>>>>>>>>>                                               // if rpc, this should be in the global ws, if doc use respons NS
24770>>>>>>>>>                                               Move (If(eSoapStyle=ssRpc,"",sResponseNSURI)) to sNamespace
24771>>>>>>>>>                                               If (eSoapStyle=ssRPC or not(bValidateResponse) or ;                                                     IsElementNS(hoParam2,ReturnParameters[iParam].SoapParamDef.sNamespace,ReturnParameters[iParam].SoapParamDef.sName)) Begin
24773>>>>>>>>>                                                   // if any or xmlelement, we handle this with a special function.
24773>>>>>>>>>                                                   If (ReturnParameters[iParam].SoapParamDef.eType=xsAnyType or ReturnParameters[iParam].SoapParamDef.eType=xsXmlElement) Begin
24775>>>>>>>>>                                                      Get XmlHandleToValueTree ReturnParameters[iParam].SoapParamDef hoParam2 to ReturnParameters[iParam].ValueTree
24776>>>>>>>>>                                                   End
24776>>>>>>>>>>
24776>>>>>>>>>                                                   Else Begin
24777>>>>>>>>>                                                      // convert XML data to Value Tree data
24777>>>>>>>>>                                                      Get XmlToValueTree ReturnParameters[iParam].SoapParamDef hoParam2 (&iError) to ReturnParameters[iParam].ValueTree
24778>>>>>>>>>                                                   End
24778>>>>>>>>>>
24778>>>>>>>>>                                                   Get NextNonCommentNode hoParam2 to hoParam2
24779>>>>>>>>>                                               End
24779>>>>>>>>>>
24779>>>>>>>>>                                               // if the param has the wrong name and it is a minOccurs=0, we assume we are skipping the param and the next will be ok
24779>>>>>>>>>                                               Else If (ReturnParameters[iParam].SoapParamDef.iMin<>0) Begin
24782>>>>>>>>>                                                   Move wssInvalidSoap to iError
24783>>>>>>>>>                                               End
24783>>>>>>>>>>
24783>>>>>>>>>                                           End
24783>>>>>>>>>>
24783>>>>>>>>>                                           // if no param it is possible it is a minOccurs=0, if so, skip the param. If not, this is anerror
24783>>>>>>>>>                                           Else If (ReturnParameters[iParam].SoapParamDef.iMin<>0) Begin
24786>>>>>>>>>                                               Move wssInvalidSoap to iError
24787>>>>>>>>>                                           End
24787>>>>>>>>>>
24787>>>>>>>>>                                           Increment iParam
24788>>>>>>>>>                                       End
24789>>>>>>>>>>
24789>>>>>>>>>                                       Move (If(iError=0, wssOk, iError)) to eStatus
24790>>>>>>>>>                                   End
24790>>>>>>>>>>
24790>>>>>>>>>                                   If hoParam2 Begin
24792>>>>>>>>>                                       Send Destroy of hoParam2
24793>>>>>>>>>                                   End
24793>>>>>>>>>>
24793>>>>>>>>>                               End
24793>>>>>>>>>>
24793>>>>>>>>>                           End
24793>>>>>>>>>>
24793>>>>>>>>>                           Send destroy of hoParam
24794>>>>>>>>>                       End
24794>>>>>>>>>>
24794>>>>>>>>>                   End
24794>>>>>>>>>>
24794>>>>>>>>>                   Set phoReturnBody to 0
24795>>>>>>>>>                   Send destroy of hoBody
24796>>>>>>>>>                End
24796>>>>>>>>>>
24796>>>>>>>>>            End
24796>>>>>>>>>>
24796>>>>>>>>>            Send destroy of hoRoot
24797>>>>>>>>>        End
24797>>>>>>>>>>
24797>>>>>>>>>        Set pspReturnParameters to ReturnParameters
24798>>>>>>>>>        Function_Return eStatus
24799>>>>>>>>>    End_Function
24800>>>>>>>>>
24800>>>>>>>>>    // handle a soap fault, pass the XML Fault node. Set Fault strings etc and Return appropriate Status
24800>>>>>>>>>    Function HandleSoapFault Handle hoParam Returns Integer
24802>>>>>>>>>        Handle hoParam2
24802>>>>>>>>>        Get FirstNonCommentChild hoParam to hoParam2 // should be faultcode
24803>>>>>>>>>        If hoParam2 Begin
24805>>>>>>>>>            If (IsElementNS(hoParam2,"","faultcode")) Begin
24807>>>>>>>>>                Set psFaultCode to (psText(hoParam2))
24808>>>>>>>>>            End
24808>>>>>>>>>>
24808>>>>>>>>>            Get NextNonCommentNode hoParam2 to hoParam2 // should be faultstring
24809>>>>>>>>>            If hoParam2 Begin
24811>>>>>>>>>                If (IsElementNS(hoParam2,"","faultstring")) Begin
24813>>>>>>>>>                    Set psFaultString to (psText(hoParam2))
24814>>>>>>>>>                End
24814>>>>>>>>>>
24814>>>>>>>>>                Send destroy of hoParam2
24815>>>>>>>>>            End
24815>>>>>>>>>>
24815>>>>>>>>>        End
24815>>>>>>>>>>
24815>>>>>>>>>        Function_Return wssSoapFault
24816>>>>>>>>>    End_Function
24817>>>>>>>>>
24817>>>>>>>>>    Function CreateSoapRequest Returns Handle
24819>>>>>>>>>        String sSoapNs sSoapNSPre
24819>>>>>>>>>        String sPiInf sXMLVersion sXmlEncoding
24819>>>>>>>>>        Handle hoXml hoEnv hoPI
24819>>>>>>>>>        Boolean bOK
24819>>>>>>>>>
24819>>>>>>>>>        Get psSoapEnvNsUri to sSoapNS
24820>>>>>>>>>        Get psSoapEnvNsPre to sSoapNSPre
24821>>>>>>>>>        Get psXmlVersion   to sXmlVersion
24822>>>>>>>>>        Get psXmlEncoding  to sXmlEncoding
24823>>>>>>>>>
24823>>>>>>>>>        Get Create U_cXMLDOMDocument to hoXML
24824>>>>>>>>>
24824>>>>>>>>>        // Create the SOAP Envelope as the document root:
24824>>>>>>>>>        Get CreateDocumentElementNS of hoXML sSoapNS (sSoapNSPre + ":Envelope") to hoEnv
24825>>>>>>>>>
24825>>>>>>>>>        // Add the XML processing instruction *ahead* of it:
24825>>>>>>>>>        Move ("version='" - sXmlVersion - "'" * "encoding='" - sXmlEncoding - "'") to sPiInf
24826>>>>>>>>>        Get CreateChildProcessingInstruction of hoEnv "xml" sPiInf to hoPI
24827>>>>>>>>>        Get InsertBeforeNode of hoXML hoPI hoEnv to hoPI
24828>>>>>>>>>        Send Destroy of hoPI
24829>>>>>>>>>        //
24829>>>>>>>>>        Get CreateSoapHeader hoEnv to bOk
24830>>>>>>>>>        If bOk Begin
24832>>>>>>>>>            Get CreateSoapBody hoEnv to bOk
24833>>>>>>>>>        End
24833>>>>>>>>>>
24833>>>>>>>>>        Send destroy of hoEnv
24834>>>>>>>>>        If not bOk Begin
24836>>>>>>>>>            Send destroy of hoXML
24837>>>>>>>>>            Move 0 to hoXML
24838>>>>>>>>>        End
24838>>>>>>>>>>
24838>>>>>>>>>        Function_Return hoXML
24839>>>>>>>>>    End_Function
24840>>>>>>>>>
24840>>>>>>>>>    Function CreateSoapHeader Integer hoEnv Returns Boolean
24842>>>>>>>>>        Handle hoHeader hoNew hoRoot hoNew1
24842>>>>>>>>>        Boolean bOk
24842>>>>>>>>>        Move True to bOk
24843>>>>>>>>>        Get phoSoapHeaderRequest to hoHeader
24844>>>>>>>>>        // we allow either no header or any empty document (no root), which is less likely
24844>>>>>>>>>        If hoHeader Begin
24846>>>>>>>>>            Get DocumentElement of hoHeader to hoRoot
24847>>>>>>>>>            If hoRoot Begin
24849>>>>>>>>>                Get CloneNode of hoRoot True to hoNew
24850>>>>>>>>>                Move (hoNew<>0) to bOk // if hoNew=0, the clone failed.
24851>>>>>>>>>                If bOk Begin
24853>>>>>>>>>                    Get AppendNode of hoEnv hoNew to hoNew1
24854>>>>>>>>>                    Move (hoNew1<>0) to bOk // if hoNew1=0, the append failed.
24855>>>>>>>>>                    Send Destroy of hoNew
24856>>>>>>>>>                End
24856>>>>>>>>>>
24856>>>>>>>>>                Send Destroy of hoRoot
24857>>>>>>>>>            End
24857>>>>>>>>>>
24857>>>>>>>>>        End
24857>>>>>>>>>>
24857>>>>>>>>>        Function_Return bOk
24858>>>>>>>>>    End_Function
24859>>>>>>>>>    
24859>>>>>>>>>    Function CreateSoapBody Integer hoEnv Returns Boolean
24861>>>>>>>>>        Handle hoBody
24861>>>>>>>>>        String sSoapEnvNsURI sSoapEnvNsPre sSoapEncodingNsUri sSoapEncodingNsPre
24861>>>>>>>>>        Integer eSoapEncoding
24861>>>>>>>>>        Boolean bOk
24861>>>>>>>>>        Get peSoapEncoding to eSoapEncoding
24862>>>>>>>>>        Get psSoapEnvNsURI to sSoapEnvNsURI
24863>>>>>>>>>        Get psSoapEnvNsPre to sSoapEnvNsPre
24864>>>>>>>>>        Get AddElementNS of hoEnv sSoapEnvNsURI (sSoapEnvNsPRE - ":Body") "" to hoBody
24865>>>>>>>>>        If not hoBody Function_Return 0
24868>>>>>>>>>        // if encoding, must add soap encoding style attribute
24868>>>>>>>>>        If (eSoapEncoding=seEncoded) Begin
24870>>>>>>>>>            Get psSoapEncodingNsUri to sSoapEncodingNsUri
24871>>>>>>>>>            Get psSoapEncodingNsPre to sSoapEncodingNsPre
24872>>>>>>>>>            // add encodingStyle attribute
24872>>>>>>>>>            Send AddAttributeNS of hoEnv sSoapEnvNsURI (sSoapEnvNsPRE - ":encodingStyle") sSoapEncodingNsUri
24873>>>>>>>>>            // define attribute
24873>>>>>>>>>            Send AddAttribute   of hoEnv ("xmlns:"+sSoapEncodingNsPre) sSoapEncodingNsUri
24874>>>>>>>>>        End
24874>>>>>>>>>>
24874>>>>>>>>>        Get CreateSoapMethod hoBody to bOk
24875>>>>>>>>>        Send Destroy of hoBody
24876>>>>>>>>>        Function_Return boK
24877>>>>>>>>>   End_Function
24878>>>>>>>>>
24878>>>>>>>>>    Function CreateSoapMethod Integer hoBody Returns Boolean
24880>>>>>>>>>        Handle  hoMethod
24880>>>>>>>>>        String  sMethod sNameSpace sPre
24880>>>>>>>>>        Integer eSoapEncoding
24880>>>>>>>>>        Boolean bOk bRequestBare
24880>>>>>>>>>        Get peSoapEncoding  to eSoapEncoding
24881>>>>>>>>>        Get psMethodRequest to sMethod
24882>>>>>>>>>        Get psRequestNSURI  to sNameSpace
24883>>>>>>>>>        Get pbRequestBare to bRequestBare
24884>>>>>>>>>        // Soap-encoded Methods should be qualified. However, if there is no namespace we cannot force it.
24884>>>>>>>>>        If (eSoapEncoding=seEncoded and sNameSpace<>"") Begin
24886>>>>>>>>>            Get psMethodsNsPre to sPre
24887>>>>>>>>>            Move (sPre + ":" + sMethod) to sMethod
24888>>>>>>>>>        End
24888>>>>>>>>>>
24888>>>>>>>>>        If (bRequestBare) Begin
24890>>>>>>>>>            // if bare, we don't create the method wrapper. We add the parameters directly
24890>>>>>>>>>            // under the body.
24890>>>>>>>>>            Get CreateParameters hoBody to bOk
24891>>>>>>>>>        End
24891>>>>>>>>>>
24891>>>>>>>>>        Else Begin
24892>>>>>>>>>            // when wrapped (normal) we create a wrapper element and add the params under that
24892>>>>>>>>>            Get AddElementNS of hoBody sNameSpace sMethod "" to hoMethod
24893>>>>>>>>>            If (hoMethod=0) Function_Return 0
24896>>>>>>>>>            Get CreateParameters hoMethod to bOk
24897>>>>>>>>>            Send destroy of hoMethod
24898>>>>>>>>>        End
24898>>>>>>>>>>
24898>>>>>>>>>        Function_Return bOk
24899>>>>>>>>>    End_Function
24900>>>>>>>>>
24900>>>>>>>>>    Function CreateParameters Integer hoMethod Returns Boolean
24902>>>>>>>>>        Integer iParam iParams
24902>>>>>>>>>        Boolean bOk
24902>>>>>>>>>        Handle hoParamNode
24902>>>>>>>>>        tSoapParameter[] SoapParameters
24902>>>>>>>>>        tSoapParameter[] SoapParameters
24903>>>>>>>>>        tSoapParameter   SoapParameter
24903>>>>>>>>>        tSoapParameter   SoapParameter
24903>>>>>>>>>
24903>>>>>>>>>        Get pspParameters to SoapParameters
24904>>>>>>>>>        Move (SizeOfArray(SoapParameters)) to iParams
24905>>>>>>>>>
24905>>>>>>>>>        For iParam from 0 to (iParams-1)
24911>>>>>>>>>>
24911>>>>>>>>>            Move SoapParameters[iParam] to SoapParameter
24912>>>>>>>>>            // if xsAnyType or xsXmlElement the entire param is treated as single piece of xml
24912>>>>>>>>>            If (SoapParameter.SoapParamDef.eType=xsAnyType or SoapParameter.SoapParamDef.eType=xsXmlElement) Begin
24914>>>>>>>>>                Get ValueTreeXmlParamToXml SoapParameter.SoapParamDef SoapParameter.ValueTree hoMethod to bOk
24915>>>>>>>>>            End
24915>>>>>>>>>>
24915>>>>>>>>>            // either a known type/struct or serialized XML
24915>>>>>>>>>            Else Begin
24916>>>>>>>>>                Get ValueTreeToXml SoapParameter.SoapParamDef SoapParameter.ValueTree hoMethod to bOk
24917>>>>>>>>>            End
24917>>>>>>>>>>
24917>>>>>>>>>        Loop
24918>>>>>>>>>>
24918>>>>>>>>>        Function_Return True
24919>>>>>>>>>    End_Function
24920>>>>>>>>>    
24920>>>>>>>>>    Function TransferErrorFaultDescription Returns String
24922>>>>>>>>>        String  sError sFaultCode sFaultString
24922>>>>>>>>>        Move C_$SoapFault to sError
24923>>>>>>>>>        Get psFaultCode   to sFaultCode
24924>>>>>>>>>        Get psFaultstring to sFaultString
24925>>>>>>>>>        Move (sError + "\n" + C_$SoapFaultCode * sFaultCode + ;                       "\n" + C_$SoapFaultString * sFaultString) to sError
24926>>>>>>>>>        Function_Return sError               
24927>>>>>>>>>    End_Function
24928>>>>>>>>>
24928>>>>>>>>>
24928>>>>>>>>>    Function TransferErrorDescription Returns String
24930>>>>>>>>>        String  sError sText sType
24930>>>>>>>>>        Integer eXmlTransferStatus
24930>>>>>>>>>        Handle  hoHttp
24930>>>>>>>>>        Get peTransferStatus to eXmlTransferStatus
24931>>>>>>>>>        Case Begin
24931>>>>>>>>>            Case (eXmlTransferStatus=wssOk)                  Move "" to sError
24934>>>>>>>>>            Case (eXmlTransferStatus=wssHttpRequestFailed)   Move C_$HttpRequestFailed          to sError
24938>>>>>>>>>            Case (eXmlTransferStatus=wssBadRequest)          Move C_$BadOrMissingDataSent       to sError
24942>>>>>>>>>            Case (eXmlTransferStatus=wssNoData)              Move C_$NoDataWasReceived          to sError
24946>>>>>>>>>            Case (eXmlTransferStatus=wssNotXml)              Move C_$ReceivedDataNotInXMLFormat to sError
24950>>>>>>>>>            Case (eXmlTransferStatus=wssNotSoap)             Move C_$XmlDataNotInSoapFormat     to sError
24954>>>>>>>>>            Case (eXmlTransferStatus=wssInvalidSoap)         Move C_$SoapDataNotAsWSDL          to sError
24958>>>>>>>>>            Case (eXmlTransferStatus=wssInvalidDataForType)  Move C_$ReceivedDataTypeIsBad      to sError
24962>>>>>>>>>            Case (eXmlTransferStatus=wssCouldNotResolveHRef) Move C_$CouldNotFindHRefedData     to sError
24966>>>>>>>>>            Case (eXmlTransferStatus=wssInvalidContentType) Begin
24969>>>>>>>>>                Get phoHttp to hoHttp
24970>>>>>>>>>                // if the content is html, let's show what we got in the error
24970>>>>>>>>>                Get psContentTypeReceived of hoHttp to sType
24971>>>>>>>>>                Move (SFormat(C_$InvalidContentTypeReceived,sType))  to sError
24972>>>>>>>>>                If (pos("html",Lowercase(sType))) Begin
24974>>>>>>>>>                     Get paDataReceived of hoHttp to sText
24975>>>>>>>>>                     Move (sError + "\n" + sText) to sError
24976>>>>>>>>>                End
24976>>>>>>>>>>
24976>>>>>>>>>            End
24976>>>>>>>>>>
24976>>>>>>>>>            Case (eXmlTransferStatus=wssSoapFault) Begin
24979>>>>>>>>>                Get TransferErrorFaultDescription to sError
24980>>>>>>>>>            End
24980>>>>>>>>>>
24980>>>>>>>>>            Case Else Move C_$ReceivedDataIsBad to sError
24982>>>>>>>>>        Case End
24982>>>>>>>>>        Function_Return sError
24983>>>>>>>>>    End_Function
24984>>>>>>>>>
24984>>>>>>>>>    Procedure LastError
24986>>>>>>>>>        Integer eTransferStatus
24986>>>>>>>>>        String sError
24986>>>>>>>>>        Boolean bSuppressLastError
24986>>>>>>>>>        Get pbSuppressLastError to bSuppressLastError
24987>>>>>>>>>        If not (bSuppressLastError) Begin
24989>>>>>>>>>            Get peTransferStatus to eTransferStatus
24990>>>>>>>>>            If (eTransferStatus<>wssOk) Begin
24992>>>>>>>>>                Get TransferErrorDescription to sError
24993>>>>>>>>>                // we differentiate between a soap-fault and a general error.
24993>>>>>>>>>                Error (If(eTransferStatus=wssSoapFault, DFERR_CLIENT_SOAP_FAULT, DFERR_CLIENT_SOAP_TRANSFER)) sError
24994>>>>>>>>>>
24994>>>>>>>>>            End
24994>>>>>>>>>>
24994>>>>>>>>>        End
24994>>>>>>>>>>
24994>>>>>>>>>    End_Procedure
24995>>>>>>>>>
24995>>>>>>>>>    Procedure OnSoapReceived
24997>>>>>>>>>        Handle hoSoapClientHelper
24997>>>>>>>>>        Get phoSoapClientHelper to hoSoapClientHelper
24998>>>>>>>>>        If hoSoapClientHelper Begin
25000>>>>>>>>>            Send OnSoapReceived of hoSoapClientHelper Self
25001>>>>>>>>>        End
25001>>>>>>>>>>
25001>>>>>>>>>    End_Procedure
25002>>>>>>>>>
25002>>>>>>>>>    // special case when parameter is xsAnyType or xsXmlElement. Only occurs at outer paramter level.
25002>>>>>>>>>    Function ValueTreeXmlParamToXml tSoapParamDef SoapParamDef tValueTreeEx ValueTree Handle hoParam Returns Boolean
25004>>>>>>>>>
25004>>>>>>>>>        Handle hoNode hoDataRoot hoData hoNode1
25004>>>>>>>>>        Boolean bRpc
25004>>>>>>>>>
25004>>>>>>>>>        Move (peSoapStyle(Self)=ssRpc) to bRpc
25005>>>>>>>>>
25005>>>>>>>>>        // if xmlElement simply add the param to an xml document wrapper
25005>>>>>>>>>        Move ValueTree.sValue to hoData // data is pointer to XML Node
25006>>>>>>>>>        // take the xml document we have and add it to the param
25006>>>>>>>>>        Get DocumentElement of hoData to hoDataRoot
25007>>>>>>>>>        If (SoapParamDef.eType=xsAnyType) Begin
25009>>>>>>>>>            // if any, pass as entire param plus wrapper. The wrapper MUST be correct.
25009>>>>>>>>>            Get CloneNode  of hoDataRoot True to hoNode
25010>>>>>>>>>            Get AppendNode of hoParam hoNode to hoNode
25011>>>>>>>>>        End
25011>>>>>>>>>>
25011>>>>>>>>>        Else Begin
25012>>>>>>>>>            Get AddElementNS of hoParam (If(bRpc,"",SoapParamDef.sNamespace)) SoapParamDef.sName '' to hoNode
25013>>>>>>>>>            // if xmlElement, pass the entire document as a child of the wrapper
25013>>>>>>>>>            Get CloneNode of hoDataRoot True to hoNode1
25014>>>>>>>>>            Get AppendNode of hoNode hoNode1 to hoNode1
25015>>>>>>>>>            Send Destroy of hoNode1
25016>>>>>>>>>        End
25016>>>>>>>>>>
25016>>>>>>>>>        Send destroy of hoDataRoot
25017>>>>>>>>>        Send destroy of hoNode
25018>>>>>>>>>        Function_Return True
25019>>>>>>>>>    End_Function
25020>>>>>>>>>
25020>>>>>>>>>    // Value Tree ---> XML
25020>>>>>>>>>    //
25020>>>>>>>>>    // Create XML based on contents of ValueTree data add as child node of passed hoParam
25020>>>>>>>>>    // (this doesn't support SoapEncArray yet
25020>>>>>>>>>    //
25020>>>>>>>>>    Function ValueTreeToXml tSoapParamDef SoapParamDef tValueTreeEx ValueTree Handle hoParam Returns Boolean
25022>>>>>>>>>
25022>>>>>>>>>        Handle   hoNode hoChildNode hoArrayChildNode
25022>>>>>>>>>        Integer  iChildren i iItems j eArrayType iDimensions iChoice
25022>>>>>>>>>        Boolean  bOk bRpc bSimpleContent bChoice
25022>>>>>>>>>        String   sSchemaNSPre sSchemaNSURI sType sDims
25022>>>>>>>>>        Boolean bSkipMinZero
25022>>>>>>>>>        DateTime dtDatetimeValue
25022>>>>>>>>>        tSoapParamDef   ChildSoapParamDef
25022>>>>>>>>>        tSoapParamDef   ChildSoapParamDef
25022>>>>>>>>>        tSoapParamDef[] SoapParamDefs
25022>>>>>>>>>        tSoapParamDef[] SoapParamDefs
25023>>>>>>>>>        tValueTreeEx ChildValueTree ArrayChildValueTree
25023>>>>>>>>>        tValueTreeEx ChildValueTree ArrayChildValueTree
25023>>>>>>>>>        
25023>>>>>>>>>        // AnyType or XmlElement should never be passed as a member, this is a programming error
25023>>>>>>>>>        If (SoapParamDef.eType=xsAnyType or SoapParamDef.eType=xsXmlElement) Begin
25025>>>>>>>>>            Error DFERR_PROGRAM ("Assert: ValueTreeToXml passed xsAnyType or xsXmlElement member for" * SoapParamDef.sName) 
25026>>>>>>>>>>
25026>>>>>>>>>            Function_Return False
25027>>>>>>>>>        End
25027>>>>>>>>>>
25027>>>>>>>>>        
25027>>>>>>>>>        // AnyTypeStr or XmlElementStr are seralized XML strings and can be passed as a member, handle
25027>>>>>>>>>        If (SoapParamDef.eType=xsAnyTypeStr or SoapParamDef.eType=xsXmlElementStr) Begin
25029>>>>>>>>>            Get ValueTreeXmlStrToXml SoapParamDef ValueTree hoParam to bOk
25030>>>>>>>>>            Function_Return bOk
25031>>>>>>>>>        End
25031>>>>>>>>>>
25031>>>>>>>>>        
25031>>>>>>>>>        Move (peSoapStyle(Self)=ssRpc) to bRpc
25032>>>>>>>>>
25032>>>>>>>>>        // case of a regular datatype or a struct/array
25032>>>>>>>>>
25032>>>>>>>>>        // if an attribute, add as a child of the current node. There can be no other children under this
25032>>>>>>>>>        If (SoapParamDef.bAttribute) Begin
25034>>>>>>>>>            // note we always add attributes. There is no way to do this optionally but it should not matter
25034>>>>>>>>>            Send AddAttributeNS of hoParam SoapParamDef.sNamespace SoapParamDef.sName ValueTree.sValue
25035>>>>>>>>>            Function_Return True
25036>>>>>>>>>        End
25036>>>>>>>>>>
25036>>>>>>>>>        
25036>>>>>>>>>        If (SoapParamDef.hoStruct) Begin
25038>>>>>>>>>            Get pbChoice of SoapParamDef.hoStruct to bChoice
25039>>>>>>>>>        End
25039>>>>>>>>>>
25039>>>>>>>>>        
25039>>>>>>>>>        If bChoice Begin
25041>>>>>>>>>            
25041>>>>>>>>>             // if a struct with choice, this is special. The valuetree child structure is the value-1 and the following
25041>>>>>>>>>             // members are choices, which are zero based. So if first value is "2" (third enum), the 2+1 item will be choice.
25041>>>>>>>>>             // Note this must be added to the current xml node and not a level in.
25041>>>>>>>>>             //
25041>>>>>>>>>             // so if simplecontent the value tree will be:
25041>>>>>>>>>             //
25041>>>>>>>>>             // ValueTree[x].Children 
25041>>>>>>>>>             //   ValueTree[0].sValue = Value1
25041>>>>>>>>>             //   ValueTree[1].Children              <--- this is the choice node struct
25041>>>>>>>>>             //        ValueTree[0].sValue = eChoice <---first node is the choice offset.
25041>>>>>>>>>             //        ValueTree[1].sValue = sVal1   <---remaining nodes are the choices
25041>>>>>>>>>             //        ValueTree[2].sValue = sVal2
25041>>>>>>>>>             //   ValueTree[2].sValue = Value3
25041>>>>>>>>>             //
25041>>>>>>>>>             // and xml will be:
25041>>>>>>>>>             //
25041>>>>>>>>>             //    <m:FooEle1>Value1<mFooEle1/>
25041>>>>>>>>>             //    <m:FooEle2>Val1<mFooEle2/> <---stuct becomes choice if eChoice was 0
25041>>>>>>>>>             //    <m:FooEle3>Value3<mFooEle3/>
25041>>>>>>>>>
25041>>>>>>>>>             Get pSoapParamDefs of SoapParamDef.hoStruct to SoapParamDefs // get struct object params
25042>>>>>>>>>             Move (SizeofArray(SoapParamDefs)) to iChildren
25043>>>>>>>>>             If (iChildren) Begin
25045>>>>>>>>>                Move ValueTree.Children[0].sValue to iChoice
25046>>>>>>>>>                // if set to none it means that none of the choices are selected, which may or may not
25046>>>>>>>>>                // be allowed at the server. If not, don't do it.
25046>>>>>>>>>                If (iChoice<>C_ChoiceStructNone) Begin
25048>>>>>>>>>                    Increment iChoice
25049>>>>>>>>>                    If (iChoice>0 and iChoice<iChildren) Begin
25051>>>>>>>>>                        
25051>>>>>>>>>                        Move ValueTree.Children[iChoice] to ChildValueTree
25052>>>>>>>>>                        
25052>>>>>>>>>                        // If an array
25052>>>>>>>>>                        If (SoapParamDefs[iChoice].iMax>1 or SoapParamDefs[iChoice].iMax=C_Unbounded) Begin
25054>>>>>>>>>                            // if an array we go in one more level of the value tree and handle all array items for
25054>>>>>>>>>                            // the one choice child SoapParamDef
25054>>>>>>>>>                            Move (SizeOfArray(ChildValueTree.Children)) to iItems
25055>>>>>>>>>                            For j from 0 to (iItems-1)
25061>>>>>>>>>>
25061>>>>>>>>>                                // if array, the valueTree children are the array values
25061>>>>>>>>>                                Get ValueTreeToXml SoapParamDefs[iChoice] ChildValueTree.Children[j] hoParam to bOk
25062>>>>>>>>>                            Loop
25063>>>>>>>>>>
25063>>>>>>>>>                        End
25063>>>>>>>>>>
25063>>>>>>>>>                        // not an array
25063>>>>>>>>>                        Else Begin
25064>>>>>>>>>                            Get ValueTreeToXml SoapParamDefs[iChoice] ChildValueTree hoParam to bOk
25065>>>>>>>>>                        End
25065>>>>>>>>>>
25065>>>>>>>>>                    End
25065>>>>>>>>>>
25065>>>>>>>>>                    Else Begin
25066>>>>>>>>>                        // this is most likely a programming error
25066>>>>>>>>>                        Error DFERR_PROGRAM ("Invalid value ("+ String(iChoice-1) + ") for choice member in struct for" * SoapParamDef.sName) 
25067>>>>>>>>>>
25067>>>>>>>>>                        Function_Return False
25068>>>>>>>>>                    End
25068>>>>>>>>>>
25068>>>>>>>>>                End
25068>>>>>>>>>>
25068>>>>>>>>>             End
25068>>>>>>>>>>
25068>>>>>>>>>             Function_Return bOk
25069>>>>>>>>>        End
25069>>>>>>>>>>
25069>>>>>>>>>        
25069>>>>>>>>>
25069>>>>>>>>>        If (SoapParamDef.hoStruct=0) Begin
25071>>>>>>>>>            // this is simple data-create an element.
25071>>>>>>>>>            
25071>>>>>>>>>            // if this is date or datetime and the value is null and minOccurs=0 is allowed we will not pass the data as the service
25071>>>>>>>>>            // may not be able to handle a zero datetime value. We can only safely do this with dates and datetimes because a zero date
25071>>>>>>>>>            // is a null value. We can't do this with strings or numbers because a "" or 0, may be Null or may be a real value.
25071>>>>>>>>>            Move False to bSkipMinZero
25072>>>>>>>>>            If (SoapParamDef.iMin=0 and (SoapParamDef.eType=xsDate or SoapParamDef.eType=xsDatetime)) Begin
25074>>>>>>>>>                ConvertFromXML  SoapParamDef.eType ValueTree.sValue to dtDatetimeValue
25075>>>>>>>>>                If (IsNullDateTime(dtDatetimeValue)) Begin
25077>>>>>>>>>                    Move True to bSkipMinZero
25078>>>>>>>>>                End
25078>>>>>>>>>>
25078>>>>>>>>>            End
25078>>>>>>>>>>
25078>>>>>>>>>            
25078>>>>>>>>>            If not bSkipMinZero Begin
25080>>>>>>>>>                Get AddElementNS of hoParam (If(bRpc,"", SoapParamDef.sNamespace)) SoapParamDef.sName '' to hoNode
25081>>>>>>>>>                // simple datatype. Just set the value in the xml node
25081>>>>>>>>>                Set psText of hoNode to ValueTree.sValue
25082>>>>>>>>>            End
25082>>>>>>>>>>
25082>>>>>>>>>            Move True to bOk
25083>>>>>>>>>        End
25083>>>>>>>>>>
25083>>>>>>>>>        Else Begin
25084>>>>>>>>>            
25084>>>>>>>>>            
25084>>>>>>>>>            Get pbSimpleContent of SoapParamDef.hoStruct to bSimpleContent
25085>>>>>>>>>
25085>>>>>>>>>            If bSimpleContent Begin
25087>>>>>>>>>                
25087>>>>>>>>>                 // if a struct with simple content, this is special. The valuetree child structure must be one element value followed by attributes
25087>>>>>>>>>                 // we want the element node added here and all of the remaining children to be attributes of this element
25087>>>>>>>>>                 //
25087>>>>>>>>>                 // so if simplecontent the value tree will be:
25087>>>>>>>>>                 //
25087>>>>>>>>>                 // ValueTree[x].Children 
25087>>>>>>>>>                 //   ValueTree[0].sValue = Value1
25087>>>>>>>>>                 //   ValueTree[1].Children             <--- this is the simplecontent node struct
25087>>>>>>>>>                 //        ValueTree[0].sValue = Value2 <---first node must be element
25087>>>>>>>>>                 //        ValueTree[1].sValue = attr1  <---remaining nodes are attributes
25087>>>>>>>>>                 //        ValueTree[2].sValue = attr2
25087>>>>>>>>>                 //   ValueTree[2].sValue = Value3
25087>>>>>>>>>                 //
25087>>>>>>>>>                 // and xml will be:
25087>>>>>>>>>                 //
25087>>>>>>>>>                 //    <m:FooEle1>Value1<m"FooEle1/>
25087>>>>>>>>>                 //    <m:FooEle2 Fooattr1="attr1" Fooattr2="attr2">Value2<m:FooEle2/> <---stuct becomes element w/ attrs
25087>>>>>>>>>                 //    <m:FooEle3>Value3<m:FooEle3/>
25087>>>>>>>>>                 // Note we will use the SoapParamDef from the parent for the ns and name of the XML element. This first child value
25087>>>>>>>>>                 // found in SoapParamDefs[0] has no real meaning here.
25087>>>>>>>>>
25087>>>>>>>>>                 Get pSoapParamDefs of SoapParamDef.hoStruct to SoapParamDefs // get struct object params
25088>>>>>>>>>                 Move (SizeofArray(SoapParamDefs)) to iChildren
25089>>>>>>>>>                 If (iChildren) Begin
25091>>>>>>>>>                    // we must use the element ns/name from the parent SoapParamDef for the xml tag.
25091>>>>>>>>>                    Get AddElementNS of hoParam (If(bRpc,"", SoapParamDef.sNamespace)) SoapParamDef.sName '' to hoNode
25092>>>>>>>>>                    // set the element text which is the first child
25092>>>>>>>>>                    Set psText of hoNode to ValueTree.Children[0].sValue
25093>>>>>>>>>                    // all remaining children should be attributes
25093>>>>>>>>>                    For i from 1 to (iChildren-1)
25099>>>>>>>>>>
25099>>>>>>>>>                        Move ValueTree.Children[i] to ChildValueTree
25100>>>>>>>>>                        Get ValueTreeToXml SoapParamDefs[i] ChildValueTree hoNode to bOk
25101>>>>>>>>>                    Loop
25102>>>>>>>>>>
25102>>>>>>>>>                 End
25102>>>>>>>>>>
25102>>>>>>>>>                 Else Begin
25103>>>>>>>>>                    // this is actually an invalid defintion and should never happen
25103>>>>>>>>>                    Move False to bOk
25104>>>>>>>>>                 End
25104>>>>>>>>>>
25104>>>>>>>>>            End
25104>>>>>>>>>>
25104>>>>>>>>>            
25104>>>>>>>>>            Else Begin
25105>>>>>>>>>                 // Complex. Either an Array or a Struct
25105>>>>>>>>>                 Get pSoapParamDefs of SoapParamDef.hoStruct to SoapParamDefs // get struct object params
25106>>>>>>>>>                 Get peArrayType    of SoapParamDef.hoStruct to eArrayType
25107>>>>>>>>>                 Move (SizeofArray(SoapParamDefs)) to iChildren
25108>>>>>>>>>                 If (eArrayType=C_atNone and iChildren=0 and SoapParamDef.iMin=0) Begin
25110>>>>>>>>>                     // this is a special case where we do not pass the data at all. If this is a struct with no children, this is one of those
25110>>>>>>>>>                     // strange complexType that have no content. If minOccurs=0, there is no need to pass the parameter at all.
25110>>>>>>>>>                 End
25110>>>>>>>>>>
25110>>>>>>>>>                 Else Begin
25111>>>>>>>>>                     Get AddElementNS of hoParam (If(bRpc,"", SoapParamDef.sNamespace)) SoapParamDef.sName '' to hoNode
25112>>>>>>>>>        
25112>>>>>>>>>        
25112>>>>>>>>>                     // if arrayType is C_atArray or C_atSoapEncArray then we know that we only have a single element and that this
25112>>>>>>>>>                     // describes the array. We also don't want to treat this as a Struct with an array member in the value tree. That would
25112>>>>>>>>>                     // create two levels and we only want one. In addition, soap-enc arrays are special. If multi-dimensional the XML
25112>>>>>>>>>                     // should provide the information needed about the size of dimensions and the dimensional data is all presented flat.
25112>>>>>>>>>                     If (eArrayType=C_atSoapEncArray) Begin
25114>>>>>>>>>                         //to do
25114>>>>>>>>>                     End
25114>>>>>>>>>>
25114>>>>>>>>>        
25114>>>>>>>>>        
25114>>>>>>>>>                     For i from 0 to (iChildren-1)
25120>>>>>>>>>>
25120>>>>>>>>>                        // must always be a 1 to 1 between child param def and value tree
25120>>>>>>>>>                        Move SoapParamDefs[i]      to ChildSoapParamDef
25121>>>>>>>>>        
25121>>>>>>>>>                        // If an array of some sort.
25121>>>>>>>>>                        If (ChildSoapParamDef.iMax>1 or ChildSoapParamDef.iMax=C_Unbounded) Begin
25123>>>>>>>>>                            // if an array we go in one more level of the value tree and handle all array items for
25123>>>>>>>>>                            // the one childSoapParamDef
25123>>>>>>>>>        
25123>>>>>>>>>                            // if non declared array-type, we bump in one more level of the value tree
25123>>>>>>>>>                            If (eArrayType=C_atNone) Begin
25125>>>>>>>>>                                Move ValueTree.Children[i] to ChildValueTree
25126>>>>>>>>>                                Move (SizeOfArray(ChildValueTree.Children)) to iItems
25127>>>>>>>>>                                For j from 0 to (iItems-1)
25133>>>>>>>>>>
25133>>>>>>>>>                                    // if array, the valueTree children are the array values
25133>>>>>>>>>                                    Move ChildValueTree.Children[j] to ArrayChildValueTree
25134>>>>>>>>>                                    Get ValueTreeToXml ChildSoapParamDef ArrayChildValueTree hoNode to bOk
25135>>>>>>>>>                                Loop
25136>>>>>>>>>>
25136>>>>>>>>>                            End
25136>>>>>>>>>>
25136>>>>>>>>>                            // if array-type, the value tree has the children (we've already processed one level in because it has an extra struct)
25136>>>>>>>>>                            Else Begin
25137>>>>>>>>>                                Move (SizeOfArray(ValueTree.Children)) to iItems
25138>>>>>>>>>        
25138>>>>>>>>>                                If (eArrayType=C_atSoapEncArray) Begin
25140>>>>>>>>>                                    Get piDimensions    of SoapParamDef.hoStruct to iDimensions
25141>>>>>>>>>                                    Get psDataType of SoapParamDef.hoStruct to sType
25142>>>>>>>>>        
25142>>>>>>>>>                                    If (ChildSoapParamDef.eType<>xsStruct) Begin
25144>>>>>>>>>                                        Get psSchemaNSPre to sSchemaNSPre
25145>>>>>>>>>                                        Get psSchemaNSUri to sSchemaNSUri
25146>>>>>>>>>                                    End
25146>>>>>>>>>>
25146>>>>>>>>>                                    Else Begin
25147>>>>>>>>>                                        // if a struct, the namespace for the struct is defined in the array struct 
25147>>>>>>>>>                                        // We can't just use psNameSpace because it will be "" if not qualified. With
25147>>>>>>>>>                                        // soap encoded array we must now this to define arrayType. If this package is
25147>>>>>>>>>                                        // used on a web client sub-class defined with a pre 14.0 class generator this will
25147>>>>>>>>>                                        // always be blank (which may be wrong but is no better or no worse that it already was).
25147>>>>>>>>>                                        Get psDataTypeNamespace of SoapParamDef.hoStruct to sSchemaNSURI
25148>>>>>>>>>                                        //Get psNameSpace  of ChildSoapParamDef.hoStruct to sSchemaNSUri // pre 14.0
25148>>>>>>>>>                                        Move "n" to sSchemaNSPre
25149>>>>>>>>>                                    End
25149>>>>>>>>>>
25149>>>>>>>>>                                    Send CreateSoapEncodedArrayAttributes hoNode sType sSchemaNSPre sSchemaNSURI iDimensions iItems
25150>>>>>>>>>                                End
25150>>>>>>>>>>
25150>>>>>>>>>        
25150>>>>>>>>>                                For j from 0 to (iItems-1)
25156>>>>>>>>>>
25156>>>>>>>>>                                    // if array, the valueTree children are the array values
25156>>>>>>>>>                                    Move ValueTree.Children[j] to ArrayChildValueTree
25157>>>>>>>>>                                    Get ValueTreeToXml ChildSoapParamDef ArrayChildValueTree hoNode to bOk
25158>>>>>>>>>                                Loop
25159>>>>>>>>>>
25159>>>>>>>>>                            End
25159>>>>>>>>>>
25159>>>>>>>>>                        End
25159>>>>>>>>>>
25159>>>>>>>>>                        // if a struct, just recurse and handle struct members
25159>>>>>>>>>                        Else Begin
25160>>>>>>>>>                            Move ValueTree.Children[i] to ChildValueTree
25161>>>>>>>>>                            Get ValueTreeToXml ChildSoapParamDef ChildValueTree hoNode to bOk
25162>>>>>>>>>                        End
25162>>>>>>>>>>
25162>>>>>>>>>        
25162>>>>>>>>>                     Loop
25163>>>>>>>>>>
25163>>>>>>>>>                End
25163>>>>>>>>>>
25163>>>>>>>>>            End
25163>>>>>>>>>>
25163>>>>>>>>>        End
25163>>>>>>>>>>
25163>>>>>>>>>        
25163>>>>>>>>>        If hoNode Begin
25165>>>>>>>>>            Send destroy of hoNode
25166>>>>>>>>>         End
25166>>>>>>>>>>
25166>>>>>>>>>         Function_Return bOK
25167>>>>>>>>>    End_Function
25168>>>>>>>>>
25168>>>>>>>>>    Procedure CreateSoapEncodedArrayAttributes Handle hoNode String sType String sSchemaNSPre String sSchemaNSURI Integer iDimensions Integer iItems
25170>>>>>>>>>        String sSoapEncodingNsPre sSoapEncodingNsURI
25170>>>>>>>>>        String sDims sArrayType
25170>>>>>>>>>        Get psSoapEncodingNsUri to sSoapEncodingNsUri
25171>>>>>>>>>        Get psSoapEncodingNsPre to sSoapEncodingNsPre
25172>>>>>>>>>        Move (Repeat("[]",iDimensions-1)+"["+String(iItems)+"]") to sDims
25173>>>>>>>>>        Move (sSchemaNSPre+":"+sType+sDims) to sArrayType
25174>>>>>>>>>        Send AddAttributeNS of hoNode sSoapEncodingNsUri (sSoapEncodingNsPre - ":arrayType") sArrayType
25175>>>>>>>>>        Send AddAttribute of hoNode ("xmlns:"+sSchemaNSPre) sSchemaNSUri
25176>>>>>>>>>    End_Procedure
25177>>>>>>>>>
25177>>>>>>>>>
25177>>>>>>>>>
25177>>>>>>>>>    // look for an id="xxxx" at the body level and return this node.
25177>>>>>>>>>    Function ResolveHRef Handle hoNode String sHRef Returns Handle
25179>>>>>>>>>        Handle hoBody hoId
25179>>>>>>>>>        // we assume that all multi-reference values are stored as direct children of the body section. This is how .net does it.
25179>>>>>>>>>        Get phoReturnBody to hoBody
25180>>>>>>>>>        // strip first characer in sHRef, it is a "#" and it not part of the ID
25180>>>>>>>>>        // Look for any element with an attribute of id="xxx". e.g. *[@id="id-27"] looks for <anyelement id="id-27" ...>
25180>>>>>>>>>        Get FindNode of hoBody ('*[@id = "'+remove(sHRef,1,1)+'"]') to hoId
25181>>>>>>>>>        Function_Return hoId
25182>>>>>>>>>    End_Procedure
25183>>>>>>>>>
25183>>>>>>>>>
25183>>>>>>>>>    // this is an xsAnyType or xsXmlElement. This is only supported at the outer (return level). Create the
25183>>>>>>>>>    // needed XML node and add the value to the valuetee.
25183>>>>>>>>>    Function XMLHandleToValueTree tSoapParamDef SoapParamDef Handle hoNode Returns tValueTreeEx
25185>>>>>>>>>        Handle     hoChildNode hoReturnNode hoReturnObj
25185>>>>>>>>>        tValueTreeEx ValueTree
25185>>>>>>>>>        tValueTreeEx ValueTree
25185>>>>>>>>>        Boolean bRpc
25185>>>>>>>>>        Move (peSoapStyle(Self)=ssRpc) to bRpc
25186>>>>>>>>>
25186>>>>>>>>>        // if any type we use the entire parameter including the wrapper. This is the "give me the whole thing mode"
25186>>>>>>>>>        If (SoapParamDef.eType=xsAnyType) Begin
25188>>>>>>>>>            Get CloneNode of hoNode True to hoReturnNode
25189>>>>>>>>>        End
25189>>>>>>>>>>
25189>>>>>>>>>        Else Begin
25190>>>>>>>>>            // if xmlElement we are saying there is a single xml parameter passed. Remove the wrapper and get the document
25190>>>>>>>>>            Get FirstNonCommentChild hoNode to hoChildNode
25191>>>>>>>>>            Get CloneNode of hoChildNode True to hoReturnNode
25192>>>>>>>>>            Send Destroy of hoChildNode
25193>>>>>>>>>        End
25193>>>>>>>>>>
25193>>>>>>>>>        // we are not handling hrefs here. If there are hrefs the developer will need handle this themselves by looking at the
25193>>>>>>>>>        // entire soap response.
25193>>>>>>>>>
25193>>>>>>>>>        // return desktop XML object
25193>>>>>>>>>        Get Create  of desktop U_cXmlDomDocument to hoReturnObj
25194>>>>>>>>>        Get AppendNode of hoReturnObj hoReturnNode to hoReturnNode
25195>>>>>>>>>        Send destroy of hoReturnNode
25196>>>>>>>>>        Move hoReturnObj to ValueTree.sValue // return ob is an handle to a desktop XML object
25197>>>>>>>>>        Function_Return ValueTree
25198>>>>>>>>>   End_Function
25199>>>>>>>>>
25199>>>>>>>>>
25199>>>>>>>>>
25199>>>>>>>>>    // XML Node to Value Tree
25199>>>>>>>>>    //
25199>>>>>>>>>    // Create XML based on contents of ValueTree data.
25199>>>>>>>>>    // (this doesn't support SoapEncArray yet
25199>>>>>>>>>    //
25199>>>>>>>>>    // iError is passed by reference. If it is non-zero, we must exit
25199>>>>>>>>>    Function XMLToValueTree tSoapParamDef SoapParamDef Handle hoNode Integer ByRef iError Returns tValueTreeEx
25201>>>>>>>>>        Handle     hoChildNode hoDataNode
25201>>>>>>>>>        Integer    iChildren i iItems eArrayType iMatch iType
25201>>>>>>>>>        String     sValue sRef sNil sNs sBaseName sRefToken
25201>>>>>>>>>        Boolean    bNodeIsHRef bRpc bIsAll bSimpleContent bChoice bMatch
25201>>>>>>>>>        tSoapParamDef  ChildSoapParamDef
25201>>>>>>>>>        tSoapParamDef  ChildSoapParamDef
25201>>>>>>>>>        tSoapParamDef[] SoapParamDefs
25201>>>>>>>>>        tSoapParamDef[] SoapParamDefs
25202>>>>>>>>>        tValueTreeEx ValueTree ChildValueTree ArrayChildValueTree EmptyValueTree
25202>>>>>>>>>        tValueTreeEx ValueTree ChildValueTree ArrayChildValueTree EmptyValueTree
25202>>>>>>>>>
25202>>>>>>>>>        Move (peSoapStyle(Self)=ssRpc) to bRpc
25203>>>>>>>>>
25203>>>>>>>>>        // AnyType or XmlElement should never be passed as a member, this is an error
25203>>>>>>>>>        If (SoapParamDef.eType=xsAnyType or SoapParamDef.eType=xsXmlElement) Begin
25205>>>>>>>>>            Move wssInvalidDataForType to iError // programming error. these types should never be in structs
25206>>>>>>>>>            Function_Return ValueTree
25207>>>>>>>>>        End
25207>>>>>>>>>>
25207>>>>>>>>>        
25207>>>>>>>>>        // support for nillable nodes. If we get a xsi:nil="true", assume empty node
25207>>>>>>>>>        If (not(SoapParamDef.bAttribute)) Begin
25209>>>>>>>>>            Get AttributeValueNS of hoNode C_XMLSCHEMAXSIURI "nil" to sNil
25210>>>>>>>>>            If (sNil="true" or sNil="1") Begin
25212>>>>>>>>>               Function_Return ValueTree
25213>>>>>>>>>            End
25213>>>>>>>>>>
25213>>>>>>>>>        End
25213>>>>>>>>>>
25213>>>>>>>>>
25213>>>>>>>>>        // AnyTypeStr or XmlElementStr are seralized XML variant Bstrings and can be passed as a member
25213>>>>>>>>>        If (SoapParamDef.eType=xsAnyTypeStr or SoapParamDef.eType=xsXmlElementStr) Begin
25215>>>>>>>>>            Get XMLVariantBStrToValueTree SoapParamDef hoNode (&iError) to  ValueTree 
25216>>>>>>>>>            Function_Return ValueTree
25217>>>>>>>>>        End
25217>>>>>>>>>>
25217>>>>>>>>>
25217>>>>>>>>>        // if the elemement node is href, we will replace the node with the proper ID node and
25217>>>>>>>>>        // proceed on from that node.
25217>>>>>>>>>        Get psRefToken to sRefToken
25218>>>>>>>>>        Get AttributeValue of hoNode sRefToken to sRef
25219>>>>>>>>>        Move (sRef<>"") to bNodeIsHRef
25220>>>>>>>>>        If bNodeIsHRef Begin
25222>>>>>>>>>            Get ResolveHRef hoNode sRef to hoDataNode
25223>>>>>>>>>            If (hoDataNode=0) Begin
25225>>>>>>>>>                Move wssCouldNotResolveHRef to iError
25226>>>>>>>>>                Function_Return ValueTree // error could not resolve href node
25227>>>>>>>>>            End
25227>>>>>>>>>>
25227>>>>>>>>>        End
25227>>>>>>>>>>
25227>>>>>>>>>        Else Begin
25228>>>>>>>>>            Move hoNode to hoDataNode
25229>>>>>>>>>        End
25229>>>>>>>>>>
25229>>>>>>>>>
25229>>>>>>>>>        // if an attribute, this will be an attribute in the parent xml node. Get the
25229>>>>>>>>>        // value. If not found use the default. Update the value tree
25229>>>>>>>>>        If (SoapParamDef.bAttribute) Begin
25231>>>>>>>>>            // add an attribute
25231>>>>>>>>>            Get AttributeValueNodeNS of hoDataNode SoapParamDef.sNamespace SoapParamDef.sName to hoChildNode
25232>>>>>>>>>            If hoChildNode Begin
25234>>>>>>>>>                Get Value of hoChildNode to sValue
25235>>>>>>>>>                Send Destroy of hoChildNode
25236>>>>>>>>>            End
25236>>>>>>>>>>
25236>>>>>>>>>            Else Begin
25237>>>>>>>>>                // if not found we can just use the default as defined in the schema
25237>>>>>>>>>                Move SoapParamDef.sDefaultAttr to sValue
25238>>>>>>>>>            End
25238>>>>>>>>>>
25238>>>>>>>>>            Move sValue to ValueTree.sValue
25239>>>>>>>>>        End
25239>>>>>>>>>>
25239>>>>>>>>>        Else If (SoapParamDef.hoStruct=0) Begin
25242>>>>>>>>>            // simple datatype. Just set the xml value in the value node
25242>>>>>>>>>            Get psText of hoDataNode to sValue
25243>>>>>>>>>            Move sValue to ValueTree.sValue
25244>>>>>>>>>        End
25244>>>>>>>>>>
25244>>>>>>>>>        Else Begin
25245>>>>>>>>>            
25245>>>>>>>>>            Get pbSimpleContent of SoapParamDef.hoStruct to bSimpleContent
25246>>>>>>>>>            Get pbChoice of SoapParamDef.hoStruct to bChoice
25247>>>>>>>>>            
25247>>>>>>>>>            If bChoice Begin // choice is handled in its own method. This is an error
25249>>>>>>>>>                Error DFERR_PROGRAM "XMLToValueTree called in wrong state (choice)"
25250>>>>>>>>>>
25250>>>>>>>>>                Move wssInvalidDataForType to iError // this is a programming error
25251>>>>>>>>>            End
25251>>>>>>>>>>
25251>>>>>>>>>
25251>>>>>>>>>            Else If bSimpleContent Begin
25254>>>>>>>>>                
25254>>>>>>>>>                // if simpleContent, this is node represents a single element and attributes
25254>>>>>>>>>                // for the element. These all belong in a child node. There will be no children.                
25254>>>>>>>>>                // if a struct with simple content, this is special. The valuetree child structure must be one element value followed by attributes
25254>>>>>>>>>                // we want the element node added here and all of the remaining children to be attributes of this element
25254>>>>>>>>>                //
25254>>>>>>>>>                // so xml is 
25254>>>>>>>>>                //
25254>>>>>>>>>                //    <m:FooEle1>Value1<mFooEle1/>
25254>>>>>>>>>                //    <m:FooEle2 Fooattr1="attr1" Fooattr2="attr2">Value2<mFooEle2/> <---stuct becomes element w/ attrs
25254>>>>>>>>>                //    <m:FooEle3>Value3<mFooEle3/>
25254>>>>>>>>>                //
25254>>>>>>>>>                // the value tree will be:
25254>>>>>>>>>                //
25254>>>>>>>>>                // ValueTree[x].Children 
25254>>>>>>>>>                //   ValueTree[0].sValue = Value1
25254>>>>>>>>>                //   ValueTree[1].Children             <--- this is the simplecontent node struct
25254>>>>>>>>>                //        ValueTree[0].sValue = Value2 <---first node must be element
25254>>>>>>>>>                //        ValueTree[1].sValue = attr1  <---remaining nodes are attributes
25254>>>>>>>>>                //        ValueTree[2].sValue = attr2
25254>>>>>>>>>                //   ValueTree[2].sValue = Value3
25254>>>>>>>>>                //
25254>>>>>>>>>                
25254>>>>>>>>>                Get pSoapParamDefs   of SoapParamDef.hoStruct to SoapParamDefs // get struct object params
25255>>>>>>>>>                Move (SizeofArray(SoapParamDefs)) to iChildren
25256>>>>>>>>>                If iChildren Begin
25258>>>>>>>>>                    
25258>>>>>>>>>                    // the element goes in 0
25258>>>>>>>>>                    Move EmptyValueTree to ChildValueTree
25259>>>>>>>>>                    Get psText of hoDataNode to sValue
25260>>>>>>>>>                    Move sValue to ChildValueTree.sValue
25261>>>>>>>>>                    // update the first value tree child node with the element
25261>>>>>>>>>                    Move ChildValueTree to ValueTree.Children[0]
25262>>>>>>>>>                    
25262>>>>>>>>>                    // update remaining sibling childnodes with attributes
25262>>>>>>>>>                    For i from 1 to (iChildren-1)
25268>>>>>>>>>>
25268>>>>>>>>>                        Move EmptyValueTree to ChildValueTree
25269>>>>>>>>>                        Move SoapParamDefs[i]  to ChildSoapParamDef
25270>>>>>>>>>                        Get XMLToValueTree ChildSoapParamDef hoDataNode (&iError) to ChildValueTree
25271>>>>>>>>>                        Move ChildValueTree to ValueTree.Children[i]
25272>>>>>>>>>                    End
25273>>>>>>>>>>
25273>>>>>>>>>                End
25273>>>>>>>>>>
25273>>>>>>>>>                Else Begin
25274>>>>>>>>>                    // this is actually an invalid defintion and should never happen
25274>>>>>>>>>                    Move wssInvalidDataForType to iError
25275>>>>>>>>>                End
25275>>>>>>>>>>
25275>>>>>>>>>            End
25275>>>>>>>>>>
25275>>>>>>>>>            Else Begin
25276>>>>>>>>>            
25276>>>>>>>>>                // Complex. Either an Array or a Struct
25276>>>>>>>>>    
25276>>>>>>>>>                Get pSoapParamDefs   of SoapParamDef.hoStruct to SoapParamDefs // get struct object params
25277>>>>>>>>>                Get peArrayType      of SoapParamDef.hoStruct to eArrayType
25278>>>>>>>>>                Get pbSchemaAllGroup of SoapParamDef.hoStruct to bIsAll        // true if the schema defines struct elements via <all>
25279>>>>>>>>>    
25279>>>>>>>>>                // if arrayType is C_atArray or C_atSoapEncArray then we know that we only have a single element and that this
25279>>>>>>>>>                // describes the array. We also don't want to treat this as a Struct with an array member in the value tree. That would
25279>>>>>>>>>                // create two levels and we only want one. At the moment both array types can be treated the same. Soap-enc array will get tricky if
25279>>>>>>>>>                // we decide to support multi-dim soap enc ([,]) instead of jagged arrays ([][]) - we don't do that yet.
25279>>>>>>>>>    
25279>>>>>>>>>                Move (SizeofArray(SoapParamDefs)) to iChildren
25280>>>>>>>>>    
25280>>>>>>>>>                If not (bIsAll) Begin
25282>>>>>>>>>                    Get FirstNonCommentChild hoDataNode to hoChildNode
25283>>>>>>>>>                End
25283>>>>>>>>>>
25283>>>>>>>>>    
25283>>>>>>>>>                For i from 0 to (iChildren-1)
25289>>>>>>>>>>
25289>>>>>>>>>                    Move EmptyValueTree to ChildValueTree
25290>>>>>>>>>                    Move SoapParamDefs[i]  to ChildSoapParamDef
25291>>>>>>>>>    
25291>>>>>>>>>                    If (ChildSoapParamDef.iMax>1 or ChildSoapParamDef.iMax=C_Unbounded) Begin
25293>>>>>>>>>    
25293>>>>>>>>>                        // if an array we go in one more level of the value tree and handle all array items for the one childSoapParamDef
25293>>>>>>>>>                        // there are two types of arrays at this point. A struct that is really an array (C_atArray or C_atSoapEncArray) or a struct member
25293>>>>>>>>>                        // that that is an array (because the element is unbounded). If C_atArray/C_atSoapEncArray we don't need the extra valueTree level
25293>>>>>>>>>                        // (because it is already there). We make adjustments here so that the valueTree is the same with all array styles
25293>>>>>>>>>                        Move 0 to iItems
25294>>>>>>>>>                        
25294>>>>>>>>>                        // handling for array of choices.
25294>>>>>>>>>                        If (ChildSoapParamDef.hoStruct and (pbChoice(ChildSoapParamDef.hoStruct) )) Begin
25296>>>>>>>>>                            // we need to keep looking at child nodes to see if they are one of the valid choices. If they are
25296>>>>>>>>>                            // we will add another choice array. 
25296>>>>>>>>>                            Repeat 
25296>>>>>>>>>>
25296>>>>>>>>>                                // Note that this can be called with no childnode at all, which is legal when there is no more struct members.
25296>>>>>>>>>                                // hoChildNode will return pointing to the next non-choice node.
25296>>>>>>>>>                                // bMatch will be True if a choice element was processed. This is how we know when we are done. 
25296>>>>>>>>>                                // Note that an empty array of choices is always allowed.
25296>>>>>>>>>                                Get XMLChoiceToValueTree ChildSoapParamDef (&hoChildNode) (&iError) (&bMatch) to ArrayChildValueTree
25297>>>>>>>>>                                // only add an array choice item if there is an actual match
25297>>>>>>>>>                                If (iError=0 and bMatch) Begin
25299>>>>>>>>>                                    If (eArrayType=C_atNone) Begin
25301>>>>>>>>>                                        // if not defined as an array (but it is) we bump in one more level.
25301>>>>>>>>>                                        Move ArrayChildValueTree to ChildValueTree.Children[iItems]
25302>>>>>>>>>                                    End
25302>>>>>>>>>>
25302>>>>>>>>>                                    Else Begin
25303>>>>>>>>>                                        // if one of the atArray types, update ValueTree directly (the bump in level has already happened)
25303>>>>>>>>>                                        // I don't think this is possible
25303>>>>>>>>>                                        Move ArrayChildValueTree to ValueTree.Children[iItems]
25304>>>>>>>>>                                    End
25304>>>>>>>>>>
25304>>>>>>>>>        
25304>>>>>>>>>                                    Increment iItems
25305>>>>>>>>>                                    
25305>>>>>>>>>                                    // Note: hoChildNode will end up pointing the next node to be processed. No need for NextNonCommentNode
25305>>>>>>>>>                                        
25305>>>>>>>>>                                End
25305>>>>>>>>>>
25305>>>>>>>>>                            Until (iError or hoChildNode=0 or not(bMatch))
25307>>>>>>>>>                        End
25307>>>>>>>>>>
25307>>>>>>>>>                        // a non-choice array
25307>>>>>>>>>                        Else Begin
25308>>>>>>>>>    
25308>>>>>>>>>                            // if Rpc it's a soap enc array -  we allow anything through (and we will assume the node is an element).
25308>>>>>>>>>                            While (iError=0 and hoChildNode and (bRpc or IsElementNS(hoChildNode, ChildSoapParamDef.sNamespace, ChildSoapParamDef.sName)))
25312>>>>>>>>>                                Get XMLToValueTree ChildSoapParamDef hoChildNode (&iError) to ArrayChildValueTree
25313>>>>>>>>>                                If (iError=0) Begin
25315>>>>>>>>>                                    If (eArrayType=C_atNone) Begin
25317>>>>>>>>>                                        // if not defined as an array (but it is) we bump in one more level.
25317>>>>>>>>>                                        Move ArrayChildValueTree to ChildValueTree.Children[iItems]
25318>>>>>>>>>                                    End
25318>>>>>>>>>>
25318>>>>>>>>>                                    Else Begin
25319>>>>>>>>>                                        // if one of the atArray types, update ValueTree directly (the bump in level has already happened)
25319>>>>>>>>>                                        Move ArrayChildValueTree to ValueTree.Children[iItems]
25320>>>>>>>>>                                    End
25320>>>>>>>>>>
25320>>>>>>>>>        
25320>>>>>>>>>                                    Increment iItems
25321>>>>>>>>>                                    Get NextNonCommentNode hoChildNode to hoChildNode
25322>>>>>>>>>                                End
25322>>>>>>>>>>
25322>>>>>>>>>                            End
25323>>>>>>>>>>
25323>>>>>>>>>                        End
25323>>>>>>>>>>
25323>>>>>>>>>                    End
25323>>>>>>>>>>
25323>>>>>>>>>                    
25323>>>>>>>>>                    // a struct - either all or sequence
25323>>>>>>>>>                    
25323>>>>>>>>>                    Else Begin
25324>>>>>>>>>    
25324>>>>>>>>>                        // If a struct with <all> schema. We must search for nodes in any order.
25324>>>>>>>>>                        If (bIsAll) Begin
25326>>>>>>>>>                            Get ChildElementNS of hoDataNode (If(bRpc,"", ChildSoapParamDef.sNamespace)) (ChildSoapParamDef.sName) to hoChildNode
25327>>>>>>>>>                            If hoChildNode Begin
25329>>>>>>>>>                                Get XMLToValueTree ChildSoapParamDef hoChildNode (&iError) to ChildValueTree
25330>>>>>>>>>                                Send Destroy of hoChildNode
25331>>>>>>>>>                                Move 0 to hoChildNode
25332>>>>>>>>>                            End
25332>>>>>>>>>>
25332>>>>>>>>>                            Else If (ChildSoapParamDef.iMin=0) Begin
25335>>>>>>>>>                                // if not match and min is 0, assume this is a min zero case and create empty value
25335>>>>>>>>>                            End
25335>>>>>>>>>>
25335>>>>>>>>>                            Else Begin
25336>>>>>>>>>                                // data does not match what we are expecting
25336>>>>>>>>>                                Move wssInvalidDataForType to iError
25337>>>>>>>>>                            End
25337>>>>>>>>>>
25337>>>>>>>>>                        End
25337>>>>>>>>>>
25337>>>>>>>>>                        // If a <sequence> struct see if it matches what we are expecting in the order we are exepcting.
25337>>>>>>>>>                        // If not, and it's either a min 0 or an error
25337>>>>>>>>>                        Else Begin
25338>>>>>>>>>                            If (ChildSoapParamDef.bAttribute) Begin
25340>>>>>>>>>                                Get XMLToValueTree ChildSoapParamDef hoDataNode (&iError) to ChildValueTree
25341>>>>>>>>>                            End
25341>>>>>>>>>>
25341>>>>>>>>>                            Else If (ChildSoapParamDef.hoStruct and (pbChoice(ChildSoapParamDef.hoStruct) )) Begin
25344>>>>>>>>>                                // Note that this can be called with no childnode at all, which is legal when there is no choice and it is at the end.
25344>>>>>>>>>                                // hoChildNode will end up pointing the next node to be processed. No need for NextNonCommentNode
25344>>>>>>>>>                                // We don't do anything with bMatch, which is needed for array of choices which is handled above
25344>>>>>>>>>                                Get XMLChoiceToValueTree ChildSoapParamDef (&hoChildNode) (&iError)  (&bMatch) to ChildValueTree
25345>>>>>>>>>                            End
25345>>>>>>>>>>
25345>>>>>>>>>                            Else If (hoChildNode and ;                                     (IsElementNS(hoChildNode, If(bRpc,"", ChildSoapParamDef.sNamespace), ChildSoapParamDef.sName)) or ;                                     (ChildSoapParamDef.hoStruct and pbSimpleContent(ChildSoapParamDef.hoStruct)) ) Begin
25348>>>>>>>>>                                Get XMLToValueTree ChildSoapParamDef hoChildNode (&iError) to ChildValueTree
25349>>>>>>>>>                                If (iError=0) Begin
25351>>>>>>>>>                                    Get NextNonCommentNode hoChildNode to hoChildNode
25352>>>>>>>>>                                End
25352>>>>>>>>>>
25352>>>>>>>>>                            End
25352>>>>>>>>>>
25352>>>>>>>>>                            Else Begin
25353>>>>>>>>>                                If (ChildSoapParamDef.iMin=0) Begin
25355>>>>>>>>>                                    // if not match and min is 0, assume this is a min zero case and create empty value
25355>>>>>>>>>                                End
25355>>>>>>>>>>
25355>>>>>>>>>                                Else Begin
25356>>>>>>>>>                                    // data does not match what we are expecting
25356>>>>>>>>>                                    Move wssInvalidDataForType to iError
25357>>>>>>>>>                                End
25357>>>>>>>>>>
25357>>>>>>>>>                            End
25357>>>>>>>>>>
25357>>>>>>>>>                        End
25357>>>>>>>>>>
25357>>>>>>>>>                    End
25357>>>>>>>>>>
25357>>>>>>>>>    
25357>>>>>>>>>                    // if an array type, valueTree.Children is already updated
25357>>>>>>>>>                    If (iError=0 and eArrayType=C_atNone) Begin
25359>>>>>>>>>                        Move ChildValueTree to ValueTree.Children[i]
25360>>>>>>>>>                    End
25360>>>>>>>>>>
25360>>>>>>>>>    
25360>>>>>>>>>                    If (iError<>0) Move iChildren to i // if an error drop out of for loop
25363>>>>>>>>>                Loop
25364>>>>>>>>>>
25364>>>>>>>>>    
25364>>>>>>>>>                If hoChildNode Begin
25366>>>>>>>>>                    Send Destroy of hoChildNode
25367>>>>>>>>>                End
25367>>>>>>>>>>
25367>>>>>>>>>            End
25367>>>>>>>>>>
25367>>>>>>>>>        End
25367>>>>>>>>>>
25367>>>>>>>>>        // if href node, we've created an additional node which must be removed
25367>>>>>>>>>        If bNodeIsHRef Begin
25369>>>>>>>>>            Send Destroy of hoDataNode
25370>>>>>>>>>        End
25370>>>>>>>>>>
25370>>>>>>>>>
25370>>>>>>>>>        Function_Return ValueTree
25371>>>>>>>>>    End_Function
25372>>>>>>>>>    
25372>>>>>>>>>    // this is called to handle a <choice> xml value to the value tree. Passing an empty Node is allowed as this might be a minOccurs choice.
25372>>>>>>>>>    // This will change hoNode to point to the next node to be used for processing. This is needed because we may process multiple nodes here (arrays).
25372>>>>>>>>>    // The bMatch parameter indicates if a one or more matches was found (multiple possible with arrays).
25372>>>>>>>>>    Function XMLChoiceToValueTree tSoapParamDef SoapParamDef Handle ByRef hoNode Integer ByRef iError Boolean ByRef bMatch Returns tValueTreeEx
25374>>>>>>>>>        Handle     hoChildNode hoDataNode
25374>>>>>>>>>        Integer    iChildren iChoiceIndex iMatch iType iArrayItems
25374>>>>>>>>>        String     sValue sNs sBaseName
25374>>>>>>>>>        Boolean    bRpc bChoice 
25374>>>>>>>>>        tSoapParamDef  ChildSoapParamDef
25374>>>>>>>>>        tSoapParamDef  ChildSoapParamDef
25374>>>>>>>>>        tSoapParamDef[] SoapParamDefs
25374>>>>>>>>>        tSoapParamDef[] SoapParamDefs
25375>>>>>>>>>        tValueTreeEx ValueTree ChildValueTree EmptyValueTree ArrayChildValueTree 
25375>>>>>>>>>        tValueTreeEx ValueTree ChildValueTree EmptyValueTree ArrayChildValueTree 
25375>>>>>>>>>        
25375>>>>>>>>>        Move False to bMatch // this will be set true if we find a choice match
25376>>>>>>>>>
25376>>>>>>>>>        Move (peSoapStyle(Self)=ssRpc) to bRpc
25377>>>>>>>>>
25377>>>>>>>>>        // test this is called properly 
25377>>>>>>>>>        
25377>>>>>>>>>        Get pbChoice of SoapParamDef.hoStruct to bChoice
25378>>>>>>>>>        Get pSoapParamDefs  of SoapParamDef.hoStruct to SoapParamDefs // get struct object params
25379>>>>>>>>>        Move (SizeofArray(SoapParamDefs)) to iChildren
25380>>>>>>>>>        If (not(bChoice) or (iChildren=0)) Begin
25382>>>>>>>>>            Error DFERR_PROGRAM "XMLChoiceToValueTree called in wrong state"
25383>>>>>>>>>>
25383>>>>>>>>>            Move wssInvalidDataForType to iError
25384>>>>>>>>>            Function_Return ValueTree
25385>>>>>>>>>        End
25385>>>>>>>>>>
25385>>>>>>>>>        If hoNode Begin
25387>>>>>>>>>            Get piNodeType of hoNode to iType
25388>>>>>>>>>            If (iType<>NODE_ELEMENT) Begin
25390>>>>>>>>>                Error DFERR_PROGRAM "XMLChoiceToValueTree called in wrong state"
25391>>>>>>>>>>
25391>>>>>>>>>                Move wssInvalidDataForType to iError
25392>>>>>>>>>                Function_Return ValueTree
25393>>>>>>>>>            End
25393>>>>>>>>>>
25393>>>>>>>>>        End
25393>>>>>>>>>>
25393>>>>>>>>>        
25393>>>>>>>>>        // if choice, this is node represents a choice constant member followed by a member for each choice
25393>>>>>>>>>        //
25393>>>>>>>>>        // so xml is 
25393>>>>>>>>>        //
25393>>>>>>>>>        //    <m:FooEle1>Value1<mFooEle1/>
25393>>>>>>>>>        //    <m:FooEle2Choice2>Value2<m:FooEle2Choice2/>
25393>>>>>>>>>        //    <m:FooEle3>Value3<mFooEle3/>
25393>>>>>>>>>        //
25393>>>>>>>>>        // the value tree will be:
25393>>>>>>>>>        //
25393>>>>>>>>>        // ValueTree[x].Children 
25393>>>>>>>>>        //   ValueTree[0].sValue = Value1
25393>>>>>>>>>        //   ValueTree[1].Children       
25393>>>>>>>>>        //        ValueTree[0].eChoice = 1 <---- indicates the second choice
25393>>>>>>>>>        //        ValueTree[1]             <-- empty
25393>>>>>>>>>        //        ValueTree[2].sValue = Value2
25393>>>>>>>>>        //   ValueTree[2].sValue = Value3
25393>>>>>>>>>        //
25393>>>>>>>>>        // Even if there is no choice (minOccurs=0) we must full the valuetree with empty values. In that case eChoice will be -1
25393>>>>>>>>>        //
25393>>>>>>>>>        // If the choice elemnt is an array, you might have something like this:
25393>>>>>>>>>        //
25393>>>>>>>>>        //    <m:FooEle1>Value1<mFooEle1/>
25393>>>>>>>>>        //    <m:FooEle2Choice2>Value2.0<m:FooEle2Choice2/>
25393>>>>>>>>>        //    <m:FooEle2Choice2>Value2.1<m:FooEle2Choice2/>
25393>>>>>>>>>        //    <m:FooEle2Choice2>Value2.2<m:FooEle2Choice2/>
25393>>>>>>>>>        //    <m:FooEle3>Value3<mFooEle3/>
25393>>>>>>>>>        //
25393>>>>>>>>>        // the value tree will be:
25393>>>>>>>>>        //
25393>>>>>>>>>        // ValueTree[x].Children 
25393>>>>>>>>>        //   ValueTree[0].sValue = Value1
25393>>>>>>>>>        //   ValueTree[1].Children       
25393>>>>>>>>>        //        ValueTree[0].eChoice = 1 <---- indicates the second choice
25393>>>>>>>>>        //        ValueTree[1]             <-- empty
25393>>>>>>>>>        //        ValueTree[2].Children
25393>>>>>>>>>        //            ValueTree[0].sValue = Value2.0
25393>>>>>>>>>        //            ValueTree[1].sValue = Value2.1
25393>>>>>>>>>        //            ValueTree[2].sValue = Value2.2
25393>>>>>>>>>        //   ValueTree[2].sValue = Value3
25393>>>>>>>>>        //
25393>>>>>>>>>        // when this function is called, hoNode will point to the first choice e.g., <m:FooEle2Choice2>Value2<m:FooEle2Choice2/>
25393>>>>>>>>>        // when done it will point to the next element following the choice e.g.,    <m:FooEle3>Value3<mFooEle3/>  
25393>>>>>>>>>
25393>>>>>>>>>        If hoNode Begin
25395>>>>>>>>>            // if we have a node, see if this node matches any of the choices
25395>>>>>>>>>            Get psNamespaceURI of hoNode to sNs
25396>>>>>>>>>            If bRpc Begin
25398>>>>>>>>>                Move '' to sNs
25399>>>>>>>>>            End
25399>>>>>>>>>>
25399>>>>>>>>>            Get psBaseName of hoNode to sBaseName
25400>>>>>>>>>            Move 0 to iChoiceIndex
25401>>>>>>>>>            While (not(bMatch) and (iChoiceIndex < iChildren-1) )
25405>>>>>>>>>                Increment iChoiceIndex // test from 1 (skipping the first paramdef which is eChoice)
25406>>>>>>>>>                Move (sNs=SoapParamDefs[iChoiceIndex].sNamespace and sBaseName=SoapParamDefs[iChoiceIndex].sName) to bMatch
25407>>>>>>>>>            Loop
25408>>>>>>>>>>
25408>>>>>>>>>            Move (If(bMatch,iChoiceIndex-1,C_ChoiceStructNone)) to iMatch // no match is possible. Nothing was passed
25409>>>>>>>>>        End 
25409>>>>>>>>>>
25409>>>>>>>>>        Else Begin
25410>>>>>>>>>            // if no node, no match. Although the schema may not allow this, we will allow it as we can handle it.
25410>>>>>>>>>            Move False to bMatch
25411>>>>>>>>>            Move C_ChoiceStructNone to iMatch
25412>>>>>>>>>        End
25412>>>>>>>>>>
25412>>>>>>>>>            
25412>>>>>>>>>        
25412>>>>>>>>>        // update all value tree child values
25412>>>>>>>>>
25412>>>>>>>>>        // the choice goes in 0, if no match it is -1
25412>>>>>>>>>        Move EmptyValueTree to ChildValueTree
25413>>>>>>>>>        Move iMatch to ChildValueTree.sValue
25414>>>>>>>>>        // update the first value tree child node with the element
25414>>>>>>>>>        Move ChildValueTree to ValueTree.Children[0]
25415>>>>>>>>>        
25415>>>>>>>>>        For iChoiceIndex from 1 to (iChildren-1)
25421>>>>>>>>>>
25421>>>>>>>>>            Move EmptyValueTree to ChildValueTree
25422>>>>>>>>>            
25422>>>>>>>>>            If ((iMatch+1=iChoiceIndex) and hoNode) Begin
25424>>>>>>>>>                Move SoapParamDefs[iChoiceIndex]  to ChildSoapParamDef
25425>>>>>>>>>                
25425>>>>>>>>>                // if this choice is an array, process this node and all succeeding nodes that are of the same
25425>>>>>>>>>                // element as an array. ChildValueTree will be an array node
25425>>>>>>>>>                If (ChildSoapParamDef.iMax>1 or ChildSoapParamDef.iMax=C_Unbounded) Begin
25427>>>>>>>>>                    Move 0 to iArrayItems
25428>>>>>>>>>                    While (iError=0 and hoNode and (IsElementNS(hoNode, ChildSoapParamDef.sNamespace, ChildSoapParamDef.sName)))
25432>>>>>>>>>                        Get XMLToValueTree ChildSoapParamDef hoNode (&iError) to ArrayChildValueTree
25433>>>>>>>>>                        If (iError=0) Begin
25435>>>>>>>>>                            Move ArrayChildValueTree to ChildValueTree.Children[iArrayItems]
25436>>>>>>>>>                            Increment iArrayItems
25437>>>>>>>>>                            Get NextNonCommentNode hoNode to hoNode
25438>>>>>>>>>                        End
25438>>>>>>>>>>
25438>>>>>>>>>                    End
25439>>>>>>>>>>
25439>>>>>>>>>                End
25439>>>>>>>>>>
25439>>>>>>>>>                // choice is a non-array. process the one item
25439>>>>>>>>>                Else Begin
25440>>>>>>>>>                    Get XMLToValueTree ChildSoapParamDef hoNode (&iError) to ChildValueTree
25441>>>>>>>>>                    Get NextNonCommentNode hoNode to hoNode // we must leave this with the next node! 
25442>>>>>>>>>                End
25442>>>>>>>>>>
25442>>>>>>>>>            End
25442>>>>>>>>>>
25442>>>>>>>>>            
25442>>>>>>>>>            Move ChildValueTree to ValueTree.Children[iChoiceIndex]
25443>>>>>>>>>        Loop
25444>>>>>>>>>>
25444>>>>>>>>>        // at this point:
25444>>>>>>>>>        //    hoNode (which is returned ByRef) points to the node following the last processed choice
25444>>>>>>>>>        //    iError may contain an error code
25444>>>>>>>>>        //    bMatch is true if a valid choice was found and processed
25444>>>>>>>>>        Function_Return ValueTree // and ValueTree contains the complete data from this one choice
25445>>>>>>>>>    End_Function
25446>>>>>>>>>    
25446>>>>>>>>>
25446>>>>>>>>>
25446>>>>>>>>>    // These obsolete messages are the messages used by the vdf10 class to handle defining parameters and setting values. These are no
25446>>>>>>>>>    // longer used in VDF11 and when a class is generated (or regenerated) they will go away. These interfaces are provided here to allow
25446>>>>>>>>>    // old VDF10 clients to work with this class. They only work with vdf10 style simple data (no structs/arrays). These messages simply
25446>>>>>>>>>    // redirect to the newer interface. Note that you can not mix old and new interfaces within a single class.
25446>>>>>>>>>    Procedure DefineParameter Integer iParameterNumber Integer eType String sName String sSchemaType
25448>>>>>>>>>        tSoapParameter[] spParameters
25448>>>>>>>>>        tSoapParameter[] spParameters
25449>>>>>>>>>        Get pspParameters to spParameters
25450>>>>>>>>>        Get DefineParameter eType 1 1 sName (psRequestNSURI(Self)) to spParameters[iParameterNumber].SoapParamDef
25451>>>>>>>>>        Set pspParameters to spParameters
25452>>>>>>>>>    End_Procedure
25453>>>>>>>>>
25453>>>>>>>>>    Procedure DefineReturn Integer eType String sname String sSchemaType
25455>>>>>>>>>        tSoapParameter[]   spReturnParameters
25455>>>>>>>>>        tSoapParameter[]   spReturnParameters
25456>>>>>>>>>        Get pspReturnParameters to spReturnParameters
25457>>>>>>>>>        Get DefineParameter eType 1 1 sName (psRequestNSURI(Self)) to spReturnParameters[0].SoapParamDef
25458>>>>>>>>>        Set pspReturnParameters to spReturnParameters
25459>>>>>>>>>    End_Procedure
25460>>>>>>>>>
25460>>>>>>>>>    Procedure AddParameter Integer iParameterNumber String sValue // sValue can by any type
25462>>>>>>>>>        tSoapParameter[] spParameters
25462>>>>>>>>>        tSoapParameter[] spParameters
25463>>>>>>>>>        Integer eType
25463>>>>>>>>>        Get pspParameters to spParameters
25464>>>>>>>>>        Move spParameters[iParameterNumber].SoapParamDef.eType to eType
25465>>>>>>>>>        If (eType<>xsAnyType and eType<>xsXmlElement) Begin
25467>>>>>>>>>            ConvertToXml eType sValue to sValue
25468>>>>>>>>>        End
25468>>>>>>>>>>
25468>>>>>>>>>        Move sValue to spParameters[iParameterNumber].ValueTree.sValue
25469>>>>>>>>>        Set pspParameters to spParameters
25470>>>>>>>>>    End_Procedure
25471>>>>>>>>>
25471>>>>>>>>>    Function ReturnValue Returns String // return can be any value based on type
25473>>>>>>>>>         tSoapParameter[]   spReturnParameters
25473>>>>>>>>>         tSoapParameter[]   spReturnParameters
25474>>>>>>>>>         String sValue
25474>>>>>>>>>         Integer eType iSize
25474>>>>>>>>>         Get pspReturnParameters   to spReturnParameters
25475>>>>>>>>>         If (SizeOfArray(spReturnParameters)>0) Begin
25477>>>>>>>>>             Move spReturnParameters[0].SoapParamDef.eType to eType
25478>>>>>>>>>             Move spReturnParameters[0].ValueTree.sValue to sValue
25479>>>>>>>>>             If (eType<>xsAnyType and eType<>xsXmlElement) Begin
25481>>>>>>>>>                 ConvertFromXml eType sValue to sValue
25482>>>>>>>>>             End
25482>>>>>>>>>>
25482>>>>>>>>>         End
25482>>>>>>>>>>
25482>>>>>>>>>         Function_Return sValue
25483>>>>>>>>>    End_Function
25484>>>>>>>>>
25484>>>>>>>>>    // useful in testing
25484>>>>>>>>>    Procedure ShowValueTree tValueTreeEx V Integer iLevel
25486>>>>>>>>>        Integer iLev i iC
25486>>>>>>>>>        If (num_arguments<=1) Move 0 to iLev
25489>>>>>>>>>        Else Move iLevel to iLev
25491>>>>>>>>>        Showln (String(iLev) + ":" +  Repeat(" ",iLev*2)+"["+V.sValue+"]")
25493>>>>>>>>>        //writeln (string(iLev) + ":" +  repeat(" ",iLev*2)+V.sValue)
25493>>>>>>>>>        Move (SizeOfArray(V.Children)) to iC
25494>>>>>>>>>        Increment iLev
25495>>>>>>>>>        For i from 0 to (iC-1)
25501>>>>>>>>>>
25501>>>>>>>>>            Send ShowValueTree v.children[i] iLev
25502>>>>>>>>>        Loop
25503>>>>>>>>>>
25503>>>>>>>>>    End_Procedure
25504>>>>>>>>>    
25504>>>>>>>>>  
25504>>>>>>>>>    // do a XML node to variant string conversion. Note this returns a Unicode string
25504>>>>>>>>>    Function XMLNodetoXmlVariantBStr Handle hoNode Integer ByRef iError Returns Variant
25506>>>>>>>>>        Variant vXML
25506>>>>>>>>>        Get pvXML of hoNode to vXML
25507>>>>>>>>>        Function_Return vXML
25508>>>>>>>>>    End_Function
25509>>>>>>>>>
25509>>>>>>>>>    // this adds an xsAnyTypeStr or xsXmlElementStr, which is an XML node serialized as a variant BString, to the valuetree.
25509>>>>>>>>>    // If xsAnyTypeStr, the value should be the entire serialized XML node (wrapper and data) and it is up to the developer to get this right.
25509>>>>>>>>>    // If xsXmlElementStr, we will provide the wrapper and the data can be a single XML element or an array of XML elements.
25509>>>>>>>>>
25509>>>>>>>>>    Function XMLVariantBStrToValueTree tSoapParamDef SoapParamDef Handle hoNode Integer ByRef iError Returns tValueTreeEx
25511>>>>>>>>>        Handle hoChildNode
25511>>>>>>>>>        tValueTreeEx ValueTree
25511>>>>>>>>>        tValueTreeEx ValueTree
25511>>>>>>>>>        String sXML
25511>>>>>>>>>        Variant vXML
25511>>>>>>>>>        Integer iCount
25511>>>>>>>>>
25511>>>>>>>>>        // if any-type we use the entire parameter including the wrapper. This is the "give me the whole thing mode"
25511>>>>>>>>>        If (SoapParamDef.eType=xsAnyTypeStr) Begin
25513>>>>>>>>>            Get XMLNodetoXmlVariantBStr hoNode (&iError) to  vXML
25514>>>>>>>>>            Move vXML to ValueTree.sValue // return ob is an handle to a desktop XML object
25515>>>>>>>>>        End
25515>>>>>>>>>>
25515>>>>>>>>>        Else Begin // if xsXmlElementStr
25516>>>>>>>>>            Get FirstNonCommentChild hoNode to hoChildNode
25517>>>>>>>>>            If hoChildNode Begin
25519>>>>>>>>>                // can be a single node or an array of nodes
25519>>>>>>>>>                If (SoapParamDef.iMax=1) Begin
25521>>>>>>>>>                    // return as a single element
25521>>>>>>>>>                    Get XMLNodetoXmlVariantBStr hoChildNode (&iError) to  sXML
25522>>>>>>>>>                    Move sXML to ValueTree.sValue // return ob is an handle to a desktop XML object
25523>>>>>>>>>                    Send Destroy of hoChildNode
25524>>>>>>>>>                End
25524>>>>>>>>>>
25524>>>>>>>>>                Else Begin
25525>>>>>>>>>                    // return as an array of elements
25525>>>>>>>>>                    While hoChildNode
25529>>>>>>>>>                        Get XMLNodetoXmlVariantBStr hoChildNode (&iError) to  sXML
25530>>>>>>>>>                        Move sXML to ValueTree.children[iCount].sValue
25531>>>>>>>>>                        If (iError=0) Begin
25533>>>>>>>>>                            Increment iCount
25534>>>>>>>>>                            Get NextNonCommentNode hoChildNode to hoChildNode
25535>>>>>>>>>                        End
25535>>>>>>>>>>
25535>>>>>>>>>                        Else Begin
25536>>>>>>>>>                            Send Destroy of hoChildNode
25537>>>>>>>>>                            Move 0 to hoChildNode                           
25538>>>>>>>>>                        End
25538>>>>>>>>>>
25538>>>>>>>>>                    Loop
25539>>>>>>>>>>
25539>>>>>>>>>                End
25539>>>>>>>>>>
25539>>>>>>>>>            End
25539>>>>>>>>>>
25539>>>>>>>>>        End
25539>>>>>>>>>>
25539>>>>>>>>>        Function_Return ValueTree
25540>>>>>>>>>    End_Function
25541>>>>>>>>>
25541>>>>>>>>>    // Adds a serialized XML string from teh value tree to the XML param node. This should only be called with the 
25541>>>>>>>>>    // datatype is xsAnyTypeStr or xsXmlElementStr. Mostly xsAnyTypeStr is passed which means that the entire parameter -
25541>>>>>>>>>    // element definition (i.e., wrapper) and data, is passed. This passed xsAnyType parameter must be a single XML mode.
25541>>>>>>>>>    // If xsXmlElementStr is passed then the XML data is added to a wrapper which is created here. The xsXmlElementStr can be a single
25541>>>>>>>>>    // node (maxOccurs=1) or an array of elements (maxOccurs>1).
25541>>>>>>>>>     
25541>>>>>>>>>    Function ValueTreeXmlStrToXml tSoapParamDef SoapParamDef tValueTreeEx ValueTree Handle hoParam Returns Boolean
25543>>>>>>>>>
25543>>>>>>>>>        Handle hoParamChildNode hoDataRoot hoData hoNode
25543>>>>>>>>>        Boolean bRpc bOk
25543>>>>>>>>>        Integer i
25543>>>>>>>>>        
25543>>>>>>>>>
25543>>>>>>>>>        Move (peSoapStyle(Self)=ssRpc) to bRpc
25544>>>>>>>>>
25544>>>>>>>>>        // if anyType, there should be a single node which we add, as is, to the document. With AnyType it doesn't
25544>>>>>>>>>        // matter what the SoapParamDef name and namespace are as they are not used.
25544>>>>>>>>>        // take the xml document we have and add it to the param
25544>>>>>>>>>        
25544>>>>>>>>>        If (SoapParamDef.eType=xsAnyTypeStr) Begin
25546>>>>>>>>>            
25546>>>>>>>>>            If (SizeOfArray(ValueTree.children)<>0) Begin
25548>>>>>>>>>                Error DFERR_PROGRAM ("Could not convert multi element xsAnyTypeStr ValueTree data to maxOccurs=1 XML node")
25549>>>>>>>>>>
25549>>>>>>>>>                Function_Return False
25550>>>>>>>>>            End
25550>>>>>>>>>>
25550>>>>>>>>>            
25550>>>>>>>>>            If (ValueTree.sValue="") Begin
25552>>>>>>>>>                Function_Return True    
25553>>>>>>>>>            End
25553>>>>>>>>>>
25553>>>>>>>>>            
25553>>>>>>>>>            Get Create (RefClass(cXMLDOMDocument)) to hoData
25554>>>>>>>>>            Get LoadXMLFromVariant of hoData ValueTree.sValue to bOk
25555>>>>>>>>>            If Not bOk Begin
25557>>>>>>>>>                Error DFERR_PROGRAM ("Could not convert string to XML node (" - Left(ValueTree.sValue,1000) - ")")
25558>>>>>>>>>>
25558>>>>>>>>>                Send Destroy of hoData
25559>>>>>>>>>                Function_Return False
25560>>>>>>>>>            End
25560>>>>>>>>>>
25560>>>>>>>>>            
25560>>>>>>>>>            Get DocumentElement of hoData to hoDataRoot
25561>>>>>>>>>            // if any, pass as entire param plus wrapper. The wrapper MUST be correct.
25561>>>>>>>>>            Get CloneNode  of hoDataRoot True to hoParamChildNode
25562>>>>>>>>>            Get AppendNode of hoParam hoParamChildNode to hoParamChildNode
25563>>>>>>>>>            Send destroy of hoParamChildNode
25564>>>>>>>>>            Send destroy of hoDataRoot
25565>>>>>>>>>            Send Destroy of hoData
25566>>>>>>>>>        End
25566>>>>>>>>>>
25566>>>>>>>>>        
25566>>>>>>>>>        // if xmlElement, pass the entire document and we add the wrapper as defined in SoapParaDef
25566>>>>>>>>>        
25566>>>>>>>>>        Else Begin
25567>>>>>>>>>            
25567>>>>>>>>>            
25567>>>>>>>>>            // if a single element
25567>>>>>>>>>            If (SoapParamDef.iMax=1) Begin        
25569>>>>>>>>>                // test that it is a single node 
25569>>>>>>>>>                If (SizeOfArray(ValueTree.children)<>0) Begin
25571>>>>>>>>>                    Error DFERR_PROGRAM ("Could not convert multi element xsXmlElement ValueTree data to maxOccurs=1 XML node")
25572>>>>>>>>>>
25572>>>>>>>>>                    Function_Return False
25573>>>>>>>>>                End
25573>>>>>>>>>>
25573>>>>>>>>>                
25573>>>>>>>>>                If (ValueTree.sValue="") Begin
25575>>>>>>>>>                    Function_Return True    
25576>>>>>>>>>                End
25576>>>>>>>>>>
25576>>>>>>>>>                
25576>>>>>>>>>                Get Create (RefClass(cXMLDOMDocument)) to hoData
25577>>>>>>>>>                Get LoadXMLFromVariant of hoData ValueTree.sValue to bOk
25578>>>>>>>>>                If not bOk Begin
25580>>>>>>>>>                    Error DFERR_PROGRAM ("Could not convert string to XML node (" - Left(ValueTree.sValue,1000) - ")")
25581>>>>>>>>>>
25581>>>>>>>>>                    Send Destroy of hoData
25582>>>>>>>>>                    Function_Return False
25583>>>>>>>>>                End
25583>>>>>>>>>>
25583>>>>>>>>>                // add the wrapper for this param
25583>>>>>>>>>                Get AddElementNS of hoParam (If(bRpc,"",SoapParamDef.sNamespace)) SoapParamDef.sName '' to hoParamChildNode
25584>>>>>>>>>                // if xmlElement, pass the entire document as a child of the wrapper
25584>>>>>>>>>                Get DocumentElement of hoData to hoDataRoot
25585>>>>>>>>>                Get CloneNode of hoDataRoot True to hoNode
25586>>>>>>>>>                Get AppendNode of hoParamChildNode hoNode to hoNode
25587>>>>>>>>>                Send Destroy of hoNode
25588>>>>>>>>>                Send destroy of hoParamChildNode
25589>>>>>>>>>                Send destroy of hoDataRoot
25590>>>>>>>>>                Send Destroy of hoData
25591>>>>>>>>>            End
25591>>>>>>>>>>
25591>>>>>>>>>            // if an array of elements
25591>>>>>>>>>            Else Begin
25592>>>>>>>>>                
25592>>>>>>>>>                If (SizeOfArray(ValueTree.children)=0) Begin
25594>>>>>>>>>                    Function_Return True                    
25595>>>>>>>>>                End
25595>>>>>>>>>>
25595>>>>>>>>>                
25595>>>>>>>>>                Get AddElementNS of hoParam (If(bRpc,"",SoapParamDef.sNamespace)) SoapParamDef.sName '' to hoParamChildNode
25596>>>>>>>>>                Get Create (RefClass(cXMLDOMDocument)) to hoData
25597>>>>>>>>>                For i from 0 to (SizeOfArray(ValueTree.children)-1)
25603>>>>>>>>>>
25603>>>>>>>>>                    Get LoadXMLFromVariant of hoData ValueTree.children[i].sValue to bOk
25604>>>>>>>>>                    If not bOk Begin
25606>>>>>>>>>                        Error DFERR_PROGRAM ("Could not convert string to XML node (" - Left(ValueTree.children[i].sValue,1000) - ")")
25607>>>>>>>>>>
25607>>>>>>>>>                        Send Destroy of hoData
25608>>>>>>>>>                        Function_Return False
25609>>>>>>>>>                    End
25609>>>>>>>>>>
25609>>>>>>>>>                    Get DocumentElement of hoData to hoDataRoot
25610>>>>>>>>>                    Get CloneNode of hoDataRoot True to hoNode
25611>>>>>>>>>                    Get AppendNode of hoParamChildNode hoNode to hoNode
25612>>>>>>>>>                    Send Destroy of hoNode
25613>>>>>>>>>                Loop
25614>>>>>>>>>>
25614>>>>>>>>>                Send destroy of hoParamChildNode
25615>>>>>>>>>                Send destroy of hoDataRoot
25616>>>>>>>>>                Send Destroy of hoData
25617>>>>>>>>>            End
25617>>>>>>>>>>
25617>>>>>>>>>        End
25617>>>>>>>>>>
25617>>>>>>>>>        Function_Return True
25618>>>>>>>>>    End_Function
25619>>>>>>>>>
25619>>>>>>>>>
25619>>>>>>>>>End_Class
25620>>>>>>>>>
25620>>>>>>>
25620>>>>>>>Global_Variable Integer oStructFunctions
25620>>>>>>>
25620>>>>>>>Object _oStructFunctions is a cObject
25622>>>>>>>    Move Self to oStructFunctions
25623>>>>>>>
25623>>>>>>>    Procedure WriteValueTree Integer iChannel tValueTree strValueTree
25626>>>>>>>        Integer iLen iIndex iMax
25626>>>>>>>        Move (Length(strValueTree.sValue)) to iLen
25627>>>>>>>        Writeln channel iChannel iLen
25630>>>>>>>        Write strValueTree.sValue
25631>>>>>>>        Move (SizeOfArray(strValueTree.children)-1) to iMax
25632>>>>>>>        Writeln iMax
25634>>>>>>>        For iIndex from 0 to iMax
25640>>>>>>>>
25640>>>>>>>            Send WriteValueTree iChannel strValueTree.children[iIndex]
25641>>>>>>>        Loop
25642>>>>>>>>
25642>>>>>>>    End_Procedure
25643>>>>>>>
25643>>>>>>>    Procedure WriteVariant Integer iChannel Variant vValue
25646>>>>>>>        tValueTree strValueTree
25646>>>>>>>        tValueTree strValueTree
25646>>>>>>>        ValueTreeSerializeParameter vValue to strValueTree
25647>>>>>>>        Send WriteValueTree iChannel strValueTree
25648>>>>>>>    End_Procedure
25649>>>>>>>
25649>>>>>>>    Procedure ReadValueTree Integer iChannel tValueTree ByRef strValueTree
25652>>>>>>>        Integer iLen iIndex iMax
25652>>>>>>>        tValueTree strEmpty
25652>>>>>>>        tValueTree strEmpty
25652>>>>>>>        Readln channel iChannel iLen
25654>>>>>>>        Read_Block strValueTree.sValue iLen
25655>>>>>>>        Readln iMax
25656>>>>>>>        For iIndex from 0 to iMax
25662>>>>>>>>
25662>>>>>>>            Move strEmpty to strValueTree.children[iIndex]
25663>>>>>>>            Send ReadValueTree iChannel (&strValueTree.children[iIndex])
25664>>>>>>>        Loop
25665>>>>>>>>
25665>>>>>>>    End_Procedure
25666>>>>>>>
25666>>>>>>>            Procedure _VTTS_AppendValue String ByRef sCurrentString String sNewValue
25669>>>>>>>                Integer iLen
25669>>>>>>>                Move (Length(sNewValue)) to iLen
25670>>>>>>>                Move (sCurrentString+String(iLen)+","+sNewValue) to sCurrentString
25671>>>>>>>            End_Procedure
25672>>>>>>>
25672>>>>>>>            Procedure _VTTS_AppendValueTree String ByRef sCurrentString tValueTree strValueTree
25675>>>>>>>                Integer iIndex iMax
25675>>>>>>>                Send _VTTS_AppendValue (&sCurrentString) strValueTree.sValue
25676>>>>>>>                Move (SizeOfArray(strValueTree.children)-1) to iMax
25677>>>>>>>                Send _VTTS_AppendValue (&sCurrentString) iMax
25678>>>>>>>                For iIndex from 0 to iMax
25684>>>>>>>>
25684>>>>>>>                    Send _VTTS_AppendValueTree (&sCurrentString) strValueTree.children[iIndex]
25685>>>>>>>                Loop
25686>>>>>>>>
25686>>>>>>>            End_Procedure
25687>>>>>>>
25687>>>>>>>    //> Use this only for "small" to "moderate" size values of strValueTree. It is not too efficient.
25687>>>>>>>    Function ValueTreeToString tValueTree strValueTree Returns String
25690>>>>>>>        String sValue
25690>>>>>>>        Move "" to sValue
25691>>>>>>>        Send _VTTS_AppendValueTree (&sValue) strValueTree
25692>>>>>>>        Function_Return sValue
25693>>>>>>>    End_Function
25694>>>>>>>
25694>>>>>>>            Function _STVT_ReadValue String sCurrentString Integer ByRef iPos Returns String
25697>>>>>>>                Integer iIndex iMax iCommaPos iLen
25697>>>>>>>                Move (Pos(",",sCurrentString,iPos,10)) to iCommaPos
25698>>>>>>>                Move (Integer(Mid(sCurrentString,iCommaPos-iPos,iPos))) to iLen
25699>>>>>>>                Move (iCommaPos+1) to iPos
25700>>>>>>>                Move (iPos+iLen) to iPos
25701>>>>>>>                Function_Return (Mid(sCurrentString,iLen,iPos-iLen))
25702>>>>>>>            End_Function
25703>>>>>>>
25703>>>>>>>
25703>>>>>>>            Procedure _STVT_ReadValueTree tValueTree ByRef strValueTree String sCurrentString Integer ByRef iPos
25706>>>>>>>                Integer iIndex iMax
25706>>>>>>>                tValueTree strValueTreeEmpty
25706>>>>>>>                tValueTree strValueTreeEmpty
25706>>>>>>>                Get _STVT_ReadValue sCurrentString (&iPos) to strValueTree.sValue
25707>>>>>>>                Get _STVT_ReadValue sCurrentString (&iPos) to iMax
25708>>>>>>>                For iIndex from 0 to iMax
25714>>>>>>>>
25714>>>>>>>                    Move strValueTreeEmpty to strValueTree.children[iIndex]
25715>>>>>>>                    Send _STVT_ReadValueTree (&strValueTree.children[iIndex]) sCurrentString (&iPos)
25716>>>>>>>                Loop
25717>>>>>>>>
25717>>>>>>>            End_Procedure
25718>>>>>>>
25718>>>>>>>    //> Use this only for "small" to "moderate" size values of strValueTree. It is not too efficient.
25718>>>>>>>    Function StringToValueTree String sValue Returns tValueTree
25721>>>>>>>        Integer iPos
25721>>>>>>>        tValueTree strValueTree
25721>>>>>>>        tValueTree strValueTree
25721>>>>>>>        Move 1 to iPos
25722>>>>>>>        Send _STVT_ReadValueTree (&strValueTree) sValue (&iPos)
25723>>>>>>>        Function_Return strValueTree
25724>>>>>>>    End_Function
25725>>>>>>>
25725>>>>>>>    Function VariantToString Variant vValue Returns String
25728>>>>>>>        String sValue
25728>>>>>>>        tValueTree strValueTree
25728>>>>>>>        tValueTree strValueTree
25728>>>>>>>
25728>>>>>>>        ValueTreeSerializeParameter vValue to strValueTree
25729>>>>>>>        Get ValueTreeToString strValueTree to sValue
25730>>>>>>>
25730>>>>>>>        Function_Return sValue
25731>>>>>>>    End_Function
25732>>>>>>>
25732>>>>>>>//    Procedure StringToVariant String sValue Variant ByRef vValue
25732>>>>>>>//        Variant vLocalValue
25732>>>>>>>//        tValueTree strValueTree
25732>>>>>>>//
25732>>>>>>>//        Move vValue to vLocalValue // We'll work on a local copy
25732>>>>>>>//        
25732>>>>>>>//        Get StringToValueTree sValue to strValueTree
25732>>>>>>>//
25732>>>>>>>//        ValueTreeDeserializeParameter strValueTree to vLocalValue // Does not work
25732>>>>>>>//        Move vLocalValue to vValue
25732>>>>>>>//    End_Procedure
25732>>>>>>>
25732>>>>>>>//    Function ReadVariant Variant ByRef vValue Returns Boolean
25732>>>>>>>//        Integer iChannel
25732>>>>>>>//        Boolean bOk
25732>>>>>>>//        tValueTree strValueTree
25732>>>>>>>//
25732>>>>>>>//        Move False to bOk
25732>>>>>>>//        Get DirectInput of oFileFunctions ("binary:"+_FileName(Self)) to iChannel
25732>>>>>>>//        If (iChannel>=0) Begin
25732>>>>>>>//            Move True to bOk
25732>>>>>>>//            Send ReadValueTree iChannel (&strValueTree)
25732>>>>>>>//            Send CloseInput of oFileFunctions iChannel
25732>>>>>>>//            ValueTreeDeserializeParameter strValueTree to vValue // Does not work
25732>>>>>>>//        End
25732>>>>>>>//        Function_Return bOk
25732>>>>>>>//    End_Function
25732>>>>>>>
25732>>>>>>>        Function _IsIdenticalStructValue tValueTree strValueTree1 tValueTree strValueTree2 Returns Boolean
25735>>>>>>>            Integer iMax iIndex
25735>>>>>>>            If (strValueTree1.sValue<>strValueTree2.sValue) Begin
25737>>>>>>>                Function_Return False
25738>>>>>>>            End
25738>>>>>>>>
25738>>>>>>>            Move (SizeOfArray(strValueTree1.children)) to iMax
25739>>>>>>>            If (iMax<>SizeOfArray(strValueTree2.children)) Begin
25741>>>>>>>                Function_Return False
25742>>>>>>>            End
25742>>>>>>>>
25742>>>>>>>            Else Begin
25743>>>>>>>                Decrement iMax
25744>>>>>>>                For iIndex from 0 to iMax
25750>>>>>>>>
25750>>>>>>>                    If (not(_IsIdenticalStructValue(Self,strValueTree1.children[iIndex],strValueTree2.children[iIndex]))) Begin
25752>>>>>>>                        Function_Return False
25753>>>>>>>                    End
25753>>>>>>>>
25753>>>>>>>                Loop
25754>>>>>>>>
25754>>>>>>>            End
25754>>>>>>>>
25754>>>>>>>            Function_Return True
25755>>>>>>>        End_Function
25756>>>>>>>    
25756>>>>>>>    Function IsIdenticalStructValue Variant vValue1 Variant vValue2 Returns Boolean
25759>>>>>>>        tValueTree strValueTree1 strValueTree2
25759>>>>>>>        tValueTree strValueTree1 strValueTree2
25759>>>>>>>        ValueTreeSerializeParameter vValue1 to strValueTree1
25760>>>>>>>        ValueTreeSerializeParameter vValue2 to strValueTree2
25761>>>>>>>        Function_Return (_IsIdenticalStructValue(Self,strValueTree1,strValueTree2))
25762>>>>>>>    End_Function
25763>>>>>>>End_Object
25764>>>>>>>
25764>>>>>>>
25764>>>>>>>// Test:
25764>>>>>>>//
25764>>>>>>>//Struct tTest
25764>>>>>>>//    Integer iDirection
25764>>>>>>>//    String  sLabel
25764>>>>>>>//End_Struct
25764>>>>>>>//
25764>>>>>>>//Procedure test
25764>>>>>>>//    tTest strTest strTest2
25764>>>>>>>//    String sValue
25764>>>>>>>//    Move 3 to strTest.iDirection
25764>>>>>>>//    Move "west" to strTest.sLabel
25764>>>>>>>//    Get VariantToString of oStructFunctions strTest to sValue
25764>>>>>>>//    Move 2 to strTest.iDirection
25764>>>>>>>//    Move "north" to strTest.sLabel
25764>>>>>>>//    Move strTest to strTest2
25764>>>>>>>//    Send StringToVariant of oStructFunctions sValue (&strTest2) << - That can't work
25764>>>>>>>//End_Procedure
25764>>>>>>>//
25764>>>>>>>//Send test
25764>>>>>Use cExpressionParser.pkg
Including file: cExpressionParser.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\cExpressionParser.pkg)
25764>>>>>>>//> The cExpressionParser implements Dijkstras Shunting-yard algorithm as described 
25764>>>>>>>//> here: http://en.wikipedia.org/wiki/Shunting-yard_algorithm.
25764>>>>>>>//>
25764>>>>>>>//><code> 
25764>>>>>>>//> Object oExpressionParser is a cExpressionParser
25764>>>>>>>//>     Procedure Demo
25764>>>>>>>//>         tXPGrammar strGrammar
25764>>>>>>>//>         tXPToken[] aSymbols
25764>>>>>>>//>         tXPError strError
25764>>>>>>>//>         tXPValue strResult
25764>>>>>>>//>     
25764>>>>>>>//>         // Get a grammer with operators and functions:
25764>>>>>>>//>         Get NewGrammar to strGrammar                  
25764>>>>>>>//> 
25764>>>>>>>//>         // Parse an expression into an array of symbols:
25764>>>>>>>//>         Get TokenizeString strGrammar '3+4*2/(1-5)^2^3' (&strError) to aSymbols
25764>>>>>>>//>
25764>>>>>>>//>         // Convert into "reverse polish notation" that can be used for evaluating the expression:
25764>>>>>>>//>         Get ReversePolishNotation strGrammar aSymbols (&strError) to aSymbols
25764>>>>>>>//>
25764>>>>>>>//>         // Evaluate the expression:
25764>>>>>>>//>         Get Evaluate strGrammar aSymbols (&strError) to strResult
25764>>>>>>>//> 
25764>>>>>>>//>         Send Info_Box (strResult.sValue+", type: "+String(strResult.iValueType))
25764>>>>>>>//>     End_Procedure
25764>>>>>>>//> End_Object
25764>>>>>>>//>
25764>>>>>>>//> Send Demo of oExpressionParser
25764>>>>>>>//></code>
25764>>>>>>>//>
25764>>>>>>>//> Extending the grammar
25764>>>>>>>//> ---------------------
25764>>>>>>>//>
25764>>>>>>>//>     real soon
25764>>>>>>>//>     
25764>>>>>>>//>     
25764>>>>>>>//> Class cMyExpressionParser is a cExpressionParser
25764>>>>>>>//> End_Class
25764>>>>>>>//>
25764>>>>>>>//>
25764>>>>>>>//>
25764>>>>>>>//> pkg.doc.end
25764>>>>>>>
25764>>>>>>>Use StackFunctions.pkg
Including file: StackFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\StackFunctions.pkg)
25764>>>>>>>>>// Use StackFunctions.pkg // Define oStackFunctions object
25764>>>>>>>>>
25764>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
25764>>>>>>>>>
25764>>>>>>>>>Global_Variable Integer oStackFunctions
25764>>>>>>>>>
25764>>>>>>>>>Object _oStackFunctions is a cObject
25766>>>>>>>>>    Move Self to oStackFunctions
25767>>>>>>>>>
25767>>>>>>>>>    // Boolean interface:
25767>>>>>>>>>    Procedure BooleanPush Boolean bValue Boolean[] ByRef aValues
25770>>>>>>>>>        Move bValue to aValues[SizeOfArray(aValues)]
25771>>>>>>>>>    End_Procedure
25772>>>>>>>>>    Function BooleanPop Boolean[] ByRef aValues Returns Boolean
25775>>>>>>>>>        Boolean bRval
25775>>>>>>>>>        Integer iSize
25775>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
25776>>>>>>>>>        Move aValues[iSize-1] to bRval
25777>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
25778>>>>>>>>>        Function_Return bRval
25779>>>>>>>>>    End_Function
25780>>>>>>>>>    Function BooleanCopy Boolean[] aValues Returns Boolean
25783>>>>>>>>>        Function_Return aValues[SizeOfArray(aValues)-1]
25784>>>>>>>>>    End_Function
25785>>>>>>>>>    Function BooleanIsEmpty Boolean[] aValues Returns Boolean
25788>>>>>>>>>        Function_Return (SizeOfArray(aValues)=0)
25789>>>>>>>>>    End_Function
25790>>>>>>>>>    Function BooleanIsOnStack Boolean bValue Boolean[] aValues Returns Boolean
25793>>>>>>>>>        Integer iSearchItem
25793>>>>>>>>>        Move (SearchArray(bValue,aValues)) to iSearchItem
25794>>>>>>>>>        Function_Return (iSearchItem<>-1)
25795>>>>>>>>>    End_Function
25796>>>>>>>>>    Procedure BooleanDrop Boolean[] ByRef aValues
25799>>>>>>>>>        Integer iSize
25799>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
25800>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
25801>>>>>>>>>    End_Procedure
25802>>>>>>>>>
25802>>>>>>>>>    // Integer interface:
25802>>>>>>>>>    Procedure IntegerPush Integer iValue Integer[] ByRef aValues
25805>>>>>>>>>        Move iValue to aValues[SizeOfArray(aValues)]
25806>>>>>>>>>    End_Procedure
25807>>>>>>>>>    Function IntegerPop Integer[] ByRef aValues Returns Integer
25810>>>>>>>>>        Integer iRval iSize
25810>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
25811>>>>>>>>>        Move aValues[iSize-1] to iRval
25812>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
25813>>>>>>>>>        Function_Return iRval
25814>>>>>>>>>    End_Function
25815>>>>>>>>>    Function IntegerCopy Integer[] aValues Returns Integer
25818>>>>>>>>>        Function_Return aValues[SizeOfArray(aValues)-1]
25819>>>>>>>>>    End_Function
25820>>>>>>>>>    Function IntegerIsEmpty Integer[] aValues Returns Boolean
25823>>>>>>>>>        Function_Return (SizeOfArray(aValues)=0)
25824>>>>>>>>>    End_Function
25825>>>>>>>>>    Function IntegerIsOnStack Integer iValue Integer[] aValues Returns Boolean
25828>>>>>>>>>        Integer iSearchItem
25828>>>>>>>>>        Move (SearchArray(iValue,aValues)) to iSearchItem
25829>>>>>>>>>        Function_Return (iSearchItem<>-1)
25830>>>>>>>>>    End_Function
25831>>>>>>>>>    Procedure IntegerDrop Integer[] ByRef aValues
25834>>>>>>>>>        Integer iSize
25834>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
25835>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
25836>>>>>>>>>    End_Procedure
25837>>>>>>>>>
25837>>>>>>>>>
25837>>>>>>>>>    Procedure IntegerRemoveDoublettes Integer[] ByRef aValues //> aValues must be sorted!
25840>>>>>>>>>        Integer iLengthMinusOne iPos
25840>>>>>>>>>        Move (SizeOfArray(aValues)-2) to iLengthMinusOne
25841>>>>>>>>>        Move 0 to iPos
25842>>>>>>>>>        While (iPos<iLengthMinusOne)
25846>>>>>>>>>            If (aValues[iPos]=aValues[iPos+1]) Begin
25848>>>>>>>>>                Move (RemoveFromArray(aValues,iPos+1)) to aValues
25849>>>>>>>>>            End
25849>>>>>>>>>>
25849>>>>>>>>>            Else Begin
25850>>>>>>>>>                Increment iPos
25851>>>>>>>>>            End
25851>>>>>>>>>>
25851>>>>>>>>>        Loop
25852>>>>>>>>>>
25852>>>>>>>>>    End_Procedure
25853>>>>>>>>>
25853>>>>>>>>>//    Procedure IntegerTopDrop Integer[] ByRef aValues
25853>>>>>>>>>//        Move (RemoveFromArray(aValues,SizeOfArray(aValues)-1)) to aValues
25853>>>>>>>>>//    End_Procedure
25853>>>>>>>>>//    Function IntegerTopDrop Integer[] aValues Returns Integer[]
25853>>>>>>>>>//        Function_Return (RemoveFromArray(aValues,SizeOfArray(aValues)-1))
25853>>>>>>>>>//    End_Function
25853>>>>>>>>>
25853>>>>>>>>>    // WHAT HAVE WE HERE? That's not a stack function!
25853>>>>>>>>>    // iOpCode=0: Logical AND,   1:Logical OR,   2: In Set1 but NOT in Set2
25853>>>>>>>>>    Function IntegerLogicalOperationSets Integer iOpCode Integer[] aValue1 Integer[] aValue2 Returns Integer[]
25856>>>>>>>>>        Integer iMax1 iMax2 iIndex1 iIndex2 iResultItem
25856>>>>>>>>>        Integer[] aResult
25857>>>>>>>>>
25857>>>>>>>>>        Move 0 to iIndex1
25858>>>>>>>>>        Move 0 to iIndex2
25859>>>>>>>>>        Move 0 to iResultItem
25860>>>>>>>>>        Move (SortArray(aValue1)) to aValue1
25861>>>>>>>>>        Move (SortArray(aValue2)) to aValue2
25862>>>>>>>>>        Move (SizeOfArray(aValue1)) to iMax1
25863>>>>>>>>>        Move (SizeOfArray(aValue2)) to iMax2
25864>>>>>>>>>
25864>>>>>>>>>        While (iIndex1<iMax1 or iIndex2<iMax2)
25868>>>>>>>>>            If (iIndex1<iMax1 and iIndex2<iMax2 and aValue1[iIndex1]=aValue2[iIndex2]) Begin // It occurs in both
25870>>>>>>>>>                If (iOpCode<>2) Begin
25872>>>>>>>>>                    Move aValue1[iIndex1] to aResult[iResultItem]
25873>>>>>>>>>                    Increment iResultItem
25874>>>>>>>>>                End
25874>>>>>>>>>>
25874>>>>>>>>>                Increment iIndex1
25875>>>>>>>>>                Increment iIndex2
25876>>>>>>>>>            End
25876>>>>>>>>>>
25876>>>>>>>>>            Else If (iIndex2=iMax2 or (iIndex1<iMax1 and aValue1[iIndex1]<aValue2[iIndex2])) Begin // It's only in array 1.
25879>>>>>>>>>                If (iOpCode<>0) Begin
25881>>>>>>>>>                    Move aValue1[iIndex1] to aResult[iResultItem]
25882>>>>>>>>>                    Increment iResultItem
25883>>>>>>>>>                End
25883>>>>>>>>>>
25883>>>>>>>>>                Increment iIndex1
25884>>>>>>>>>            End
25884>>>>>>>>>>
25884>>>>>>>>>            Else Begin // It's only in array 2.
25885>>>>>>>>>                If (iOpCode=1) Begin
25887>>>>>>>>>                    Move aValue2[iIndex2] to aResult[iResultItem]
25888>>>>>>>>>                    Increment iResultItem
25889>>>>>>>>>                End
25889>>>>>>>>>>
25889>>>>>>>>>                Increment iIndex2
25890>>>>>>>>>            End
25890>>>>>>>>>>
25890>>>>>>>>>        Loop
25891>>>>>>>>>>
25891>>>>>>>>>
25891>>>>>>>>>        Function_Return aResult
25892>>>>>>>>>    End_Function
25893>>>>>>>>>
25893>>>>>>>>>    Function IntegerAddToSet Integer[] ByRef aSet Integer iMember Returns Boolean
25896>>>>>>>>>        Integer iMax iIndex
25896>>>>>>>>>        Move (SizeOfArray(aSet)-1) to iMax
25897>>>>>>>>>        For iIndex from 0 to iMax
25903>>>>>>>>>>
25903>>>>>>>>>            If (iMember=aSet[iIndex]) Begin
25905>>>>>>>>>                Function_Return False
25906>>>>>>>>>            End
25906>>>>>>>>>>
25906>>>>>>>>>        Loop
25907>>>>>>>>>>
25907>>>>>>>>>        Move iMember to aSet[SizeOfArray(aSet)]
25908>>>>>>>>>        Function_Return True
25909>>>>>>>>>    End_Function
25910>>>>>>>>>
25910>>>>>>>>>    Function IntegerIsMember Integer[] aSet Integer iValue Returns Boolean
25913>>>>>>>>>        Integer iMax iIndex
25913>>>>>>>>>        Move (SizeOfArray(aSet)-1) to iMax
25914>>>>>>>>>        For iIndex from 0 to iMax
25920>>>>>>>>>>
25920>>>>>>>>>            If (iValue=aSet[iIndex]) Begin
25922>>>>>>>>>                Function_Return True
25923>>>>>>>>>            End
25923>>>>>>>>>>
25923>>>>>>>>>        Loop
25924>>>>>>>>>>
25924>>>>>>>>>        Function_Return False
25925>>>>>>>>>    End_Function
25926>>>>>>>>>
25926>>>>>>>>>    Procedure IntegerIncrement Integer[] ByRef aArray Integer iIndex
25929>>>>>>>>>        If (iIndex>=SizeOfArray(aArray)) Begin
25931>>>>>>>>>            Move (ResizeArray(aArray,iIndex+1)) to aArray
25932>>>>>>>>>        End
25932>>>>>>>>>>
25932>>>>>>>>>        Increment aArray[iIndex]
25933>>>>>>>>>    End_Procedure
25934>>>>>>>>>
25934>>>>>>>>>
25934>>>>>>>>>    // Number interface:
25934>>>>>>>>>    Procedure NumberPush Number nValue Number[] ByRef aValues
25937>>>>>>>>>        Move nValue to aValues[SizeOfArray(aValues)]
25938>>>>>>>>>    End_Procedure
25939>>>>>>>>>    Function NumberPop Number[] ByRef aValues Returns Number
25942>>>>>>>>>        Integer iSize
25942>>>>>>>>>        Number nRval 
25942>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
25943>>>>>>>>>        Move aValues[iSize-1] to nRval
25944>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
25945>>>>>>>>>        Function_Return nRval
25946>>>>>>>>>    End_Function
25947>>>>>>>>>    Function NumberCopy Number[] aValues Returns Number
25950>>>>>>>>>        Function_Return aValues[SizeOfArray(aValues)-1]
25951>>>>>>>>>    End_Function
25952>>>>>>>>>    Function NumberIsEmpty Number[] aValues Returns Boolean
25955>>>>>>>>>        Function_Return (SizeOfArray(aValues)=0)
25956>>>>>>>>>    End_Function
25957>>>>>>>>>
25957>>>>>>>>>    Function NumberIsOnStack Number nValue Number[] aValues Returns Boolean
25960>>>>>>>>>        Integer iSearchItem
25960>>>>>>>>>        Move (SearchArray(nValue,aValues)) to iSearchItem
25961>>>>>>>>>        Function_Return (iSearchItem<>-1)
25962>>>>>>>>>    End_Function
25963>>>>>>>>>
25963>>>>>>>>>    Function NumberAddToSet Number[] ByRef aSet Number nMember Returns Boolean
25966>>>>>>>>>        Integer iMax iIndex
25966>>>>>>>>>        Move (SizeOfArray(aSet)-1) to iMax
25967>>>>>>>>>        For iIndex from 0 to iMax
25973>>>>>>>>>>
25973>>>>>>>>>            If (nMember=aSet[iIndex]) Begin
25975>>>>>>>>>                Function_Return False
25976>>>>>>>>>            End
25976>>>>>>>>>>
25976>>>>>>>>>        Loop
25977>>>>>>>>>>
25977>>>>>>>>>        Move nMember to aSet[SizeOfArray(aSet)]
25978>>>>>>>>>        Function_Return True
25979>>>>>>>>>    End_Function
25980>>>>>>>>>
25980>>>>>>>>>    Procedure NumberDrop Number[] ByRef aValues
25983>>>>>>>>>        Integer iSize
25983>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
25984>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
25985>>>>>>>>>    End_Procedure
25986>>>>>>>>>
25986>>>>>>>>>
25986>>>>>>>>>    Procedure NumberRemoveDoublettes Number[] ByRef aValues //> aValues must be sorted!
25989>>>>>>>>>        Integer iLengthMinusOne iPos
25989>>>>>>>>>        Move (SizeOfArray(aValues)-2) to iLengthMinusOne
25990>>>>>>>>>        Move 0 to iPos
25991>>>>>>>>>        While (iPos<iLengthMinusOne)
25995>>>>>>>>>            If (aValues[iPos]=aValues[iPos+1]) Begin
25997>>>>>>>>>                Move (RemoveFromArray(aValues,iPos+1)) to aValues
25998>>>>>>>>>            End
25998>>>>>>>>>>
25998>>>>>>>>>            Else Begin
25999>>>>>>>>>                Increment iPos
26000>>>>>>>>>            End
26000>>>>>>>>>>
26000>>>>>>>>>        Loop
26001>>>>>>>>>>
26001>>>>>>>>>    End_Procedure
26002>>>>>>>>>
26002>>>>>>>>>//    Procedure NumberTopDrop Number[] ByRef aValues
26002>>>>>>>>>//        Move (RemoveFromArray(aValues,SizeOfArray(aValues)-1)) to aValues
26002>>>>>>>>>//    End_Procedure
26002>>>>>>>>>//    Function NumberTopDrop Number[] aValues Returns Number[]
26002>>>>>>>>>//        Function_Return (RemoveFromArray(aValues,SizeOfArray(aValues)-1))
26002>>>>>>>>>//    End_Function
26002>>>>>>>>>
26002>>>>>>>>>    // WHAT HAVE WE HERE? That's not a stack function!
26002>>>>>>>>>    // iOpCode=0: Logical AND,   1:Logical OR,   2: In Set1 but NOT in Set2
26002>>>>>>>>>    Function NumberLogicalOperationSets Integer iOpCode Number[] aValue1 Number[] aValue2 Returns Number[]
26005>>>>>>>>>        Integer iMax1 iMax2 iIndex1 iIndex2 iResultItem
26005>>>>>>>>>        Number[] aResult
26006>>>>>>>>>
26006>>>>>>>>>        Move 0 to iIndex1
26007>>>>>>>>>        Move 0 to iIndex2
26008>>>>>>>>>        Move 0 to iResultItem
26009>>>>>>>>>        Move (SortArray(aValue1)) to aValue1
26010>>>>>>>>>        Move (SortArray(aValue2)) to aValue2
26011>>>>>>>>>        Move (SizeOfArray(aValue1)) to iMax1
26012>>>>>>>>>        Move (SizeOfArray(aValue2)) to iMax2
26013>>>>>>>>>
26013>>>>>>>>>        While (iIndex1<iMax1 or iIndex2<iMax2)
26017>>>>>>>>>            If (iIndex1<iMax1 and iIndex2<iMax2 and aValue1[iIndex1]=aValue2[iIndex2]) Begin // It occurs in both
26019>>>>>>>>>                If (iOpCode<>2) Begin
26021>>>>>>>>>                    Move aValue1[iIndex1] to aResult[iResultItem]
26022>>>>>>>>>                    Increment iResultItem
26023>>>>>>>>>                End
26023>>>>>>>>>>
26023>>>>>>>>>                Increment iIndex1
26024>>>>>>>>>                Increment iIndex2
26025>>>>>>>>>            End
26025>>>>>>>>>>
26025>>>>>>>>>            Else If (iIndex2=iMax2 or (iIndex1<iMax1 and aValue1[iIndex1]<aValue2[iIndex2])) Begin // It's only in array 1.
26028>>>>>>>>>                If (iOpCode<>0) Begin
26030>>>>>>>>>                    Move aValue1[iIndex1] to aResult[iResultItem]
26031>>>>>>>>>                    Increment iResultItem
26032>>>>>>>>>                End
26032>>>>>>>>>>
26032>>>>>>>>>                Increment iIndex1
26033>>>>>>>>>            End
26033>>>>>>>>>>
26033>>>>>>>>>            Else Begin // It's only in array 2.
26034>>>>>>>>>                If (iOpCode=1) Begin
26036>>>>>>>>>                    Move aValue2[iIndex2] to aResult[iResultItem]
26037>>>>>>>>>                    Increment iResultItem
26038>>>>>>>>>                End
26038>>>>>>>>>>
26038>>>>>>>>>                Increment iIndex2
26039>>>>>>>>>            End
26039>>>>>>>>>>
26039>>>>>>>>>        Loop
26040>>>>>>>>>>
26040>>>>>>>>>
26040>>>>>>>>>        Function_Return aResult
26041>>>>>>>>>    End_Function
26042>>>>>>>>>
26042>>>>>>>>>    Function NumberAddToSet Number[] ByRef aSet Number nValue Returns Boolean
26045>>>>>>>>>        Integer iMax iIndex
26045>>>>>>>>>        Move (SizeOfArray(aSet)-1) to iMax
26046>>>>>>>>>        For iIndex from 0 to iMax
26052>>>>>>>>>>
26052>>>>>>>>>            If (nValue=aSet[iIndex]) Begin
26054>>>>>>>>>                Function_Return False
26055>>>>>>>>>            End
26055>>>>>>>>>>
26055>>>>>>>>>        Loop
26056>>>>>>>>>>
26056>>>>>>>>>        Move nValue to aSet[SizeOfArray(aSet)]
26057>>>>>>>>>        Function_Return True
26058>>>>>>>>>    End_Function
26059>>>>>>>>>
26059>>>>>>>>>    Function NumberIsMember Number[] aSet Number nValue Returns Boolean
26062>>>>>>>>>        Integer iMax iIndex
26062>>>>>>>>>        Move (SizeOfArray(aSet)-1) to iMax
26063>>>>>>>>>        For iIndex from 0 to iMax
26069>>>>>>>>>>
26069>>>>>>>>>            If (nValue=aSet[iIndex]) Begin
26071>>>>>>>>>                Function_Return True
26072>>>>>>>>>            End
26072>>>>>>>>>>
26072>>>>>>>>>        Loop
26073>>>>>>>>>>
26073>>>>>>>>>        Function_Return False
26074>>>>>>>>>    End_Function
26075>>>>>>>>>
26075>>>>>>>>>
26075>>>>>>>>>    Function StringAddToSet String[] ByRef aSet String sMember Returns Boolean
26078>>>>>>>>>        Integer iMax iIndex
26078>>>>>>>>>        Move (SizeOfArray(aSet)-1) to iMax
26079>>>>>>>>>        For iIndex from 0 to iMax
26085>>>>>>>>>>
26085>>>>>>>>>            If (sMember=aSet[iIndex]) Begin
26087>>>>>>>>>                Function_Return False
26088>>>>>>>>>            End
26088>>>>>>>>>>
26088>>>>>>>>>        Loop
26089>>>>>>>>>>
26089>>>>>>>>>        Move sMember to aSet[SizeOfArray(aSet)]
26090>>>>>>>>>        Function_Return True
26091>>>>>>>>>    End_Function
26092>>>>>>>>>    
26092>>>>>>>>>    Function StringRemoveFromSet String[] ByRef aSet String sMember Returns Boolean
26095>>>>>>>>>        Integer iMax iIndex
26095>>>>>>>>>        Move (SizeOfArray(aSet)-1) to iMax
26096>>>>>>>>>        For iIndex from 0 to iMax
26102>>>>>>>>>>
26102>>>>>>>>>            If (sMember=aSet[iIndex]) Begin
26104>>>>>>>>>                Move (RemoveFromArray(aSet,iIndex)) to aSet
26105>>>>>>>>>                Function_Return True
26106>>>>>>>>>            End
26106>>>>>>>>>>
26106>>>>>>>>>        Loop
26107>>>>>>>>>>
26107>>>>>>>>>        Function_Return False
26108>>>>>>>>>    End_Function
26109>>>>>>>>>
26109>>>>>>>>>
26109>>>>>>>>>    // String interface
26109>>>>>>>>>    Procedure StringPush String sValue String[] ByRef aValues
26112>>>>>>>>>        Move sValue to aValues[SizeOfArray(aValues)]
26113>>>>>>>>>    End_Procedure
26114>>>>>>>>>    Function StringPop String[] ByRef aValues Returns String
26117>>>>>>>>>        Integer iSize
26117>>>>>>>>>        String sRval
26117>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
26118>>>>>>>>>        Move aValues[iSize-1] to sRval
26119>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
26120>>>>>>>>>        Function_Return sRval
26121>>>>>>>>>    End_Function
26122>>>>>>>>>    Function StringCopy String[] aValues Returns String
26125>>>>>>>>>        Function_Return aValues[SizeOfArray(aValues)-1]
26126>>>>>>>>>    End_Function
26127>>>>>>>>>    Function StringIsEmpty String[] aValues Returns Boolean
26130>>>>>>>>>        Function_Return (SizeOfArray(aValues)=0)
26131>>>>>>>>>    End_Function
26132>>>>>>>>>    Function StringIsOnStack String sValue String[] aValues Returns Boolean
26135>>>>>>>>>        Integer iSearchItem
26135>>>>>>>>>        Move (SearchArray(sValue,aValues)) to iSearchItem
26136>>>>>>>>>        Function_Return (iSearchItem<>-1)
26137>>>>>>>>>    End_Function
26138>>>>>>>>>    Procedure StringDrop String[] ByRef aValues
26141>>>>>>>>>        Integer iSize
26141>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
26142>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
26143>>>>>>>>>    End_Procedure
26144>>>>>>>>>    
26144>>>>>>>>>
26144>>>>>>>>>    Procedure StringRemoveDoublettes String[] ByRef aValues //> aValues must be sorted!
26147>>>>>>>>>        Integer iLengthMinusOne iPos
26147>>>>>>>>>        Move (SizeOfArray(aValues)-2) to iLengthMinusOne
26148>>>>>>>>>        Move 0 to iPos
26149>>>>>>>>>        While (iPos<iLengthMinusOne)
26153>>>>>>>>>            If (aValues[iPos]=aValues[iPos+1]) Begin
26155>>>>>>>>>                Move (RemoveFromArray(aValues,iPos+1)) to aValues
26156>>>>>>>>>            End
26156>>>>>>>>>>
26156>>>>>>>>>            Else Begin
26157>>>>>>>>>                Increment iPos
26158>>>>>>>>>            End
26158>>>>>>>>>>
26158>>>>>>>>>        Loop
26159>>>>>>>>>>
26159>>>>>>>>>    End_Procedure
26160>>>>>>>>>
26160>>>>>>>>>    
26160>>>>>>>>>//    Procedure StringTopDrop String[] ByRef aValues
26160>>>>>>>>>//        Move (RemoveFromArray(aValues,SizeOfArray(aValues)-1)) to aValues
26160>>>>>>>>>//    End_Procedure
26160>>>>>>>>>//    Function StringTopDrop String[] aValues Returns String[]
26160>>>>>>>>>//        Function_Return (RemoveFromArray(aValues,SizeOfArray(aValues)-1))
26160>>>>>>>>>//    End_Function
26160>>>>>>>>>
26160>>>>>>>>>    // Handle interface
26160>>>>>>>>>    Procedure HandlePush Handle hValue Handle[] ByRef aValues
26163>>>>>>>>>        Move hValue to aValues[SizeOfArray(aValues)]
26164>>>>>>>>>    End_Procedure
26165>>>>>>>>>    Function HandlePop Handle[] ByRef aValues Returns Handle
26168>>>>>>>>>        Integer iSize
26168>>>>>>>>>        Handle hRval
26168>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
26169>>>>>>>>>        Move aValues[iSize-1] to hRval
26170>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
26171>>>>>>>>>        Function_Return hRval
26172>>>>>>>>>    End_Function
26173>>>>>>>>>    Function HandleCopy Handle[] aValues Returns Handle
26176>>>>>>>>>        Function_Return aValues[SizeOfArray(aValues)-1]
26177>>>>>>>>>    End_Function
26178>>>>>>>>>    Function HandleIsEmpty Handle[] aValues Returns Boolean
26181>>>>>>>>>        Function_Return (SizeOfArray(aValues)=0)
26182>>>>>>>>>    End_Function
26183>>>>>>>>>    Function HandleIsOnStack Handle hValue Handle[] aValues Returns Boolean
26186>>>>>>>>>        Integer iSearchItem
26186>>>>>>>>>        Move (SearchArray(hValue,aValues)) to iSearchItem
26187>>>>>>>>>        Function_Return (iSearchItem<>-1)
26188>>>>>>>>>    End_Function
26189>>>>>>>>>    Procedure HandleDrop Handle[] ByRef aValues
26192>>>>>>>>>        Integer iSize
26192>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
26193>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
26194>>>>>>>>>    End_Procedure
26195>>>>>>>>>End_Object
26196>>>>>>>Use DateFunctions.pkg
Including file: DateFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\DateFunctions.pkg)
26196>>>>>>>>>// Use DateFunctions.pkg // Define oDateFunctions object
26196>>>>>>>>>
26196>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
26196>>>>>>>>>
26196>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
26196>>>>>>>>>
26196>>>>>>>>>Use DatesLD.pkg // Language dictionary for day and month names
Including file: DatesLD.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\DatesLD.pkg)
26196>>>>>>>>>>>Use LanguageDictionary.pkg
Including file: LanguageDictionary.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\LanguageDictionary.pkg)
26196>>>>>>>>>>>>>// Use LanguageDictionary.pkg // cLanguageDictionary class and oLanguageFunctions object
26196>>>>>>>>>>>>>
26196>>>>>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
26196>>>>>>>>>>>>>
26196>>>>>>>>>>>>>Use Language.pkg
Including file: Language.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\Language.pkg)
26196>>>>>>>>>>>>>>>// Use Language     // Default language setup
26196>>>>>>>>>>>>>>>// Sets default languange
26196>>>>>>>>>>>>>>>
26196>>>>>>>>>>>>>>>Use LangSymb.pkg // Language symbols
Including file: LangSymb.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\LangSymb.pkg)
26196>>>>>>>>>>>>>>>>>// Use LangSymb.pkg // Language symbols
26196>>>>>>>>>>>>>>>>>//
26196>>>>>>>>>>>>>>>>>// This package file is part of FreeLib.
26196>>>>>>>>>>>>>>>>>
26196>>>>>>>>>>>>>>>>>define LNG_DUTCH       for  0  // 131
26196>>>>>>>>>>>>>>>>>define LNG_FRENCH      for  1  // 133
26196>>>>>>>>>>>>>>>>>define LNG_SPANISH     for  2  // 134
26196>>>>>>>>>>>>>>>>>define LNG_ITALIAN     for  3  // 139 // NOT TRANSLATED. DO NOT SELECT!
26196>>>>>>>>>>>>>>>>>define LNG_ENGLISH     for  4  // 144
26196>>>>>>>>>>>>>>>>>define LNG_DANISH      for  5  // 145
26196>>>>>>>>>>>>>>>>>define LNG_SWEDISH     for  6  // 146
26196>>>>>>>>>>>>>>>>>define LNG_NORWEGIAN   for  7  // 147
26196>>>>>>>>>>>>>>>>>define LNG_GERMAN      for  8  // 149
26196>>>>>>>>>>>>>>>>>define LNG_PORTUGUESE  for  9  // 155
26196>>>>>>>>>>>>>>>>>define LNG_PAPIAMENTU  for 10  // 199 // NOT TRANSLATED. DO NOT SELECT!
26196>>>>>>>>>>>>>>>>>define LNG_MAX         for 11  // Points one higher than the highest language
26196>>>>>>>>>>>>>>>
26196>>>>>>>>>>>>>>> define LNG_DEFAULT for LNG_ENGLISH // <-- Change default language here
26196>>>>>>>>>>>>>>>
26196>>>>>>>>>>>>>>>  define _LANGUAGE_ for $ENGLISH$
26196>>>>>>>>>>>>>>>
#REM LANGUAGE SET BY LANGUAGE.PKG: $ENGLISH$
26196>>>>>>>>>>>>>>>
26196>>>>>>>>>>>>>>>
26196>>>>>>>>>>>>>>>Integer giLanguage
26196>>>>>>>>>>>>>>>Move LNG_DEFAULT to giLanguage
26197>>>>>>>>>>>>>>>
26197>>>>>>>>>>>>>
26197>>>>>>>>>>>>>Struct tTranslateResult // The return type of a symbol translation
26197>>>>>>>>>>>>>    String  sResult          // The translated value to print or display
26197>>>>>>>>>>>>>    Boolean bOptimize        // TRUE if symbol should be updated
26197>>>>>>>>>>>>>    String  sOptimizedLookup // An optimized symbol (faster to translate)
26197>>>>>>>>>>>>>End_Struct
26197>>>>>>>>>>>>>
26197>>>>>>>>>>>>>Struct tSupLng // Supported language. Which language is determined by its position in an array
26197>>>>>>>>>>>>>    Boolean bActive // TRUE if the language is supported by the application
26197>>>>>>>>>>>>>    Integer iIndex  // Index value to use in language dictionaries for retrieving translated value
26197>>>>>>>>>>>>>End_Struct
26197>>>>>>>>>>>>>
26197>>>>>>>>>>>>>Struct tLngDictListItem // An array of elements of this type holds a list of all language dictionaries in the application.
26197>>>>>>>>>>>>>    Integer hDictionary    // A handle for a alnguage dictionary object
26197>>>>>>>>>>>>>    String  sDictionaryId  // A copy of the unique id that identifies the language dictionary object.
26197>>>>>>>>>>>>>End_Struct
26197>>>>>>>>>>>>>
26197>>>>>>>>>>>>>Struct tLngDictSymbol // Type of a symbol in a language dictionary object
26197>>>>>>>>>>>>>    String sSymbol             // Symbol to be translated ("save")
26197>>>>>>>>>>>>>    String sDefaultTranslation // Default translation if LNG_DEFAULT is not part of the compressed array defined by oSupportedLanguages
26197>>>>>>>>>>>>>    String[] sTranslations     // Array of translations.
26197>>>>>>>>>>>>>End_Struct
26197>>>>>>>>>>>>>
26197>>>>>>>>>>>>>//> Language.pkg defines a global integer called giLanguage that identifies the language currently
26197>>>>>>>>>>>>>//> "spoken" by the application. The cLanguageDictionary class defined in this package internally needs to
26197>>>>>>>>>>>>>//> translate the value of giLanguage into a "compressed index" value (it is compressed because it can only
26197>>>>>>>>>>>>>//> point to the languages supported by this particular application). This compressed value is stored in the
26197>>>>>>>>>>>>>//> global integer gi$CmprLngIdx
26197>>>>>>>>>>>>>  Global_Variable Integer gi$CmprLngIdx
26197>>>>>>>>>>>>>
26197>>>>>>>>>>>>>Class _cLanguageFunctions is a cObject
26198>>>>>>>>>>>>>    Procedure construct_object
26200>>>>>>>>>>>>>        Forward Send Construct_Object
26202>>>>>>>>>>>>>
26202>>>>>>>>>>>>>        // After the first cLanguageDictionary object has been declared, it is no longer
26202>>>>>>>>>>>>>        // possible to add languages that should be supported (via DoAddLanguage).
26202>>>>>>>>>>>>>        Property Boolean _StopForAddingLanguages False
26203>>>>>>>>>>>>>
26203>>>>>>>>>>>>>        // The paLanguages property determines what languages are supported in the
26203>>>>>>>>>>>>>        // application at hand. The purpose of this is to compress the arrays that holds
26203>>>>>>>>>>>>>        // language dependant values and to make sure that un-needed values aren't loaded.
26203>>>>>>>>>>>>>        Property tSupLng[] paLanguages
26204>>>>>>>>>>>>>
26204>>>>>>>>>>>>>        Property Integer _piCounter 0
26205>>>>>>>>>>>>>
26205>>>>>>>>>>>>>        // This property holds references to all cLanguageDictionary objects
26205>>>>>>>>>>>>>        // declared in the application. It is because of this property that the function
26205>>>>>>>>>>>>>        // translate_value is able to find the correct dictionary to handle a given translation.
26205>>>>>>>>>>>>>        Property tLngDictListItem[] _paLngDictList
26206>>>>>>>>>>>>>
26206>>>>>>>>>>>>>        Send _OnInitializeObject
26207>>>>>>>>>>>>>    End_Procedure
26208>>>>>>>>>>>>>
26208>>>>>>>>>>>>>            Procedure _OnInitializeObject
26210>>>>>>>>>>>>>                Integer iLng
26210>>>>>>>>>>>>>                tSupLng sLanguage
26210>>>>>>>>>>>>>                tSupLng sLanguage
26210>>>>>>>>>>>>>                tSupLng[] aLanguages
26210>>>>>>>>>>>>>                tSupLng[] aLanguages
26211>>>>>>>>>>>>>                Move False to sLanguage.bActive
26212>>>>>>>>>>>>>                Move -1 to sLanguage.iIndex
26213>>>>>>>>>>>>>                Move (ResizeArray(aLanguages,LNG_MAX,sLanguage)) to aLanguages
26214>>>>>>>>>>>>>                Set paLanguages to aLanguages
26215>>>>>>>>>>>>>                Send DoAddLanguage LNG_DEFAULT
26216>>>>>>>>>>>>>                Set CurrentLanguage to LNG_DEFAULT
26217>>>>>>>>>>>>>            End_Procedure
26218>>>>>>>>>>>>>
26218>>>>>>>>>>>>>    //> All languages that must be supported by the application at hand msut be added by this method. And this must be done before
26218>>>>>>>>>>>>>    //> the first translation is done. The reason is that only the languages supposed to be supported by the application are read
26218>>>>>>>>>>>>>    //> into memory on calling OnDefineSymbols.
26218>>>>>>>>>>>>>    Procedure DoAddLanguage Integer iLng
26220>>>>>>>>>>>>>        Integer iCount iSize
26220>>>>>>>>>>>>>        tSupLng[] aLanguages
26220>>>>>>>>>>>>>        tSupLng[] aLanguages
26221>>>>>>>>>>>>>        If (_StopForAddingLanguages(Self)) Error 783 "Languages cannot be added after cLanguageDictionary objects has been added"
26224>>>>>>>>>>>>>        Else Begin
26225>>>>>>>>>>>>>            Get paLanguages to aLanguages
26226>>>>>>>>>>>>>            Move (SizeOfArray(aLanguages)) to iSize
26227>>>>>>>>>>>>>            If (iLng>=iSize or aLanguages[iLng].bActive=False) Begin
26229>>>>>>>>>>>>>                 Get _piCounter to iCount
26230>>>>>>>>>>>>>                 Move iCount to aLanguages[iLng].iIndex
26231>>>>>>>>>>>>>                 Move True to aLanguages[iLng].bActive
26232>>>>>>>>>>>>>                 Set _piCounter to (iCount+1)
26233>>>>>>>>>>>>>                 Set paLanguages to aLanguages
26234>>>>>>>>>>>>>             End
26234>>>>>>>>>>>>>>
26234>>>>>>>>>>>>>         End
26234>>>>>>>>>>>>>>
26234>>>>>>>>>>>>>    End_Procedure
26235>>>>>>>>>>>>>
26235>>>>>>>>>>>>>    //
26235>>>>>>>>>>>>>    Procedure Set CurrentLanguage Integer iLng
26237>>>>>>>>>>>>>        Move iLng to giLanguage
26238>>>>>>>>>>>>>        Get _IndexToCompressedIndex iLng to gi$CmprLngIdx
26239>>>>>>>>>>>>>    End_Procedure
26240>>>>>>>>>>>>>
26240>>>>>>>>>>>>>    Function CurrentLanguage Returns Integer
26242>>>>>>>>>>>>>        Integer iMax iIndex
26242>>>>>>>>>>>>>        tSupLng[] aLanguages
26242>>>>>>>>>>>>>        tSupLng[] aLanguages
26243>>>>>>>>>>>>>        Get paLanguages to aLanguages
26244>>>>>>>>>>>>>        Move (SizeOfArray(aLanguages)-1) to iMax
26245>>>>>>>>>>>>>        For iIndex from 0 to iMax
26251>>>>>>>>>>>>>>
26251>>>>>>>>>>>>>            If (aLanguages[iIndex].iIndex=gi$CmprLngIdx) Function_Return iIndex
26254>>>>>>>>>>>>>        Loop
26255>>>>>>>>>>>>>>
26255>>>>>>>>>>>>>        Function_Return -1
26256>>>>>>>>>>>>>    End_Function
26257>>>>>>>>>>>>>
26257>>>>>>>>>>>>>    // This may be used by a language selector or by a page where it's possible
26257>>>>>>>>>>>>>    // to edit the values in a database.
26257>>>>>>>>>>>>>    Procedure CallbackSupportedLanguages Integer hMsg Integer hObj
26259>>>>>>>>>>>>>        Integer iMax iLng
26259>>>>>>>>>>>>>        tSupLng[] aLanguages
26259>>>>>>>>>>>>>        tSupLng[] aLanguages
26260>>>>>>>>>>>>>        Get paLanguages to aLanguages
26261>>>>>>>>>>>>>        Move (SizeOfArray(aLanguages)-1) to iMax
26262>>>>>>>>>>>>>        For iLng from 0 to iMax
26268>>>>>>>>>>>>>>
26268>>>>>>>>>>>>>            If (aLanguages[iLng].bActive) Send hMsg of hObj iLng
26271>>>>>>>>>>>>>        Loop
26272>>>>>>>>>>>>>>
26272>>>>>>>>>>>>>    End_Procedure
26273>>>>>>>>>>>>>
26273>>>>>>>>>>>>>    Procedure CallbackDictionaries Integer hMsg Integer hObj
26275>>>>>>>>>>>>>        Integer iMax iIndex
26275>>>>>>>>>>>>>        tLngDictListItem[] aLngDictList
26275>>>>>>>>>>>>>        tLngDictListItem[] aLngDictList
26276>>>>>>>>>>>>>        Get _paLngDictList to aLngDictList
26277>>>>>>>>>>>>>        Move (SizeOfArray(aLngDictList)-1) to iMax
26278>>>>>>>>>>>>>        For iIndex from 0 to iMax
26284>>>>>>>>>>>>>>
26284>>>>>>>>>>>>>            Send hMsg of hObj aLngDictList[iIndex].sDictionaryId aLngDictList[iIndex].hDictionary
26285>>>>>>>>>>>>>        Loop
26286>>>>>>>>>>>>>>
26286>>>>>>>>>>>>>    End_Procedure
26287>>>>>>>>>>>>>
26287>>>>>>>>>>>>>            Function _IndexToCompressedIndex Integer iLng Returns Integer
26289>>>>>>>>>>>>>                tSupLng[] aLanguages
26289>>>>>>>>>>>>>                tSupLng[] aLanguages
26290>>>>>>>>>>>>>                Get paLanguages to aLanguages
26291>>>>>>>>>>>>>                if (SizeOfArray(aLanguages)>iLng) Function_Return aLanguages[iLng].iIndex
26294>>>>>>>>>>>>>                Function_Return 0
26295>>>>>>>>>>>>>            End_Function
26296>>>>>>>>>>>>>
26296>>>>>>>>>>>>>                     Function _Compare_LngDictListItem tLngDictListItem sVal1 tLngDictListItem sVal2 Returns Integer
26298>>>>>>>>>>>>>                         If (sVal1.sDictionaryId>sVal2.sDictionaryId) Function_Return (GT)
26301>>>>>>>>>>>>>                         If (sVal1.sDictionaryId=sVal2.sDictionaryId) Function_Return (EQ)
26304>>>>>>>>>>>>>                         Function_Return (LT)
26305>>>>>>>>>>>>>                     End_Function
26306>>>>>>>>>>>>>
26306>>>>>>>>>>>>>            Function _Search_LngDictListItem_Array tLngDictListItem[] aLngDictList String sDictionaryId Returns Integer
26308>>>>>>>>>>>>>                tLngDictListItem sVal
26308>>>>>>>>>>>>>                tLngDictListItem sVal
26308>>>>>>>>>>>>>                Move sDictionaryId to sVal.sDictionaryId
26309>>>>>>>>>>>>>                Function_Return (SearchArray(sVal,aLngDictList,Self,GET__Compare_LngDictListItem))
26310>>>>>>>>>>>>>            End_Function
26311>>>>>>>>>>>>>
26311>>>>>>>>>>>>>                     Function _Compare_LngDictSymbols tLngDictSymbol sVal1 tLngDictSymbol sVal2 Returns Integer
26313>>>>>>>>>>>>>                         If (sVal1.sSymbol>sVal2.sSymbol) Function_Return (GT)
26316>>>>>>>>>>>>>                         If (sVal1.sSymbol=sVal2.sSymbol) Function_Return (EQ)
26319>>>>>>>>>>>>>                         Function_Return (LT)
26320>>>>>>>>>>>>>                     End_Function
26321>>>>>>>>>>>>>
26321>>>>>>>>>>>>>            Function _Search_LngDictSymbol_Array tLngDictSymbol[] aLngDictSymbols String sSymbol Returns Integer
26323>>>>>>>>>>>>>                tLngDictSymbol sVal
26323>>>>>>>>>>>>>                tLngDictSymbol sVal
26323>>>>>>>>>>>>>                Move sSymbol to sVal.sSymbol
26324>>>>>>>>>>>>>                Function_Return (BinarySearchArray(sVal,aLngDictSymbols,Self,GET__Compare_LngDictSymbols))
26325>>>>>>>>>>>>>            End_Function
26326>>>>>>>>>>>>>
26326>>>>>>>>>>>>>            Procedure _Sort_LngDictSymbols tLngDictSymbol[] ByRef aLngDictSymbols
26328>>>>>>>>>>>>>                Move (SortArray(aLngDictSymbols,Self,GET__Compare_LngDictSymbols)) to aLngDictSymbols
26329>>>>>>>>>>>>>            End_Procedure
26330>>>>>>>>>>>>>
26330>>>>>>>>>>>>>            // Called automatically when defining cLaguageDictionaryObjects
26330>>>>>>>>>>>>>            Procedure _Add_Dictionary_Object Integer hDictionary
26332>>>>>>>>>>>>>                Integer iRow
26332>>>>>>>>>>>>>                String sDictionaryId
26332>>>>>>>>>>>>>                tLngDictListItem[] aLngDics
26332>>>>>>>>>>>>>                tLngDictListItem[] aLngDics
26333>>>>>>>>>>>>>                Get _paLngDictList to aLngDics
26334>>>>>>>>>>>>>                Get psDictionaryId of hDictionary to sDictionaryId
26335>>>>>>>>>>>>>                If (sDictionaryId<>"") Begin
26337>>>>>>>>>>>>>                    Move (SizeOfArray(aLngDics)) to iRow
26338>>>>>>>>>>>>>                    Move (lowercase(sDictionaryId)) to aLngDics[iRow].sDictionaryId
26339>>>>>>>>>>>>>                    Move hDictionary to aLngDics[iRow].hDictionary
26340>>>>>>>>>>>>>                    Set _paLngDictList to aLngDics
26341>>>>>>>>>>>>>                End
26341>>>>>>>>>>>>>>
26341>>>>>>>>>>>>>            End_Procedure
26342>>>>>>>>>>>>>
26342>>>>>>>>>>>>>    // Examples:
26342>>>>>>>>>>>>>    // "ls.button.save"    ->  "Save", TRUE, "lv.23.3"    (not so fast)
26342>>>>>>>>>>>>>    // "lv.23.3"           ->  "Save", FALSE, ""          (fast)
26342>>>>>>>>>>>>>    // "Save"              ->  "Save", FALSE, ""          (fastest, but no point)
26342>>>>>>>>>>>>>    Function TranslateValue String sValue Returns tTranslateResult
26344>>>>>>>>>>>>>        Integer iRow hDictionary iSymbolId
26344>>>>>>>>>>>>>        String sDictionaryId sSymbol
26344>>>>>>>>>>>>>        tTranslateResult sRval
26344>>>>>>>>>>>>>        tTranslateResult sRval
26344>>>>>>>>>>>>>        tLngDictListItem[] aLngDics
26344>>>>>>>>>>>>>        tLngDictListItem[] aLngDics
26345>>>>>>>>>>>>>
26345>>>>>>>>>>>>>        Get _paLngDictList to aLngDics
26346>>>>>>>>>>>>>
26346>>>>>>>>>>>>>        Move False to sRval.bOptimize
26347>>>>>>>>>>>>>
26347>>>>>>>>>>>>>        If (left(sValue,3)="ls.") Begin // Value could be: "ls.buttons.save"
26349>>>>>>>>>>>>>            // It's a "language symbol" and we must translate it into a language value
26349>>>>>>>>>>>>>            Move (replace("ls.",sValue,"")) to sValue // "buttons.save"
26350>>>>>>>>>>>>>            Move (left(sValue,pos(".",sValue)-1)) to sDictionaryId // "buttons"
26351>>>>>>>>>>>>>            //get iFindRow.s sDictionaryId to iRow
26351>>>>>>>>>>>>>            Get _Search_LngDictListItem_Array aLngDics sDictionaryId to iRow
26352>>>>>>>>>>>>>            If (iRow>=0) Begin
26354>>>>>>>>>>>>>                Move aLngDics[iRow].hDictionary to hDictionary
26355>>>>>>>>>>>>>                Move (Replace(sDictionaryId+".",sValue,"")) to sSymbol // "save"
26356>>>>>>>>>>>>>                Get _SymbolToId of hDictionary sSymbol to iSymbolId // The number we're going to use when asking for this value in the future
26357>>>>>>>>>>>>>                Move True to sRval.bOptimize
26358>>>>>>>>>>>>>                Move ("lv."+String(iRow)+"."+String(iSymbolId)) to sRval.sOptimizedLookup
26359>>>>>>>>>>>>>                Get _TranslateItem of hDictionary iSymbolId to sValue // Get actual return value
26360>>>>>>>>>>>>>            End
26360>>>>>>>>>>>>>>
26360>>>>>>>>>>>>>        End
26360>>>>>>>>>>>>>>
26360>>>>>>>>>>>>>        Else Begin
26361>>>>>>>>>>>>>            If (left(sValue,3)="lv.") Begin // Value is: "lv.23.3" (23rd dictionary, 3rd item)
26363>>>>>>>>>>>>>                Move (replace("lv.",sValue,"")) to sValue // "23.3"
26364>>>>>>>>>>>>>                Move (left(sValue,pos(".",sValue)-1)) to iRow // "23"
26365>>>>>>>>>>>>>                Move aLngDics[iRow].hDictionary to hDictionary
26366>>>>>>>>>>>>>                Move (replace(String(iRow)+".",sValue,"")) to iSymbolId // "3"
26367>>>>>>>>>>>>>                Get _TranslateItem of hDictionary iSymbolId to sValue // Get actual return value
26368>>>>>>>>>>>>>            End
26368>>>>>>>>>>>>>>
26368>>>>>>>>>>>>>        End
26368>>>>>>>>>>>>>>
26368>>>>>>>>>>>>>        Move sValue to sRval.sResult
26369>>>>>>>>>>>>>        Function_Return sRval
26370>>>>>>>>>>>>>    End_Function
26371>>>>>>>>>>>>>
26371>>>>>>>>>>>>>    Function Translate String sSymbol Returns String
26373>>>>>>>>>>>>>        tTranslateResult stResult
26373>>>>>>>>>>>>>        tTranslateResult stResult
26373>>>>>>>>>>>>>        Get TranslateValue sSymbol to stResult
26374>>>>>>>>>>>>>        Function_Return stResult.sResult
26375>>>>>>>>>>>>>    End_Function
26376>>>>>>>>>>>>>
26376>>>>>>>>>>>>>    Function DictionaryHandle String sDictionaryId Returns Integer
26378>>>>>>>>>>>>>        Integer iIndex
26378>>>>>>>>>>>>>        tLngDictListItem[] aLngDics
26378>>>>>>>>>>>>>        tLngDictListItem[] aLngDics
26379>>>>>>>>>>>>>
26379>>>>>>>>>>>>>        Get _paLngDictList to aLngDics
26380>>>>>>>>>>>>>        Get _Search_LngDictListItem_Array aLngDics sDictionaryId to iIndex
26381>>>>>>>>>>>>>        If (iIndex>=0) Function_Return aLngDics[iIndex].hDictionary
26384>>>>>>>>>>>>>        Function_Return 0
26385>>>>>>>>>>>>>    End_Function
26386>>>>>>>>>>>>>
26386>>>>>>>>>>>>>End_Class // cLanguageFunctions
26387>>>>>>>>>>>>>
26387>>>>>>>>>>>>>Global_Variable Integer oLanguageFunctions
26387>>>>>>>>>>>>>
26387>>>>>>>>>>>>>Object _oLanguageFunctions is a _cLanguageFunctions
26389>>>>>>>>>>>>>    Move Self to oLanguageFunctions
26390>>>>>>>>>>>>>End_Object
26391>>>>>>>>>>>>>
26391>>>>>>>>>>>>>Class cLanguageDictionary is a cObject
26392>>>>>>>>>>>>>    Procedure construct_object
26394>>>>>>>>>>>>>        Forward Send construct_object
26396>>>>>>>>>>>>>
26396>>>>>>>>>>>>>        Property String  psDictionaryId "" // Name of the dictionary,
26397>>>>>>>>>>>>>
26397>>>>>>>>>>>>>        //> If a value returns blank, the default behavior is to try the default
26397>>>>>>>>>>>>>        //> language (LNG_DEFAULT).
26397>>>>>>>>>>>>>        Property Integer piDefaultLanguage LNG_DEFAULT // -1: No default languages (=blank values are OK)
26398>>>>>>>>>>>>>
26398>>>>>>>>>>>>>                 Property Boolean pbLoadData True
26399>>>>>>>>>>>>>
26399>>>>>>>>>>>>>                 // These are used internally to optimize the process of adding
26399>>>>>>>>>>>>>                 Property String  _PreviousSymbol ""
26400>>>>>>>>>>>>>                 Property Integer _PreviousIndex 0
26401>>>>>>>>>>>>>
26401>>>>>>>>>>>>>        Property tLngDictSymbol[] paSymbols
26402>>>>>>>>>>>>>    End_Procedure
26403>>>>>>>>>>>>>
26403>>>>>>>>>>>>>    Procedure OnDefineSymbols
26405>>>>>>>>>>>>>    End_Procedure
26406>>>>>>>>>>>>>
26406>>>>>>>>>>>>>    // Translate symbol into a unique item id (item no in array or other integer id)
26406>>>>>>>>>>>>>    Function _SymbolToId String sSymbol Returns Integer
26408>>>>>>>>>>>>>        Integer iItem
26408>>>>>>>>>>>>>        tLngDictSymbol[] aSymbols
26408>>>>>>>>>>>>>        tLngDictSymbol[] aSymbols
26409>>>>>>>>>>>>>        Get paSymbols to aSymbols
26410>>>>>>>>>>>>>        If (pbLoadData(Self)) Begin // If array is empty
26412>>>>>>>>>>>>>            Set pbLoadData to False
26413>>>>>>>>>>>>>            Set _StopForAddingLanguages of oLanguageFunctions to True
26414>>>>>>>>>>>>>            Send OnDefineSymbols // Fill array
26415>>>>>>>>>>>>>            Get paSymbols to aSymbols
26416>>>>>>>>>>>>>            Send _Sort_LngDictSymbols of oLanguageFunctions (&aSymbols) // Prepare for BinarySearchArray
26417>>>>>>>>>>>>>            Set paSymbols to aSymbols
26418>>>>>>>>>>>>>        End
26418>>>>>>>>>>>>>>
26418>>>>>>>>>>>>>        Get _Search_LngDictSymbol_Array of oLanguageFunctions aSymbols sSymbol to iItem
26419>>>>>>>>>>>>>        Function_Return iItem
26420>>>>>>>>>>>>>    End_Function
26421>>>>>>>>>>>>>
26421>>>>>>>>>>>>>    Function _TranslateItem Integer iSymbolId Returns String
26423>>>>>>>>>>>>>        Integer iCmprLngIdx iMaxIndex
26423>>>>>>>>>>>>>        String sValue
26423>>>>>>>>>>>>>        tLngDictSymbol[] aSymbols
26423>>>>>>>>>>>>>        tLngDictSymbol[] aSymbols
26424>>>>>>>>>>>>>        Get paSymbols to aSymbols
26425>>>>>>>>>>>>>
26425>>>>>>>>>>>>>        Move (SizeOfArray(aSymbols[iSymbolId].sTranslations)-1) to iMaxIndex
26426>>>>>>>>>>>>>
26426>>>>>>>>>>>>>        // First we try the straight way:
26426>>>>>>>>>>>>>        If (gi$CmprLngIdx<=iMaxIndex) Move aSymbols[iSymbolId].sTranslations[gi$CmprLngIdx] to sValue
26429>>>>>>>>>>>>>        Else Move "" to sValue
26431>>>>>>>>>>>>>
26431>>>>>>>>>>>>>        If (sValue="") Begin // This didn't give us a value to return
26433>>>>>>>>>>>>>            // We'll therefore try to get a value using the default language of the application:
26433>>>>>>>>>>>>>            Get _IndexToCompressedIndex of oLanguageFunctions LNG_DEFAULT to iCmprLngIdx
26434>>>>>>>>>>>>>            If (iCmprLngIdx>=0) Begin
26436>>>>>>>>>>>>>                If (iCmprLngIdx<=iMaxIndex) Move aSymbols[iSymbolId].sTranslations[iCmprLngIdx] to sValue
26439>>>>>>>>>>>>>                Else Move "" to sValue
26441>>>>>>>>>>>>>            End
26441>>>>>>>>>>>>>>
26441>>>>>>>>>>>>>
26441>>>>>>>>>>>>>            If (sValue="") Begin // This didn't give us a value either.
26443>>>>>>>>>>>>>                  // We will therefore now try to get the value of default language of the dictionary:
26443>>>>>>>>>>>>>                  If (piDefaultLanguage(Self)>=0) Begin
26445>>>>>>>>>>>>>                      Get _IndexToCompressedIndex of oLanguageFunctions (piDefaultLanguage(Self)) to iCmprLngIdx
26446>>>>>>>>>>>>>                      If (iCmprLngIdx>=0) begin
26448>>>>>>>>>>>>>                          If (iCmprLngIdx<=iMaxIndex) Move aSymbols[iSymbolId].sTranslations[iCmprLngIdx] to sValue
26451>>>>>>>>>>>>>                          Else Move "" to sValue
26453>>>>>>>>>>>>>                      End
26453>>>>>>>>>>>>>>
26453>>>>>>>>>>>>>                  End
26453>>>>>>>>>>>>>>
26453>>>>>>>>>>>>>
26453>>>>>>>>>>>>>                  If (sValue="") Begin // The default language of this LanguageDictionary is not part of the supported languages
26455>>>>>>>>>>>>>                      // As a last resort we will therefore try to get the value from the default column of the object
26455>>>>>>>>>>>>>                      Move aSymbols[iSymbolId].sDefaultTranslation to sValue
26456>>>>>>>>>>>>>                  End
26456>>>>>>>>>>>>>>
26456>>>>>>>>>>>>>            End
26456>>>>>>>>>>>>>>
26456>>>>>>>>>>>>>        End
26456>>>>>>>>>>>>>>
26456>>>>>>>>>>>>>
26456>>>>>>>>>>>>>        Function_Return sValue
26457>>>>>>>>>>>>>    End_Function
26458>>>>>>>>>>>>>
26458>>>>>>>>>>>>>            Function _SymbolToIdOrCreate String sSymbol Returns Integer // Private
26460>>>>>>>>>>>>>                Integer iSymbolId iItem
26460>>>>>>>>>>>>>                tLngDictSymbol[] aSymbols
26460>>>>>>>>>>>>>                tLngDictSymbol[] aSymbols
26461>>>>>>>>>>>>>
26461>>>>>>>>>>>>>                Get _SymbolToId sSymbol to iSymbolId
26462>>>>>>>>>>>>>                If (iSymbolId=-1) Begin
26464>>>>>>>>>>>>>                    Get paSymbols to aSymbols
26465>>>>>>>>>>>>>                    Move (SizeOfArray(aSymbols)) to iSymbolId
26466>>>>>>>>>>>>>                    Move sSymbol to aSymbols[iSymbolId].sSymbol
26467>>>>>>>>>>>>>                    Set paSymbols to aSymbols
26468>>>>>>>>>>>>>                End
26468>>>>>>>>>>>>>>
26468>>>>>>>>>>>>>                Function_Return iSymbolId
26469>>>>>>>>>>>>>            End_Function
26470>>>>>>>>>>>>>
26470>>>>>>>>>>>>>    Procedure Set Language_Value String sSymbol Integer iLng String sValue
26472>>>>>>>>>>>>>        Integer iCmprLngIdx iSymbolId
26472>>>>>>>>>>>>>        tLngDictSymbol[] aSymbols
26472>>>>>>>>>>>>>        tLngDictSymbol[] aSymbols
26473>>>>>>>>>>>>>        Get paSymbols to aSymbols
26474>>>>>>>>>>>>>
26474>>>>>>>>>>>>>        Get _IndexToCompressedIndex of oLanguageFunctions iLng to iCmprLngIdx
26475>>>>>>>>>>>>>        If (iCmprLngIdx>=0) Begin // If language is supported by this application
26477>>>>>>>>>>>>>            Move (lowercase(sSymbol)) to sSymbol
26478>>>>>>>>>>>>>            If (sSymbol=_PreviousSymbol(Self)) Begin // It's the same symbol => we reuse its position
26480>>>>>>>>>>>>>                Get _PreviousIndex to iSymbolId
26481>>>>>>>>>>>>>            End
26481>>>>>>>>>>>>>>
26481>>>>>>>>>>>>>            Else Begin
26482>>>>>>>>>>>>>                Get _SymbolToIdOrCreate sSymbol to iSymbolId
26483>>>>>>>>>>>>>                Move sSymbol to aSymbols[iSymbolId].sSymbol
26484>>>>>>>>>>>>>                Set _PreviousIndex to iSymbolId
26485>>>>>>>>>>>>>                Set _PreviousSymbol to sSymbol
26486>>>>>>>>>>>>>            End
26486>>>>>>>>>>>>>>
26486>>>>>>>>>>>>>            Move sValue to aSymbols[iSymbolId].sTranslations[iCmprLngIdx]
26487>>>>>>>>>>>>>        End
26487>>>>>>>>>>>>>>
26487>>>>>>>>>>>>>        Else Begin // The language is not supported by the application.
26488>>>>>>>>>>>>>            // However, if the language passed is the default language of the
26488>>>>>>>>>>>>>            // language dictionary, we'll put the value in the default column.
26488>>>>>>>>>>>>>            If (iLng=piDefaultLanguage(Self)) begin
26490>>>>>>>>>>>>>                Move sSymbol to aSymbols[iSymbolId].sSymbol
26491>>>>>>>>>>>>>                Move sValue to aSymbols[iSymbolId].sDefaultTranslation
26492>>>>>>>>>>>>>            End
26492>>>>>>>>>>>>>>
26492>>>>>>>>>>>>>        End
26492>>>>>>>>>>>>>>
26492>>>>>>>>>>>>>        Set paSymbols to aSymbols
26493>>>>>>>>>>>>>    End_Procedure
26494>>>>>>>>>>>>>
26494>>>>>>>>>>>>>    Procedure CallbackSymbols Integer hMsg Integer hObj
26496>>>>>>>>>>>>>        Integer iMax iIndex
26496>>>>>>>>>>>>>        String sSymbol sValue
26496>>>>>>>>>>>>>        tLngDictSymbol[] aSymbols
26496>>>>>>>>>>>>>        tLngDictSymbol[] aSymbols
26497>>>>>>>>>>>>>
26497>>>>>>>>>>>>>        If (pbLoadData(Self)) Get _SymbolToId "dummy" to iIndex // Load symbols if not already loaded
26500>>>>>>>>>>>>>
26500>>>>>>>>>>>>>        Get paSymbols to aSymbols
26501>>>>>>>>>>>>>        Move (SizeOfArray(aSymbols)-1) to iMax
26502>>>>>>>>>>>>>        For iIndex from 0 to iMax
26508>>>>>>>>>>>>>>
26508>>>>>>>>>>>>>            Move ("ls."+psDictionaryId(Self)+"."+aSymbols[iIndex].sSymbol) to sSymbol
26509>>>>>>>>>>>>>            Get Translate of oLanguageFunctions sSymbol to sValue
26510>>>>>>>>>>>>>            Send hMsg of hObj sSymbol sValue
26511>>>>>>>>>>>>>        Loop
26512>>>>>>>>>>>>>>
26512>>>>>>>>>>>>>    End_Procedure
26513>>>>>>>>>>>>>
26513>>>>>>>>>>>>>    Procedure end_construct_object
26515>>>>>>>>>>>>>        Forward Send end_construct_object
26517>>>>>>>>>>>>>        Send _Add_Dictionary_Object of oLanguageFunctions Self // Register with global list of language dictionaries
26518>>>>>>>>>>>>>    End_Procedure
26519>>>>>>>>>>>>>End_Class // cLanguageDictionary
26520>>>>>>>>>>>>>
26520>>>>>>>>>>>>>Global_Variable Integer oLanguageLD
26520>>>>>>>>>>>>>
26520>>>>>>>>>>>>>Object _oLanguageLD is a cLanguageDictionary
26522>>>>>>>>>>>>>    Move Self to oLanguageLD
26523>>>>>>>>>>>>>    Set psDictionaryId to "lng"
26524>>>>>>>>>>>>>    Set piDefaultLanguage to LNG_ENGLISH
26525>>>>>>>>>>>>>
26525>>>>>>>>>>>>>    Procedure OnDefineSymbols
26528>>>>>>>>>>>>>        Set Language_Value "language"   LNG_DUTCH      to "Taal"
26529>>>>>>>>>>>>>      //Set Language_Value "language"   LNG_ITALIAN    to
26529>>>>>>>>>>>>>      //Set Language_Value "language"   LNG_SPANISH    to
26529>>>>>>>>>>>>>        Set Language_Value "language"   LNG_ENGLISH    to "Language"
26530>>>>>>>>>>>>>        Set Language_Value "language"   LNG_DANISH     to "Sprog"
26531>>>>>>>>>>>>>        Set Language_Value "language"   LNG_SWEDISH    to "Sprk"
26532>>>>>>>>>>>>>        Set Language_Value "language"   LNG_NORWEGIAN  to "Sprog"
26533>>>>>>>>>>>>>        Set Language_Value "language"   LNG_GERMAN     to "Sprache"
26534>>>>>>>>>>>>>      //Set Language_Value "language"   LNG_PORTUGUESE to
26534>>>>>>>>>>>>>      //Set Language_Value "language"   LNG_FRENCH     to
26534>>>>>>>>>>>>>
26534>>>>>>>>>>>>>        Set Language_Value "dutch"      LNG_DUTCH      to "Nederlands"
26535>>>>>>>>>>>>>      //Set Language_Value "dutch"      LNG_ITALIAN    to
26535>>>>>>>>>>>>>      //Set Language_Value "dutch"      LNG_SPANISH    to
26535>>>>>>>>>>>>>        Set Language_Value "dutch"      LNG_ENGLISH    to "Dutch"
26536>>>>>>>>>>>>>        Set Language_Value "dutch"      LNG_DANISH     to "Hollandsk"
26537>>>>>>>>>>>>>        Set Language_Value "dutch"      LNG_SWEDISH    to "Hollandska"
26538>>>>>>>>>>>>>      //Set Language_Value "dutch"      LNG_NORWEGIAN  to ""
26538>>>>>>>>>>>>>      //Set Language_Value "dutch"      LNG_GERMAN     to ""
26538>>>>>>>>>>>>>      //Set Language_Value "dutch"      LNG_PORTUGUESE to ""
26538>>>>>>>>>>>>>      //Set Language_Value "dutch"      LNG_FRENCH     to ""
26538>>>>>>>>>>>>>
26538>>>>>>>>>>>>>      //Set Language_Value "danish"     LNG_DUTCH      to ""
26538>>>>>>>>>>>>>      //Set Language_Value "danish"     LNG_ITALIAN    to
26538>>>>>>>>>>>>>      //Set Language_Value "danish"     LNG_SPANISH    to
26538>>>>>>>>>>>>>        Set Language_Value "danish"     LNG_ENGLISH    to "Danish"
26539>>>>>>>>>>>>>        Set Language_Value "danish"     LNG_DANISH     to "Dansk"
26540>>>>>>>>>>>>>        Set Language_Value "danish"     LNG_SWEDISH    to "Danska"
26541>>>>>>>>>>>>>      //Set Language_Value "danish"     LNG_NORWEGIAN  to ""
26541>>>>>>>>>>>>>      //Set Language_Value "danish"     LNG_GERMAN     to ""
26541>>>>>>>>>>>>>      //Set Language_Value "danish"     LNG_PORTUGUESE to ""
26541>>>>>>>>>>>>>      //Set Language_Value "danish"     LNG_FRENCH     to ""
26541>>>>>>>>>>>>>
26541>>>>>>>>>>>>>      //Set Language_Value "english"    LNG_DUTCH      to ""
26541>>>>>>>>>>>>>      //Set Language_Value "english"    LNG_ITALIAN    to
26541>>>>>>>>>>>>>      //Set Language_Value "english"    LNG_SPANISH    to
26541>>>>>>>>>>>>>        Set Language_Value "english"    LNG_ENGLISH    to "English"
26542>>>>>>>>>>>>>        Set Language_Value "english"    LNG_DANISH     to "Engelsk"
26543>>>>>>>>>>>>>        Set Language_Value "english"    LNG_SWEDISH    to "Engelska"
26544>>>>>>>>>>>>>      //Set Language_Value "english"    LNG_NORWEGIAN  to ""
26544>>>>>>>>>>>>>      //Set Language_Value "english"    LNG_GERMAN     to ""
26544>>>>>>>>>>>>>      //Set Language_Value "english"    LNG_PORTUGUESE to ""
26544>>>>>>>>>>>>>      //Set Language_Value "english"    LNG_FRENCH     to ""
26544>>>>>>>>>>>>>
26544>>>>>>>>>>>>>      //Set Language_Value "french"     LNG_DUTCH      to ""
26544>>>>>>>>>>>>>      //Set Language_Value "french"     LNG_ITALIAN    to
26544>>>>>>>>>>>>>      //Set Language_Value "french"     LNG_SPANISH    to
26544>>>>>>>>>>>>>        Set Language_Value "french"     LNG_ENGLISH    to "French"
26545>>>>>>>>>>>>>        Set Language_Value "french"     LNG_DANISH     to "Fransk"
26546>>>>>>>>>>>>>        Set Language_Value "french"     LNG_SWEDISH    to "Franska"
26547>>>>>>>>>>>>>      //Set Language_Value "french"     LNG_NORWEGIAN  to ""
26547>>>>>>>>>>>>>      //Set Language_Value "french"     LNG_GERMAN     to ""
26547>>>>>>>>>>>>>      //Set Language_Value "french"     LNG_PORTUGUESE to ""
26547>>>>>>>>>>>>>      //Set Language_Value "french"     LNG_FRENCH     to ""
26547>>>>>>>>>>>>>
26547>>>>>>>>>>>>>      //Set Language_Value "german"     LNG_DUTCH      to ""
26547>>>>>>>>>>>>>      //Set Language_Value "german"     LNG_ITALIAN    to
26547>>>>>>>>>>>>>      //Set Language_Value "german"     LNG_SPANISH    to
26547>>>>>>>>>>>>>        Set Language_Value "german"     LNG_ENGLISH    to "German"
26548>>>>>>>>>>>>>        Set Language_Value "german"     LNG_DANISH     to "Tysk"
26549>>>>>>>>>>>>>        Set Language_Value "german"     LNG_SWEDISH    to "Tyska"
26550>>>>>>>>>>>>>      //Set Language_Value "german"     LNG_NORWEGIAN  to ""
26550>>>>>>>>>>>>>      //Set Language_Value "german"     LNG_GERMAN     to ""
26550>>>>>>>>>>>>>      //Set Language_Value "german"     LNG_PORTUGUESE to ""
26550>>>>>>>>>>>>>      //Set Language_Value "german"     LNG_FRENCH     to ""
26550>>>>>>>>>>>>>
26550>>>>>>>>>>>>>      //Set Language_Value "italian"    LNG_DUTCH      to ""
26550>>>>>>>>>>>>>      //Set Language_Value "italian"    LNG_ITALIAN    to
26550>>>>>>>>>>>>>      //Set Language_Value "italian"    LNG_SPANISH    to
26550>>>>>>>>>>>>>        Set Language_Value "italian"    LNG_ENGLISH    to "Italian"
26551>>>>>>>>>>>>>        Set Language_Value "italian"    LNG_DANISH     to "Italiensk"
26552>>>>>>>>>>>>>        Set Language_Value "italian"    LNG_SWEDISH    to "Italienska"
26553>>>>>>>>>>>>>      //Set Language_Value "italian"    LNG_NORWEGIAN  to ""
26553>>>>>>>>>>>>>      //Set Language_Value "italian"    LNG_GERMAN     to ""
26553>>>>>>>>>>>>>      //Set Language_Value "italian"    LNG_PORTUGUESE to ""
26553>>>>>>>>>>>>>      //Set Language_Value "italian"    LNG_FRENCH     to ""
26553>>>>>>>>>>>>>
26553>>>>>>>>>>>>>      //Set Language_Value "norwegian"  LNG_DUTCH      to ""
26553>>>>>>>>>>>>>      //Set Language_Value "norwegian"  LNG_ITALIAN    to
26553>>>>>>>>>>>>>      //Set Language_Value "norwegian"  LNG_SPANISH    to
26553>>>>>>>>>>>>>        Set Language_Value "norwegian"  LNG_ENGLISH    to "Norwegian"
26554>>>>>>>>>>>>>        Set Language_Value "norwegian"  LNG_DANISH     to "Norsk"
26555>>>>>>>>>>>>>        Set Language_Value "norwegian"  LNG_SWEDISH    to "Norska"
26556>>>>>>>>>>>>>      //Set Language_Value "norwegian"  LNG_NORWEGIAN  to ""
26556>>>>>>>>>>>>>      //Set Language_Value "norwegian"  LNG_GERMAN     to ""
26556>>>>>>>>>>>>>      //Set Language_Value "norwegian"  LNG_PORTUGUESE to ""
26556>>>>>>>>>>>>>      //Set Language_Value "norwegian"  LNG_FRENCH     to ""
26556>>>>>>>>>>>>>
26556>>>>>>>>>>>>>      //Set Language_Value "portuguese" LNG_DUTCH      to ""
26556>>>>>>>>>>>>>      //Set Language_Value "portuguese" LNG_ITALIAN    to
26556>>>>>>>>>>>>>      //Set Language_Value "portuguese" LNG_SPANISH    to
26556>>>>>>>>>>>>>        Set Language_Value "portuguese" LNG_ENGLISH    to "Portuguese"
26557>>>>>>>>>>>>>        Set Language_Value "portuguese" LNG_DANISH     to "Portugisisk"
26558>>>>>>>>>>>>>        Set Language_Value "portuguese" LNG_SWEDISH    to "Portugisiska"
26559>>>>>>>>>>>>>      //Set Language_Value "portuguese" LNG_NORWEGIAN  to ""
26559>>>>>>>>>>>>>      //Set Language_Value "portuguese" LNG_GERMAN     to ""
26559>>>>>>>>>>>>>      //Set Language_Value "portuguese" LNG_PORTUGUESE to ""
26559>>>>>>>>>>>>>      //Set Language_Value "portuguese" LNG_FRENCH     to ""
26559>>>>>>>>>>>>>
26559>>>>>>>>>>>>>      //Set Language_Value "spanish"    LNG_DUTCH      to ""
26559>>>>>>>>>>>>>      //Set Language_Value "spanish"    LNG_ITALIAN    to
26559>>>>>>>>>>>>>      //Set Language_Value "spanish"    LNG_SPANISH    to
26559>>>>>>>>>>>>>        Set Language_Value "spanish"    LNG_ENGLISH    to "Spanish"
26560>>>>>>>>>>>>>        Set Language_Value "spanish"    LNG_DANISH     to "Spansk"
26561>>>>>>>>>>>>>        Set Language_Value "spanish"    LNG_SWEDISH    to "Spanska"
26562>>>>>>>>>>>>>      //Set Language_Value "spanish"    LNG_NORWEGIAN  to ""
26562>>>>>>>>>>>>>      //Set Language_Value "spanish"    LNG_GERMAN     to ""
26562>>>>>>>>>>>>>      //Set Language_Value "spanish"    LNG_PORTUGUESE to ""
26562>>>>>>>>>>>>>      //Set Language_Value "spanish"    LNG_FRENCH     to ""
26562>>>>>>>>>>>>>
26562>>>>>>>>>>>>>      //Set Language_Value "swedish"    LNG_DUTCH      to ""
26562>>>>>>>>>>>>>      //Set Language_Value "swedish"    LNG_ITALIAN    to
26562>>>>>>>>>>>>>      //Set Language_Value "swedish"    LNG_SPANISH    to
26562>>>>>>>>>>>>>        Set Language_Value "swedish"    LNG_ENGLISH    to "Swedish"
26563>>>>>>>>>>>>>        Set Language_Value "swedish"    LNG_DANISH     to "Svensk"
26564>>>>>>>>>>>>>        Set Language_Value "swedish"    LNG_SWEDISH    to "Svenska"
26565>>>>>>>>>>>>>      //Set Language_Value "swedish"    LNG_NORWEGIAN  to ""
26565>>>>>>>>>>>>>      //Set Language_Value "swedish"    LNG_GERMAN     to ""
26565>>>>>>>>>>>>>      //Set Language_Value "swedish"    LNG_PORTUGUESE to ""
26565>>>>>>>>>>>>>      //Set Language_Value "swedish"    LNG_FRENCH     to ""
26565>>>>>>>>>>>>>    End_Procedure
26566>>>>>>>>>>>>>
26566>>>>>>>>>>>>>    Function LanguageSymbolId Integer iLng Returns String
26569>>>>>>>>>>>>>        If (iLng=LNG_DUTCH)      Function_Return "ls.lng.dutch"
26572>>>>>>>>>>>>>        If (iLng=LNG_FRENCH)     Function_Return "ls.lng.french"
26575>>>>>>>>>>>>>        If (iLng=LNG_SPANISH)    Function_Return "ls.lng.spanish"
26578>>>>>>>>>>>>>        If (iLng=LNG_ITALIAN)    Function_Return "ls.lng.italian"
26581>>>>>>>>>>>>>        If (iLng=LNG_ENGLISH)    Function_Return "ls.lng.english"
26584>>>>>>>>>>>>>        If (iLng=LNG_DANISH)     Function_Return "ls.lng.danish"
26587>>>>>>>>>>>>>        If (iLng=LNG_SWEDISH)    Function_Return "ls.lng.swedish"
26590>>>>>>>>>>>>>        If (iLng=LNG_NORWEGIAN)  Function_Return "ls.lng.norwegian"
26593>>>>>>>>>>>>>        If (iLng=LNG_GERMAN)     Function_Return "ls.lng.german"
26596>>>>>>>>>>>>>        If (iLng=LNG_PORTUGUESE) Function_Return "ls.lng.portuguese"
26599>>>>>>>>>>>>>    End_Function
26600>>>>>>>>>>>>>End_Object // oLanguageLD
26601>>>>>>>>>>>>>
26601>>>>>>>>>>>>>Class cStringConstantsArray is an Array
26602>>>>>>>>>>>>>    Procedure Construct_Object
26604>>>>>>>>>>>>>        Forward Send Construct_Object
26606>>>>>>>>>>>>>        Set Delegation_Mode to Delegate_To_Parent
26607>>>>>>>>>>>>>    End_Procedure
26608>>>>>>>>>>>>>    Function Value Integer iItem Returns String
26610>>>>>>>>>>>>>        String sValue
26610>>>>>>>>>>>>>        tTranslateResult stTranslateResult
26610>>>>>>>>>>>>>        tTranslateResult stTranslateResult
26610>>>>>>>>>>>>>
26610>>>>>>>>>>>>>        Forward Get value iItem to sValue
26612>>>>>>>>>>>>>
26612>>>>>>>>>>>>>        Get TranslateValue of oLanguageFunctions sValue to stTranslateResult
26613>>>>>>>>>>>>>
26613>>>>>>>>>>>>>        If (stTranslateResult.bOptimize) Set Value iItem to stTranslateResult.sOptimizedLookup
26616>>>>>>>>>>>>>        Function_Return stTranslateResult.sResult
26617>>>>>>>>>>>>>    End_Function
26618>>>>>>>>>>>>>End_Class
26619>>>>>>>>>>>
26619>>>>>>>>>>>Object oDatesLD is a cLanguageDictionary
26621>>>>>>>>>>>    Set psDictionaryId to "date"
26622>>>>>>>>>>>    Set piDefaultLanguage to LNG_DEFAULT // Not necessary. But now we know that there is such a thing.
26623>>>>>>>>>>>
26623>>>>>>>>>>>    Procedure OnDefineSymbols
26626>>>>>>>>>>>        Set Language_Value "calendar"  LNG_DUTCH      to "Kalender"
26627>>>>>>>>>>>        Set Language_Value "calendar"  LNG_ITALIAN    to "Calendario"
26628>>>>>>>>>>>        Set Language_Value "calendar"  LNG_SPANISH    to "Calendario"
26629>>>>>>>>>>>        Set Language_Value "calendar"  LNG_ENGLISH    to "Calendar"
26630>>>>>>>>>>>        Set Language_Value "calendar"  LNG_DANISH     to "Kalender"
26631>>>>>>>>>>>        Set Language_Value "calendar"  LNG_SWEDISH    to "Kalender"
26632>>>>>>>>>>>        Set Language_Value "calendar"  LNG_NORWEGIAN  to "Kalender"
26633>>>>>>>>>>>        Set Language_Value "calendar"  LNG_GERMAN     to "Kalender"
26634>>>>>>>>>>>        Set Language_Value "calendar"  LNG_PORTUGUESE to "Calendrio"
26635>>>>>>>>>>>        Set Language_Value "calendar"  LNG_FRENCH     to "Calendrier"
26636>>>>>>>>>>>        
26636>>>>>>>>>>>        Set Language_Value "day"       LNG_DUTCH      to "Dag"
26637>>>>>>>>>>>        Set Language_Value "day"       LNG_ITALIAN    to "Giorno"
26638>>>>>>>>>>>        Set Language_Value "day"       LNG_SPANISH    to "Da"
26639>>>>>>>>>>>        Set Language_Value "day"       LNG_ENGLISH    to "Day"
26640>>>>>>>>>>>        Set Language_Value "day"       LNG_DANISH     to "Dag"
26641>>>>>>>>>>>        Set Language_Value "day"       LNG_SWEDISH    to "Dag"
26642>>>>>>>>>>>        Set Language_Value "day"       LNG_NORWEGIAN  to "Dag"
26643>>>>>>>>>>>        Set Language_Value "day"       LNG_GERMAN     to "Tag"
26644>>>>>>>>>>>        Set Language_Value "day"       LNG_PORTUGUESE to "Day"
26645>>>>>>>>>>>        Set Language_Value "day"       LNG_FRENCH     to "Jour"
26646>>>>>>>>>>>        
26646>>>>>>>>>>>        Set Language_Value "month"     LNG_DUTCH      to "Maand"
26647>>>>>>>>>>>        Set Language_Value "month"     LNG_ITALIAN    to "Mese"
26648>>>>>>>>>>>        Set Language_Value "month"     LNG_SPANISH    to "Mes"
26649>>>>>>>>>>>        Set Language_Value "month"     LNG_ENGLISH    to "Month"
26650>>>>>>>>>>>        Set Language_Value "month"     LNG_DANISH     to "Mned"
26651>>>>>>>>>>>        Set Language_Value "month"     LNG_SWEDISH    to "Mnad"
26652>>>>>>>>>>>        Set Language_Value "month"     LNG_NORWEGIAN  to "Mned"
26653>>>>>>>>>>>        Set Language_Value "month"     LNG_GERMAN     to "Monat"
26654>>>>>>>>>>>        Set Language_Value "month"     LNG_PORTUGUESE to "Ms"
26655>>>>>>>>>>>        Set Language_Value "month"     LNG_FRENCH     to "Mois"
26656>>>>>>>>>>>        
26656>>>>>>>>>>>        Set Language_Value "week"      LNG_DUTCH      to "Wk."
26657>>>>>>>>>>>        Set Language_Value "week"      LNG_ITALIAN    to "Set."
26658>>>>>>>>>>>        Set Language_Value "week"      LNG_SPANISH    to "Sem"
26659>>>>>>>>>>>        Set Language_Value "week"      LNG_ENGLISH    to "Wk."
26660>>>>>>>>>>>        Set Language_Value "week"      LNG_DANISH     to "Uge"
26661>>>>>>>>>>>        Set Language_Value "week"      LNG_SWEDISH    to "Vck"
26662>>>>>>>>>>>        Set Language_Value "week"      LNG_NORWEGIAN  to "Uke"
26663>>>>>>>>>>>        Set Language_Value "week"      LNG_GERMAN     to "Wo."
26664>>>>>>>>>>>        Set Language_Value "week"      LNG_PORTUGUESE to "Sem."
26665>>>>>>>>>>>        Set Language_Value "week"      LNG_FRENCH     to "Sem."
26666>>>>>>>>>>>
26666>>>>>>>>>>>        Set Language_Value "year"      LNG_DUTCH      to "Jaar"
26667>>>>>>>>>>>        Set Language_Value "year"      LNG_ITALIAN    to "Anno"
26668>>>>>>>>>>>        Set Language_Value "year"      LNG_SPANISH    to "Ao"
26669>>>>>>>>>>>        Set Language_Value "year"      LNG_ENGLISH    to "Year"
26670>>>>>>>>>>>        Set Language_Value "year"      LNG_DANISH     to "r"
26671>>>>>>>>>>>        Set Language_Value "year"      LNG_SWEDISH    to "r"
26672>>>>>>>>>>>        Set Language_Value "year"      LNG_NORWEGIAN  to "r"
26673>>>>>>>>>>>        Set Language_Value "year"      LNG_GERMAN     to "Jahr"
26674>>>>>>>>>>>        Set Language_Value "year"      LNG_PORTUGUESE to "Ano"
26675>>>>>>>>>>>        Set Language_Value "year"      LNG_FRENCH     to "Anne"
26676>>>>>>>>>>>        
26676>>>>>>>>>>>        Set Language_Value "january"   LNG_DUTCH      to "Januari"
26677>>>>>>>>>>>        Set Language_Value "january"   LNG_ITALIAN    to "Gennaio"
26678>>>>>>>>>>>        Set Language_Value "january"   LNG_SPANISH    to "Enero"
26679>>>>>>>>>>>        Set Language_Value "january"   LNG_ENGLISH    to "January"
26680>>>>>>>>>>>        Set Language_Value "january"   LNG_DANISH     to "Januar"
26681>>>>>>>>>>>        Set Language_Value "january"   LNG_SWEDISH    to "Januari"
26682>>>>>>>>>>>        Set Language_Value "january"   LNG_NORWEGIAN  to "Januar"
26683>>>>>>>>>>>        Set Language_Value "january"   LNG_GERMAN     to "Januar"
26684>>>>>>>>>>>        Set Language_Value "january"   LNG_PORTUGUESE to "Janeiro"
26685>>>>>>>>>>>        Set Language_Value "january"   LNG_FRENCH     to "Janvier"
26686>>>>>>>>>>>        
26686>>>>>>>>>>>        Set Language_Value "february"  LNG_DUTCH      to "Februari"
26687>>>>>>>>>>>        Set Language_Value "february"  LNG_ITALIAN    to "Febbraio"
26688>>>>>>>>>>>        Set Language_Value "february"  LNG_SPANISH    to "Febrero"
26689>>>>>>>>>>>        Set Language_Value "february"  LNG_ENGLISH    to "February"
26690>>>>>>>>>>>        Set Language_Value "february"  LNG_DANISH     to "Februar"
26691>>>>>>>>>>>        Set Language_Value "february"  LNG_SWEDISH    to "Februari"
26692>>>>>>>>>>>        Set Language_Value "february"  LNG_NORWEGIAN  to "Februar"
26693>>>>>>>>>>>        Set Language_Value "february"  LNG_GERMAN     to "Februar"
26694>>>>>>>>>>>        Set Language_Value "february"  LNG_PORTUGUESE to "Fevereiro"
26695>>>>>>>>>>>        Set Language_Value "february"  LNG_FRENCH     to "Fvrier"
26696>>>>>>>>>>>        
26696>>>>>>>>>>>        Set Language_Value "march"     LNG_DUTCH      to "Maart"
26697>>>>>>>>>>>        Set Language_Value "march"     LNG_ITALIAN    to "Marzo"
26698>>>>>>>>>>>        Set Language_Value "march"     LNG_SPANISH    to "Marzo"
26699>>>>>>>>>>>        Set Language_Value "march"     LNG_ENGLISH    to "March"
26700>>>>>>>>>>>        Set Language_Value "march"     LNG_DANISH     to "Marts"
26701>>>>>>>>>>>        Set Language_Value "march"     LNG_SWEDISH    to "Mars"
26702>>>>>>>>>>>        Set Language_Value "march"     LNG_NORWEGIAN  to "Mars"
26703>>>>>>>>>>>        Set Language_Value "march"     LNG_GERMAN     to "Mrz"
26704>>>>>>>>>>>        Set Language_Value "march"     LNG_PORTUGUESE to "Maro"
26705>>>>>>>>>>>        Set Language_Value "march"     LNG_FRENCH     to "Mars"
26706>>>>>>>>>>>        
26706>>>>>>>>>>>        Set Language_Value "april"     LNG_DUTCH      to "April"
26707>>>>>>>>>>>        Set Language_Value "april"     LNG_ITALIAN    to "Aprile"
26708>>>>>>>>>>>        Set Language_Value "april"     LNG_SPANISH    to "Abril"
26709>>>>>>>>>>>        Set Language_Value "april"     LNG_ENGLISH    to "April"
26710>>>>>>>>>>>        Set Language_Value "april"     LNG_DANISH     to "April"
26711>>>>>>>>>>>        Set Language_Value "april"     LNG_SWEDISH    to "April"
26712>>>>>>>>>>>        Set Language_Value "april"     LNG_NORWEGIAN  to "April"
26713>>>>>>>>>>>        Set Language_Value "april"     LNG_GERMAN     to "April"
26714>>>>>>>>>>>        Set Language_Value "april"     LNG_PORTUGUESE to "Abril"
26715>>>>>>>>>>>        Set Language_Value "april"     LNG_FRENCH     to "Avril"
26716>>>>>>>>>>>        
26716>>>>>>>>>>>        Set Language_Value "may"       LNG_DUTCH      to "Mei"
26717>>>>>>>>>>>        Set Language_Value "may"       LNG_ITALIAN    to "Maggio"
26718>>>>>>>>>>>        Set Language_Value "may"       LNG_SPANISH    to "Mayo"
26719>>>>>>>>>>>        Set Language_Value "may"       LNG_ENGLISH    to "May"
26720>>>>>>>>>>>        Set Language_Value "may"       LNG_DANISH     to "Maj"
26721>>>>>>>>>>>        Set Language_Value "may"       LNG_SWEDISH    to "Maj"
26722>>>>>>>>>>>        Set Language_Value "may"       LNG_NORWEGIAN  to "Mai"
26723>>>>>>>>>>>        Set Language_Value "may"       LNG_GERMAN     to "Mai"
26724>>>>>>>>>>>        Set Language_Value "may"       LNG_PORTUGUESE to "Maio"
26725>>>>>>>>>>>        Set Language_Value "may"       LNG_FRENCH     to "Mai"
26726>>>>>>>>>>>        
26726>>>>>>>>>>>        Set Language_Value "june"      LNG_DUTCH      to "Juni"
26727>>>>>>>>>>>        Set Language_Value "june"      LNG_ITALIAN    to "Giugno"
26728>>>>>>>>>>>        Set Language_Value "june"      LNG_SPANISH    to "Junio"
26729>>>>>>>>>>>        Set Language_Value "june"      LNG_ENGLISH    to "June"
26730>>>>>>>>>>>        Set Language_Value "june"      LNG_DANISH     to "Juni"
26731>>>>>>>>>>>        Set Language_Value "june"      LNG_SWEDISH    to "Juni"
26732>>>>>>>>>>>        Set Language_Value "june"      LNG_NORWEGIAN  to "Juni"
26733>>>>>>>>>>>        Set Language_Value "june"      LNG_GERMAN     to "Juni"
26734>>>>>>>>>>>        Set Language_Value "june"      LNG_PORTUGUESE to "Junho"
26735>>>>>>>>>>>        Set Language_Value "june"      LNG_FRENCH     to "Juin"
26736>>>>>>>>>>>        
26736>>>>>>>>>>>        Set Language_Value "july"      LNG_DUTCH      to "Juli"
26737>>>>>>>>>>>        Set Language_Value "july"      LNG_ITALIAN    to "Luglio"
26738>>>>>>>>>>>        Set Language_Value "july"      LNG_SPANISH    to "Julio"
26739>>>>>>>>>>>        Set Language_Value "july"      LNG_ENGLISH    to "July"
26740>>>>>>>>>>>        Set Language_Value "july"      LNG_DANISH     to "Juli"
26741>>>>>>>>>>>        Set Language_Value "july"      LNG_SWEDISH    to "Juli"
26742>>>>>>>>>>>        Set Language_Value "july"      LNG_NORWEGIAN  to "Juli"
26743>>>>>>>>>>>        Set Language_Value "july"      LNG_GERMAN     to "Juli"
26744>>>>>>>>>>>        Set Language_Value "july"      LNG_PORTUGUESE to "Julho"
26745>>>>>>>>>>>        Set Language_Value "july"      LNG_FRENCH     to "Juillet"
26746>>>>>>>>>>>
26746>>>>>>>>>>>        Set Language_Value "august"    LNG_DUTCH      to "Augustus"
26747>>>>>>>>>>>        Set Language_Value "august"    LNG_ITALIAN    to "Agosto"
26748>>>>>>>>>>>        Set Language_Value "august"    LNG_SPANISH    to "Agosto"
26749>>>>>>>>>>>        Set Language_Value "august"    LNG_ENGLISH    to "August"
26750>>>>>>>>>>>        Set Language_Value "august"    LNG_DANISH     to "August"
26751>>>>>>>>>>>        Set Language_Value "august"    LNG_SWEDISH    to "Augusti"
26752>>>>>>>>>>>        Set Language_Value "august"    LNG_NORWEGIAN  to "August"
26753>>>>>>>>>>>        Set Language_Value "august"    LNG_GERMAN     to "August"
26754>>>>>>>>>>>        Set Language_Value "august"    LNG_PORTUGUESE to "Agosto"
26755>>>>>>>>>>>        Set Language_Value "august"    LNG_FRENCH     to "Aot"
26756>>>>>>>>>>>        
26756>>>>>>>>>>>        Set Language_Value "september" LNG_DUTCH      to "September"
26757>>>>>>>>>>>        Set Language_Value "september" LNG_ITALIAN    to "Settembre"
26758>>>>>>>>>>>        Set Language_Value "september" LNG_SPANISH    to "Septiembre"
26759>>>>>>>>>>>        Set Language_Value "september" LNG_ENGLISH    to "September"
26760>>>>>>>>>>>        Set Language_Value "september" LNG_DANISH     to "September"
26761>>>>>>>>>>>        Set Language_Value "september" LNG_SWEDISH    to "September"
26762>>>>>>>>>>>        Set Language_Value "september" LNG_NORWEGIAN  to "September"
26763>>>>>>>>>>>        Set Language_Value "september" LNG_GERMAN     to "September"
26764>>>>>>>>>>>        Set Language_Value "september" LNG_PORTUGUESE to "Setembro"
26765>>>>>>>>>>>        Set Language_Value "september" LNG_FRENCH     to "Septembre"
26766>>>>>>>>>>>        
26766>>>>>>>>>>>        Set Language_Value "october"   LNG_DUTCH      to "Oktober"
26767>>>>>>>>>>>        Set Language_Value "october"   LNG_ITALIAN    to "Ottobre"
26768>>>>>>>>>>>        Set Language_Value "october"   LNG_SPANISH    to "Octubre"
26769>>>>>>>>>>>        Set Language_Value "october"   LNG_ENGLISH    to "October"
26770>>>>>>>>>>>        Set Language_Value "october"   LNG_DANISH     to "Oktober"
26771>>>>>>>>>>>        Set Language_Value "october"   LNG_SWEDISH    to "Oktober"
26772>>>>>>>>>>>        Set Language_Value "october"   LNG_NORWEGIAN  to "Oktober"
26773>>>>>>>>>>>        Set Language_Value "october"   LNG_GERMAN     to "Oktober"
26774>>>>>>>>>>>        Set Language_Value "october"   LNG_PORTUGUESE to "Outubro"
26775>>>>>>>>>>>        Set Language_Value "october"   LNG_FRENCH     to "Octobre"
26776>>>>>>>>>>>        
26776>>>>>>>>>>>        Set Language_Value "november"  LNG_DUTCH      to "November"
26777>>>>>>>>>>>        Set Language_Value "november"  LNG_ITALIAN    to "Novembre"
26778>>>>>>>>>>>        Set Language_Value "november"  LNG_SPANISH    to "Noviembre"
26779>>>>>>>>>>>        Set Language_Value "november"  LNG_ENGLISH    to "November"
26780>>>>>>>>>>>        Set Language_Value "november"  LNG_DANISH     to "November"
26781>>>>>>>>>>>        Set Language_Value "november"  LNG_SWEDISH    to "November"
26782>>>>>>>>>>>        Set Language_Value "november"  LNG_NORWEGIAN  to "November"
26783>>>>>>>>>>>        Set Language_Value "november"  LNG_GERMAN     to "November"
26784>>>>>>>>>>>        Set Language_Value "november"  LNG_PORTUGUESE to "Novembro"
26785>>>>>>>>>>>        Set Language_Value "november"  LNG_FRENCH     to "Novembre"
26786>>>>>>>>>>>        
26786>>>>>>>>>>>        Set Language_Value "december"  LNG_DUTCH      to "December"
26787>>>>>>>>>>>        Set Language_Value "december"  LNG_ITALIAN    to "Dicembre"
26788>>>>>>>>>>>        Set Language_Value "december"  LNG_SPANISH    to "Diciembre"
26789>>>>>>>>>>>        Set Language_Value "december"  LNG_ENGLISH    to "December"
26790>>>>>>>>>>>        Set Language_Value "december"  LNG_DANISH     to "December"
26791>>>>>>>>>>>        Set Language_Value "december"  LNG_SWEDISH    to "December"
26792>>>>>>>>>>>        Set Language_Value "december"  LNG_NORWEGIAN  to "Desember"
26793>>>>>>>>>>>        Set Language_Value "december"  LNG_GERMAN     to "Dezember"
26794>>>>>>>>>>>        Set Language_Value "december"  LNG_PORTUGUESE to "Dezembro"
26795>>>>>>>>>>>        Set Language_Value "december"  LNG_FRENCH     to "Dcembre"
26796>>>>>>>>>>>        
26796>>>>>>>>>>>        Set Language_Value "monday"    LNG_DUTCH      to "Maandag"
26797>>>>>>>>>>>        Set Language_Value "monday"    LNG_ITALIAN    to "Luned"
26798>>>>>>>>>>>        Set Language_Value "monday"    LNG_SPANISH    to "Lunes"
26799>>>>>>>>>>>        Set Language_Value "monday"    LNG_ENGLISH    to "Monday"
26800>>>>>>>>>>>        Set Language_Value "monday"    LNG_DANISH     to "Mandag"
26801>>>>>>>>>>>        Set Language_Value "monday"    LNG_SWEDISH    to "Mndag"
26802>>>>>>>>>>>        Set Language_Value "monday"    LNG_NORWEGIAN  to "Mandag"
26803>>>>>>>>>>>        Set Language_Value "monday"    LNG_GERMAN     to "Montag"
26804>>>>>>>>>>>        Set Language_Value "monday"    LNG_PORTUGUESE to "Segunda"
26805>>>>>>>>>>>        Set Language_Value "monday"    LNG_FRENCH     to "Lundi"
26806>>>>>>>>>>>        
26806>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_DUTCH      to "Dinsdag"
26807>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_ITALIAN    to "Marted"
26808>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_SPANISH    to "Martes"
26809>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_ENGLISH    to "Tuesday"
26810>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_DANISH     to "Tirsdag"
26811>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_SWEDISH    to "Tisdag"
26812>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_NORWEGIAN  to "Tirsdag"
26813>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_GERMAN     to "Dienstag"
26814>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_PORTUGUESE to "Tera"
26815>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_FRENCH     to "Mardi"
26816>>>>>>>>>>>        
26816>>>>>>>>>>>        Set Language_Value "wednesday" LNG_DUTCH      to "Woensdag"
26817>>>>>>>>>>>        Set Language_Value "wednesday" LNG_ITALIAN    to "Mercoled"
26818>>>>>>>>>>>        Set Language_Value "wednesday" LNG_SPANISH    to "Mircoles"
26819>>>>>>>>>>>        Set Language_Value "wednesday" LNG_ENGLISH    to "Wednesday"
26820>>>>>>>>>>>        Set Language_Value "wednesday" LNG_DANISH     to "Onsdag"
26821>>>>>>>>>>>        Set Language_Value "wednesday" LNG_SWEDISH    to "Onsdag"
26822>>>>>>>>>>>        Set Language_Value "wednesday" LNG_NORWEGIAN  to "Onsdag"
26823>>>>>>>>>>>        Set Language_Value "wednesday" LNG_GERMAN     to "Mittwoch"
26824>>>>>>>>>>>        Set Language_Value "wednesday" LNG_PORTUGUESE to "Quarta"
26825>>>>>>>>>>>        Set Language_Value "wednesday" LNG_FRENCH     to "Mercredi"
26826>>>>>>>>>>>        
26826>>>>>>>>>>>        Set Language_Value "thursday"  LNG_DUTCH      to "Donderdag"
26827>>>>>>>>>>>        Set Language_Value "thursday"  LNG_ITALIAN    to "Gioved"
26828>>>>>>>>>>>        Set Language_Value "thursday"  LNG_SPANISH    to "Jueves"
26829>>>>>>>>>>>        Set Language_Value "thursday"  LNG_ENGLISH    to "Thursday"
26830>>>>>>>>>>>        Set Language_Value "thursday"  LNG_DANISH     to "Torsdag"
26831>>>>>>>>>>>        Set Language_Value "thursday"  LNG_SWEDISH    to "Torsdag"
26832>>>>>>>>>>>        Set Language_Value "thursday"  LNG_NORWEGIAN  to "Torsdag"
26833>>>>>>>>>>>        Set Language_Value "thursday"  LNG_GERMAN     to "Donnerstag"
26834>>>>>>>>>>>        Set Language_Value "thursday"  LNG_PORTUGUESE to "Quinta"
26835>>>>>>>>>>>        Set Language_Value "thursday"  LNG_FRENCH     to "Jeudi"
26836>>>>>>>>>>>        
26836>>>>>>>>>>>        Set Language_Value "friday"    LNG_DUTCH      to "Vrijdag"
26837>>>>>>>>>>>        Set Language_Value "friday"    LNG_ITALIAN    to "Venerd"
26838>>>>>>>>>>>        Set Language_Value "friday"    LNG_SPANISH    to "Viernes"
26839>>>>>>>>>>>        Set Language_Value "friday"    LNG_ENGLISH    to "Friday"
26840>>>>>>>>>>>        Set Language_Value "friday"    LNG_DANISH     to "Fredag"
26841>>>>>>>>>>>        Set Language_Value "friday"    LNG_SWEDISH    to "Fredag"
26842>>>>>>>>>>>        Set Language_Value "friday"    LNG_NORWEGIAN  to "Fredag"
26843>>>>>>>>>>>        Set Language_Value "friday"    LNG_GERMAN     to "Freitag"
26844>>>>>>>>>>>        Set Language_Value "friday"    LNG_PORTUGUESE to "Sexta"
26845>>>>>>>>>>>        Set Language_Value "friday"    LNG_FRENCH     to "Vendredi"
26846>>>>>>>>>>>
26846>>>>>>>>>>>        Set Language_Value "saturday"  LNG_DUTCH      to "Zaterdag"
26847>>>>>>>>>>>        Set Language_Value "saturday"  LNG_ITALIAN    to "Sabato"
26848>>>>>>>>>>>        Set Language_Value "saturday"  LNG_SPANISH    to "Sbado"
26849>>>>>>>>>>>        Set Language_Value "saturday"  LNG_ENGLISH    to "Saturday"
26850>>>>>>>>>>>        Set Language_Value "saturday"  LNG_DANISH     to "Lrdag"
26851>>>>>>>>>>>        Set Language_Value "saturday"  LNG_SWEDISH    to "Lrdag"
26852>>>>>>>>>>>        Set Language_Value "saturday"  LNG_NORWEGIAN  to "Lrdag"
26853>>>>>>>>>>>        Set Language_Value "saturday"  LNG_GERMAN     to "Samstag"
26854>>>>>>>>>>>        Set Language_Value "saturday"  LNG_PORTUGUESE to "Sbado"
26855>>>>>>>>>>>        Set Language_Value "saturday"  LNG_FRENCH     to "Samedi"
26856>>>>>>>>>>>
26856>>>>>>>>>>>        Set Language_Value "sunday"    LNG_DUTCH      to "Zondag"
26857>>>>>>>>>>>        Set Language_Value "sunday"    LNG_ITALIAN    to "Domenica"
26858>>>>>>>>>>>        Set Language_Value "sunday"    LNG_SPANISH    to "Domingo"
26859>>>>>>>>>>>        Set Language_Value "sunday"    LNG_ENGLISH    to "Sunday"
26860>>>>>>>>>>>        Set Language_Value "sunday"    LNG_DANISH     to "Sndag"
26861>>>>>>>>>>>        Set Language_Value "sunday"    LNG_SWEDISH    to "Sndag"
26862>>>>>>>>>>>        Set Language_Value "sunday"    LNG_NORWEGIAN  to "Sndag"
26863>>>>>>>>>>>        Set Language_Value "sunday"    LNG_GERMAN     to "Sonntag"
26864>>>>>>>>>>>        Set Language_Value "sunday"    LNG_PORTUGUESE to "Domingo"
26865>>>>>>>>>>>        Set Language_Value "sunday"    LNG_FRENCH     to "Dimanche"
26866>>>>>>>>>>>
26866>>>>>>>>>>>        Set Language_Value "int_userentry"   LNG_ENGLISH to "Explicit"
26867>>>>>>>>>>>        Set Language_Value "int_userentry"   LNG_DANISH  to "Tast selv"
26868>>>>>>>>>>>  
26868>>>>>>>>>>>        Set Language_Value "int_nolimit"     LNG_ENGLISH to "No limits"
26869>>>>>>>>>>>        Set Language_Value "int_nolimit"     LNG_DANISH  to "Ingen begr."
26870>>>>>>>>>>>        
26870>>>>>>>>>>>        Set Language_Value "int_lastweek"    LNG_ENGLISH to "Last week"
26871>>>>>>>>>>>        Set Language_Value "int_lastweek"    LNG_DANISH  to "Sidste uge"
26872>>>>>>>>>>>        
26872>>>>>>>>>>>        Set Language_Value "int_lastmonth"   LNG_ENGLISH to "Last month"
26873>>>>>>>>>>>        Set Language_Value "int_lastmonth"   LNG_DANISH  to "Sidste mned"
26874>>>>>>>>>>>        
26874>>>>>>>>>>>        Set Language_Value "int_lastyear"    LNG_ENGLISH to "Last year"
26875>>>>>>>>>>>        Set Language_Value "int_lastyear"    LNG_DANISH  to "Sidste r"
26876>>>>>>>>>>>        
26876>>>>>>>>>>>        Set Language_Value "int_weektodate"  LNG_ENGLISH to "Week to date"
26877>>>>>>>>>>>        Set Language_Value "int_weektodate"  LNG_DANISH  to "Uge til dato"
26878>>>>>>>>>>>        
26878>>>>>>>>>>>        Set Language_Value "int_monthtodate" LNG_ENGLISH to "Month to date"
26879>>>>>>>>>>>        Set Language_Value "int_monthtodate" LNG_DANISH  to "Mned til dato"
26880>>>>>>>>>>>        
26880>>>>>>>>>>>        Set Language_Value "int_yeartodate"  LNG_ENGLISH to "Year to date"
26881>>>>>>>>>>>        Set Language_Value "int_yeartodate"  LNG_DANISH  to "r til dato"
26882>>>>>>>>>>>
26882>>>>>>>>>>>    End_Procedure
26883>>>>>>>>>>>
26883>>>>>>>>>>>End_Object // oDatesLD
26884>>>>>>>>>Use Windows.pkg
26884>>>>>>>>>Use DfLine.pkg
Including file: Dfline.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\Dfline.pkg)
26884>>>>>>>>>>>//************************************************************************
26884>>>>>>>>>>>//--- DFLine.pkg   Line-Drawing
26884>>>>>>>>>>>//
26884>>>>>>>>>>>// Copyright (c) 1983-1997 Data Access Corporation, Miami Florida,
26884>>>>>>>>>>>// All rights reserved.
26884>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
26884>>>>>>>>>>>//
26884>>>>>>>>>>>//************************************************************************
26884>>>>>>>>>>>//  Description:
26884>>>>>>>>>>>//      A class designed to draw lines.
26884>>>>>>>>>>>//************************************************************************
26884>>>>>>>>>>>
26884>>>>>>>>>>>use windows.pkg
26884>>>>>>>>>>>
26884>>>>>>>>>>>//
26884>>>>>>>>>>>// Line Styles
26884>>>>>>>>>>>//
26884>>>>>>>>>>>Enumeration_list
26884>>>>>>>>>>>  define lnDIP        // grey (Shadow) top line, light bottom (highlight)
26884>>>>>>>>>>>  define lnBUMP       // light top (highlight), grey (Shadow) bottom
26884>>>>>>>>>>>  define lnSINGLE     // Single dark line
26884>>>>>>>>>>>  define lnCUSTOM     // create your own with line_color1 & 2.
26884>>>>>>>>>>>End_Enumeration_list
26884>>>>>>>>>>>
26884>>>>>>>>>>>// Interface:
26884>>>>>>>>>>>//
26884>>>>>>>>>>>//  Set Size             to Height Width
26884>>>>>>>>>>>//  Set Location         to col row
26884>>>>>>>>>>>//  Set Horizontal_State to TRUE|FALSE
26884>>>>>>>>>>>//  Set Line_Style       to lnDIP | lnBUMP | lnSINGLE | LnCUSTOM
26884>>>>>>>>>>>//  Set Line_Thickness   to pixel-thickness
26884>>>>>>>>>>>//  Set Line_Margin      to pixel-border
26884>>>>>>>>>>>//
26884>>>>>>>>>>>//  If LnCustom you must define both of these colors
26884>>>>>>>>>>>//     Set Line_Color1 to Windows_Color
26884>>>>>>>>>>>//     Set Line_Color2 to Windows_Color  (if 0, single line)
26884>>>>>>>>>>>//
26884>>>>>>>>>>>
26884>>>>>>>>>>>Class LineControl is a DFBaseLineControl
26885>>>>>>>>>>>
26885>>>>>>>>>>>    Procedure Construct_Object
26887>>>>>>>>>>>        Forward Send Construct_Object
26889>>>>>>>>>>>        Property integer Line_Color1  COLOR_BTNSHADOW
26890>>>>>>>>>>>        Property integer Line_Color2  COLOR_BTNHIGHLIGHT
26891>>>>>>>>>>>        // we do not want control to participate in forward backwards object navigation
26891>>>>>>>>>>>        set Skip_State to True
26892>>>>>>>>>>>    End_Procedure
26893>>>>>>>>>>>
26893>>>>>>>>>>>    Procedure Notify Integer wParam Integer lParam
26895>>>>>>>>>>>    End_Procedure
26896>>>>>>>>>>>
26896>>>>>>>>>>>    Procedure set Line_Color1 integer theColor
26898>>>>>>>>>>>        set top_line_color to theColor
26899>>>>>>>>>>>    End_Procedure
26900>>>>>>>>>>>
26900>>>>>>>>>>>    Procedure set Line_Color2 integer theColor
26902>>>>>>>>>>>        set bottom_line_color to theColor
26903>>>>>>>>>>>    End_Procedure
26904>>>>>>>>>>>
26904>>>>>>>>>>>    Function Line_Color1 returns integer
26906>>>>>>>>>>>        Function_Return (top_line_color(self))
26907>>>>>>>>>>>    End_Function
26908>>>>>>>>>>>
26908>>>>>>>>>>>    Function Line_Color2 returns integer
26910>>>>>>>>>>>        Function_Return (bottom_line_color(self))
26911>>>>>>>>>>>    End_Function
26912>>>>>>>>>>>End_Class
26913>>>>>>>>>Use RgbFunctions.pkg
Including file: RgbFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\RgbFunctions.pkg)
26913>>>>>>>>>>>
26913>>>>>>>>>>>//> This package contains functions to manipulate RGB colors.
26913>>>>>>>>>>>//> The RGB color model is an additive color model in which red, green, and blue light are combined in various ways
26913>>>>>>>>>>>//> to create other colors. The very idea for the model itself and the abbreviation "RGB" come from the three primary
26913>>>>>>>>>>>//> colors in additive light models (http://www.wordiq.com/definition/RGB).
26913>>>>>>>>>>>//> pkg.doc.end
26913>>>>>>>>>>>
26913>>>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and web)
26913>>>>>>>>>>>
26913>>>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
26913>>>>>>>>>>>
26913>>>>>>>>>>>Class cRgbFunctions is a cObject
26914>>>>>>>>>>>    Procedure Construct_Object
26916>>>>>>>>>>>        Integer[] aColors
26917>>>>>>>>>>>        Forward Send Construct_Object
26919>>>>>>>>>>>        Property Integer[] paBrightColors
26920>>>>>>>>>>>        Get Brighten clRed 80 to aColors[0]
26921>>>>>>>>>>>        Get Brighten clGreen 80 to aColors[1]
26922>>>>>>>>>>>        Get Brighten clBlue 80 to aColors[2]
26923>>>>>>>>>>>        Get Brighten clYellow 80 to aColors[3]
26924>>>>>>>>>>>        Get Brighten clGray 80 to aColors[4]
26925>>>>>>>>>>>        Set paBrightColors to aColors
26926>>>>>>>>>>>    End_Procedure
26927>>>>>>>>>>>
26927>>>>>>>>>>>    Function BrightColor Integer iColor Returns Integer
26929>>>>>>>>>>>        Integer[] aColors
26930>>>>>>>>>>>        get paBrightColors to aColors
26931>>>>>>>>>>>        If (iColor=clRed) Function_Return aColors[0]
26934>>>>>>>>>>>        If (iColor=clGreen) Function_Return aColors[1]
26937>>>>>>>>>>>        If (iColor=clBlue) Function_Return aColors[2]
26940>>>>>>>>>>>        If (iColor=clYellow) Function_Return aColors[3]
26943>>>>>>>>>>>        If (iColor=clGray) Function_Return aColors[4]
26946>>>>>>>>>>>    End_Function
26947>>>>>>>>>>>
26947>>>>>>>>>>>    //> Return a RGB color composed from red, green and blue components (each of a value between 0 and 255)
26947>>>>>>>>>>>    Function Compose Integer iRed Integer iGreen Integer iBlue Returns Integer
26949>>>>>>>>>>>        Function_Return (iBlue*256+iGreen*256+iRed)
26950>>>>>>>>>>>    End_Function
26951>>>>>>>>>>>
26951>>>>>>>>>>>    //> Brighten a RGB color by a percentage.
26951>>>>>>>>>>>    Function Brighten Integer iColor Integer iPercent Returns Integer
26953>>>>>>>>>>>        Integer iRed iGreen iBlue
26953>>>>>>>>>>>        Move (iColor iand $0000FF) to iRed
26954>>>>>>>>>>>        Move (iColor iand $00FF00/256) to iGreen
26955>>>>>>>>>>>        Move (iColor iand $FF0000/65536) to iBlue
26956>>>>>>>>>>>        Move (255-iRed*iPercent/100+iRed) to iRed
26957>>>>>>>>>>>        Move (255-iGreen*iPercent/100+iGreen) to iGreen
26958>>>>>>>>>>>        Move (255-iBlue*iPercent/100+iBlue) to iBlue
26959>>>>>>>>>>>        Function_Return (iBlue*256+iGreen*256+iRed)
26960>>>>>>>>>>>    End_Function
26961>>>>>>>>>>>
26961>>>>>>>>>>>    //> Darken a RGB color by a percentage.
26961>>>>>>>>>>>    Function Darken Integer iColor Integer iPercent Returns Integer
26963>>>>>>>>>>>        Integer iRed iGreen iBlue
26963>>>>>>>>>>>        Move (iColor iand $0000FF) to iRed
26964>>>>>>>>>>>        Move (iColor iand $00FF00/256) to iGreen
26965>>>>>>>>>>>        Move (iColor iand $FF0000/65536) to iBlue
26966>>>>>>>>>>>        Move (-iRed*iPercent/100+iRed) to iRed
26967>>>>>>>>>>>        Move (-iGreen*iPercent/100+iGreen) to iGreen
26968>>>>>>>>>>>        Move (-iBlue*iPercent/100+iBlue) to iBlue
26969>>>>>>>>>>>        Function_Return (iBlue*256+iGreen*256+iRed)
26970>>>>>>>>>>>    End_Function
26971>>>>>>>>>>>
26971>>>>>>>>>>>    //> Blend two RGB colors weighing color1 by a percentage.
26971>>>>>>>>>>>    Function Blend Integer iColor1 Integer iColor2 Integer iPercent1 Returns Integer
26973>>>>>>>>>>>        Integer iRed1 iGreen1 iBlue1
26973>>>>>>>>>>>        Integer iRed2 iGreen2 iBlue2
26973>>>>>>>>>>>        Move (iColor1 iand $0000FF) to iRed1
26974>>>>>>>>>>>        Move (iColor1 iand $00FF00/256) to iGreen1
26975>>>>>>>>>>>        Move (iColor1 iand $FF0000/65536) to iBlue1
26976>>>>>>>>>>>        Move (iColor2 iand $0000FF) to iRed2
26977>>>>>>>>>>>        Move (iColor2 iand $00FF00/256) to iGreen2
26978>>>>>>>>>>>        Move (iColor2 iand $FF0000/65536) to iBlue2
26979>>>>>>>>>>>        Move (iRed1*iPercent1+(100-iPercent1*iRed2)/100) to iRed1
26980>>>>>>>>>>>        Move (iGreen1*iPercent1+(100-iPercent1*iGreen2)/100) to iGreen1
26981>>>>>>>>>>>        Move (iBlue1*iPercent1+(100-iPercent1*iBlue2)/100) to iBlue1
26982>>>>>>>>>>>        Function_Return (iBlue1*256+iGreen1*256+iRed1)
26983>>>>>>>>>>>    End_Function
26984>>>>>>>>>>>
26984>>>>>>>>>>>    //> Negate a RGB color
26984>>>>>>>>>>>    Function Negate Integer iColor Returns Integer
26986>>>>>>>>>>>        Integer iRed iGreen iBlue
26986>>>>>>>>>>>        Move (iColor iand $0000FF) to iRed
26987>>>>>>>>>>>        Move (iColor iand $00FF00/256) to iGreen
26988>>>>>>>>>>>        Move (iColor iand $FF0000/65536) to iBlue
26989>>>>>>>>>>>        Move (255-iRed) to iRed
26990>>>>>>>>>>>        Move (255-iGreen) to iGreen
26991>>>>>>>>>>>        Move (255-iBlue) to iBlue
26992>>>>>>>>>>>        Function_Return (iBlue*256+iGreen*256+iRed)
26993>>>>>>>>>>>    End_Function
26994>>>>>>>>>>>
26994>>>>>>>>>>>    //> Translate a RGB color to HTML syntax.
26994>>>>>>>>>>>    Function ToHTML Integer iColor Returns String
26996>>>>>>>>>>>        Integer iRed iGreen iBlue
26996>>>>>>>>>>>        Move (iColor iand $0000FF) to iRed
26997>>>>>>>>>>>        Move (iColor iand $00FF00/256) to iGreen
26998>>>>>>>>>>>        Move (iColor iand $FF0000/65536) to iBlue
26999>>>>>>>>>>>        Function_Return ("#"+ByteToHex(oStringFunctions,iRed)+ByteToHex(oStringFunctions,iGreen)+ByteToHex(oStringFunctions,iBlue))
27000>>>>>>>>>>>    End_Function
27001>>>>>>>>>>>
27001>>>>>>>>>>>    Function HTMLToRgb String sColor Returns Integer
27003>>>>>>>>>>>        Integer iRed iGreen iBlue
27003>>>>>>>>>>>        Move (Uppercase(Replace("#",sColor,""))) to sColor
27004>>>>>>>>>>>        Get HexToByte of oStringFunctions (Mid(sColor,2,1)) to iRed
27005>>>>>>>>>>>        Get HexToByte of oStringFunctions (Mid(sColor,2,3)) to iGreen
27006>>>>>>>>>>>        Get HexToByte of oStringFunctions (Mid(sColor,2,5)) to iBlue
27007>>>>>>>>>>>        Function_Return (Compose(Self,iRed,iGreen,iBlue))
27008>>>>>>>>>>>    End_Function
27009>>>>>>>>>>>    
27009>>>>>>>>>>>End_Class // cRgbFunctions
27010>>>>>>>>>>>
27010>>>>>>>>>>>Global_Variable Integer oRgbFunctions
27010>>>>>>>>>>>
27010>>>>>>>>>>>Object _oRgbFunctions is a cRgbFunctions
27012>>>>>>>>>>>    Move Self to oRgbFunctions
27013>>>>>>>>>>>End_Object
27014>>>>>>>>>
27014>>>>>>>>>
27014>>>>>>>>>Define LargestPossibleDate for 913490 // December 31st 2500
27014>>>>>>>>>Define Jan1st1900          for 693975
27014>>>>>>>>>Define Jan1st2000          for 730500
27014>>>>>>>>>Define Jan1st1930          for 704933
27014>>>>>>>>>Define Jan1st1000          for 365250
27014>>>>>>>>>Define Jan1st105           for 38352
27014>>>>>>>>>Define Jan1st100           for 36525
27014>>>>>>>>>
27014>>>>>>>>>Enumeration_List // Date Segments. Sequence of definitions determined granularity
27014>>>>>>>>>    Define DS_SECOND
27014>>>>>>>>>    Define DS_MINUTE
27014>>>>>>>>>    Define DS_HOUR
27014>>>>>>>>>    Define DS_DAY
27014>>>>>>>>>    Define DS_WEEK
27014>>>>>>>>>    Define DS_MONTH
27014>>>>>>>>>    Define DS_QUARTER
27014>>>>>>>>>    Define DS_YEAR
27014>>>>>>>>>End_Enumeration_List
27014>>>>>>>>>
27014>>>>>>>>>//#IFNDEF TS_HOUR
27014>>>>>>>>>//    Enumeration_List // Time Segments. Sequence of definitions determined granularity
27014>>>>>>>>>//        Define TS_SECOND
27014>>>>>>>>>//        Define TS_MINUTE
27014>>>>>>>>>//        Define TS_HOUR
27014>>>>>>>>>//    End_Enumeration_List
27014>>>>>>>>>//#ENDIF
27014>>>>>>>>>
27014>>>>>>>>>Enumeration_List // Codes for date interval presets
27014>>>>>>>>>  Define DI_EXPLICIT
27014>>>>>>>>>  Define DI_NO_LIMIT
27014>>>>>>>>>  Define DI_LAST_WEEK
27014>>>>>>>>>  Define DI_LAST_MONTH
27014>>>>>>>>>  Define DI_LAST_YEAR
27014>>>>>>>>>  Define DI_WEEK_TO_DATE
27014>>>>>>>>>  Define DI_MONTH_TO_DATE
27014>>>>>>>>>  Define DI_YEAR_TO_DATE
27014>>>>>>>>>End_Enumeration_List
27014>>>>>>>>>
27014>>>>>>>>>
27014>>>>>>>>>External_Function do_GetSystemTime "GetSystemTime" kernel32.dll Pointer lpGST Returns VOID_TYPE
27015>>>>>>>>>
27015>>>>>>>>>Struct tSystemTimeMS
27015>>>>>>>>>    Short iYear
27015>>>>>>>>>    Short iMonth
27015>>>>>>>>>    Short iDayOfWeek
27015>>>>>>>>>    Short iDay
27015>>>>>>>>>    Short iHour
27015>>>>>>>>>    Short iMinute
27015>>>>>>>>>    Short iSecond
27015>>>>>>>>>    Short iMilliSeconds
27015>>>>>>>>>End_Struct
27015>>>>>>>>>
27015>>>>>>>>>Global_Variable String _gsDate$ModuleStartTime
27015>>>>>>>>>
27015>>>>>>>>>Class cDateFunctions is a cObject
27016>>>>>>>>>    Procedure Construct_Object
27018>>>>>>>>>        Integer iValue
27018>>>>>>>>>        Forward Send Construct_Object  
27020>>>>>>>>>        Property String  psDateSeparator //
27021>>>>>>>>>        Property Integer piDateFormat    //
27022>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iValue  
27025>>>>>>>>>        Set psDateSeparator to (character(iValue)) 
27026>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iValue 
27029>>>>>>>>>        Set piDateFormat to iValue 
27030>>>>>>>>>        
27030>>>>>>>>>        // The next cryptic objects enables the language dependent functions of this package to change
27030>>>>>>>>>        // their language on the fly in an efficient manner.
27030>>>>>>>>>        
27030>>>>>>>>>        Object oDayNames is a cStringConstantsArray 
27032>>>>>>>>>            Set Value 1 to "ls.date.monday"
27033>>>>>>>>>            Set Value 2 to "ls.date.tuesday"
27034>>>>>>>>>            Set Value 3 to "ls.date.wednesday"
27035>>>>>>>>>            Set Value 4 to "ls.date.thursday"
27036>>>>>>>>>            Set Value 5 to "ls.date.friday"
27037>>>>>>>>>            Set Value 6 to "ls.date.saturday"
27038>>>>>>>>>            Set Value 7 to "ls.date.sunday"
27039>>>>>>>>>        End_Object
27040>>>>>>>>>
27040>>>>>>>>>        Object oMonthNames is a cStringConstantsArray
27042>>>>>>>>>            Set Value  1 to "ls.date.january"
27043>>>>>>>>>            Set Value  2 to "ls.date.february"
27044>>>>>>>>>            Set Value  3 to "ls.date.march"
27045>>>>>>>>>            Set Value  4 to "ls.date.april"
27046>>>>>>>>>            Set Value  5 to "ls.date.may"
27047>>>>>>>>>            Set Value  6 to "ls.date.june"
27048>>>>>>>>>            Set Value  7 to "ls.date.july"
27049>>>>>>>>>            Set Value  8 to "ls.date.august"
27050>>>>>>>>>            Set Value  9 to "ls.date.september"
27051>>>>>>>>>            Set Value 10 to "ls.date.october"
27052>>>>>>>>>            Set Value 11 to "ls.date.november"
27053>>>>>>>>>            Set Value 12 to "ls.date.december"
27054>>>>>>>>>        End_Object
27055>>>>>>>>>        
27055>>>>>>>>>        Object oIntervalLabels is a cStringConstantsArray
27057>>>>>>>>>            Set Value DI_EXPLICIT      to "ls.date.int_userentry"
27058>>>>>>>>>            Set Value DI_NO_LIMIT      to "ls.date.int_nolimit"
27059>>>>>>>>>            Set Value DI_LAST_WEEK     to "ls.date.int_lastweek"
27060>>>>>>>>>            Set Value DI_LAST_MONTH    to "ls.date.int_lastmonth"
27061>>>>>>>>>            Set Value DI_LAST_YEAR     to "ls.date.int_lastyear"
27062>>>>>>>>>            Set Value DI_WEEK_TO_DATE  to "ls.date.int_weektodate"
27063>>>>>>>>>            Set Value DI_MONTH_TO_DATE to "ls.date.int_monthtodate"
27064>>>>>>>>>            Set Value DI_YEAR_TO_DATE  to "ls.date.int_yeartodate"
27065>>>>>>>>>        End_Object
27066>>>>>>>>>    End_Procedure
27067>>>>>>>>>   
27067>>>>>>>>>    Procedure DecomposeDate Date dValue Integer ByRef iDay Integer ByRef iMonth Integer ByRef iYear
27069>>>>>>>>>        Integer iValue iFormat 
27069>>>>>>>>>        String sValue sSep 
27069>>>>>>>>>        Integer[] aNumbers
27070>>>>>>>>>   
27070>>>>>>>>>        Move (Date(dValue)) to dValue  
27071>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iFormat
27074>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iValue // overload  
27077>>>>>>>>>        Move (character(iValue)) to sSep          // end overload  
27078>>>>>>>>>        Move dValue to sValue  
27079>>>>>>>>>   
27079>>>>>>>>>        Send SplitString of oStringFunctions sValue sSep False False (&aNumbers)  
27080>>>>>>>>>        Move (SizeOfArray(aNumbers)) to iValue 
27081>>>>>>>>>        If (iValue=3) Begin
27083>>>>>>>>>            If (iFormat=DF_DATE_EUROPEAN) Begin
27085>>>>>>>>>                Move aNumbers[0] to iDay
27086>>>>>>>>>                Move aNumbers[1] to iMonth 
27087>>>>>>>>>                Move aNumbers[2] to iYear
27088>>>>>>>>>            End
27088>>>>>>>>>>
27088>>>>>>>>>            If (iFormat=DF_DATE_USA) Begin 
27090>>>>>>>>>                Move aNumbers[0] to iMonth 
27091>>>>>>>>>                Move aNumbers[1] to iDay   
27092>>>>>>>>>                Move aNumbers[2] to iYear  
27093>>>>>>>>>            End
27093>>>>>>>>>>
27093>>>>>>>>>            If (iFormat=DF_DATE_MILITARY) Begin
27095>>>>>>>>>                Move aNumbers[0] to iYear  
27096>>>>>>>>>                Move aNumbers[1] to iMonth 
27097>>>>>>>>>                Move aNumbers[2] to iDay   
27098>>>>>>>>>            End
27098>>>>>>>>>>
27098>>>>>>>>>        End
27098>>>>>>>>>>
27098>>>>>>>>>        Else Begin 
27099>>>>>>>>>            Move 0 to iDay 
27100>>>>>>>>>            Move 0 to iMonth   
27101>>>>>>>>>            Move 0 to iYear
27102>>>>>>>>>        End
27102>>>>>>>>>>
27102>>>>>>>>>    End_Procedure
27103>>>>>>>>>   
27103>>>>>>>>>    Function ComposeDate Integer iDay Integer iMonth Integer iYear Returns Date
27105>>>>>>>>>        Integer iFormat iDD iMM iYY
27105>>>>>>>>>        Date dValue
27105>>>>>>>>>        String sSep
27105>>>>>>>>>        ifnot (iDay*iMonth) Function_Return 0
27108>>>>>>>>>
27108>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iFormat // overload 
27111>>>>>>>>>        Move (character(iFormat)) to sSep          // end overload 
27112>>>>>>>>>   
27112>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iFormat
27115>>>>>>>>>        If (iDay>28) Begin 
27117>>>>>>>>>            If (iFormat=DF_DATE_EUROPEAN) Move (Date(String(iDay)+sSep+String(iMonth)+sSep+String(iYear))) to dValue // DMY
27120>>>>>>>>>            If (iFormat=DF_DATE_USA)      Move (Date(String(iMonth)+sSep+String(iDay)+sSep+String(iYear))) to dValue // MDY
27123>>>>>>>>>            If (iFormat=DF_DATE_MILITARY) Move (Date(String(iYear)+sSep+String(iMonth)+sSep+String(iDay))) to dValue // YMD
27126>>>>>>>>>            Send DecomposeDate dValue (&iDD) (&iMM) (&iYY)
27127>>>>>>>>>            If (iMM<>iMonth) Move (iDay-IDD) to iDay   
27130>>>>>>>>>        End
27130>>>>>>>>>>
27130>>>>>>>>>        If (iFormat=DF_DATE_EUROPEAN) Function_Return (Date(String(iDay)+sSep+String(iMonth)+sSep+String(iYear))) // DMY   
27133>>>>>>>>>        If (iFormat=DF_DATE_USA) Function_Return (Date(String(iMonth)+sSep+String(iDay)+sSep+String(iYear))) // MDY
27136>>>>>>>>>        Function_Return (Date(String(iYear)+sSep+String(iMonth)+sSep+String(iDay))) // YMD 
27137>>>>>>>>>    End_Function
27138>>>>>>>>>    
27138>>>>>>>>>    // DecomposeTimeString / TimeStringDecompose
27138>>>>>>>>>    Procedure DecomposeTimeString String sTime Integer ByRef iHour Integer ByRef iMin Integer ByRef iSec
27140>>>>>>>>>        String[] aValues
27141>>>>>>>>>        Send SplitString of oStringFunctions (trim(sTime)) ":" False False (&aValues)
27142>>>>>>>>>        If (SizeOfArray(aValues)=2) Begin
27144>>>>>>>>>            Move aValues[0] to iHour
27145>>>>>>>>>            Move aValues[1] to iMin
27146>>>>>>>>>            Move 0 to iSec
27147>>>>>>>>>        End
27147>>>>>>>>>>
27147>>>>>>>>>        Else If (SizeOfArray(aValues)=3) Begin
27150>>>>>>>>>            Move aValues[0] to iHour
27151>>>>>>>>>            Move aValues[1] to iMin
27152>>>>>>>>>            Move aValues[2] to iSec
27153>>>>>>>>>        End
27153>>>>>>>>>>
27153>>>>>>>>>        Else If (length(sTime)=4) Begin
27156>>>>>>>>>            Move (Mid(sTime,2,1)) to iHour
27157>>>>>>>>>            Move (Mid(sTime,2,3)) to iMin
27158>>>>>>>>>            Move 0 to iSec
27159>>>>>>>>>        End
27159>>>>>>>>>>
27159>>>>>>>>>        Else If (length(sTime)=6) Begin
27162>>>>>>>>>            Move (Mid(sTime,2,1)) to iHour
27163>>>>>>>>>            Move (Mid(sTime,2,3)) to iMin
27164>>>>>>>>>            Move (Mid(sTime,2,5)) to iSec            
27165>>>>>>>>>        End
27165>>>>>>>>>>
27165>>>>>>>>>        Else Begin
27166>>>>>>>>>            Move 0 to iHour
27167>>>>>>>>>            Move 0 to iMin 
27168>>>>>>>>>            Move 0 to iSec 
27169>>>>>>>>>        End
27169>>>>>>>>>>
27169>>>>>>>>>    End_Procedure
27170>>>>>>>>>    
27170>>>>>>>>>    // ComposeTimeString / TimeStringCompose
27170>>>>>>>>>    Function ComposeTimeString Integer iHour Integer iMin Integer iSec Returns String
27172>>>>>>>>>        Function_Return (If(iHour<10,"0","")+String(iHour)+":"+If(iMin<10,"0","")+String(iMin)+":"+If(iSec<10,"0","")+String(iSec))
27173>>>>>>>>>    End_Function
27174>>>>>>>>>    
27174>>>>>>>>>    // DecomposeTime / TimeDecompose
27174>>>>>>>>>    Procedure DecomposeTime Time tmTime Integer ByRef iHour Integer ByRef iMin Integer ByRef iSec
27176>>>>>>>>>        Move (DateGetHour(tmTime)) to iHour
27177>>>>>>>>>        Move (DateGetMinute(tmTime)) to iMin
27178>>>>>>>>>        Move (DateGetSecond(tmTime)) to iSec
27179>>>>>>>>>    End_Procedure
27180>>>>>>>>>    
27180>>>>>>>>>    // ComposeTime / TimeCompose
27180>>>>>>>>>    Function ComposeTime Integer iHour Integer iMin Integer iSec Returns Time
27182>>>>>>>>>        Time tRval
27182>>>>>>>>>        Move (DateSetHour(tRval,iHour)) to tRval
27183>>>>>>>>>        Move (DateSetMinute(tRval,iMin)) to tRval
27184>>>>>>>>>        Move (DateSetSecond(tRval,iSec)) to tRval
27185>>>>>>>>>        Function_Return tRval
27186>>>>>>>>>    End_Function
27187>>>>>>>>>        
27187>>>>>>>>>    // DecomposeDateTime / DateTimeDecompose
27187>>>>>>>>>    Procedure DecomposeDateTime DateTime dtValue Date ByRef dDate Time ByRef tmTime
27189>>>>>>>>>        Move (ComposeDate(Self,DateGetDay(dtValue),DateGetMonth(dtValue),DateGetYear(dtValue))) to dDate
27190>>>>>>>>>        Move (ComposeTime(Self,DateGetHour(dtValue),DateGetMinute(dtValue),DateGetSecond(dtValue))) to tmTime
27191>>>>>>>>>    End_Procedure
27192>>>>>>>>>    
27192>>>>>>>>>    // ComposeDateTime / DateTimeCompose
27192>>>>>>>>>    Function ComposeDateTime Date dDate Time tmTime Returns DateTime
27194>>>>>>>>>        Integer iHour iMin iSec
27194>>>>>>>>>        DateTime dtRval
27194>>>>>>>>>        Move dDate to dtRval
27195>>>>>>>>>        Move (DateGetHour(tmTime)) to iHour
27196>>>>>>>>>        Move (DateGetMinute(tmTime)) to iMin
27197>>>>>>>>>        Move (DateGetSecond(tmTime)) to iSec
27198>>>>>>>>>        If (iHour<>0) Move (DateSetHour(dtRval,iHour)) to dtRval
27201>>>>>>>>>        If (iMin<>0) Move (DateSetMinute(dtRval,iMin)) to dtRval
27204>>>>>>>>>        If (iSec<>0) Move (DateSetSecond(dtRval,iSec)) to dtRval
27207>>>>>>>>>        Function_Return dtRval
27208>>>>>>>>>    End_Function
27209>>>>>>>>>    
27209>>>>>>>>>    // DecomposeDateTimeString / DateTimeStringDecompose
27209>>>>>>>>>    Procedure DecomposeDateTimeString DateTime dtValue Date ByRef dDate String ByRef sTime
27211>>>>>>>>>        Move (ComposeDate(Self,DateGetDay(dtValue),DateGetMonth(dtValue),DateGetYear(dtValue))) to dDate
27212>>>>>>>>>        Move (ComposeTimeString(Self,DateGetHour(dtValue),DateGetMinute(dtValue),DateGetSecond(dtValue))) to sTime
27213>>>>>>>>>    End_Procedure
27214>>>>>>>>>    
27214>>>>>>>>>    // ComposeDateTimeString / DateTimeStringCompose
27214>>>>>>>>>    Function ComposeDateTimeString Date dDate String sTime Returns DateTime
27216>>>>>>>>>        Integer iHour iMin iSec
27216>>>>>>>>>        DateTime dtRval
27216>>>>>>>>>        Send DecomposeTimeString sTime (&iHour) (&iMin) (&iSec)
27217>>>>>>>>>        Move dDate to dtRval
27218>>>>>>>>>        Move (DateSetHour(dtRval,iHour)) to dtRval
27219>>>>>>>>>        Move (DateSetMinute(dtRval,iMin)) to dtRval
27220>>>>>>>>>        Move (DateSetSecond(dtRval,iSec)) to dtRval
27221>>>>>>>>>        Function_Return dtRval
27222>>>>>>>>>    End_Function
27223>>>>>>>>>    
27223>>>>>>>>>    Procedure DecomposeDateTimeAtoms DateTime dtValue Date ByRef dDate Integer ByRef iHour Integer ByRef iMin Integer ByRef iSec 
27225>>>>>>>>>        Time tmTime
27225>>>>>>>>>        Send DecomposeDateTime dtValue (&dDate) (&tmTime)
27226>>>>>>>>>        Send DecomposeTime tmTime (&iHour) (&iMin) (&iSec)
27227>>>>>>>>>    End_Procedure
27228>>>>>>>>>    
27228>>>>>>>>>    Function ComposeDateTimeAtoms Date dDate Integer iHour Integer iMin Integer iSec Returns DateTime
27230>>>>>>>>>        Time tmTime
27230>>>>>>>>>        DateTime dtValue
27230>>>>>>>>>        Get ComposeTime iHour iMin iSec to tmTime
27231>>>>>>>>>        Get ComposeDateTime dDate tmTime to dtValue
27232>>>>>>>>>        Function_Return dtValue
27233>>>>>>>>>    End_Function
27234>>>>>>>>>
27234>>>>>>>>>    Procedure DecomposeDateTimeQuarks DateTime dtValue Integer ByRef iYear Integer ByRef iMonth Integer ByRef iDay Integer ByRef iHour Integer ByRef iMin Integer ByRef iSec 
27236>>>>>>>>>        Date dDate
27236>>>>>>>>>        Time tmTime
27236>>>>>>>>>        Send DecomposeDateTime dtValue (&dDate) (&tmTime)
27237>>>>>>>>>        Send DecomposeDate dDate (&iDay) (&iMonth) (&iYear)
27238>>>>>>>>>        Send DecomposeTime tmTime (&iHour) (&iMin) (&iSec)
27239>>>>>>>>>    End_Procedure
27240>>>>>>>>>    
27240>>>>>>>>>    Function ComposeDateTimeQuarks Integer iYear Integer iMonth Integer iDay Integer iHour Integer iMin Integer iSec Returns DateTime
27242>>>>>>>>>        Time tmTime
27242>>>>>>>>>        Date dDate
27242>>>>>>>>>        DateTime dtValue
27242>>>>>>>>>        Get ComposeDate iDay iMonth iYear to dDate
27243>>>>>>>>>        Get ComposeTime iHour iMin iSec to tmTime
27244>>>>>>>>>        Get ComposeDateTime dDate tmTime to dtValue
27245>>>>>>>>>        Function_Return dtValue
27246>>>>>>>>>    End_Function
27247>>>>>>>>>
27247>>>>>>>>>    Function TimeToTimeString Time tmTime Returns String
27249>>>>>>>>>        Integer iHour iMin iSec
27249>>>>>>>>>        Send DecomposeTime tmTime (&iHour) (&iMin) (&iSec)
27250>>>>>>>>>        Function_Return (ComposeTimeString(Self,iHour,iMin,iSec))
27251>>>>>>>>>    End_Function
27252>>>>>>>>>    
27252>>>>>>>>>    Function TimeStringToTime String sTime Returns Time
27254>>>>>>>>>        Integer iHour iMin iSec
27254>>>>>>>>>        Send DecomposeTimeString sTime (&iHour) (&iMin) (&iSec)
27255>>>>>>>>>        Function_Return (ComposeTime(Self,iHour,iMin,iSec))
27256>>>>>>>>>    End_Function
27257>>>>>>>>>    
27257>>>>>>>>>    // The number returned is equivalent to the number of seconds between Jan 1st year 0 and the value of dtValue. This means that you may subtract two such values to get the number of seconds elapsed between the two.
27257>>>>>>>>>    Function DateTimeToNumber DateTime dtValue Returns Number
27259>>>>>>>>>        Date dValue
27259>>>>>>>>>        Move dtValue to dValue // Strip hours, minutes and seconds
27260>>>>>>>>>        Function_Return (Integer(dValue)*24.0+DateGetHour(dtValue)*60+DateGetMinute(dtValue)*60+DateGetSecond(dtValue))
27261>>>>>>>>>    End_Function
27262>>>>>>>>>
27262>>>>>>>>>    Function NumberToDateTime Number nValue Returns DateTime
27264>>>>>>>>>        Integer iSeconds iHours iMinutes
27264>>>>>>>>>        Date dValue
27264>>>>>>>>>        String sTime
27264>>>>>>>>>        Time tmTime
27264>>>>>>>>>        DateTime dtRval
27264>>>>>>>>>        Move (Date(Integer(nValue/86400))) to dValue
27265>>>>>>>>>        If (Integer(dValue)<>0) Begin
27267>>>>>>>>>            Move (nValue-(86400.0*Integer(dValue))) to iSeconds
27268>>>>>>>>>            Move (iSeconds/3600) to iHours
27269>>>>>>>>>            Move (iSeconds-(iHours*3600)) to iSeconds
27270>>>>>>>>>            Move (iSeconds/60) to iMinutes
27271>>>>>>>>>            Move (iSeconds-(iMinutes*60)) to iSeconds
27272>>>>>>>>>            Get ComposeTimeString iHours iMinutes iSeconds to sTime
27273>>>>>>>>>            Get TimeStringToTime sTime to tmTime
27274>>>>>>>>>            Get ComposeDateTime dValue tmTime to dtRval
27275>>>>>>>>>            
27275>>>>>>>>>            //Function_Return (DateTimeCompose(Self,dValue,TimeStringToTime(Self,sTime)))
27275>>>>>>>>>        End
27275>>>>>>>>>>
27275>>>>>>>>>        Function_Return dtRval
27276>>>>>>>>>    End_Function
27277>>>>>>>>>   
27277>>>>>>>>>    Function SystemDate Returns Date
27279>>>>>>>>>        Date dDate
27279>>>>>>>>>        Sysdate4 dDate
27280>>>>>>>>>        Function_Return dDate
27281>>>>>>>>>    End_Function
27282>>>>>>>>>
27282>>>>>>>>>    Function SystemTimeString Returns String
27284>>>>>>>>>        Integer iHour iMin iSec
27284>>>>>>>>>        Sysdate4 iHour iHour iMin iSec
27288>>>>>>>>>        Function_Return (ComposeTimeString(Self,iHour,iMin,iSec))
27289>>>>>>>>>    End_Function
27290>>>>>>>>>    
27290>>>>>>>>>    Function SystemTimeStringMS Returns String
27292>>>>>>>>>        tSystemTimeMS strTime
27292>>>>>>>>>        tSystemTimeMS strTime
27292>>>>>>>>>        String sValue
27292>>>>>>>>>        Get SystemTimeMilliSeconds to strTime
27293>>>>>>>>>        Get SystemTimeToString23 strTime to sValue
27294>>>>>>>>>        Function_Return (Right(sValue,12)) // Only the 'time' part
27295>>>>>>>>>    End_Function
27296>>>>>>>>>    
27296>>>>>>>>>    Function SystemDateTime Returns DateTime
27298>>>>>>>>>        Function_Return (CurrentDateTime())
27299>>>>>>>>>    End_Function
27300>>>>>>>>>    
27300>>>>>>>>>    Function SystemTime Returns Time // <-New
27302>>>>>>>>>        Date dValue
27302>>>>>>>>>        DateTime dtValue
27302>>>>>>>>>        Time tmResult
27302>>>>>>>>>        Move (CurrentDateTime()) to dtValue
27303>>>>>>>>>        Send DecomposeDateTime dtValue (&dValue) (&tmResult)
27304>>>>>>>>>        Function_Return tmResult
27305>>>>>>>>>    End_Function
27306>>>>>>>>>    
27306>>>>>>>>>    Function SystemTimeMilliSeconds Returns tSystemTimeMS
27308>>>>>>>>>        Integer iVoid
27308>>>>>>>>>        tSystemTimeMS stRval
27308>>>>>>>>>        tSystemTimeMS stRval
27308>>>>>>>>>        Move (do_GetSystemTime(AddressOf(stRval))) to iVoid
27309>>>>>>>>>        Function_Return stRval
27310>>>>>>>>>    End_Function 
27311>>>>>>>>>    
27311>>>>>>>>>    Function ModuleStartTime Returns String // YYYY-MM-DDTHH:MM:SS.mmm
27313>>>>>>>>>        Function_Return _gsDate$ModuleStartTime 
27314>>>>>>>>>    End_Function
27315>>>>>>>>>    
27315>>>>>>>>>    Function SystemTimeMilliSecondsElapsed tSystemTimeMS strStart tSystemTimeMS strStop Returns Number
27317>>>>>>>>>        Integer iDays
27317>>>>>>>>>        tSystemTimeMS strStopX
27317>>>>>>>>>        tSystemTimeMS strStopX
27317>>>>>>>>>        If (num_arguments>1) Begin
27319>>>>>>>>>            Move strStop to strStopX
27320>>>>>>>>>        End
27320>>>>>>>>>>
27320>>>>>>>>>        Else Begin
27321>>>>>>>>>            Get SystemTimeMilliSeconds to strStopX
27322>>>>>>>>>        End
27322>>>>>>>>>>
27322>>>>>>>>>        Move (Integer(ComposeDate(Self,strStopX.iDay,strStopX.iMonth,strStopX.iYear))-Integer(ComposeDate(Self,strStart.iDay,strStart.iMonth,strStart.iYear))) to iDays
27323>>>>>>>>>        Function_Return (iDays*24.0+(strStopX.iHour-strStart.iHour)*60+(strStopX.iMinute-strStart.iMinute)*60+(strStopX.iSecond-strStart.iSecond)*1000+strStopX.iMilliSeconds-strStart.iMilliSeconds)
27324>>>>>>>>>    End_Function
27325>>>>>>>>>
27325>>>>>>>>>    Function SystemTimeToString tSystemTimeMS stTime Returns String
27327>>>>>>>>>        String sValue
27327>>>>>>>>>
27327>>>>>>>>>        Move stTime.iYear to sValue
27328>>>>>>>>>        Move (sValue+IntegerToStringRzf(oStringFunctions,stTime.iMonth,2)) to sValue
27329>>>>>>>>>        Move (sValue+IntegerToStringRzf(oStringFunctions,stTime.iDay,2)) to sValue
27330>>>>>>>>>        Move (sValue+IntegerToStringRzf(oStringFunctions,stTime.iHour,2)) to sValue
27331>>>>>>>>>        Move (sValue+IntegerToStringRzf(oStringFunctions,stTime.iMinute,2)) to sValue
27332>>>>>>>>>        Move (sValue+IntegerToStringRzf(oStringFunctions,stTime.iSecond,2)) to sValue
27333>>>>>>>>>        Move (sValue+IntegerToStringRzf(oStringFunctions,stTime.iMilliSeconds,3)) to sValue
27334>>>>>>>>>        
27334>>>>>>>>>        Function_Return sValue // 19991231135959999 (=length:17)
27335>>>>>>>>>    End_Function
27336>>>>>>>>>    
27336>>>>>>>>>    Function SystemTimeToString23 tSystemTimeMS stTime Returns String
27338>>>>>>>>>        String sValue 
27338>>>>>>>>>
27338>>>>>>>>>        Move stTime.iYear to sValue
27339>>>>>>>>>        Move (sValue+"-"+IntegerToStringRzf(oStringFunctions,stTime.iMonth,2)) to sValue
27340>>>>>>>>>        Move (sValue+"-"+IntegerToStringRzf(oStringFunctions,stTime.iDay,2)) to sValue
27341>>>>>>>>>        Move (sValue+"T"+IntegerToStringRzf(oStringFunctions,stTime.iHour,2)) to sValue
27342>>>>>>>>>        Move (sValue+":"+IntegerToStringRzf(oStringFunctions,stTime.iMinute,2)) to sValue
27343>>>>>>>>>        Move (sValue+":"+IntegerToStringRzf(oStringFunctions,stTime.iSecond,2)) to sValue
27344>>>>>>>>>        Move (sValue+"."+IntegerToStringRzf(oStringFunctions,stTime.iMilliSeconds,3)) to sValue
27345>>>>>>>>>        
27345>>>>>>>>>        Function_Return sValue // 1999-12-31T13:59:59.999 (=length:23)
27346>>>>>>>>>    End_Function               // 1    6  9  2  5  8  1
27347>>>>>>>>>    
27347>>>>>>>>>    Function String23ToSystemTime String sValue Returns tSystemTimeMS 
27349>>>>>>>>>        tSystemTimeMS strTime
27349>>>>>>>>>        tSystemTimeMS strTime
27349>>>>>>>>>        Move (Integer(Mid(sValue,4,1))) to strTime.iYear
27350>>>>>>>>>        Move (Integer(Mid(sValue,2,6))) to strTime.iMonth
27351>>>>>>>>>        Move (Integer(Mid(sValue,2,9))) to strTime.iDay
27352>>>>>>>>>        Move (Integer(Mid(sValue,2,12))) to strTime.iHour
27353>>>>>>>>>        Move (Integer(Mid(sValue,2,15))) to strTime.iMinute
27354>>>>>>>>>        Move (Integer(Mid(sValue,2,18))) to strTime.iSecond
27355>>>>>>>>>        Move (Integer(Mid(sValue,3,21))) to strTime.iMilliSeconds
27356>>>>>>>>>        Function_Return strTime
27357>>>>>>>>>    End_Function
27358>>>>>>>>>    
27358>>>>>>>>>    Function SystemTimeString23 Returns String
27360>>>>>>>>>        Function_Return (SystemTimeToString23(Self,SystemTimeMilliSeconds(Self)))
27361>>>>>>>>>    End_Function
27362>>>>>>>>>
27362>>>>>>>>>    Function SystemTimeAsPathNameSegment Returns String
27364>>>>>>>>>        String sPathNameSegment
27364>>>>>>>>>        Get SystemTimeString23 to sPathNameSegment
27365>>>>>>>>>        Move (Replace(":",sPathNameSegment,"")) to sPathNameSegment
27366>>>>>>>>>        Move (Replace(":",sPathNameSegment,"")) to sPathNameSegment
27367>>>>>>>>>        Move (Replace(".",sPathNameSegment,"")) to sPathNameSegment
27368>>>>>>>>>        Function_Return sPathNameSegment
27369>>>>>>>>>    End_Function
27370>>>>>>>>>    
27370>>>>>>>>>
27370>>>>>>>>>    //> Use Increment to add or subtract a number of months, years, days or
27370>>>>>>>>>    //> weeks to/from a given date.
27370>>>>>>>>>    //>
27370>>>>>>>>>    //>  date dValue        is the date to which the time interval will be added or subtracted 
27370>>>>>>>>>    //>
27370>>>>>>>>>    //>  integer iSegment   may be one of these constants: DS_YEAR, DS_MONTH, DS_DAY or DS_WEEK
27370>>>>>>>>>    //>
27370>>>>>>>>>    //>  integer iAmount    is the (positive or negative) amount of units (indicated by iSegment) to be added.
27370>>>>>>>>>    Function DateIncrement Date dValue Integer iSegment Integer iAmount Returns Date   
27372>>>>>>>>>        Integer iDay iMonth iYear  
27372>>>>>>>>>        If (Integer(dValue)=0) Function_Return 0  
27375>>>>>>>>>        If (iSegment=DS_QUARTER) Function_Return (DateIncrement(Self,dValue,DS_MONTH,iAmount*3))   
27378>>>>>>>>>        If (iSegment=DS_WEEK) Function_Return (dValue+(iAmount*7)) //weeks 
27381>>>>>>>>>        If (iSegment<>DS_DAY) Begin // months or years 
27383>>>>>>>>>            Send DecomposeDate dValue (&iDay) (&iMonth) (&iYear)   
27384>>>>>>>>>            If (iSegment=DS_MONTH) Begin //months  
27386>>>>>>>>>                Move (iMonth+iAmount) to iMonth
27387>>>>>>>>>                If (iAmount>=0) Function_Return (ComposeDate(Self,iDay,iMonth-(((iMonth-1)/12)*12),iYear+((iMonth-1)/12))) 
27390>>>>>>>>>                Function_Return (ComposeDate(Self,iDay,iMonth-(((iMonth-12)/12)*12),iYear+((iMonth-12)/12)))   
27391>>>>>>>>>            End //years:   
27391>>>>>>>>>>
27391>>>>>>>>>            If (iSegment=DS_YEAR) Function_Return (ComposeDate(Self,iDay,iMonth,iYear+iAmount))
27394>>>>>>>>>        End
27394>>>>>>>>>>
27394>>>>>>>>>        Else Function_Return (dValue+iAmount) //days   
27396>>>>>>>>>    End_Function   
27397>>>>>>>>>   
27397>>>>>>>>>    Function DateSegment Date dValue Integer iSegment Returns Integer  
27399>>>>>>>>>        Integer iDay iMonth iYear iWeek
27399>>>>>>>>>        If (iSegment=DS_WEEK) Begin
27401>>>>>>>>>            Get WeekNumber dValue to iWeek
27402>>>>>>>>>            Function_Return iWeek
27403>>>>>>>>>        End
27403>>>>>>>>>>
27403>>>>>>>>>        Else Begin
27404>>>>>>>>>            Send DecomposeDate dValue (&iDay) (&iMonth) (&iYear)   
27405>>>>>>>>>            If (iSegment=DS_DAY)     Function_Return iDay  
27408>>>>>>>>>            If (iSegment=DS_MONTH)   Function_Return iMonth
27411>>>>>>>>>            If (iSegment=DS_YEAR)    Function_Return iYear 
27414>>>>>>>>>            If (iSegment=DS_QUARTER) Function_Return (iMonth+2/3)
27417>>>>>>>>>        End
27417>>>>>>>>>>
27417>>>>>>>>>        Function_Return 0 // Also covers DS_ETERNITY
27418>>>>>>>>>    End_Function
27419>>>>>>>>>    
27419>>>>>>>>>    Function TimeIncrement Time tmValue Integer iSegment Integer iAmount Integer ByRef iDays Returns Time
27421>>>>>>>>>        Integer iHour iMin iSec
27421>>>>>>>>>        Send DecomposeTime tmValue (&iHour) (&iMin) (&iSec)
27422>>>>>>>>>        If (iSegment=DS_HOUR) Begin
27424>>>>>>>>>            Move (iHour+iAmount) to iHour
27425>>>>>>>>>        End
27425>>>>>>>>>>
27425>>>>>>>>>        If (iSegment=DS_MINUTE) Begin
27427>>>>>>>>>            Move (iMin+iAmount) to iMin
27428>>>>>>>>>        End
27428>>>>>>>>>>
27428>>>>>>>>>        If (iSegment=DS_SECOND) Begin
27430>>>>>>>>>            Move (iSec+iAmount) to iSec
27431>>>>>>>>>        End
27431>>>>>>>>>>
27431>>>>>>>>>        Move (iHour*60+iMin*60+iSec) to iSec
27432>>>>>>>>>        If (iSec>=0) Begin
27434>>>>>>>>>            Move (iSec/86400) to iDays
27435>>>>>>>>>        End
27435>>>>>>>>>>
27435>>>>>>>>>        Else Begin
27436>>>>>>>>>            Move (iSec/86400) to iDays
27437>>>>>>>>>            Decrement iDays
27438>>>>>>>>>        End
27438>>>>>>>>>>
27438>>>>>>>>>        Move (iSec-(iDays*86400)) to iSec
27439>>>>>>>>>        Move (iSec/3600) to iHour
27440>>>>>>>>>        Move (iSec-(iHour*3600)) to iSec
27441>>>>>>>>>        Move (iSec/60) to iMin
27442>>>>>>>>>        Move (iSec-(iMin*60)) to iSec
27443>>>>>>>>>        Get ComposeTime iHour iMin iSec to tmValue
27444>>>>>>>>>        Function_Return tmValue
27445>>>>>>>>>    End_Function
27446>>>>>>>>>
27446>>>>>>>>>    Function DateTimeIncrement DateTime dtValue Integer iSegment Integer iAmount Returns DateTime
27448>>>>>>>>>        Integer iDays
27448>>>>>>>>>        Date dValue
27448>>>>>>>>>        Time tmValue
27448>>>>>>>>>        Send DecomposeDateTime dtValue (&dValue) (&tmValue)
27449>>>>>>>>>        If (iSegment>=DS_DAY) Begin
27451>>>>>>>>>            Get DateIncrement dValue iSegment iAmount to dValue
27452>>>>>>>>>        End
27452>>>>>>>>>>
27452>>>>>>>>>        Else Begin
27453>>>>>>>>>            Get TimeIncrement tmValue iSegment iAmount (&iDays) to tmValue
27454>>>>>>>>>            Move (dValue+iDays) to dValue
27455>>>>>>>>>        End
27455>>>>>>>>>>
27455>>>>>>>>>        Function_Return (ComposeDateTime(Self,dValue,tmValue))
27456>>>>>>>>>    End_Function
27457>>>>>>>>>    
27457>>>>>>>>>    Function FirstDateIn Integer iDateSegment Date dValue Returns Date
27459>>>>>>>>>        Integer iQuarter iYear iMonth iWeek
27459>>>>>>>>>        If (iDateSegment=DS_MONTH) Begin
27461>>>>>>>>>            Get DateSegment dValue DS_MONTH to iMonth
27462>>>>>>>>>            Get DateSegment dValue DS_YEAR to iYear
27463>>>>>>>>>            Function_Return (ComposeDate(Self,1,iMonth,iYear))
27464>>>>>>>>>        End
27464>>>>>>>>>>
27464>>>>>>>>>        If (iDateSegment=DS_QUARTER) Begin
27466>>>>>>>>>            Get DateSegment dValue DS_QUARTER to iQuarter
27467>>>>>>>>>            Get DateSegment dValue DS_YEAR to iYear
27468>>>>>>>>>            Function_Return (ComposeDate(Self,1,iQuarter-1*3+1,iYear))
27469>>>>>>>>>        End
27469>>>>>>>>>>
27469>>>>>>>>>        If (iDateSegment=DS_YEAR) Begin
27471>>>>>>>>>            Get DateSegment dValue DS_YEAR to iYear
27472>>>>>>>>>            Function_Return (ComposeDate(Self,1,1,iYear))
27473>>>>>>>>>        End
27473>>>>>>>>>>
27473>>>>>>>>>        If (iDateSegment=DS_WEEK) Begin
27475>>>>>>>>>            Get DateSegment dValue DS_WEEK to iWeek
27476>>>>>>>>>            Get DateSegment dValue DS_YEAR to iYear
27477>>>>>>>>>            Get MondayInWeek iYear iWeek to dValue
27478>>>>>>>>>            Function_Return dValue
27479>>>>>>>>>        End
27479>>>>>>>>>>
27479>>>>>>>>>        Error 123 "Illegal iDateSegment value (Function FirstDateIn)"
27480>>>>>>>>>>
27480>>>>>>>>>    End_Function
27481>>>>>>>>>
27481>>>>>>>>>    Function LastDateIn Integer iDateSegment Date dValue Returns Date
27483>>>>>>>>>        If (iDateSegment=DS_MONTH) Begin
27485>>>>>>>>>            Get DateIncrement dValue DS_MONTH 1 to dValue
27486>>>>>>>>>            Function_Return (FirstDateIn(Self,DS_MONTH,dValue)-1)
27487>>>>>>>>>        End
27487>>>>>>>>>>
27487>>>>>>>>>        If (iDateSegment=DS_QUARTER) Begin
27489>>>>>>>>>            Get FirstDateIn DS_QUARTER dValue to dValue
27490>>>>>>>>>            Get DateIncrement dValue DS_QUARTER 1 to dValue
27491>>>>>>>>>            Function_Return (DateIncrement(Self,dValue,DS_DAY,-1))
27492>>>>>>>>>        End
27492>>>>>>>>>>
27492>>>>>>>>>        If (iDateSegment=DS_YEAR) Begin
27494>>>>>>>>>            Get DateIncrement dValue DS_YEAR 1 to dValue   
27495>>>>>>>>>            Function_Return (FirstDateIn(Self,DS_YEAR,dValue)-1)
27496>>>>>>>>>        End
27496>>>>>>>>>>
27496>>>>>>>>>        If (iDateSegment=DS_WEEK) Begin
27498>>>>>>>>>            Get FirstDateIn DS_WEEK dValue to dValue
27499>>>>>>>>>            Get DateIncrement dValue DS_DAY 6 to dValue
27500>>>>>>>>>            Function_Return dValue
27501>>>>>>>>>        End
27501>>>>>>>>>>
27501>>>>>>>>>        Error 123 "Illegal iDateSegment value (Function LastDateIn)"
27502>>>>>>>>>>
27502>>>>>>>>>    End_Function
27503>>>>>>>>>   
27503>>>>>>>>>    // This procedure calculates the date interval including dAnchor in the last interval and the previous iIntervals-1 intervals.
27503>>>>>>>>>    Procedure CalculateStartStopDates Date dAnchor Integer iDateSegment Integer iIntervals Date ByRef dBegin Date ByRef dEnd
27505>>>>>>>>>        If (iDateSegment=DS_DAY) Begin
27507>>>>>>>>>            Get DateIncrement dAnchor DS_DAY (1-iIntervals) to dBegin
27508>>>>>>>>>            Move dAnchor to dEnd
27509>>>>>>>>>        End
27509>>>>>>>>>>
27509>>>>>>>>>        If (iDateSegment=DS_WEEK) Begin
27511>>>>>>>>>            Get MondayInWeek (DateSegment(Self,dAnchor,DS_YEAR)) (DateSegment(Self,dAnchor,DS_WEEK)) to dAnchor
27512>>>>>>>>>            Get DateIncrement dAnchor DS_DAY 6 to dEnd
27513>>>>>>>>>            Get DateIncrement dAnchor DS_WEEK (1-iIntervals) to dBegin
27514>>>>>>>>>        End
27514>>>>>>>>>>
27514>>>>>>>>>        If (iDateSegment=DS_MONTH) Begin
27516>>>>>>>>>            Get FirstDateIn DS_MONTH dAnchor to dAnchor
27517>>>>>>>>>            Get DateIncrement dAnchor DS_MONTH (1-iIntervals) to dBegin
27518>>>>>>>>>            Get LastDateIn DS_MONTH dAnchor to dEnd
27519>>>>>>>>>        End
27519>>>>>>>>>>
27519>>>>>>>>>        If (iDateSegment=DS_QUARTER) Begin
27521>>>>>>>>>            Get FirstDateIn DS_QUARTER dAnchor to dAnchor
27522>>>>>>>>>            Get DateIncrement dAnchor DS_QUARTER (1-iIntervals) to dBegin
27523>>>>>>>>>            Get LastDateIn DS_QUARTER dAnchor to dEnd
27524>>>>>>>>>        End
27524>>>>>>>>>>
27524>>>>>>>>>        If (iDateSegment=DS_YEAR) Begin
27526>>>>>>>>>            Get FirstDateIn DS_YEAR dAnchor to dAnchor
27527>>>>>>>>>            Get DateIncrement dAnchor DS_YEAR (1-iIntervals) to dBegin
27528>>>>>>>>>            Get LastDateIn DS_YEAR dAnchor to dEnd
27529>>>>>>>>>        End
27529>>>>>>>>>>
27529>>>>>>>>>    End_Procedure
27530>>>>>>>>>    
27530>>>>>>>>>    Function DatesDistance Date dValue1 Date dValue2 Integer iSegment Returns Integer   
27532>>>>>>>>>        Integer bNeg iDistance iDay iYear1 iYear2 iMonth1 iMonth2  
27532>>>>>>>>>        Date dTemp 
27532>>>>>>>>>        If (dValue1>dValue2) Begin 
27534>>>>>>>>>            Move dValue1 to dTemp  
27535>>>>>>>>>            Move dValue2 to dValue1
27536>>>>>>>>>            Move dTemp to dValue2  
27537>>>>>>>>>            Move True to bNeg  
27538>>>>>>>>>        End
27538>>>>>>>>>>
27538>>>>>>>>>        Else Move False to bNeg
27540>>>>>>>>>        If (iSegment=DS_DAY) Move (Integer(dValue2)-Integer(dValue1)) to iDistance 
27543>>>>>>>>>        If (iSegment=DS_WEEK) Begin
27545>>>>>>>>>            Get DayNumber dValue1 to iDay  
27546>>>>>>>>>            Move (Date(Integer(dValue1)-iDay+1)) to dValue1 // Now a monday
27547>>>>>>>>>            Get DayNumber dValue2 to iDay  
27548>>>>>>>>>            Move (Date(Integer(dValue2)-iDay+1)) to dValue2 // Now a monday
27549>>>>>>>>>            Move (Integer(dValue2)-Integer(dValue1)) to iDistance  
27550>>>>>>>>>            Move (iDistance/7) to iDistance
27551>>>>>>>>>        End
27551>>>>>>>>>>
27551>>>>>>>>>        If (iSegment=DS_MONTH) Begin   
27553>>>>>>>>>            Get DateSegment dValue1 DS_MONTH to iMonth1
27554>>>>>>>>>            Get DateSegment dValue1 DS_YEAR to iYear1
27555>>>>>>>>>            Get DateSegment dValue2 DS_MONTH to iMonth2
27556>>>>>>>>>            Get DateSegment dValue2 DS_YEAR to iYear2  
27557>>>>>>>>>            Move (iYear2-iYear1*12+iMonth2-iMonth1) to iDistance   
27558>>>>>>>>>        End
27558>>>>>>>>>>
27558>>>>>>>>>        If (iSegment=DS_QUARTER) Begin
27560>>>>>>>>>            Get DateSegment dValue1 DS_QUARTER to iMonth1 // Overload  
27561>>>>>>>>>            Get DateSegment dValue1 DS_YEAR to iYear1  
27562>>>>>>>>>            Get DateSegment dValue2 DS_QUARTER to iMonth2 // Overload  
27563>>>>>>>>>            Get DateSegment dValue2 DS_YEAR to iYear2  
27564>>>>>>>>>            Move (iYear2-iYear1*4+iMonth2-iMonth1) to iDistance
27565>>>>>>>>>        End
27565>>>>>>>>>>
27565>>>>>>>>>        If (iSegment=DS_YEAR) Begin
27567>>>>>>>>>            Get DateSegment dValue1 DS_YEAR to iYear1  
27568>>>>>>>>>            Get DateSegment dValue2 DS_YEAR to iYear2  
27569>>>>>>>>>            Move (iYear2-iYear1) to iDistance  
27570>>>>>>>>>        End
27570>>>>>>>>>>
27570>>>>>>>>>        If bNeg Move (0-iDistance) to iDistance
27573>>>>>>>>>        Function_Return iDistance  
27574>>>>>>>>>    End_Function
27575>>>>>>>>>
27575>>>>>>>>>    Function WeekNumber Date dValue Returns Integer
27577>>>>>>>>>        Integer iWeek iFirstWeekDay iDayOfYear iYear iWeekDay  
27577>>>>>>>>>        If not (Integer(dValue)) Function_Return 0  
27580>>>>>>>>>   
27580>>>>>>>>>        Get DayNumber dValue to iWeekDay   
27581>>>>>>>>>        Get DateSegment (dValue-iWeekDay+1) DS_YEAR to iYear   
27582>>>>>>>>>   
27582>>>>>>>>>        Get DayNumber (FirstDateIn(Self,DS_YEAR,dValue)) to iFirstWeekDay   
27583>>>>>>>>>        Move (dValue-FirstDateIn(Self,DS_YEAR,dValue)) to iDayOfYear
27584>>>>>>>>>        Move (iDayOfYear-1-7+iFirstWeekDay) to iDayOfYear  
27585>>>>>>>>>        If ((iDayOfYear/7.0)>=0) Move (iDayOfYear/7+1) to iWeek
27588>>>>>>>>>        Else Move 0 to iWeek   
27590>>>>>>>>>        If (iFirstWeekDay<=4) Increment iWeek  
27593>>>>>>>>>        If (iWeek>52) Begin
27595>>>>>>>>>            Move 1 to iWeek
27596>>>>>>>>>            If (iFirstWeekDay=4) Move 53 to iWeek  
27599>>>>>>>>>            If (iFirstWeekDay=3) If (((iYear/4)*4)=iYear) If (((iYear/100)*100)<>iYear) Move 53 to iWeek   
27606>>>>>>>>>        End
27606>>>>>>>>>>
27606>>>>>>>>>        If (iWeek=0) Begin 
27608>>>>>>>>>            // Week 52 or 53   
27608>>>>>>>>>            Get DayNumber (DateIncrement(Self,FirstDateIn(Self,DS_YEAR,dValue),DS_YEAR,-1)) to iFirstWeekDay 
27609>>>>>>>>>            Move 52 to iWeek   
27610>>>>>>>>>            If (iFirstWeekDay=4) Move 53 to iWeek  
27613>>>>>>>>>            If (iFirstWeekDay=3) If (((iYear/4)*4)=iYear) If (((iYear/100)*100)<>iYear) Move 53 to iWeek
27620>>>>>>>>>        End
27620>>>>>>>>>>
27620>>>>>>>>>        Function_Return iWeek  
27621>>>>>>>>>    End_Function   
27622>>>>>>>>>
27622>>>>>>>>>    Function DayNumber Date dValue Returns Integer 
27624>>>>>>>>>        Integer iRval // 1=Monday, ... , 7=Sunday  
27624>>>>>>>>>        //get Date2to4 dValue to dValue
27624>>>>>>>>>        Move dValue to iRval   
27625>>>>>>>>>        If iRval Begin
27627>>>>>>>>>            If (iRval>693975) Move (iRval-2) to iRval  
27630>>>>>>>>>            Move (iRval-((iRval/7)*7)) to iRval
27631>>>>>>>>>            If (iRval=0) Move 7 to iRval   
27634>>>>>>>>>        End
27634>>>>>>>>>>
27634>>>>>>>>>        Function_Return iRval  
27635>>>>>>>>>    End_Function   
27636>>>>>>>>>    
27636>>>>>>>>>    Function DayName Integer iDay Returns String
27638>>>>>>>>>        Function_Return (Value(oDayNames,iDay))
27639>>>>>>>>>    End_Function
27640>>>>>>>>>    
27640>>>>>>>>>    Function MonthName Integer iMonth Returns String
27642>>>>>>>>>        Function_Return (Value(oMonthNames,iMonth))
27643>>>>>>>>>    End_Function
27644>>>>>>>>>    
27644>>>>>>>>>    Function DateMonthName Date dValue Returns String
27646>>>>>>>>>        Integer iMonth
27646>>>>>>>>>        Get DateSegment dValue DS_MONTH to iMonth
27647>>>>>>>>>        Function_Return (MonthName(Self,iMonth))
27648>>>>>>>>>    End_Function
27649>>>>>>>>>    
27649>>>>>>>>>    Function DateDayName Date dValue Returns String
27651>>>>>>>>>        Integer iDay
27651>>>>>>>>>        Get DayNumber dValue to iDay
27652>>>>>>>>>        Function_Return (DayName(Self,iDay))
27653>>>>>>>>>    End_Function
27654>>>>>>>>>
27654>>>>>>>>>    Function WeekCountOfYear Integer iYear Returns Integer
27656>>>>>>>>>        Integer iWeek1 iWeek2  
27656>>>>>>>>>        Get WeekNumber (ComposeDate(Self,31,12,iYear)) to iWeek1   
27657>>>>>>>>>        Get WeekNumber (ComposeDate(Self,24,12,iYear)) to iWeek2   
27658>>>>>>>>>        Function_Return (iWeek1 max iWeek2)
27659>>>>>>>>>    End_Function   
27660>>>>>>>>>   
27660>>>>>>>>>    Function MondayInWeek Integer iYear Integer iWeek Returns Date
27662>>>>>>>>>        Date dVal
27662>>>>>>>>>        Get ComposeDate 1 1 iYear to dVal
27663>>>>>>>>>        If (WeekNumber(Self,dVal)<>1) Move (dVal+7) to dVal // week 52 or 53
27666>>>>>>>>>        Move (dVal-DayNumber(Self,dVal)+1) to dVal // Now it's a Monday
27667>>>>>>>>>        Function_Return (iWeek-1*7+dVal)
27668>>>>>>>>>    End_Function
27669>>>>>>>>>    
27669>>>>>>>>>    // May be used like this:
27669>>>>>>>>>    //  get DateToText of oDateFunctions 06/06/2008 "#D-#MN3-#Y4" to sValue
27669>>>>>>>>>    //  => sValue = 6-Jul-2008
27669>>>>>>>>>    Function DateToText Date dValue String sFormat Returns String
27671>>>>>>>>>        Integer iDay iMonth iYear iYearTmp
27671>>>>>>>>>        If (Integer(dValue)=0) Function_Return ""
27674>>>>>>>>>        Move (Replace("#DN3",sFormat,Left(DateDayName(Self,dValue),3)))   to sFormat
27675>>>>>>>>>        Move (Replace("#DN2",sFormat,Left(DateDayName(Self,dValue),2)))   to sFormat // Dutch request. 
27676>>>>>>>>>        Move (Replace("#MN3",sFormat,Left(DateMonthName(Self,dValue),3))) to sFormat
27677>>>>>>>>>        Move (Replace("#DN", sFormat,DateDayName(Self,dValue)))           to sFormat
27678>>>>>>>>>        Move (Replace("#MN", sFormat,DateMonthName(Self,dValue)))         to sFormat
27679>>>>>>>>>        Move (Replace("#WN", sFormat,WeekNumber(Self,dValue)))        to sFormat
27680>>>>>>>>>        Move (DateSegment(Self,dValue,DS_DAY))   to iDay
27681>>>>>>>>>        Move (DateSegment(Self,dValue,DS_MONTH)) to iMonth
27682>>>>>>>>>        Move (DateSegment(Self,dValue,DS_YEAR))  to iYear
27683>>>>>>>>>        Move (Replace("#D2", sFormat,If(iDay<10,"0"+String(iDay),String(iDay)))) to sFormat
27684>>>>>>>>>        Move (Replace("#D",  sFormat,String(iDay))) to sFormat
27685>>>>>>>>>                    
27685>>>>>>>>>        Move (Right(String(iYear),2)) to iYearTmp // Year 4 -> 2
27686>>>>>>>>>        Move (Replace("#Y2", sFormat,If(iYearTmp<10,"0"+String(iYearTmp),String(iYearTmp)))) to sFormat
27687>>>>>>>>>        
27687>>>>>>>>>//        Get Year2to4 iYear to iYearTmp
27687>>>>>>>>>        Move (Replace("#Y4", sFormat,String(iYear))) to sFormat
27688>>>>>>>>>
27688>>>>>>>>>        Move (Replace("#M2", sFormat,If(iMonth<10,"0"+String(iMonth),String(iMonth)))) to sFormat
27689>>>>>>>>>        Move (Replace("#M",  sFormat,String(iMonth))) to sFormat
27690>>>>>>>>>        Function_Return sFormat
27691>>>>>>>>>    End_Function
27692>>>>>>>>>
27692>>>>>>>>>    Function DateToString Date dValue Integer iFormat Boolean bLong String sSep Returns String
27694>>>>>>>>>        Integer iDay iMonth iYear
27694>>>>>>>>>        String sRval sDay sMonth sYear
27694>>>>>>>>>        If (Integer(dValue)) Begin
27696>>>>>>>>>            Send DecomposeDate dValue (&iDay) (&iMonth) (&iYear)
27697>>>>>>>>>            Get IntegerToStringRzf of oStringFunctions iDay 2 to sDay
27698>>>>>>>>>            Get IntegerToStringRzf of oStringFunctions iMonth 2 to sMonth
27699>>>>>>>>>            Move iYear to sYear
27700>>>>>>>>>            If (not(bLong)) Move (right(sYear,2)) to sYear
27703>>>>>>>>>            If (iFormat=DF_DATE_EUROPEAN) Move (sDay+sSep+sMonth+sSep+sYear) to sRval // DMY
27706>>>>>>>>>            If (iFormat=DF_DATE_USA)      Move (sMonth+sSep+sDay+sSep+sYear) to sRval // MDY
27709>>>>>>>>>            If (iFormat=DF_DATE_MILITARY) Move (sYear+sSep+sMonth+sSep+sDay) to sRval // YMD
27712>>>>>>>>>        End
27712>>>>>>>>>>
27712>>>>>>>>>        Else Move "" to sRval
27714>>>>>>>>>        Function_Return sRval
27715>>>>>>>>>    End_Function
27716>>>>>>>>>
27716>>>>>>>>>    Function StringToDate String sDate Integer iFormat Returns Date
27718>>>>>>>>>        Integer iLen iPos iValIdx
27718>>>>>>>>>        Integer[3] aValues
27719>>>>>>>>>        Date dRval
27719>>>>>>>>>        String sChar
27719>>>>>>>>>        Move (Trim(sDate)) to sDate
27720>>>>>>>>>        Move (Length(sDate)) to iLen
27721>>>>>>>>>        Move 0 to iValIdx
27722>>>>>>>>>
27722>>>>>>>>>        For iPos from 1 to iLen
27728>>>>>>>>>>
27728>>>>>>>>>            Move (mid(sDate,1,iPos)) to sChar
27729>>>>>>>>>            If ("0123456789" contains sChar) Move (aValues[iValIdx]*10+Integer(sChar)) to aValues[iValIdx]
27732>>>>>>>>>            Else Increment iValIdx
27734>>>>>>>>>        Loop
27735>>>>>>>>>>
27735>>>>>>>>>
27735>>>>>>>>>        If (iValIdx=2 or (iValIdx=0 and (iLen=6 or iLen=8))) Begin // 3 values or 1
27737>>>>>>>>>            If (iValIdx=0) Begin
27739>>>>>>>>>                If (iLen=6) Begin
27741>>>>>>>>>                    Move (Left(sDate,2)) to aValues[0]
27742>>>>>>>>>                    Move (Mid(sDate,2,3)) to aValues[1]
27743>>>>>>>>>                    Move (Right(sDate,2)) to aValues[2]
27744>>>>>>>>>                End
27744>>>>>>>>>>
27744>>>>>>>>>                Else Begin // iLen:8
27745>>>>>>>>>                    If (iFormat=DF_DATE_MILITARY) Begin // Year is first
27747>>>>>>>>>                        Move (Left(sDate,4)) to aValues[0]
27748>>>>>>>>>                        Move (Mid(sDate,2,5)) to aValues[1]
27749>>>>>>>>>                        Move (Right(sDate,2)) to aValues[2]
27750>>>>>>>>>                    End
27750>>>>>>>>>>
27750>>>>>>>>>                    Else Begin // Year is last
27751>>>>>>>>>                        Move (Left(sDate,2)) to aValues[0]
27752>>>>>>>>>                        Move (Mid(sDate,2,3)) to aValues[1]
27753>>>>>>>>>                        Move (Right(sDate,4)) to aValues[2]
27754>>>>>>>>>                    End
27754>>>>>>>>>>
27754>>>>>>>>>                End
27754>>>>>>>>>>
27754>>>>>>>>>            End
27754>>>>>>>>>>
27754>>>>>>>>>
27754>>>>>>>>>            // We have now done our utmost to produce 3 numbers. Make them into a date:
27754>>>>>>>>>            If (iFormat=DF_DATE_EUROPEAN) Get ComposeDate aValues[0] aValues[1] aValues[2] to dRval
27757>>>>>>>>>            If (iFormat=DF_DATE_USA)      Get ComposeDate aValues[1] aValues[0] aValues[2] to dRval
27760>>>>>>>>>            If (iFormat=DF_DATE_MILITARY) Get ComposeDate aValues[2] aValues[1] aValues[0] to dRval
27763>>>>>>>>>        End
27763>>>>>>>>>>
27763>>>>>>>>>        Else Move 0 to dRval
27765>>>>>>>>>
27765>>>>>>>>>        Function_Return dRval
27766>>>>>>>>>    End_Function
27767>>>>>>>>>
27767>>>>>>>>>    Function DateTimeToString23 DateTime dtValue Returns String
27769>>>>>>>>>        String sValue
27769>>>>>>>>>
27769>>>>>>>>>        Move (DateGetYear(dtValue)) to sValue
27770>>>>>>>>>        Move (sValue+"-"+IntegerToStringRzf(oStringFunctions,DateGetMonth(dtValue),2)) to sValue
27771>>>>>>>>>        Move (sValue+"-"+IntegerToStringRzf(oStringFunctions,DateGetDay(dtValue),2)) to sValue
27772>>>>>>>>>        Move (sValue+"T"+IntegerToStringRzf(oStringFunctions,DateGetHour(dtValue),2)) to sValue
27773>>>>>>>>>        Move (sValue+":"+IntegerToStringRzf(oStringFunctions,DateGetMinute(dtValue),2)) to sValue
27774>>>>>>>>>        Move (sValue+":"+IntegerToStringRzf(oStringFunctions,DateGetSecond(dtValue),2)) to sValue
27775>>>>>>>>>        Move (sValue+"."+IntegerToStringRzf(oStringFunctions,DateGetMillisecond(dtValue),3)) to sValue
27776>>>>>>>>>
27776>>>>>>>>>        Function_Return sValue // 1999-12-31T13:59:59.999 (=length:23)
27777>>>>>>>>>    End_Function
27778>>>>>>>>>
27778>>>>>>>>>    Function String23ToDateTime String sValue Returns DateTime
27780>>>>>>>>>        DateTime dtValue
27780>>>>>>>>>        Move (DateSetYear(dtValue,Integer(Mid(sValue,4,1)))) to dtValue
27781>>>>>>>>>        Move (DateSetMonth(dtValue,Integer(Mid(sValue,2,6)))) to dtValue
27782>>>>>>>>>        Move (DateSetDay(dtValue,Integer(Mid(sValue,2,9)))) to dtValue
27783>>>>>>>>>        Move (DateSetHour(dtValue,Integer(Mid(sValue,2,12)))) to dtValue
27784>>>>>>>>>        Move (DateSetMinute(dtValue,Integer(Mid(sValue,2,15)))) to dtValue
27785>>>>>>>>>        Move (DateSetSecond(dtValue,Integer(Mid(sValue,2,18)))) to dtValue
27786>>>>>>>>>        Move (DateSetMillisecond(dtValue,Integer(Mid(sValue,3,21)))) to dtValue
27787>>>>>>>>>        Function_Return dtValue
27788>>>>>>>>>    End_Function
27789>>>>>>>>>
27789>>>>>>>>>    Function DateTimeToString DateTime dtValue Integer iDateFormat Boolean bLong String sSep Returns String
27791>>>>>>>>>        Date dValue
27791>>>>>>>>>        Time tmTimeValue
27791>>>>>>>>>        Integer iHour iMin iSec
27791>>>>>>>>>        String sValue
27791>>>>>>>>>        Send DecomposeDateTime dtValue (&dValue) (&tmTimeValue)
27792>>>>>>>>>        Get DateToString dValue iDateFormat bLong sSep to sValue
27793>>>>>>>>>        Send DecomposeTime tmTimeValue (&iHour) (&iMin) (&iSec)
27794>>>>>>>>>        Function_Return (sValue*ComposeTimeString(Self,iHour,iMin,iSec))
27795>>>>>>>>>    End_Function
27796>>>>>>>>>
27796>>>>>>>>>    Function StringToDateTime String sDateTimeValue Integer iDateFormat Returns DateTime
27798>>>>>>>>>        Integer iSpacePos
27798>>>>>>>>>        String sDate sTime
27798>>>>>>>>>        DateTime dtResult
27798>>>>>>>>>        Date dValue
27798>>>>>>>>>        Time tmValue
27798>>>>>>>>>        Move (Trim(sDateTimeValue)) to sDateTimeValue
27799>>>>>>>>>        Move (Pos(" ",sDateTimeValue)) to iSpacePos
27800>>>>>>>>>        If (iSpacePos<>0) Begin
27802>>>>>>>>>            Move (Left(sDateTimeValue,iSpacePos-1)) to sDate
27803>>>>>>>>>            Move (Trim(Replace(sDate,sDateTimeValue,""))) to sTime
27804>>>>>>>>>            Get StringToDate sDate iDateFormat to dValue
27805>>>>>>>>>            Get TimeStringToTime sTime to tmValue
27806>>>>>>>>>            Get ComposeDateTime dValue tmValue to dtResult
27807>>>>>>>>>        End
27807>>>>>>>>>>
27807>>>>>>>>>        Function_Return dtResult
27808>>>>>>>>>    End_Function
27809>>>>>>>>>
27809>>>>>>>>>    Function DateIntervalLabel Integer iCode Returns String
27811>>>>>>>>>        Function_Return (Value(oIntervalLabels,iCode))
27812>>>>>>>>>    End_Function
27813>>>>>>>>>
27813>>>>>>>>>    Function DateIntervalEval Date dFrom Date dTo Date dTestValue Returns Boolean
27815>>>>>>>>>        If (Integer(dFrom)+Integer(dTo)) Begin
27817>>>>>>>>>            If (Integer(dTo)=0) Function_Return (dTestValue>=dFrom)
27820>>>>>>>>>            Function_Return (dTestValue>=dFrom and dTestValue<=dTo)
27821>>>>>>>>>        End
27821>>>>>>>>>>
27821>>>>>>>>>        Function_Return True
27822>>>>>>>>>    End_Function
27823>>>>>>>>>    
27823>>>>>>>>>    Procedure DateIntervalCalc Integer iCode Date ByRef dFrom Date ByRef dTo
27825>>>>>>>>>        Date dDate
27825>>>>>>>>>        If (iCode=DI_EXPLICIT) Begin
27827>>>>>>>>>            // Do nothing
27827>>>>>>>>>        End
27827>>>>>>>>>>
27827>>>>>>>>>        If (iCode=DI_NO_LIMIT) Begin
27829>>>>>>>>>            Move "" to dFrom
27830>>>>>>>>>            Move "" to dTo
27831>>>>>>>>>        End
27831>>>>>>>>>>
27831>>>>>>>>>        If (iCode=DI_LAST_WEEK) Begin
27833>>>>>>>>>            Get DateIncrement (SystemDate(Self)) DS_WEEK -1 to dDate
27834>>>>>>>>>            Move (Date(Integer(dDate)-DayNumber(Self,dDate)+1)) to dFrom
27835>>>>>>>>>            Move (Date(Integer(dDate)-DayNumber(Self,dDate)+7)) to dTo
27836>>>>>>>>>        End
27836>>>>>>>>>>
27836>>>>>>>>>        If (iCode=DI_LAST_MONTH) Begin
27838>>>>>>>>>            Get DateIncrement (SystemDate(Self)) DS_MONTH -1 to dDate
27839>>>>>>>>>            Get FirstDateIn DS_MONTH dDate to dFrom
27840>>>>>>>>>            Get LastDateIn DS_MONTH dDate to dTo
27841>>>>>>>>>        End
27841>>>>>>>>>>
27841>>>>>>>>>        If (iCode=DI_LAST_YEAR) Begin
27843>>>>>>>>>            Get DateIncrement (SystemDate(Self)) DS_YEAR -1 to dDate
27844>>>>>>>>>            Get FirstDateIn DS_YEAR dDate to dFrom
27845>>>>>>>>>            Get LastDateIn DS_YEAR dDate to dTo
27846>>>>>>>>>        End
27846>>>>>>>>>>
27846>>>>>>>>>        If (iCode=DI_WEEK_TO_DATE) Begin
27848>>>>>>>>>            Get SystemDate to dTo
27849>>>>>>>>>            Move (Date(Integer(dTo)-DayNumber(Self,dTo)+1)) to dFrom
27850>>>>>>>>>        End
27850>>>>>>>>>>
27850>>>>>>>>>        If (iCode=DI_MONTH_TO_DATE) Begin
27852>>>>>>>>>            Get SystemDate to dTo
27853>>>>>>>>>            Get FirstDateIn DS_MONTH dTo to dFrom
27854>>>>>>>>>        End
27854>>>>>>>>>>
27854>>>>>>>>>        If (iCode=DI_YEAR_TO_DATE) Begin
27856>>>>>>>>>            Get SystemDate to dTo
27857>>>>>>>>>            Get FirstDateIn DS_YEAR dTo to dFrom
27858>>>>>>>>>        End
27858>>>>>>>>>>
27858>>>>>>>>>    End_Procedure
27859>>>>>>>>>    
27859>>>>>>>>>    Function SecondsToTimeString Integer iSeconds Returns String
27861>>>>>>>>>        Integer iHour iMinute
27861>>>>>>>>>        If (iSeconds=0) Function_Return "00:00:00"
27864>>>>>>>>>        Move (iSeconds/3600) to iHour
27865>>>>>>>>>        Move (iSeconds-(iHour*3600)) to iSeconds
27866>>>>>>>>>        Move (iSeconds/60) to iMinute
27867>>>>>>>>>        Move (iSeconds-(iMinute*60)) to iSeconds
27868>>>>>>>>>        Function_Return (If(iHour<10,"0","")+String(iHour)+":"+If(iMinute<10,"0","")+String(iMinute)+":"+If(iSeconds<10,"0","")+String(iSeconds))
27869>>>>>>>>>    End_Function
27870>>>>>>>>>    
27870>>>>>>>>>    Function MilliSecondsToTimeString Number nMilliSeconds Returns String
27872>>>>>>>>>        String sTimeString
27872>>>>>>>>>        Integer iMilliSeconds
27872>>>>>>>>>        Get SecondsToTimeString (Integer(nMilliSeconds/1000)) to sTimeString
27873>>>>>>>>>        Move (Mod(nMilliSeconds,1000)) to iMilliSeconds
27874>>>>>>>>>        Function_Return (sTimeString+"."+IntegerToStringRzf(oStringFunctions,iMilliSeconds,3))
27875>>>>>>>>>    End_Function
27876>>>>>>>>>    
27876>>>>>>>>>//    Function TimeStringFormat String sValue Integer iPrioritizedSegment Returns String
27876>>>>>>>>>//        Integer iMax iPos iHours iMinutes iTmp
27876>>>>>>>>>//        String[] aSegments
27876>>>>>>>>>//        String sRval
27876>>>>>>>>>//        If (sValue="-" or lowercase(sValue)="now") begin
27876>>>>>>>>>//            Function_Return (Left(SystemTimeString(Self),5)) // Strip away seconds
27876>>>>>>>>>//        End
27876>>>>>>>>>//        If (sValue="") begin
27876>>>>>>>>>//            Function_Return ""
27876>>>>>>>>>//        End
27876>>>>>>>>>//        Move (Replaces(" ",sValue,":")) to sValue
27876>>>>>>>>>//        Move (Replaces(",",sValue,":")) to sValue
27876>>>>>>>>>//        Send SplitString of oStringFunctions sValue ":" True False (&aSegments)
27876>>>>>>>>>//        Move (SizeOfArray(aSegments)) to iMax // Get HowManyWords sValue ":" to iMax
27876>>>>>>>>>//        If (iMax=1) Begin
27876>>>>>>>>>//            If (iPrioritizedSegment=TS_MINUTE) Begin
27876>>>>>>>>>//                Move (ExtractInteger(ExtractWord(sValue,":",1),1)) to iMinutes
27876>>>>>>>>>//                Move 0 to iHours
27876>>>>>>>>>//            End
27876>>>>>>>>>//            Else Begin //So it is hour prioritized
27876>>>>>>>>>//                Move (ExtractInteger(ExtractWord(sValue,":",1),1)) to sValue
27876>>>>>>>>>//                If (Length(sValue)>2) Begin
27876>>>>>>>>>//                    If (Length(sValue)=3) Move (Append("0",sValue)) to sValue
27876>>>>>>>>>//                    If (Length(sValue)>4) Move (Left(sValue,4)) to sValue
27876>>>>>>>>>//                    Move (Left(sValue,2)) to iHours
27876>>>>>>>>>//                    Move (Right(sValue,2)) to iMinutes
27876>>>>>>>>>//                End
27876>>>>>>>>>//                Else Begin
27876>>>>>>>>>//                    Move 0 to iMinutes
27876>>>>>>>>>//                    Move sValue to iHours
27876>>>>>>>>>//                End
27876>>>>>>>>>//            End
27876>>>>>>>>>//        End
27876>>>>>>>>>//        Else Begin
27876>>>>>>>>>//            Move (ExtractInteger(ExtractWord(sValue,":",1),1)) to iHours
27876>>>>>>>>>//            Move (ExtractInteger(ExtractWord(sValue,":",2),1)) to iMinutes
27876>>>>>>>>>//        End
27876>>>>>>>>>//        Move (iMinutes/60) to iTmp
27876>>>>>>>>>//        Move (iMinutes-(iTmp*60)) to iMinutes
27876>>>>>>>>>//        Move (iHours+iTmp) to iHours
27876>>>>>>>>>//        Function_Return (IntegerToStringRzf(oStringFunctions,iHours,2)+":"+IntegerToStringRzf(oStringFunctions,iMinutes,2))
27876>>>>>>>>>//    End_Function
27876>>>>>>>>>//Function TimeStringToHours Global String lsTime Returns Number
27876>>>>>>>>>//  Integer liHours liMinutes liFraction
27876>>>>>>>>>//  Move (ExtractWord(lsTime,":",1)) to liHours
27876>>>>>>>>>//  Move (ExtractWord(lsTime,":",2)) to liMinutes
27876>>>>>>>>>//  Move (liMinutes*25/15) to liFraction
27876>>>>>>>>>//  Function_Return (liHours+(liFraction/100.0))
27876>>>>>>>>>//End_Function
27876>>>>>>>>>//
27876>>>>>>>>>//// Returns true if lsTime is a legal time of day ("hh:mm:ss" or "hh:mm")
27876>>>>>>>>>//Function IsTimeString Global String lsTime Returns Integer
27876>>>>>>>>>//  Integer liLen liNumber
27876>>>>>>>>>//  String lsNumber
27876>>>>>>>>>//  Move (trim(lsTime)) to lsTime
27876>>>>>>>>>//  Move (length(lsTime)) to liLen
27876>>>>>>>>>//  If (liLen<>5 and liLen<>8) Function_Return 0 // Wrong length, couldn't be a time
27876>>>>>>>>>//  If (mid(lsTime,1,3)<>":") Function_Return 0 // Missing ":"
27876>>>>>>>>>//
27876>>>>>>>>>//  Move (mid(lsTime,2,1)) to lsNumber
27876>>>>>>>>>//  If (StringIsInteger(lsNumber)) Begin
27876>>>>>>>>>//    Move (Integer(lsNumber)) to liNumber
27876>>>>>>>>>//    If (liNumber<0 or liNumber>23) Function_Return 0 // Wrong hours
27876>>>>>>>>>//  End
27876>>>>>>>>>//  Else Function_Return 0 // Not digits
27876>>>>>>>>>//
27876>>>>>>>>>//  Move (mid(lsTime,2,4)) to lsNumber
27876>>>>>>>>>//  If (StringIsInteger(lsNumber)) Begin
27876>>>>>>>>>//    Move (Integer(lsNumber)) to liNumber
27876>>>>>>>>>//    If (liNumber<0 or liNumber>59) Function_Return 0 // Wrong hours
27876>>>>>>>>>//  End
27876>>>>>>>>>//  Else Function_Return 0 // Not digits
27876>>>>>>>>>//
27876>>>>>>>>>//  If (liLen=8) Begin
27876>>>>>>>>>//    If (mid(lsTime,1,6)<>":") Function_Return 0 // Missing ":"
27876>>>>>>>>>//    Move (mid(lsTime,2,7)) to lsNumber
27876>>>>>>>>>//    If (StringIsInteger(lsNumber)) Begin
27876>>>>>>>>>//      Move (Integer(lsNumber)) to liNumber
27876>>>>>>>>>//      If (liNumber<0 or liNumber>59) Function_Return 0 // Wrong hours
27876>>>>>>>>>//    End
27876>>>>>>>>>//    Else Function_Return 0 // Not digits
27876>>>>>>>>>//  End
27876>>>>>>>>>//
27876>>>>>>>>>//  Function_Return 1 // It's a time
27876>>>>>>>>>//End_Function
27876>>>>>>>>>//
27876>>>>>>>>>//Function HoursBetweenTimeStrings Global String lsTimeFrom String lsTimeTo Returns Number
27876>>>>>>>>>//  Function_Return (Time_ToHours(lsTimeTo)-Time_ToHours(lsTimeFrom))
27876>>>>>>>>>//End_Function
27876>>>>>>>>>
27876>>>>>>>>>    Function DateIndex Date dBase Date dDate Integer iSegment Returns Integer
27878>>>>>>>>>        Integer iBase iDate
27878>>>>>>>>>        If (iSegment=DS_DAY) Begin
27880>>>>>>>>>            Move (Integer(dDate)) to iDate
27881>>>>>>>>>            Move (Integer(dBase)) to iBase
27882>>>>>>>>>        End
27882>>>>>>>>>>
27882>>>>>>>>>        If (iSegment=DS_WEEK) Begin
27884>>>>>>>>>            Get DayNumber dDate to iDate
27885>>>>>>>>>            Move (Integer(dDate)+1-iDate) to iDate // Back to Monday!
27886>>>>>>>>>            Get DayNumber dBase to iBase
27887>>>>>>>>>            Move (Integer(dBase)+1-iBase) to iBase // Back to Monday!
27888>>>>>>>>>            Move (iDate-iBase) to iDate
27889>>>>>>>>>            Move (iDate/7) to iDate
27890>>>>>>>>>            Move 0 to iBase
27891>>>>>>>>>        End
27891>>>>>>>>>>
27891>>>>>>>>>        If (iSegment=DS_MONTH) Begin
27893>>>>>>>>>            Move (DateSegment(Self,dDate,DS_YEAR)*12+DateSegment(Self,dDate,DS_MONTH)) to iDate
27894>>>>>>>>>            Move (DateSegment(Self,dBase,DS_YEAR)*12+DateSegment(Self,dBase,DS_MONTH)) to iBase
27895>>>>>>>>>        End
27895>>>>>>>>>>
27895>>>>>>>>>        If (iSegment=DS_QUARTER) Begin
27897>>>>>>>>>            Move (DateSegment(Self,dDate,DS_YEAR)*4+DateSegment(Self,dDate,DS_QUARTER)) to iDate
27898>>>>>>>>>            Move (DateSegment(Self,dBase,DS_YEAR)*4+DateSegment(Self,dBase,DS_QUARTER)) to iBase
27899>>>>>>>>>        End
27899>>>>>>>>>>
27899>>>>>>>>>        If (iSegment=DS_YEAR) Begin
27901>>>>>>>>>            Move (DateSegment(Self,dDate,DS_YEAR)) to iDate
27902>>>>>>>>>            Move (DateSegment(Self,dBase,DS_YEAR)) to iBase
27903>>>>>>>>>        End
27903>>>>>>>>>>
27903>>>>>>>>>        Function_Return (iDate-iBase)
27904>>>>>>>>>    End_Function
27905>>>>>>>>>    
27905>>>>>>>>>    Function DateIndexLabel Date dBase Integer iIndex Integer iSegment Returns String
27907>>>>>>>>>        Integer iBase iMonth
27907>>>>>>>>>        If (iSegment=DS_DAY) Begin
27909>>>>>>>>>            Function_Return (String(Date(Integer(dBase)+iIndex)))
27910>>>>>>>>>        End
27910>>>>>>>>>>
27910>>>>>>>>>        If (iSegment=DS_WEEK) Begin
27912>>>>>>>>>            Get DayNumber dBase to iBase
27913>>>>>>>>>            Move (Integer(dBase)+1-iBase) to iBase // Back to Monday!
27914>>>>>>>>>            Move (iIndex*7+iBase) to iBase // Now it's the julian value of the monday in the week we want to label
27915>>>>>>>>>            Move (Date(iBase)) to dBase
27916>>>>>>>>>            Function_Return (String(DateSegment(Self,dBase,DS_YEAR))+"-"+IntegerToStringRzf(oStringFunctions,DateSegment(Self,dBase,DS_WEEK),2))
27917>>>>>>>>>        End
27917>>>>>>>>>>
27917>>>>>>>>>        If (iSegment=DS_MONTH) Begin
27919>>>>>>>>>            Get DateIncrement dBase DS_MONTH iIndex to dBase
27920>>>>>>>>>            Get DateSegment dBase DS_MONTH to iMonth
27921>>>>>>>>>//            If (iMonth=1) Begin
27921>>>>>>>>>//                Function_Return (String(DateSegment(Self,dBase,DS_YEAR))+"-"+Left(MonthName(Self,DateSegment(Self,dBase,DS_MONTH)),3))
27921>>>>>>>>>//            End
27921>>>>>>>>>//            Else Begin
27921>>>>>>>>>//                Function_Return (MonthName(Self,iMonth))
27921>>>>>>>>>//            End
27921>>>>>>>>>            Function_Return (String(DateSegment(Self,dBase,DS_YEAR))+"-"+Left(MonthName(Self,DateSegment(Self,dBase,DS_MONTH)),3))
27922>>>>>>>>>//            Function_Return (String(DateSegment(Self,dBase,DS_YEAR))+"-"+IntegerToStringRzf(oStringFunctions,DateSegment(Self,dBase,DS_MONTH),2))
27922>>>>>>>>>        End
27922>>>>>>>>>>
27922>>>>>>>>>        If (iSegment=DS_QUARTER) Begin
27924>>>>>>>>>            Get DateIncrement dBase DS_QUARTER iIndex to dBase
27925>>>>>>>>>            Function_Return (String(DateSegment(Self,dBase,DS_YEAR))+"-"+IntegerToStringRzf(oStringFunctions,DateSegment(Self,dBase,DS_QUARTER),2))
27926>>>>>>>>>        End
27926>>>>>>>>>>
27926>>>>>>>>>        If (iSegment=DS_YEAR) Begin
27928>>>>>>>>>            Get DateIncrement dBase DS_YEAR iIndex to dBase
27929>>>>>>>>>            Function_Return (String(DateSegment(Self,dBase,DS_YEAR)))
27930>>>>>>>>>        End
27930>>>>>>>>>>
27930>>>>>>>>>    End_Function
27931>>>>>>>>>    
27931>>>>>>>>>    // Function DateIndexStartDate returns the lowest date in the interval time
27931>>>>>>>>>    // interval implicitly passed in the parameters
27931>>>>>>>>>    Function DateIndexStartDate Date dBase Integer iIndex Integer iSegment Returns Date
27933>>>>>>>>>        Integer iBase
27933>>>>>>>>>        If (iSegment=DS_DAY) Begin
27935>>>>>>>>>            Function_Return (Date(Integer(dBase)+iIndex))
27936>>>>>>>>>        End
27936>>>>>>>>>>
27936>>>>>>>>>        If (iSegment=DS_WEEK) Begin
27938>>>>>>>>>            Get DayNumber dBase to iBase
27939>>>>>>>>>            Move (Integer(dBase)+1-iBase) to iBase // Back to Monday!
27940>>>>>>>>>            Move (iIndex*7+iBase) to iBase // Now it's the julian value of the monday in the week we want to label
27941>>>>>>>>>            Move (Date(iBase)) to dBase
27942>>>>>>>>>            Function_Return dBase
27943>>>>>>>>>        End
27943>>>>>>>>>>
27943>>>>>>>>>        If (iSegment=DS_MONTH) Begin
27945>>>>>>>>>            Get DateIncrement dBase DS_MONTH iIndex to dBase
27946>>>>>>>>>            Function_Return dBase
27947>>>>>>>>>        End
27947>>>>>>>>>>
27947>>>>>>>>>        If (iSegment=DS_QUARTER) Begin
27949>>>>>>>>>            Get DateIncrement dBase DS_QUARTER iIndex to dBase
27950>>>>>>>>>            Function_Return dBase
27951>>>>>>>>>        End
27951>>>>>>>>>>
27951>>>>>>>>>        If (iSegment=DS_YEAR) Begin
27953>>>>>>>>>            Get DateIncrement dBase DS_YEAR iIndex to dBase
27954>>>>>>>>>            Function_Return dBase
27955>>>>>>>>>        End
27955>>>>>>>>>>
27955>>>>>>>>>    End_Function
27956>>>>>>>>>
27956>>>>>>>>>    Function DateIndexStopDate Date dBase Integer iIndex Integer iSegment Returns Date
27958>>>>>>>>>        Date dValue
27958>>>>>>>>>        Get DateIndexStartDate dBase iIndex iSegment to dValue
27959>>>>>>>>>        Get DateIncrement dValue iSegment 1 to dValue
27960>>>>>>>>>        Get DateIncrement dValue DS_DAY -1 to dValue
27961>>>>>>>>>        Function_Return dValue
27962>>>>>>>>>    End_Function
27963>>>>>>>>>    
27963>>>>>>>>>    Function CurrentDateFormat Returns Integer
27965>>>>>>>>>        Integer iFormat
27965>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iFormat
27968>>>>>>>>>        Function_Return iFormat
27969>>>>>>>>>    End_Function
27970>>>>>>>>>    
27970>>>>>>>>>End_Class
27971>>>>>>>>>
27971>>>>>>>>>Global_Variable Integer oDateFunctions
27971>>>>>>>>>
27971>>>>>>>>>Object _oDateFunctions is a cDateFunctions
27973>>>>>>>>>    Move Self to oDateFunctions
27974>>>>>>>>>    Get SystemTimeToString23 (SystemTimeMilliSeconds(Self)) to _gsDate$ModuleStartTime
27975>>>>>>>>>End_Object
27976>>>>>>>>>
27976>>>>>>>Use StringFunctions.pkg
27976>>>>>>>
27976>>>>>>>Define C_EPSymbolLegalFirstCharacters for "_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
27976>>>>>>>Define C_EPSymbolLegalCharacters for "_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.#"
27976>>>>>>>
27976>>>>>>>Enum_List
27976>>>>>>>    Define XP_Error // As a return type this means that a function or operator errored during eval
27976>>>>>>>    Define XP_String   
27976>>>>>>>    Define XP_Numeric  
27976>>>>>>>    Define XP_Date     
27976>>>>>>>    Define XP_Integer  
27976>>>>>>>    Define XP_Boolean
27976>>>>>>>    // this has not been tested. maybe not even implemented:  
27976>>>>>>>    // Functions may have return type Variant if it varies with the input
27976>>>>>>>    // (like the 'if' function for example)
27976>>>>>>>    Define XP_Variant
27976>>>>>>>End_Enum_List
27976>>>>>>>
27976>>>>>>>Use VdfBase.pkg
27976>>>>>>>
27976>>>>>>>Struct tXPValue
27976>>>>>>>    String sValue
27976>>>>>>>    Integer iValueType // XP_String, XP_Numeric, XP_Date, XP_Integer or XP_Boolean
27976>>>>>>>End_Struct
27976>>>>>>>
27976>>>>>>>Struct tXPConstant
27976>>>>>>>    String sSymbol
27976>>>>>>>    tXPValue strValue
27976>>>>>>>    tXPValue strValue
27976>>>>>>>End_Struct
27976>>>>>>>
27976>>>>>>>Struct _tXPFunctionPointer
27976>>>>>>>    Integer iObj
27976>>>>>>>    Integer iMsg
27976>>>>>>>End_Struct
27976>>>>>>>
27976>>>>>>>Struct tXPOperator
27976>>>>>>>    String sSymbol
27976>>>>>>>    Integer iArgumentCount
27976>>>>>>>    Integer iPrecedence
27976>>>>>>>    Integer iAssociativity // 0=left 1=right
27976>>>>>>>    _tXPFunctionPointer strDispatch
27976>>>>>>>    _tXPFunctionPointer strDispatch
27976>>>>>>>End_Struct
27976>>>>>>>
27976>>>>>>>Struct tXPFunction
27976>>>>>>>    String sFunction
27976>>>>>>>    Integer iArgumentCount
27976>>>>>>>    Integer iReturnType
27976>>>>>>>    _tXPFunctionPointer strDispatch
27976>>>>>>>    _tXPFunctionPointer strDispatch
27976>>>>>>>End_Struct
27976>>>>>>>
27976>>>>>>>Struct tXPGrammar
27976>>>>>>>    tXPOperator[] aOperators
27976>>>>>>>    tXPOperator[] aOperators
27976>>>>>>>    tXPFunction[] aFunctions
27976>>>>>>>    tXPFunction[] aFunctions
27976>>>>>>>    tXPConstant[] aConstants
27976>>>>>>>    tXPConstant[] aConstants
27976>>>>>>>    String _sOperatorTestString
27976>>>>>>>End_Struct
27976>>>>>>>
27976>>>>>>>Struct _tXPSymbolValueRetrievalHint
27976>>>>>>>    Integer iTable
27976>>>>>>>    Integer iColumn
27976>>>>>>>    Integer iValueType
27976>>>>>>>    Integer iConstantIndex
27976>>>>>>>End_Struct
27976>>>>>>>
27976>>>>>>>Struct tXPToken
27976>>>>>>>    Integer iType
27976>>>>>>>    Integer iOperatorIndex // If iType is XPTokenType_Operator then this holds the index of the operator passed
27976>>>>>>>                           // If iType is XPTokenType_FunctionCall then this holds the index of the function passed
27976>>>>>>>    String sValue //
27976>>>>>>>    Integer iStartPos
27976>>>>>>>    
27976>>>>>>>    _tXPSymbolValueRetrievalHint strValueHint // Only used when iType is XPTokenType_Symbol 
27976>>>>>>>    _tXPSymbolValueRetrievalHint strValueHint // Only used when iType is XPTokenType_Symbol 
27976>>>>>>>End_Struct
27976>>>>>>>
27976>>>>>>>Enum_List
27976>>>>>>>    Define XPTokenType_Error            // As a return value this is an error
27976>>>>>>>    Define XPTokenType_Operator         // Anything from the operator array
27976>>>>>>>    Define XPTokenType_Symbol           // Variables, Table columns, True and False,
27976>>>>>>>    Define XPTokenType_FunctionCall
27976>>>>>>>    Define XPTokenType_NewParameter
27976>>>>>>>    Define XPTokenType_EndFunctionCall
27976>>>>>>>    Define XPTokenType_StringConstant
27976>>>>>>>    Define XPTokenType_NumberConstant
27976>>>>>>>    Define XPTokenType_IntegerConstant
27976>>>>>>>    Define XPTokenType_LeftParenthesis
27976>>>>>>>    Define XPTokenType_RightParenthesis
27976>>>>>>>End_Enum_List
27976>>>>>>>
27976>>>>>>>Struct tXPError
27976>>>>>>>    Integer iPos
27976>>>>>>>    String  sErrorText
27976>>>>>>>End_Struct
27976>>>>>>>
27976>>>>>>>Class cExpressionParserBasic is a cObject
27977>>>>>>>    Procedure Construct_Object
27979>>>>>>>        Forward Send Construct_Object
27981>>>>>>>        Property tXPGrammar pstrDefaultGrammar
27982>>>>>>>    End_Procedure
27983>>>>>>>    
27983>>>>>>>    Procedure End_Construct_Object
27985>>>>>>>        Forward Send End_Construct_Object
27987>>>>>>>        Send ColdBoot
27988>>>>>>>    End_Procedure
27989>>>>>>>
27989>>>>>>>        Function _fTypeCastString tXPValue strValue Returns tXPValue // 1 param
27991>>>>>>>            If (strValue.iValueType=XP_Date) Begin
27993>>>>>>>                Move (Date(Integer(strValue.sValue))) to strValue.sValue
27994>>>>>>>            End
27994>>>>>>>>
27994>>>>>>>            Else If (strValue.iValueType=XP_Boolean) Begin
27997>>>>>>>                If (Integer(strValue.sValue)<>0) Begin
27999>>>>>>>                    Move "true" to strValue.sValue
28000>>>>>>>                End
28000>>>>>>>>
28000>>>>>>>                Else Begin
28001>>>>>>>                    Move "false" to strValue.sValue
28002>>>>>>>                End
28002>>>>>>>>
28002>>>>>>>            End
28002>>>>>>>>
28002>>>>>>>            Move XP_String to strValue.iValueType
28003>>>>>>>            Function_Return strValue
28004>>>>>>>        End_Function
28005>>>>>>>
28005>>>>>>>        Function _fTypeCastNumeric tXPValue strValue Returns tXPValue // 1 param
28007>>>>>>>            Number nValue
28007>>>>>>>            Get StringToNumber of oStringFunctions strValue.sValue to nValue
28008>>>>>>>            Move nValue to strValue.sValue
28009>>>>>>>            Move XP_Numeric to strValue.iValueType
28010>>>>>>>            Function_Return strValue
28011>>>>>>>        End_Function
28012>>>>>>>
28012>>>>>>>        Function _fTypeCastDate tXPValue strValue Returns tXPValue // 1 param
28014>>>>>>>            Date dValue
28014>>>>>>>            Move strValue.sValue to dValue
28015>>>>>>>            Move (Integer(dValue)) to strValue.sValue
28016>>>>>>>            Move XP_Date to strValue.iValueType
28017>>>>>>>            Function_Return strValue
28018>>>>>>>        End_Function
28019>>>>>>>
28019>>>>>>>        Function _fTypeCastInteger tXPValue strValue Returns tXPValue // 1 param
28021>>>>>>>            Integer iValue
28021>>>>>>>            Get StringToNumber of oStringFunctions strValue.sValue to iValue
28022>>>>>>>            Move iValue to strValue.sValue
28023>>>>>>>            Move XP_Integer to strValue.iValueType
28024>>>>>>>            Function_Return strValue
28025>>>>>>>        End_Function
28026>>>>>>>
28026>>>>>>>        Function _fTypeCastBoolean tXPValue strValue Returns tXPValue // 1 param
28028>>>>>>>            Number nValue
28028>>>>>>>            If (strValue.iValueType=XP_String) Begin
28030>>>>>>>                If (lowercase(strValue.sValue)="true") Begin
28032>>>>>>>                    Move "1" to strValue.sValue
28033>>>>>>>                End
28033>>>>>>>>
28033>>>>>>>                Else If (lowercase(strValue.sValue)="false") Begin
28036>>>>>>>                    Move "0" to strValue.sValue
28037>>>>>>>                End
28037>>>>>>>>
28037>>>>>>>            End
28037>>>>>>>>
28037>>>>>>>            Get StringToNumber of oStringFunctions strValue.sValue to nValue
28038>>>>>>>            Move (nValue<>0) to strValue.sValue
28039>>>>>>>            Move XP_Boolean to strValue.iValueType
28040>>>>>>>            Function_Return strValue
28041>>>>>>>        End_Function
28042>>>>>>>        
28042>>>>>>>        Function _CastValueAs tXPValue strValue Integer iXPType Returns tXPValue
28044>>>>>>>            If (iXPType=strValue.iValueType) Begin
28046>>>>>>>                // If type is already right do nothing
28046>>>>>>>            End
28046>>>>>>>>
28046>>>>>>>            Else If (iXPType=XP_String) Begin
28049>>>>>>>                Get _fTypeCastString strValue to strValue 
28050>>>>>>>            End
28050>>>>>>>>
28050>>>>>>>            Else If (iXPType=XP_Date) Begin
28053>>>>>>>                Get _fTypeCastDate strValue to strValue 
28054>>>>>>>            End
28054>>>>>>>>
28054>>>>>>>            Else If (iXPType=XP_Numeric) Begin
28057>>>>>>>                Get _fTypeCastNumeric strValue to strValue 
28058>>>>>>>            End
28058>>>>>>>>
28058>>>>>>>            Else If (iXPType=XP_Boolean) Begin
28061>>>>>>>                Get _fTypeCastBoolean strValue to strValue 
28062>>>>>>>            End
28062>>>>>>>>
28062>>>>>>>            Else If (iXPType=XP_Integer) Begin
28065>>>>>>>                Get _fTypeCastInteger strValue to strValue 
28066>>>>>>>            End
28066>>>>>>>>
28066>>>>>>>            Function_Return strValue
28067>>>>>>>        End_Function
28068>>>>>>>
28068>>>>>>>    Procedure DefineOperator tXPGrammar ByRef strGrammar String sSymbol Integer iArgs Integer iPrecedence Integer iAssociativity Integer hGet
28070>>>>>>>        Integer iIndex
28070>>>>>>>        Move (SizeOfArray(strGrammar.aOperators)) to iIndex
28071>>>>>>>        Move sSymbol to strGrammar.aOperators[iIndex].sSymbol
28072>>>>>>>        Move iArgs to strGrammar.aOperators[iIndex].iArgumentCount
28073>>>>>>>        Move iPrecedence to strGrammar.aOperators[iIndex].iPrecedence
28074>>>>>>>        Move iAssociativity to strGrammar.aOperators[iIndex].iAssociativity
28075>>>>>>>        Move hGet to strGrammar.aOperators[iIndex].strDispatch.iMsg
28076>>>>>>>        Move Self to strGrammar.aOperators[iIndex].strDispatch.iObj
28077>>>>>>>    End_Procedure
28078>>>>>>>
28078>>>>>>>    Procedure DefineFunction tXPGrammar ByRef strGrammar String sFunction Integer iArgCount Integer iValueType Integer hGet
28080>>>>>>>        Integer iIndex
28080>>>>>>>        Move (SizeOfArray(strGrammar.aFunctions)) to iIndex
28081>>>>>>>        Move sFunction to strGrammar.aFunctions[iIndex].sFunction
28082>>>>>>>        Move iArgCount to strGrammar.aFunctions[iIndex].iArgumentCount
28083>>>>>>>        Move iValueType to strGrammar.aFunctions[iIndex].iReturnType
28084>>>>>>>        Move hGet to strGrammar.aFunctions[iIndex].strDispatch.iMsg
28085>>>>>>>        Move Self to strGrammar.aFunctions[iIndex].strDispatch.iObj
28086>>>>>>>    End_Procedure
28087>>>>>>>
28087>>>>>>>    Procedure DefineConstant tXPGrammar ByRef strGrammar String sSymbol String sValue Integer iValueType
28089>>>>>>>        tXPConstant strConstant
28089>>>>>>>        tXPConstant strConstant
28089>>>>>>>        Move (Lowercase(sSymbol)) to strConstant.sSymbol
28090>>>>>>>        Move sValue to strConstant.strValue.sValue
28091>>>>>>>        Move iValueType to strConstant.strValue.iValueType
28092>>>>>>>        Move strConstant to strGrammar.aConstants[SizeOfArray(strGrammar.aConstants)]
28093>>>>>>>    End_Procedure
28094>>>>>>>    
28094>>>>>>>    Procedure OnDefineOperators tXPGrammar ByRef strGrammar
28096>>>>>>>    End_Procedure
28097>>>>>>>    
28097>>>>>>>    Procedure OnDefineFunctions tXPGrammar ByRef strGrammar
28099>>>>>>>    End_Procedure
28100>>>>>>>    
28100>>>>>>>    Procedure OnDefineConstants tXPGrammar ByRef strGrammar
28102>>>>>>>    End_Procedure
28103>>>>>>>    
28103>>>>>>>        Function _FindConstantIndex tXPGrammar strGrammar String sSymbol Returns Integer
28105>>>>>>>            Integer iItem iMax
28105>>>>>>>            Move (Lowercase(sSymbol)) to sSymbol
28106>>>>>>>            Move (SizeOfArray(strGrammar.aConstants)-1) to iMax
28107>>>>>>>            For iItem from 0 to iMax
28113>>>>>>>>
28113>>>>>>>                If (sSymbol=strGrammar.aConstants[iItem].sSymbol) Begin
28115>>>>>>>                    Function_Return iItem
28116>>>>>>>                End
28116>>>>>>>>
28116>>>>>>>            Loop
28117>>>>>>>>
28117>>>>>>>            Function_Return -1
28118>>>>>>>        End_Function
28119>>>>>>>
28119>>>>>>>        Function _OperatorTestString tXPGrammar strGrammar Returns String
28121>>>>>>>            // The return value of this can be used as a fast way to determine if a symbol is an operator.
28121>>>>>>>            Integer iItem iMax
28121>>>>>>>            String sValue
28121>>>>>>>            Move (SizeOfArray(strGrammar.aOperators)-1) to iMax
28122>>>>>>>            Move " " to sValue
28123>>>>>>>            For iItem from 0 to iMax
28129>>>>>>>>
28129>>>>>>>                Move (sValue+strGrammar.aOperators[iItem].sSymbol+" ") to sValue
28130>>>>>>>            Loop
28131>>>>>>>>
28131>>>>>>>            Function_Return (Uppercase(sValue))
28132>>>>>>>        End_Function
28133>>>>>>>
28133>>>>>>>    Procedure ColdBoot // Reset the default grammar returned by the NewGrammar function.
28135>>>>>>>        tXPGrammar strGrammar
28135>>>>>>>        tXPGrammar strGrammar
28135>>>>>>>        Send OnDefineOperators (&strGrammar)
28136>>>>>>>        Send OnDefineFunctions (&strGrammar)
28137>>>>>>>        Send OnDefineConstants (&strGrammar)
28138>>>>>>>        Get _OperatorTestString strGrammar to strGrammar._sOperatorTestString
28139>>>>>>>        Set pstrDefaultGrammar to strGrammar
28140>>>>>>>    End_Procedure
28141>>>>>>>
28141>>>>>>>    Function NewGrammar Returns tXPGrammar
28143>>>>>>>        Function_Return (pstrDefaultGrammar(Self))
28144>>>>>>>    End_Function
28145>>>>>>>
28145>>>>>>>            Function XPSymbolClassId2Text Integer iType Returns String
28147>>>>>>>                If (iType=XPTokenType_Operator       ) Function_Return "Operator"
28150>>>>>>>                If (iType=XPTokenType_Symbol         ) Function_Return "Symbol"
28153>>>>>>>                If (iType=XPTokenType_FunctionCall   ) Function_Return "FunctionCall"
28156>>>>>>>                If (iType=XPTokenType_NewParameter   ) Function_Return "NewParameter"
28159>>>>>>>                If (iType=XPTokenType_EndFunctionCall) Function_Return "EndFunctionCall"
28162>>>>>>>                If (iType=XPTokenType_StringConstant ) Function_Return "StringConstant"
28165>>>>>>>                If (iType=XPTokenType_NumberConstant ) Function_Return "NumberConstant"
28168>>>>>>>                If (iType=XPTokenType_IntegerConstant) Function_Return "IntegerConstant"
28171>>>>>>>                If (iType=XPTokenType_LeftParenthesis ) Function_Return "Operator ("
28174>>>>>>>                If (iType=XPTokenType_RightParenthesis) Function_Return "Operator )"
28177>>>>>>>                Function_Return "Unknown class"
28178>>>>>>>            End_Function
28179>>>>>>>            
28179>>>>>>>            Function XPValueTypeToString Integer iXPType Returns String
28181>>>>>>>                If (iXPType=XP_Error  ) Function_Return "unknown"
28184>>>>>>>                If (iXPType=XP_String ) Function_Return "string"
28187>>>>>>>                If (iXPType=XP_Numeric) Function_Return "numeric"
28190>>>>>>>                If (iXPType=XP_Date   ) Function_Return "date"
28193>>>>>>>                If (iXPType=XP_Integer) Function_Return "integer"
28196>>>>>>>                If (iXPType=XP_Boolean) Function_Return "boolean"
28199>>>>>>>                Function_Return "really unknown!"
28200>>>>>>>            End_Function
28201>>>>>>>
28201>>>>>>>            Procedure _RegisterError tXPError ByRef strError Integer iPos String sErrorText
28203>>>>>>>                If (strError.iPos=0) Begin
28205>>>>>>>                    Move iPos to strError.iPos
28206>>>>>>>                    Move sErrorText to strError.sErrorText
28207>>>>>>>                End
28207>>>>>>>>
28207>>>>>>>            End_Procedure
28208>>>>>>>
28208>>>>>>>            Function _ErrorState tXPError strError Returns Boolean
28210>>>>>>>                Function_Return (strError.sErrorText<>"")
28211>>>>>>>            End_Function
28212>>>>>>>
28212>>>>>>>            Procedure _ParseStringConstant Address pExpr Integer ByRef iPos Integer iLen tXPToken ByRef strToken tXPError ByRef strError
28214>>>>>>>                Boolean bFin
28214>>>>>>>                String sQuotChar sChar
28214>>>>>>>                Move strToken.sValue to sQuotChar
28215>>>>>>>                Move "" to strToken.sValue
28216>>>>>>>                Move False to bFin
28217>>>>>>>                Repeat
28217>>>>>>>>
28217>>>>>>>                    Increment iPos
28218>>>>>>>                    If (iPos<=iLen) Begin
28220>>>>>>>                        Move (Character(DeRefC(pExpr,iPos))) to sChar
28221>>>>>>>                        If (sChar=sQuotChar) Begin
28223>>>>>>>                            Move True to bFin
28224>>>>>>>                            Increment iPos // Skip quotation character
28225>>>>>>>                        End
28225>>>>>>>>
28225>>>>>>>                        Else Begin
28226>>>>>>>                            Move (strToken.sValue+sChar) to strToken.sValue
28227>>>>>>>                        End
28227>>>>>>>>
28227>>>>>>>                    End
28227>>>>>>>>
28227>>>>>>>                    Else Begin
28228>>>>>>>                        Move True to bFin
28229>>>>>>>                        Send _RegisterError (&strError) -1 ("Missing "+sQuotChar+" in expression")
28230>>>>>>>                    End
28230>>>>>>>>
28230>>>>>>>                Until (bFin)
28232>>>>>>>            End_Procedure
28233>>>>>>>
28233>>>>>>>            Procedure _ParseNumericConstant Address pExpr Integer ByRef iPos Integer iLen tXPToken ByRef strToken tXPError ByRef strError
28235>>>>>>>                Boolean bFin bDecimalPlaceIndendified
28235>>>>>>>                String sChar
28235>>>>>>>
28235>>>>>>>                Move (strToken.sValue=".") to bDecimalPlaceIndendified
28236>>>>>>>                Repeat
28236>>>>>>>>
28236>>>>>>>                    Increment iPos
28237>>>>>>>                    If (iPos<=iLen) Begin
28239>>>>>>>                        Move (Character(DeRefC(pExpr,iPos))) to sChar
28240>>>>>>>                        If ("0123456789." contains sChar) Begin
28242>>>>>>>                            Move (strToken.sValue+sChar) to strToken.sValue
28243>>>>>>>                            If (sChar=".") Begin
28245>>>>>>>                                If (bDecimalPlaceIndendified) Begin
28247>>>>>>>                                    Move True to bFin
28248>>>>>>>                                    Send _RegisterError (&strError) iPos "Redundant decimal separator encountered"
28249>>>>>>>                                End
28249>>>>>>>>
28249>>>>>>>                                Else Begin
28250>>>>>>>                                    Move True to bDecimalPlaceIndendified
28251>>>>>>>                                End
28251>>>>>>>>
28251>>>>>>>                            End
28251>>>>>>>>
28251>>>>>>>                        End
28251>>>>>>>>
28251>>>>>>>                        Else Begin
28252>>>>>>>                            Move True to bFin
28253>>>>>>>                        End
28253>>>>>>>>
28253>>>>>>>                    End
28253>>>>>>>>
28253>>>>>>>                    Else Begin
28254>>>>>>>                        Move True to bFin
28255>>>>>>>                    End
28255>>>>>>>>
28255>>>>>>>                Until (bFin)
28257>>>>>>>                Move (If(bDecimalPlaceIndendified,XPTokenType_NumberConstant,XPTokenType_IntegerConstant)) to strToken.iType
28258>>>>>>>            End_Procedure
28259>>>>>>>
28259>>>>>>>            Procedure _ParseOperator String sOperatorTestString Address pExpr Integer ByRef iPos Integer iLen tXPToken ByRef strToken tXPError ByRef strError
28261>>>>>>>                Boolean bFin
28261>>>>>>>                String sChar
28261>>>>>>>                Move False to bFin
28262>>>>>>>                Repeat
28262>>>>>>>>
28262>>>>>>>                    Increment iPos
28263>>>>>>>                    If (iPos<=iLen) Begin
28265>>>>>>>                        Move (Character(DeRefC(pExpr,iPos))) to sChar
28266>>>>>>>                        If (sOperatorTestString contains (" "+Uppercase(strToken.sValue+sChar)+" ")) Begin
28268>>>>>>>                            Move (strToken.sValue+sChar) to strToken.sValue
28269>>>>>>>                        End
28269>>>>>>>>
28269>>>>>>>                        Else Begin
28270>>>>>>>                            Move True to bFin
28271>>>>>>>                        End
28271>>>>>>>>
28271>>>>>>>                    End
28271>>>>>>>>
28271>>>>>>>                    Else Begin
28272>>>>>>>                        Move True to bFin
28273>>>>>>>                    End
28273>>>>>>>>
28273>>>>>>>                Until (bFin)
28275>>>>>>>                If (not(sOperatorTestString contains (" "+Uppercase(strToken.sValue)+" "))) Begin
28277>>>>>>>                    Send _RegisterError (&strError) strToken.iStartPos ("Symbol not recognised: "+strToken.sValue)
28278>>>>>>>                End
28278>>>>>>>>
28278>>>>>>>            End_Procedure
28279>>>>>>>
28279>>>>>>>                Procedure _ParseResolveFunctionCall tXPGrammar strGrammar tXPToken ByRef strToken Integer iArgCount tXPError ByRef strError
28281>>>>>>>                    Boolean bResolved bFunctionFound
28281>>>>>>>                    Integer iMax iItem
28281>>>>>>>                    String sFunction
28281>>>>>>>                    Move (SizeOfArray(strGrammar.aFunctions)-1) to iMax
28282>>>>>>>                    Move 0 to iItem
28283>>>>>>>                    Move False to bResolved
28284>>>>>>>                    Move False to bFunctionFound
28285>>>>>>>                    Move (Uppercase(strToken.sValue)) to sFunction
28286>>>>>>>                    While (not(bResolved) and iItem<=iMax)
28290>>>>>>>                        If (sFunction=Uppercase(strGrammar.aFunctions[iItem].sFunction)) Begin
28292>>>>>>>                            Move True to bFunctionFound
28293>>>>>>>                            If (iArgCount=strGrammar.aFunctions[iItem].iArgumentCount) Begin
28295>>>>>>>                                Move iItem to strToken.iOperatorIndex
28296>>>>>>>                                Move True to bResolved
28297>>>>>>>                            End
28297>>>>>>>>
28297>>>>>>>                        End
28297>>>>>>>>
28297>>>>>>>                        Increment iItem
28298>>>>>>>                    Loop
28299>>>>>>>>
28299>>>>>>>                    If (not(bResolved)) Begin
28301>>>>>>>                        If (bFunctionFound) Begin
28303>>>>>>>                            Send _RegisterError (&strError) strToken.iStartPos ("Wrong number of parameters (function: "+strToken.sValue+")")
28304>>>>>>>                        End
28304>>>>>>>>
28304>>>>>>>                        Else Begin
28305>>>>>>>                            Send _RegisterError (&strError) strToken.iStartPos ("Function not defined: ("+strToken.sValue+")")
28306>>>>>>>                        End
28306>>>>>>>>
28306>>>>>>>                    End
28306>>>>>>>>
28306>>>>>>>                End_Procedure
28307>>>>>>>
28307>>>>>>>                Procedure _ParseResolveOperator tXPGrammar strGrammar tXPToken ByRef strToken Integer iArgCount tXPError ByRef strError
28309>>>>>>>                    Boolean bResolved bOperatorFound
28309>>>>>>>                    Integer iMax iItem
28309>>>>>>>                    String sOperator
28309>>>>>>>                    Move (SizeOfArray(strGrammar.aOperators)-1) to iMax
28310>>>>>>>                    Move 0 to iItem
28311>>>>>>>                    Move False to bResolved
28312>>>>>>>                    Move False to bOperatorFound
28313>>>>>>>                    Move (Uppercase(strToken.sValue)) to sOperator
28314>>>>>>>                    While (not(bResolved) and iItem<=iMax)
28318>>>>>>>                        If (sOperator=Uppercase(strGrammar.aOperators[iItem].sSymbol)) Begin
28320>>>>>>>                            Move True to bOperatorFound
28321>>>>>>>                            If (iArgCount=strGrammar.aOperators[iItem].iArgumentCount) Begin
28323>>>>>>>                                Move iItem to strToken.iOperatorIndex
28324>>>>>>>                                Move True to bResolved
28325>>>>>>>                            End
28325>>>>>>>>
28325>>>>>>>                        End
28325>>>>>>>>
28325>>>>>>>                        Increment iItem
28326>>>>>>>                    Loop
28327>>>>>>>>
28327>>>>>>>                    If (not(bResolved)) Begin
28329>>>>>>>                        If (bOperatorFound) Begin
28331>>>>>>>                            Send _RegisterError (&strError) strToken.iStartPos ("Wrong number of operands (operator: "+strToken.sValue+")")
28332>>>>>>>                        End
28332>>>>>>>>
28332>>>>>>>                        Else Begin
28333>>>>>>>                            Send _RegisterError (&strError) strToken.iStartPos ("Operator not defined: ("+strToken.sValue+")")
28334>>>>>>>                        End
28334>>>>>>>>
28334>>>>>>>                    End
28334>>>>>>>>
28334>>>>>>>                End_Procedure
28335>>>>>>>            
28335>>>>>>>
28335>>>>>>>                    Function OnColumnNameToNumber Integer iTable String sName Returns Integer
28337>>>>>>>                        Integer iMax iField
28337>>>>>>>                        String sFieldName
28337>>>>>>>                        Move (Lowercase(sName)) to sName
28338>>>>>>>                        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iMax
28341>>>>>>>                        For iField from 1 to iMax
28347>>>>>>>>
28347>>>>>>>                            Get_Attribute DF_FIELD_NAME of iTable iField to sFieldName
28350>>>>>>>                            If (sName=Lowercase(sFieldName)) Begin
28352>>>>>>>                                Function_Return iField
28353>>>>>>>                            End
28353>>>>>>>>
28353>>>>>>>                        Loop
28354>>>>>>>>
28354>>>>>>>                        If (sName="recnum") Begin
28356>>>>>>>                            Function_Return 0
28357>>>>>>>                        End
28357>>>>>>>>
28357>>>>>>>                        Function_Return -1 // not found
28358>>>>>>>                    End_Function
28359>>>>>>>                
28359>>>>>>>                    Function OnTableNameToNumber String sLogicalName Returns Integer
28361>>>>>>>                        Integer iTable
28361>>>>>>>                        String sValue
28361>>>>>>>                        Move (Uppercase(sLogicalName)) to sLogicalName
28362>>>>>>>                        Move 0 to iTable
28363>>>>>>>                        Repeat
28363>>>>>>>>
28363>>>>>>>                            Get_Attribute DF_FILE_NEXT_USED of iTable to iTable
28366>>>>>>>                            If (iTable<>0) Begin
28368>>>>>>>                                Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sValue
28371>>>>>>>                                If (sLogicalName=Uppercase(sValue)) Begin
28373>>>>>>>                                    Function_Return iTable
28374>>>>>>>                                End
28374>>>>>>>>
28374>>>>>>>                            End
28374>>>>>>>>
28374>>>>>>>                        Until (iTable=0)
28376>>>>>>>                
28376>>>>>>>                        Function_Return -1
28377>>>>>>>                    End_Function
28378>>>>>>>                    
28378>>>>>>>                    Function OnIsTableColumnReference String sSymbol Returns Boolean
28380>>>>>>>                        // ToDo: Check for exactly 1 dot in the name. And that it is not the last character
28380>>>>>>>                        Function_Return (sSymbol contains ".") // Not good enough!
28381>>>>>>>                    End_Function
28382>>>>>>>                    
28382>>>>>>>                    Function OnGetTableColumnType Integer iTable Integer iColumn Returns Integer
28384>>>>>>>                        Integer iDFType
28384>>>>>>>                        Get_Attribute DF_FIELD_TYPE of iTable iColumn to iDFType
28387>>>>>>>                        
28387>>>>>>>                        If (iDFType=DF_ASCII or iDFType=DF_TEXT)       Function_Return XP_String
28390>>>>>>>                        If (iDFType=DF_DATE or iDFType=DF_DATETIME)    Function_Return XP_Date
28393>>>>>>>                        If (iDFType=DF_BCD)                            Function_Return XP_Numeric
28396>>>>>>>                        Function_Return XP_Error // Unknown type
28397>>>>>>>                    End_Function
28398>>>>>>>                    
28398>>>>>>>                    Procedure OnAddTableColumnHint tXPToken ByRef strSymbolToken tXPError ByRef strError
28400>>>>>>>                        Integer iTable iColumn iPos
28400>>>>>>>                        String sSymbol sTable sColumn
28400>>>>>>>                        Move strSymbolToken.sValue to sSymbol
28401>>>>>>>                        Move (Pos(".",sSymbol)) to iPos
28402>>>>>>>                        If (iPos>0) Begin
28404>>>>>>>                            Move (Left(sSymbol,iPos-1)) to sTable
28405>>>>>>>                            Move (Replace(sTable+".",sSymbol,"")) to sColumn
28406>>>>>>>                            Get OnTableNameToNumber sTable to iTable
28407>>>>>>>                            If (iTable>0) Begin
28409>>>>>>>                                Get OnColumnNameToNumber iTable sColumn to iColumn
28410>>>>>>>                                If (iColumn>0) Begin
28412>>>>>>>                                    Move iTable to strSymbolToken.strValueHint.iTable
28413>>>>>>>                                    Move iColumn to strSymbolToken.strValueHint.iColumn
28414>>>>>>>                                    Get OnGetTableColumnType iTable iColumn to strSymbolToken.strValueHint.iValueType
28415>>>>>>>                                End
28415>>>>>>>>
28415>>>>>>>                                Else Begin
28416>>>>>>>                                    Send _RegisterError (&strError) strSymbolToken.iStartPos ("ExprParser: '"+sColumn+"' not a column name in table '"+sTable+"'")
28417>>>>>>>                                End
28417>>>>>>>>
28417>>>>>>>                            End
28417>>>>>>>>
28417>>>>>>>                            Else Begin
28418>>>>>>>                                Send _RegisterError (&strError) strSymbolToken.iStartPos ("ExprParser: '"+sTable+"' not a table name")
28419>>>>>>>                            End
28419>>>>>>>>
28419>>>>>>>                        End
28419>>>>>>>>
28419>>>>>>>                        Else Begin
28420>>>>>>>                            Send _RegisterError (&strError) strSymbolToken.iStartPos ("ExprParser: '"+sSymbol+"' not a table column reference")
28421>>>>>>>                        End
28421>>>>>>>>
28421>>>>>>>                    End_Procedure
28422>>>>>>>
28422>>>>>>>            Procedure OnAddSymbolRetrievalHint tXPGrammar strGrammar tXPToken ByRef strSymbolToken tXPError ByRef strError
28424>>>>>>>                String sSymbol
28424>>>>>>>                Move strSymbolToken.sValue to sSymbol
28425>>>>>>>                If (OnIsTableColumnReference(Self,sSymbol)) Begin
28427>>>>>>>                    Send OnAddTableColumnHint (&strSymbolToken) (&strError)
28428>>>>>>>                End
28428>>>>>>>>
28428>>>>>>>                Else Begin
28429>>>>>>>                    Get _FindConstantIndex strGrammar sSymbol to strSymbolToken.strValueHint.iConstantIndex
28430>>>>>>>                End
28430>>>>>>>>
28430>>>>>>>                // Check to see if its a 
28430>>>>>>>            End_Procedure
28431>>>>>>>                
28431>>>>>>>            Procedure _AddSymbolValueRetrievalHints tXPGrammar strGrammar tXPToken[] ByRef aTokens tXPError ByRef strError
28433>>>>>>>                Integer iItem iMax  
28433>>>>>>>                Move (SizeOfArray(aTokens)-1) to iMax
28434>>>>>>>                For iItem from 0 to iMax
28440>>>>>>>>
28440>>>>>>>                    If (aTokens[iItem].iType=XPTokenType_Symbol) Begin
28442>>>>>>>                        Send OnAddSymbolRetrievalHint strGrammar (&aTokens[iItem]) (&strError)
28443>>>>>>>                    End
28443>>>>>>>>
28443>>>>>>>                Loop
28444>>>>>>>>
28444>>>>>>>            End_Procedure
28445>>>>>>>
28445>>>>>>>            // Procedure _TokenizeFinalize will resolve all operators and function calls according to
28445>>>>>>>            // the number of arguments each of them has as compared to the grammar.
28445>>>>>>>            Procedure _TokenizeFinalize tXPGrammar strGrammar tXPToken[] ByRef aTokens tXPError ByRef strError
28447>>>>>>>                Integer iItem iMax iType iCountIndex iOperatorArgCount
28447>>>>>>>                Integer[] aFunctionCallStack //
28448>>>>>>>                Integer[] aFunctionParameterCounters //
28449>>>>>>>                Move (SizeOfArray(aTokens)-1) to iMax
28450>>>>>>>                For iItem from 0 to iMax
28456>>>>>>>>
28456>>>>>>>                    Move aTokens[iItem].iType to iType
28457>>>>>>>                    If (iType=XPTokenType_FunctionCall) Begin
28459>>>>>>>                        Send IntegerPush of oStackFunctions iItem (&aFunctionCallStack)
28460>>>>>>>                        Move (SizeOfArray(aFunctionCallStack)-1) to iCountIndex
28461>>>>>>>                        Move 0 to aFunctionParameterCounters[iCountIndex]
28462>>>>>>>                    End
28462>>>>>>>>
28462>>>>>>>                    Else If (iType=XPTokenType_EndFunctionCall) Begin
28465>>>>>>>                        If (aTokens[iItem-1].iType<>XPTokenType_FunctionCall) Begin
28467>>>>>>>                            Increment aFunctionParameterCounters[iCountIndex]
28468>>>>>>>                        End
28468>>>>>>>>
28468>>>>>>>                        Send _ParseResolveFunctionCall strGrammar (&aTokens[aFunctionCallStack[iCountIndex]]) aFunctionParameterCounters[iCountIndex] (&strError)
28469>>>>>>>                        Send IntegerDrop of oStackFunctions (&aFunctionCallStack)
28470>>>>>>>                        Move (SizeOfArray(aFunctionCallStack)-1) to iCountIndex
28471>>>>>>>                    End
28471>>>>>>>>
28471>>>>>>>                    Else If (iType=XPTokenType_NewParameter) Begin
28474>>>>>>>                        // Check for un-motivated new parameter 
28474>>>>>>>                        If (IntegerIsEmpty(oStackFunctions,aFunctionCallStack)) Begin
28476>>>>>>>                            Send _RegisterError (&strError) aTokens[iItem].iStartPos "Un-motivated new parameter"
28477>>>>>>>                        End
28477>>>>>>>>
28477>>>>>>>                        Else Begin
28478>>>>>>>                            Increment aFunctionParameterCounters[iCountIndex]
28479>>>>>>>                        End
28479>>>>>>>>
28479>>>>>>>                    End
28479>>>>>>>>
28479>>>>>>>                    Else If (iType=XPTokenType_Operator) Begin
28482>>>>>>>                        Move 0 to iOperatorArgCount
28483>>>>>>>                        // If there's something in front of it and it is not a left parenthesis or a comma
28483>>>>>>>                        // then we have a parameter to the left of the operator:
28483>>>>>>>                        If (iItem>0 and aTokens[iItem-1].iType<>XPTokenType_FunctionCall and ;                                        aTokens[iItem-1].iType<>XPTokenType_NewParameter) Begin
28485>>>>>>>                            Increment iOperatorArgCount
28486>>>>>>>                        End
28486>>>>>>>>
28486>>>>>>>                        // If there is something after it and it is not a right parenthesis or a function-end or a new parameter
28486>>>>>>>                        // then we have a parameter to the right of us:
28486>>>>>>>                        If (iItem<iMax and aTokens[iItem+1].sValue<>")" and aTokens[iItem+1].iType<>XPTokenType_NewParameter) Begin
28488>>>>>>>                            Increment iOperatorArgCount
28489>>>>>>>                        End
28489>>>>>>>>
28489>>>>>>>                        Send _ParseResolveOperator strGrammar (&aTokens[iItem]) iOperatorArgCount (&strError)
28490>>>>>>>                    End
28490>>>>>>>>
28490>>>>>>>                Loop
28491>>>>>>>>
28491>>>>>>>            End_Procedure
28492>>>>>>>
28492>>>>>>>    Function TokenizeString tXPGrammar strGrammar String sExpression tXPError ByRef strError Returns tXPToken[]
28494>>>>>>>        Boolean bTokenFound bFin
28494>>>>>>>        Boolean bTokenTerminatedByLeftParenthesis
28494>>>>>>>        Boolean[] aParenthesisLevelIsFunctionCall
28495>>>>>>>        Integer iTokenCount
28495>>>>>>>        Integer iPos iLen
28495>>>>>>>        Integer iItem iMax
28495>>>>>>>        String sChar sTemp
28495>>>>>>>        Address pExpr
28495>>>>>>>        tXPToken[] aTokens
28495>>>>>>>        tXPToken[] aTokens
28496>>>>>>>        tXPToken strNextToken
28496>>>>>>>        tXPToken strNextToken
28496>>>>>>>        tXPError strNoError
28496>>>>>>>        tXPError strNoError
28496>>>>>>>
28496>>>>>>>        Move (AddressOf(sExpression)) to pExpr
28497>>>>>>>        Move (Length(sExpression)) to iLen
28498>>>>>>>        Move 0 to iPos // First character is in position 0
28499>>>>>>>
28499>>>>>>>        Move strNoError to strError
28500>>>>>>>        Move 0 to iTokenCount
28501>>>>>>>
28501>>>>>>>        Repeat // until (not(bTokenFound))
28501>>>>>>>>
28501>>>>>>>
28501>>>>>>>            // Remove leadin whitespace (and set bTokenFound):
28501>>>>>>>            Move False to bFin
28502>>>>>>>            Move False to bTokenFound
28503>>>>>>>            Repeat
28503>>>>>>>>
28503>>>>>>>                If (iPos<=iLen) Begin
28505>>>>>>>                    Move (Character(DeRefC(pExpr,iPos))) to sChar
28506>>>>>>>                    If (Ascii(sChar)<=32) Begin
28508>>>>>>>                        Increment iPos // Skip blanks, tabs, cr/lf's and the lot
28509>>>>>>>                    End
28509>>>>>>>>
28509>>>>>>>                    Else Begin
28510>>>>>>>                        Move True to bFin
28511>>>>>>>                        Move True to bTokenFound
28512>>>>>>>                    End
28512>>>>>>>>
28512>>>>>>>                End
28512>>>>>>>>
28512>>>>>>>                Else begin
28513>>>>>>>                    Move True to bFin
28514>>>>>>>                End
28514>>>>>>>>
28514>>>>>>>            Until bFin
28516>>>>>>>
28516>>>>>>>            If (bTokenFound) Begin
28518>>>>>>>                // Initialize new token:
28518>>>>>>>                Move -1 to strNextToken.iType         // Type unknown
28519>>>>>>>                Move "" to strNextToken.sValue         // No value yet
28520>>>>>>>                Move -1 to strNextToken.strValueHint.iConstantIndex
28521>>>>>>>                Move (iPos+1) to strNextToken.iStartPos    // Start position of the symbol
28522>>>>>>>                Move -1 to strNextToken.iOperatorIndex
28523>>>>>>>
28523>>>>>>>                Move (Character(DeRefC(pExpr,iPos))) to sChar
28524>>>>>>>                Move sChar to strNextToken.sValue
28525>>>>>>>
28525>>>>>>>                If (C_EPSymbolLegalFirstCharacters contains sChar) Begin
28527>>>>>>>                    // It's an operator or a symbol. Or a function call if the terminating character is a "("
28527>>>>>>>                    Move False to bFin
28528>>>>>>>                    Move False to bTokenTerminatedByLeftParenthesis
28529>>>>>>>                    Repeat
28529>>>>>>>>
28529>>>>>>>                        Increment iPos
28530>>>>>>>                        If (iPos<=iLen) Begin
28532>>>>>>>                            Move (Character(DeRefC(pExpr,iPos))) to sChar
28533>>>>>>>                            If (C_EPSymbolLegalCharacters contains sChar) Begin
28535>>>>>>>                                Move (strNextToken.sValue+sChar) to strNextToken.sValue
28536>>>>>>>                            End
28536>>>>>>>>
28536>>>>>>>                            Else Begin
28537>>>>>>>                                If (sChar="(") Begin // A function call most likely!
28539>>>>>>>                                    Move True to bTokenTerminatedByLeftParenthesis
28540>>>>>>>                                End
28540>>>>>>>>
28540>>>>>>>                                Move True to bFin
28541>>>>>>>                            End
28541>>>>>>>>
28541>>>>>>>                        End
28541>>>>>>>>
28541>>>>>>>                        Else Begin
28542>>>>>>>                            Move True to bFin
28543>>>>>>>                        End
28543>>>>>>>>
28543>>>>>>>                    Until (bFin)
28545>>>>>>>                    If (strGrammar._sOperatorTestString contains (" "+Uppercase(strNextToken.sValue)+" ")) Begin
28547>>>>>>>                        // Operator!
28547>>>>>>>                        Move XPTokenType_Operator to strNextToken.iType
28548>>>>>>>                        If (strNextToken.sValue=")") Begin
28550>>>>>>>                            If (BooleanPop(oStackFunctions,&aParenthesisLevelIsFunctionCall)) Begin
28552>>>>>>>                                Move XPTokenType_EndFunctionCall to strNextToken.iType
28553>>>>>>>                            End
28553>>>>>>>>
28553>>>>>>>                        End
28553>>>>>>>>
28553>>>>>>>                    End
28553>>>>>>>>
28553>>>>>>>                    Else Begin
28554>>>>>>>                        // Symbol or function call!
28554>>>>>>>                        If (bTokenTerminatedByLeftParenthesis) Begin // Then it's a function call
28556>>>>>>>//                                Increment iPos // Skip the parenthesis
28556>>>>>>>                            Move XPTokenType_FunctionCall to strNextToken.iType
28557>>>>>>>                            Send BooleanPush of oStackFunctions True (&aParenthesisLevelIsFunctionCall)
28558>>>>>>>                        End
28558>>>>>>>>
28558>>>>>>>                        Else Begin
28559>>>>>>>                            Move XPTokenType_Symbol to strNextToken.iType
28560>>>>>>>                        End
28560>>>>>>>>
28560>>>>>>>                    End
28560>>>>>>>>
28560>>>>>>>                End
28560>>>>>>>>
28560>>>>>>>                Else Begin // Operator or constant
28561>>>>>>>                    If (("'"+'"') contains sChar) Begin // Constant string?
28563>>>>>>>                        // String constant
28563>>>>>>>                        Send _ParseStringConstant pExpr (&iPos) iLen (&strNextToken) (&strError)
28564>>>>>>>                        Move XPTokenType_StringConstant to strNextToken.iType
28565>>>>>>>                    End
28565>>>>>>>>
28565>>>>>>>                    Else If ("0123456789." contains sChar) Begin // Constant numeric?
28568>>>>>>>                        Send _ParseNumericConstant pExpr (&iPos) iLen (&strNextToken) (&strError)
28569>>>>>>>                    End
28569>>>>>>>>
28569>>>>>>>                    Else Begin // Then operator
28570>>>>>>>                        Send _ParseOperator strGrammar._sOperatorTestString pExpr (&iPos) iLen (&strNextToken) (&strError)
28571>>>>>>>                        Move XPTokenType_Operator to strNextToken.iType
28572>>>>>>>                        If (strNextToken.sValue="(") Begin
28574>>>>>>>                            If (not(iTokenCount>0 and aTokens[iTokenCount-1].iType=XPTokenType_FunctionCall)) Begin
28576>>>>>>>                                Send BooleanPush of oStackFunctions False (&aParenthesisLevelIsFunctionCall)
28577>>>>>>>                            End
28577>>>>>>>>
28577>>>>>>>                            Move XPTokenType_LeftParenthesis to strNextToken.iType
28578>>>>>>>                        End
28578>>>>>>>>
28578>>>>>>>                        Else If (strNextToken.sValue=")") Begin
28581>>>>>>>                            If (BooleanIsEmpty(oStackFunctions,aParenthesisLevelIsFunctionCall)) Begin
28583>>>>>>>                                Send _RegisterError (&strError) strNextToken.iStartPos "Cannot unstack )"
28584>>>>>>>                            End
28584>>>>>>>>
28584>>>>>>>                            Else Begin
28585>>>>>>>                                If (BooleanPop(oStackFunctions,&aParenthesisLevelIsFunctionCall)) Begin
28587>>>>>>>                                    Move XPTokenType_EndFunctionCall to strNextToken.iType
28588>>>>>>>                                End
28588>>>>>>>>
28588>>>>>>>                                Else Begin
28589>>>>>>>                                    Move XPTokenType_RightParenthesis to strNextToken.iType
28590>>>>>>>                                End
28590>>>>>>>>
28590>>>>>>>                            End
28590>>>>>>>>
28590>>>>>>>                        End
28590>>>>>>>>
28590>>>>>>>                        Else If (strNextToken.sValue=",") Begin
28593>>>>>>>                            Move XPTokenType_NewParameter to strNextToken.iType
28594>>>>>>>                        End
28594>>>>>>>>
28594>>>>>>>                    End
28594>>>>>>>>
28594>>>>>>>                End
28594>>>>>>>>
28594>>>>>>>
28594>>>>>>>                Move strNextToken to aTokens[iTokenCount]
28595>>>>>>>                Increment iTokenCount
28596>>>>>>>            End
28596>>>>>>>>
28596>>>>>>>        Until (not(bTokenFound))
28598>>>>>>>
28598>>>>>>>        If (SizeOfArray(aParenthesisLevelIsFunctionCall)>0) Begin
28600>>>>>>>            If (strError.iPos=0) Begin
28602>>>>>>>                Move -1 to strError.iPos
28603>>>>>>>                Move "Unbalanced parenthesis" to strError.sErrorText
28604>>>>>>>            End
28604>>>>>>>>
28604>>>>>>>        End
28604>>>>>>>>
28604>>>>>>>
28604>>>>>>>        Send _TokenizeFinalize strGrammar (&aTokens) (&strError)
28605>>>>>>>        
28605>>>>>>>        // Translate for example column names into iTable iColumn format instead
28605>>>>>>>        Send _AddSymbolValueRetrievalHints strGrammar (&aTokens) (&strError)
28606>>>>>>>        
28606>>>>>>>        Function_Return aTokens
28607>>>>>>>    End_Function
28608>>>>>>>
28608>>>>>>>        Procedure _OperatorStackPush tXPToken[] ByRef aOperatorStack tXPToken strToken
28610>>>>>>>            Move strToken to aOperatorStack[SizeOfArray(aOperatorStack)]
28611>>>>>>>        End_Procedure
28612>>>>>>>
28612>>>>>>>        Function _OperatorStackPop tXPToken[] ByRef aOperatorStack Returns tXPToken
28614>>>>>>>            Integer iIndex
28614>>>>>>>            tXPToken strToken strEmptyToken
28614>>>>>>>            tXPToken strToken strEmptyToken
28614>>>>>>>            Move (SizeOfArray(aOperatorStack)-1) to iIndex
28615>>>>>>>            If (iIndex>=0) Begin
28617>>>>>>>                Move aOperatorStack[iIndex] to strToken
28618>>>>>>>                Move (RemoveFromArray(aOperatorStack,iIndex)) to aOperatorStack
28619>>>>>>>                Function_Return strToken
28620>>>>>>>            End
28620>>>>>>>>
28620>>>>>>>            Error DFERR_OPERATOR ("ExprParser: Attempt to pop from empty stack")
28621>>>>>>>>
28621>>>>>>>            Function_Return strEmptyToken
28622>>>>>>>        End_Function
28623>>>>>>>
28623>>>>>>>        Function _OperatorStackCopy tXPToken[] aOperatorStack Returns tXPToken
28625>>>>>>>            Integer iIndex
28625>>>>>>>            tXPToken strEmptyToken
28625>>>>>>>            tXPToken strEmptyToken
28625>>>>>>>            Move (SizeOfArray(aOperatorStack)-1) to iIndex
28626>>>>>>>            If (iIndex>=0) Begin
28628>>>>>>>                Function_Return aOperatorStack[iIndex]
28629>>>>>>>            End
28629>>>>>>>>
28629>>>>>>>            Error DFERR_OPERATOR ("ExprParser: Attempt to copy from empty stack")
28630>>>>>>>>
28630>>>>>>>            Function_Return strEmptyToken
28631>>>>>>>        End_Function
28632>>>>>>>
28632>>>>>>>        Function _OperatorStackIsEmpty tXPToken[] aOperatorStack Returns Boolean
28634>>>>>>>            Function_Return (SizeOfArray(aOperatorStack)=0)
28635>>>>>>>        End_Function
28636>>>>>>>
28636>>>>>>>    Function ReversePolishNotation tXPGrammar strGrammar tXPToken[] aInputTokens tXPError ByRef strError Returns tXPToken[]
28638>>>>>>>        Integer iInputTokensMax iInputTokenIndex iAssociativity iPrecendence
28638>>>>>>>        Boolean bFin
28638>>>>>>>        tXPToken[] aOutputTokens
28638>>>>>>>        tXPToken[] aOutputTokens
28639>>>>>>>        tXPToken[] aOperatorStack
28639>>>>>>>        tXPToken[] aOperatorStack
28640>>>>>>>        tXPToken strInputToken strToken
28640>>>>>>>        tXPToken strInputToken strToken
28640>>>>>>>
28640>>>>>>>        Move (SizeOfArray(aInputTokens)) to iInputTokensMax
28641>>>>>>>        Move 0 to iInputTokenIndex
28642>>>>>>>        
28642>>>>>>>        While (iInputTokenIndex<iInputTokensMax)
28646>>>>>>>            Move aInputTokens[iInputTokenIndex] to strInputToken
28647>>>>>>>            If (strInputToken.iType=XPTokenType_IntegerConstant or ;                strInputToken.iType=XPTokenType_NumberConstant or ;                strInputToken.iType=XPTokenType_StringConstant or ;                strInputToken.iType=XPTokenType_Symbol) Begin
28649>>>>>>>                // If the token is an operand, then add it to the output
28649>>>>>>>                Move aInputTokens[iInputTokenIndex] to aOutputTokens[SizeOfArray(aOutputTokens)]
28650>>>>>>>            End
28650>>>>>>>>
28650>>>>>>>            Else If (strInputToken.iType=XPTokenType_FunctionCall) Begin
28653>>>>>>>                // If the token is a function, then push it onto the stack
28653>>>>>>>                Send _OperatorStackPush (&aOperatorStack) aInputTokens[iInputTokenIndex]
28654>>>>>>>            End
28654>>>>>>>>
28654>>>>>>>            Else If (strInputToken.iType=XPTokenType_NewParameter) Begin
28657>>>>>>>                // If the token is a function argument separator (e.g., a comma):
28657>>>>>>>                //   Until the token at the top of the stack is a left parenthesis, pop operators
28657>>>>>>>                //   off the stack onto the output queue. If no left parentheses are encountered,
28657>>>>>>>                //   either the separator was misplaced or parentheses were mismatched.
28657>>>>>>>                Repeat
28657>>>>>>>>
28657>>>>>>>                    Get _OperatorStackCopy aOperatorStack to strToken
28658>>>>>>>                    If (strToken.iType<>XPTokenType_LeftParenthesis and strToken.iType<>XPTokenType_Error) Begin
28660>>>>>>>                        Get _OperatorStackPop (&aOperatorStack) to aOutputTokens[SizeOfArray(aOutputTokens)]
28661>>>>>>>                    End
28661>>>>>>>>
28661>>>>>>>                Until (strToken.iType=XPTokenType_LeftParenthesis or strToken.iType=XPTokenType_Error)
28663>>>>>>>            End
28663>>>>>>>>
28663>>>>>>>            Else If (strInputToken.iType=XPTokenType_Operator) Begin
28666>>>>>>>                // If the token is an operator, o1, then:
28666>>>>>>>                //     While there is an operator token, o2, at the top of the stack, and
28666>>>>>>>                //         either o1 is left-associative and its precedence is less than or equal to that of o2,
28666>>>>>>>                //         or o1 has precedence less than that of o2,
28666>>>>>>>                //     pop o2 off the stack, onto the Output queue;
28666>>>>>>>                // push o1 onto the stack.
28666>>>>>>>
28666>>>>>>>                // associativity and precedence of o1:
28666>>>>>>>                Move strGrammar.aOperators[strInputToken.iOperatorIndex].iAssociativity to iAssociativity
28667>>>>>>>                Move strGrammar.aOperators[strInputToken.iOperatorIndex].iPrecedence to iPrecendence
28668>>>>>>>                Repeat
28668>>>>>>>>
28668>>>>>>>                    Move True to bFin // We assume we are done
28669>>>>>>>                    If (not(_OperatorStackIsEmpty(Self,aOperatorStack))) Begin
28671>>>>>>>                        Get _OperatorStackCopy aOperatorStack to strToken // o2
28672>>>>>>>                        If (strToken.iType=XPTokenType_Operator) Begin // Check that its an actual operator (and not "(" for example)
28674>>>>>>>                            // Note that I have reversed the order of precedence according to prescription:
28674>>>>>>>                            If ((iAssociativity=0 and ;                                  iPrecendence>=strGrammar.aOperators[strToken.iOperatorIndex].iPrecedence) or ;                                  iPrecendence>strGrammar.aOperators[strToken.iOperatorIndex].iPrecedence) Begin
28676>>>>>>>                                Move False to bFin // Oh! We weren't done at all
28677>>>>>>>                            End
28677>>>>>>>>
28677>>>>>>>                        End
28677>>>>>>>>
28677>>>>>>>                    End
28677>>>>>>>>
28677>>>>>>>                    If (not(bFin)) Begin
28679>>>>>>>                        Move (_OperatorStackPop(Self,&aOperatorStack)) to aOutputTokens[SizeOfArray(aOutputTokens)]
28680>>>>>>>                    End
28680>>>>>>>>
28680>>>>>>>                Until (bFin)
28682>>>>>>>                Send _OperatorStackPush (&aOperatorStack) strInputToken
28683>>>>>>>            End
28683>>>>>>>>
28683>>>>>>>            Else If (strInputToken.iType=XPTokenType_LeftParenthesis) Begin
28686>>>>>>>                // If the token is a left parenthesis, then push it onto the stack.
28686>>>>>>>                Send _OperatorStackPush (&aOperatorStack) strInputToken
28687>>>>>>>            End
28687>>>>>>>>
28687>>>>>>>            Else If (strInputToken.iType=XPTokenType_RightParenthesis or ;                     strInputToken.iType=XPTokenType_EndFunctionCall) Begin
28690>>>>>>>                // If the token is a right parenthesis:
28690>>>>>>>                //    * Until the token at the top of the stack is a left parenthesis, pop operators off the stack onto the output queue.
28690>>>>>>>                //    * Pop the left parenthesis from the stack, but not onto the output queue.
28690>>>>>>>                //    * If the token at the top of the stack is a function token, pop it onto the Output queue.
28690>>>>>>>                //    * If the stack runs out without finding a left parenthesis, then there are mismatched parentheses.
28690>>>>>>>                Repeat
28690>>>>>>>>
28690>>>>>>>                    Move True to bFin
28691>>>>>>>                    If (_OperatorStackIsEmpty(Self,aOperatorStack)) Begin
28693>>>>>>>                        Send _RegisterError (&strError) -1 "Mismatched parenthesis"
28694>>>>>>>                    End
28694>>>>>>>>
28694>>>>>>>                    Else Begin
28695>>>>>>>                        Get _OperatorStackPop (&aOperatorStack) to strToken
28696>>>>>>>                        If (strToken.iType<>XPTokenType_LeftParenthesis) Begin
28698>>>>>>>                            Move False to bFin
28699>>>>>>>                            Move strToken to aOutputTokens[SizeOfArray(aOutputTokens)]
28700>>>>>>>                        End
28700>>>>>>>>
28700>>>>>>>                        Else Begin
28701>>>>>>>                            // Do nothing
28701>>>>>>>                        End
28701>>>>>>>>
28701>>>>>>>                    End
28701>>>>>>>>
28701>>>>>>>                Until (bFin)
28703>>>>>>>                If (not(_OperatorStackIsEmpty(Self,aOperatorStack))) Begin
28705>>>>>>>                    Get _OperatorStackCopy aOperatorStack to strToken
28706>>>>>>>                End
28706>>>>>>>>
28706>>>>>>>                If (strToken.iType=XPTokenType_FunctionCall) Begin
28708>>>>>>>                    Get _OperatorStackPop (&aOperatorStack) to aOutputTokens[SizeOfArray(aOutputTokens)]
28709>>>>>>>                End
28709>>>>>>>>
28709>>>>>>>            End
28709>>>>>>>>
28709>>>>>>>            Else Begin
28710>>>>>>>                Send Info_Box "Token not handled! (error)"
28711>>>>>>>            End
28711>>>>>>>>
28711>>>>>>>            Increment iInputTokenIndex
28712>>>>>>>        Loop
28713>>>>>>>>
28713>>>>>>>
28713>>>>>>>//      When there are no more tokens to read:
28713>>>>>>>//        While there are still operator tokens in the stack:
28713>>>>>>>//          If the operator token on the top of the stack is a parenthesis, then there are mismatched parentheses.
28713>>>>>>>//          Pop the operator onto the output queue.
28713>>>>>>>//
28713>>>>>>>        While (not(_OperatorStackIsEmpty(Self,aOperatorStack)))
28717>>>>>>>            Get _OperatorStackPop (&aOperatorStack) to strToken
28718>>>>>>>            If (strToken.iType=XPTokenType_LeftParenthesis or strToken.iType=XPTokenType_RightParenthesis) Begin
28720>>>>>>>                Send _RegisterError (&strError) -1 "Mis-matched parenthesis"
28721>>>>>>>            End
28721>>>>>>>>
28721>>>>>>>            Move strToken to aOutputTokens[SizeOfArray(aOutputTokens)]
28722>>>>>>>        Loop
28723>>>>>>>>
28723>>>>>>>
28723>>>>>>>        Function_Return aOutputTokens
28724>>>>>>>    End_Function
28725>>>>>>>    
28725>>>>>>>    Function OnGetSymbolValue tXPToken strToken Returns tXPValue
28727>>>>>>>        tXPValue strValue
28727>>>>>>>        tXPValue strValue
28727>>>>>>>        Move XP_Error to strValue.iValueType
28728>>>>>>>        Move ("Don't know "+strToken.sValue) to strValue.sValue
28729>>>>>>>        Function_Return strValue
28730>>>>>>>    End_Function
28731>>>>>>>    
28731>>>>>>>    Function _OnGetSymbolValue tXPGrammar strGrammar tXPToken strToken Returns tXPValue
28733>>>>>>>        tXPValue strValue
28733>>>>>>>        tXPValue strValue
28733>>>>>>>        If (strToken.strValueHint.iTable<>0) Begin // Retrieve table.column value
28735>>>>>>>            Get_Field_Value strToken.strValueHint.iTable strToken.strValueHint.iColumn to strValue.sValue
28738>>>>>>>            Move (Rtrim(strValue.sValue)) to strValue.sValue
28739>>>>>>>            Move strToken.strValueHint.iValueType to strValue.iValueType
28740>>>>>>>        End
28740>>>>>>>>
28740>>>>>>>        Else If (strToken.strValueHint.iConstantIndex>=0) Begin // Retrieve constant value
28743>>>>>>>            Move strGrammar.aConstants[strToken.strValueHint.iConstantIndex] to strValue
28744>>>>>>>        End
28744>>>>>>>>
28744>>>>>>>        Else Begin
28745>>>>>>>            Get OnGetSymbolValue strToken to strValue
28746>>>>>>>        End
28746>>>>>>>>
28746>>>>>>>        Function_Return strValue
28747>>>>>>>    End_Function
28748>>>>>>>    
28748>>>>>>>    Function _ExecuteFunctionOrOperand _tXPFunctionPointer strFuncPointer tXPValue[] aParameters tXPError ByRef strError Returns tXPValue
28750>>>>>>>        tXPValue strValue
28750>>>>>>>        tXPValue strValue
28750>>>>>>>        Integer hFunc hObject
28750>>>>>>>        Move strFuncPointer.iMsg to hFunc
28751>>>>>>>        Move strFuncPointer.iObj to hObject
28752>>>>>>>        Get hFunc of hObject aParameters to strValue
28753>>>>>>>        Function_Return strValue
28754>>>>>>>    End_Function
28755>>>>>>>
28755>>>>>>>    //From http://en.wikipedia.org/wiki/Reverse_Polish_notation
28755>>>>>>>    // 
28755>>>>>>>    //   * While there are input tokens left
28755>>>>>>>    //      * Read the next token from input.
28755>>>>>>>    //      * If the token is a value
28755>>>>>>>    //          * Push it onto the stack.
28755>>>>>>>    //      * Otherwise, the token is an operator (operator here includes both operators, and functions).
28755>>>>>>>    //          * It is known a priori that the operator takes n arguments.
28755>>>>>>>    //          * If there are fewer than n values on the stack
28755>>>>>>>    //              * (Error) The user has not input sufficient values in the expression.
28755>>>>>>>    //          * Else, Pop the top n values from the stack.
28755>>>>>>>    //          * Evaluate the operator, with the values as arguments.
28755>>>>>>>    //          * Push the returned results, If any, back onto the stack.
28755>>>>>>>    //   * If there is only one value in the stack
28755>>>>>>>    //      * That value is the result of the calculation.
28755>>>>>>>    //   * If there are more values in the stack
28755>>>>>>>    //      * (Error) The user input has too many values.
28755>>>>>>>    
28755>>>>>>>    Function Evaluate tXPGrammar strGrammar tXPToken[] aInput tXPError ByRef strError Returns tXPValue
28757>>>>>>>        Integer iItem iMaxSymbol
28757>>>>>>>        Integer iOperatorIndex
28757>>>>>>>        Integer iStackSize
28757>>>>>>>        Integer hFunc hObject
28757>>>>>>>        
28757>>>>>>>        tXPValue[] aOperandStack 
28757>>>>>>>        tXPValue[] aOperandStack 
28758>>>>>>>        tXPToken strToken
28758>>>>>>>        tXPToken strToken
28758>>>>>>>        tXPOperator strOperator
28758>>>>>>>        tXPOperator strOperator
28758>>>>>>>        tXPFunction strFunction
28758>>>>>>>        tXPFunction strFunction
28758>>>>>>>        tXPValue strValue
28758>>>>>>>        tXPValue strValue
28758>>>>>>>        
28758>>>>>>>        Move (SizeOfArray(aInput)-1) to iMaxSymbol
28759>>>>>>>        For iItem from 0 to iMaxSymbol
28765>>>>>>>>
28765>>>>>>>            Move aInput[iItem] to strToken
28766>>>>>>>            
28766>>>>>>>            If (strToken.iType=XPTokenType_IntegerConstant) Begin
28768>>>>>>>                // If the token is a value push it on the operand stack:
28768>>>>>>>                Move strToken.sValue to strValue.sValue
28769>>>>>>>                Move XP_Integer to strValue.iValueType
28770>>>>>>>                Move strValue to aOperandStack[SizeOfArray(aOperandStack)]
28771>>>>>>>            End
28771>>>>>>>>
28771>>>>>>>            Else If (strToken.iType=XPTokenType_NumberConstant) Begin 
28774>>>>>>>                Move strToken.sValue to strValue.sValue
28775>>>>>>>                Move XP_Numeric to strValue.iValueType
28776>>>>>>>                Move strValue to aOperandStack[SizeOfArray(aOperandStack)]
28777>>>>>>>            End
28777>>>>>>>>
28777>>>>>>>            Else If (strToken.iType=XPTokenType_StringConstant) Begin 
28780>>>>>>>                Move strToken.sValue to strValue.sValue
28781>>>>>>>                Move XP_String to strValue.iValueType
28782>>>>>>>                Move strValue to aOperandStack[SizeOfArray(aOperandStack)]
28783>>>>>>>            End
28783>>>>>>>>
28783>>>>>>>            Else If (strToken.iType=XPTokenType_Symbol) Begin 
28786>>>>>>>                Get _OnGetSymbolValue strGrammar strToken to strValue
28787>>>>>>>                Move strValue to aOperandStack[SizeOfArray(aOperandStack)]
28788>>>>>>>            End
28788>>>>>>>>
28788>>>>>>>            Else If (strToken.iType=XPTokenType_FunctionCall) Begin
28791>>>>>>>                Move strGrammar.aFunctions[strToken.iOperatorIndex] to strFunction
28792>>>>>>>                Move (SizeOfArray(aOperandStack)) to iStackSize
28793>>>>>>>                If (iStackSize>=strFunction.iArgumentCount) Begin
28795>>>>>>>                    Get _ExecuteFunctionOrOperand strFunction.strDispatch (CopyArray(aOperandStack,iStackSize-strFunction.iArgumentCount,iStackSize-1)) (&strError) to strValue
28796>>>>>>>                    If (strFunction.iArgumentCount>0) Begin
28798>>>>>>>                        // Pop params off the stack
28798>>>>>>>                        Move (ResizeArray(aOperandStack,iStackSize-strFunction.iArgumentCount)) to aOperandStack
28799>>>>>>>                    End
28799>>>>>>>>
28799>>>>>>>                    Move strValue to aOperandStack[SizeOfArray(aOperandStack)] // Push result back on
28800>>>>>>>                End
28800>>>>>>>>
28800>>>>>>>                Else Begin
28801>>>>>>>                    Send _RegisterError (&strError) strToken.iStartPos "ExprParser: Eval error, not enough parameters on stack (function call)"
28802>>>>>>>                End
28802>>>>>>>>
28802>>>>>>>            End
28802>>>>>>>>
28802>>>>>>>            Else If (strToken.iType=XPTokenType_Operator) Begin 
28805>>>>>>>                Move strGrammar.aOperators[strToken.iOperatorIndex] to strOperator
28806>>>>>>>                Move (SizeOfArray(aOperandStack)) to iStackSize
28807>>>>>>>                If (iStackSize>=strOperator.iArgumentCount) Begin
28809>>>>>>>                    Get _ExecuteFunctionOrOperand strOperator.strDispatch (CopyArray(aOperandStack,iStackSize-strOperator.iArgumentCount,iStackSize-1)) (&strError) to strValue
28810>>>>>>>                    If (strOperator.iArgumentCount>0) Begin
28812>>>>>>>                        // Pop params off the stack
28812>>>>>>>                        Move (ResizeArray(aOperandStack,iStackSize-strOperator.iArgumentCount)) to aOperandStack
28813>>>>>>>                    End
28813>>>>>>>>
28813>>>>>>>                    Move strValue to aOperandStack[SizeOfArray(aOperandStack)] // Push result back on
28814>>>>>>>                End
28814>>>>>>>>
28814>>>>>>>                Else Begin
28815>>>>>>>                    Send _RegisterError (&strError) strToken.iStartPos "ExprParser: Eval error, not enough parameters on stack (operator)"
28816>>>>>>>                End
28816>>>>>>>>
28816>>>>>>>            End
28816>>>>>>>>
28816>>>>>>>            Else Begin
28817>>>>>>>                Send _RegisterError (&strError) strToken.iStartPos "ExprParser: Token type not recognised by Evaluate function"
28818>>>>>>>            End
28818>>>>>>>>
28818>>>>>>>            
28818>>>>>>>        Loop
28819>>>>>>>>
28819>>>>>>>        
28819>>>>>>>        If (SizeOfArray(aOperandStack)=1) Begin
28821>>>>>>>            Function_Return aOperandStack[0]
28822>>>>>>>        End
28822>>>>>>>>
28822>>>>>>>        Else If (SizeOfArray(aOperandStack)=0) Begin
28825>>>>>>>            Send _RegisterError (&strError) -1 "ExprParser: Missing return value"
28826>>>>>>>        End
28826>>>>>>>>
28826>>>>>>>        Else Begin
28827>>>>>>>            Send _RegisterError (&strError) -1 "ExprParser: Too many operands on stack"
28828>>>>>>>        End
28828>>>>>>>>
28828>>>>>>>        Move XP_Error to strValue.iValueType
28829>>>>>>>        
28829>>>>>>>        Function_Return strValue
28830>>>>>>>    End_Function
28831>>>>>>>End_Class
28832>>>>>>>
28832>>>>>>>Class cExpressionParser is a cExpressionParserBasic
28833>>>>>>>
28833>>>>>>>            Function _RoundNumber Number nValue Integer iDecimals Returns Number
28835>>>>>>>                String sValue
28835>>>>>>>                Get NumberToString of oStringFunctions nValue iDecimals to sValue
28836>>>>>>>                Function_Return (Number(sValue))
28837>>>>>>>            End_Function
28838>>>>>>>
28838>>>>>>>// Number functions
28838>>>>>>>
28838>>>>>>>        Function _fRound tXPValue[] aParameters Returns tXPValue
28840>>>>>>>            Integer iDecimal
28840>>>>>>>            Number nValue
28840>>>>>>>            tXPValue strRval strParam
28840>>>>>>>            tXPValue strRval strParam
28840>>>>>>>            Move aParameters[0] to strParam
28841>>>>>>>            If (strParam.iValueType=XP_Integer or strParam.iValueType=XP_Numeric) Begin
28843>>>>>>>                Move strParam.sValue to nValue
28844>>>>>>>                Move aParameters[1] to strParam
28845>>>>>>>                If (strParam.iValueType=XP_Integer) Begin
28847>>>>>>>                    Get _RoundNumber nValue iDecimal to strRval.sValue
28848>>>>>>>                    Move XP_Numeric to strRval.iValueType
28849>>>>>>>                End
28849>>>>>>>>
28849>>>>>>>                Else Begin
28850>>>>>>>                    Move XP_Error to strRval.iValueType
28851>>>>>>>                    Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'Round'"
28852>>>>>>>>
28852>>>>>>>                End
28852>>>>>>>>
28852>>>>>>>            End
28852>>>>>>>>
28852>>>>>>>            Else Begin
28853>>>>>>>                Move XP_Error to strRval.iValueType
28854>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'Round'"
28855>>>>>>>>
28855>>>>>>>            End
28855>>>>>>>>
28855>>>>>>>            Function_Return strRval
28856>>>>>>>        End_Function
28857>>>>>>>
28857>>>>>>>// Date functions
28857>>>>>>>
28857>>>>>>>        Function _fToday tXPValue[] aParameters Returns tXPValue // No params
28859>>>>>>>            tXPValue strValue
28859>>>>>>>            tXPValue strValue
28859>>>>>>>            Move (Integer(SystemDate(oDateFunctions))) to strValue.sValue
28860>>>>>>>            Move XP_Date to strValue.iValueType
28861>>>>>>>            Function_Return strValue
28862>>>>>>>        End_Function
28863>>>>>>>
28863>>>>>>>        Function _fDateSegment tXPValue[] aParameters Integer iDateSegment Returns tXPValue
28865>>>>>>>            Date dValue
28865>>>>>>>            tXPValue strParam strRval
28865>>>>>>>            tXPValue strParam strRval
28865>>>>>>>            Move aParameters[0] to strParam
28866>>>>>>>            If (strParam.iValueType=XP_Date) Begin
28868>>>>>>>                Move strParam.sValue to dValue
28869>>>>>>>                Get DateSegment of oDateFunctions dValue iDateSegment to strRval.sValue
28870>>>>>>>                Move XP_Integer to strRval.iValueType
28871>>>>>>>            End
28871>>>>>>>>
28871>>>>>>>            Else Begin
28872>>>>>>>                Move XP_Error to strRval.iValueType
28873>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'DateSegment'"
28874>>>>>>>>
28874>>>>>>>            End
28874>>>>>>>>
28874>>>>>>>            Function_Return strRval
28875>>>>>>>        End_Function
28876>>>>>>>
28876>>>>>>>        Function _fMonth tXPValue[] aParameters Returns tXPValue
28878>>>>>>>            Function_Return (_fDateSegment(Self,aParameters,DS_MONTH))
28879>>>>>>>        End_Function
28880>>>>>>>        Function _fWeek tXPValue[] aParameters Returns tXPValue
28882>>>>>>>            Function_Return (_fDateSegment(Self,aParameters,DS_WEEK))
28883>>>>>>>        End_Function
28884>>>>>>>        Function _fYear tXPValue[] aParameters Returns tXPValue
28886>>>>>>>            Function_Return (_fDateSegment(Self,aParameters,DS_YEAR))
28887>>>>>>>        End_Function
28888>>>>>>>        Function _fDay tXPValue[] aParameters Returns tXPValue
28890>>>>>>>            Function_Return (_fDateSegment(Self,aParameters,DS_DAY))
28891>>>>>>>        End_Function
28892>>>>>>>        Function _fDayName tXPValue[] aParameters Returns tXPValue
28894>>>>>>>            Integer iIndex
28894>>>>>>>            tXPValue strParam strRval
28894>>>>>>>            tXPValue strParam strRval
28894>>>>>>>            Move aParameters[0] to strParam
28895>>>>>>>            If (strParam.iValueType=XP_Integer) Begin
28897>>>>>>>                Move strParam.sValue to iIndex
28898>>>>>>>                Get DayName of oDateFunctions iIndex to strRval.sValue
28899>>>>>>>                Move XP_String to strRval.iValueType
28900>>>>>>>            End
28900>>>>>>>>
28900>>>>>>>            Else Begin
28901>>>>>>>                Move XP_Error to strRval.iValueType
28902>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'DayName'"
28903>>>>>>>>
28903>>>>>>>            End
28903>>>>>>>>
28903>>>>>>>            Function_Return strRval
28904>>>>>>>        End_Function
28905>>>>>>>        Function _fMonthName tXPValue[] aParameters Returns tXPValue
28907>>>>>>>            Integer iIndex
28907>>>>>>>            tXPValue strParam strRval
28907>>>>>>>            tXPValue strParam strRval
28907>>>>>>>            Move aParameters[0] to strParam
28908>>>>>>>            If (strParam.iValueType=XP_Integer) Begin
28910>>>>>>>                Move strParam.sValue to iIndex
28911>>>>>>>                Get MonthName of oDateFunctions iIndex to strRval.sValue
28912>>>>>>>                Move XP_String to strRval.iValueType
28913>>>>>>>            End
28913>>>>>>>>
28913>>>>>>>            Else Begin
28914>>>>>>>                Move XP_Error to strRval.iValueType
28915>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'MonthName'"
28916>>>>>>>>
28916>>>>>>>            End
28916>>>>>>>>
28916>>>>>>>            Function_Return strRval
28917>>>>>>>        End_Function
28918>>>>>>>
28918>>>>>>>// Operators
28918>>>>>>>        Function _fExponential tXPValue[] aParameters Returns tXPValue
28920>>>>>>>            tXPValue strValue
28920>>>>>>>            tXPValue strValue
28920>>>>>>>            Number nBase nPower
28920>>>>>>>            Get StringToNumber of oStringFunctions aParameters[0].sValue to nBase
28921>>>>>>>            Get StringToNumber of oStringFunctions aParameters[1].sValue to nPower
28922>>>>>>>            Move (nBase^nPower) to strValue.sValue
28923>>>>>>>            Move XP_Numeric to strValue.iValueType
28924>>>>>>>            Function_Return strValue
28925>>>>>>>        End_Function
28926>>>>>>>        
28926>>>>>>>        Function _fUnaryMinus tXPValue[] aParameters Returns tXPValue
28928>>>>>>>            tXPValue strValue
28928>>>>>>>            tXPValue strValue
28928>>>>>>>            Number nValue
28928>>>>>>>            Get StringToNumber of oStringFunctions aParameters[0].sValue to nValue
28929>>>>>>>            Move (-nValue) to strValue.sValue
28930>>>>>>>            Move XP_Numeric to strValue.iValueType
28931>>>>>>>            Function_Return strValue
28932>>>>>>>        End_Function
28933>>>>>>>        
28933>>>>>>>        Function _fUnaryPlus tXPValue[] aParameters Returns tXPValue
28935>>>>>>>            Function_Return aParameters[0]
28936>>>>>>>        End_Function
28937>>>>>>>        
28937>>>>>>>        Function _fMultiply tXPValue[] aParameters Returns tXPValue
28939>>>>>>>            tXPValue strVal1 strVal2
28939>>>>>>>            tXPValue strVal1 strVal2
28939>>>>>>>            tXPValue strRval
28939>>>>>>>            tXPValue strRval
28939>>>>>>>            Move aParameters[0] to strVal1
28940>>>>>>>            Move aParameters[1] to strVal2
28941>>>>>>>            If (strVal1.iValueType=XP_Integer or strVal1.iValueType=XP_Numeric or strVal1.iValueType=XP_Boolean) Begin
28943>>>>>>>                Move (StringToNumber(oStringFunctions,strVal1.sValue)*StringToNumber(oStringFunctions,strVal2.sValue)) to strRval.sValue
28944>>>>>>>                Move (If(strVal1.iValueType=XP_Integer and strVal2.iValueType=XP_Integer,XP_Integer,XP_Numeric)) to strRval.iValueType
28945>>>>>>>                If (strRval.iValueType=XP_Integer) Begin
28947>>>>>>>                    Move (Integer(strRval.sValue)) to strRval.sValue
28948>>>>>>>                End
28948>>>>>>>>
28948>>>>>>>            End
28948>>>>>>>>
28948>>>>>>>            Else If (strVal1.iValueType=XP_String) Begin
28951>>>>>>>                Move (strVal1.sValue*strVal2.sValue) to strRval.sValue
28952>>>>>>>                Move XP_String to strRval.iValueType
28953>>>>>>>            End
28953>>>>>>>>
28953>>>>>>>            Else Begin
28954>>>>>>>                Move XP_Error to strRval.iValueType
28955>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to '*' (multiply)"
28956>>>>>>>>
28956>>>>>>>            End
28956>>>>>>>>
28956>>>>>>>            Function_Return strRval
28957>>>>>>>        End_Function
28958>>>>>>>        
28958>>>>>>>        Function _fDivide tXPValue[] aParameters Returns tXPValue
28960>>>>>>>            tXPValue strVal1 strVal2
28960>>>>>>>            tXPValue strVal1 strVal2
28960>>>>>>>            tXPValue strRval
28960>>>>>>>            tXPValue strRval
28960>>>>>>>            Move aParameters[0] to strVal1
28961>>>>>>>            Move aParameters[1] to strVal2
28962>>>>>>>            If (strVal1.iValueType=XP_Integer or strVal1.iValueType=XP_Numeric or strVal1.iValueType=XP_Boolean) Begin
28964>>>>>>>                Move (Number(strVal1.sValue)/Number(strVal2.sValue)) to strRval.sValue
28965>>>>>>>                Move (If(strVal1.iValueType=XP_Integer and strVal2.iValueType=XP_Integer,XP_Integer,XP_Numeric)) to strRval.iValueType
28966>>>>>>>                If (strRval.iValueType=XP_Integer) Begin
28968>>>>>>>                    Move (Integer(strRval.sValue)) to strRval.sValue
28969>>>>>>>                End
28969>>>>>>>>
28969>>>>>>>            End
28969>>>>>>>>
28969>>>>>>>            Else If (strVal1.iValueType=XP_String) Begin
28972>>>>>>>                Move (strVal1.sValue-strVal2.sValue) to strRval.sValue
28973>>>>>>>                Move XP_String to strRval.iValueType
28974>>>>>>>            End
28974>>>>>>>>
28974>>>>>>>            Else Begin
28975>>>>>>>                Move XP_Error to strRval.iValueType
28976>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to '/' (divide)"
28977>>>>>>>>
28977>>>>>>>            End
28977>>>>>>>>
28977>>>>>>>            Function_Return strRval
28978>>>>>>>        End_Function
28979>>>>>>>        
28979>>>>>>>        Function _fRemainder tXPValue[] aParameters Returns tXPValue
28981>>>>>>>            tXPValue strVal1 strVal2
28981>>>>>>>            tXPValue strVal1 strVal2
28981>>>>>>>            tXPValue strRval
28981>>>>>>>            tXPValue strRval
28981>>>>>>>            Move aParameters[0] to strVal1
28982>>>>>>>            Move aParameters[1] to strVal2
28983>>>>>>>            If (strVal1.iValueType=XP_Integer or strVal1.iValueType=XP_Numeric) Begin
28985>>>>>>>                Move (Mod(Integer(strVal1.sValue),Integer(strVal2.sValue))) to strRval.sValue
28986>>>>>>>                Move XP_Integer to strRval.iValueType
28987>>>>>>>            End
28987>>>>>>>>
28987>>>>>>>            Else Begin
28988>>>>>>>                Move XP_Error to strRval.iValueType
28989>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to '%' (remainder)"
28990>>>>>>>>
28990>>>>>>>            End
28990>>>>>>>>
28990>>>>>>>            Function_Return strRval
28991>>>>>>>        End_Function
28992>>>>>>>        
28992>>>>>>>        Function _fPlus tXPValue[] aParameters Returns tXPValue
28994>>>>>>>            tXPValue strVal1 strVal2
28994>>>>>>>            tXPValue strVal1 strVal2
28994>>>>>>>            tXPValue strRval
28994>>>>>>>            tXPValue strRval
28994>>>>>>>            Move aParameters[0] to strVal1
28995>>>>>>>            Move aParameters[1] to strVal2
28996>>>>>>>            If (strVal1.iValueType=XP_Integer or strVal1.iValueType=XP_Numeric) Begin
28998>>>>>>>                Move (Number(strVal1.sValue)+Number(strVal2.sValue)) to strRval.sValue
28999>>>>>>>                Move (If(strVal1.iValueType=XP_Integer and strVal2.iValueType=XP_Integer,XP_Integer,XP_Numeric)) to strRval.iValueType
29000>>>>>>>                If (strRval.iValueType=XP_Integer) Begin
29002>>>>>>>                    Move (Integer(strRval.sValue)) to strRval.sValue
29003>>>>>>>                End
29003>>>>>>>>
29003>>>>>>>            End
29003>>>>>>>>
29003>>>>>>>            Else If (strVal1.iValueType=XP_Date) Begin
29006>>>>>>>                Move (Date(Integer(strVal1.sValue)+Integer(strVal2.sValue))) to strRval.sValue
29007>>>>>>>                Move XP_Date to strRval.iValueType
29008>>>>>>>            End
29008>>>>>>>>
29008>>>>>>>            Else If (strVal1.iValueType=XP_String) Begin
29011>>>>>>>                Move (strVal1.sValue+strVal2.sValue) to strRval.sValue
29012>>>>>>>                Move XP_String to strRval.iValueType
29013>>>>>>>            End
29013>>>>>>>>
29013>>>>>>>            Else Begin
29014>>>>>>>                Move XP_Error to strRval.iValueType
29015>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to '+' (plus)"
29016>>>>>>>>
29016>>>>>>>            End
29016>>>>>>>>
29016>>>>>>>            Function_Return strRval
29017>>>>>>>        End_Function
29018>>>>>>>
29018>>>>>>>        Function _fMinus tXPValue[] aParameters Returns tXPValue
29020>>>>>>>            tXPValue strVal1 strVal2
29020>>>>>>>            tXPValue strVal1 strVal2
29020>>>>>>>            tXPValue strRval
29020>>>>>>>            tXPValue strRval
29020>>>>>>>            Move aParameters[0] to strVal1
29021>>>>>>>            Move aParameters[1] to strVal2
29022>>>>>>>            If (strVal1.iValueType=XP_Integer or strVal1.iValueType=XP_Numeric) Begin
29024>>>>>>>                Move (Number(strVal1.sValue)-Number(strVal2.sValue)) to strRval.sValue
29025>>>>>>>                Move (If(strVal1.iValueType=XP_Integer and strVal2.iValueType=XP_Integer,XP_Integer,XP_Numeric)) to strRval.iValueType
29026>>>>>>>                If (strRval.iValueType=XP_Integer) Begin
29028>>>>>>>                    Move (Integer(strRval.sValue)) to strRval.sValue
29029>>>>>>>                End
29029>>>>>>>>
29029>>>>>>>            End
29029>>>>>>>>
29029>>>>>>>            Else If (strVal1.iValueType=XP_Date) Begin
29032>>>>>>>                Move (Date(Integer(strVal1.sValue)+Integer(strVal2.sValue))) to strRval.sValue
29033>>>>>>>                Move XP_Date to strRval.iValueType
29034>>>>>>>            End
29034>>>>>>>>
29034>>>>>>>            Else If (strVal1.iValueType=XP_String) Begin
29037>>>>>>>                Move (strVal1.sValue-strVal2.sValue) to strRval.sValue
29038>>>>>>>                Move XP_String to strRval.iValueType
29039>>>>>>>            End
29039>>>>>>>>
29039>>>>>>>            Else Begin
29040>>>>>>>                Move XP_Error to strRval.iValueType
29041>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to '-' (minus)"
29042>>>>>>>>
29042>>>>>>>            End
29042>>>>>>>>
29042>>>>>>>            Function_Return strRval
29043>>>>>>>        End_Function
29044>>>>>>>
29044>>>>>>>
29044>>>>>>>        Function _fMin tXPValue[] aParameters Returns tXPValue
29046>>>>>>>        End_Function
29047>>>>>>>        
29047>>>>>>>        Function _fMax tXPValue[] aParameters Returns tXPValue
29049>>>>>>>        End_Function
29050>>>>>>>        
29050>>>>>>>        Register_Function _DyadicBooleanOperation tXPValue[] aParameters Integer hFunc Returns tXPValue
29050>>>>>>>
29050>>>>>>>        Function _fGT tXPValue[] aParameters Returns tXPValue
29052>>>>>>>            Function_Return (_DyadicBooleanOperation(Self,aParameters,GT))
29053>>>>>>>        End_Function
29054>>>>>>>        Function _fLT tXPValue[] aParameters Returns tXPValue
29056>>>>>>>            Function_Return (_DyadicBooleanOperation(Self,aParameters,LT))
29057>>>>>>>        End_Function
29058>>>>>>>        Function _fGE tXPValue[] aParameters Returns tXPValue
29060>>>>>>>            Function_Return (_DyadicBooleanOperation(Self,aParameters,GE))
29061>>>>>>>        End_Function
29062>>>>>>>        Function _fLE tXPValue[] aParameters Returns tXPValue
29064>>>>>>>            Function_Return (_DyadicBooleanOperation(Self,aParameters,LE))
29065>>>>>>>        End_Function
29066>>>>>>>        Function _fNE tXPValue[] aParameters Returns tXPValue
29068>>>>>>>            Function_Return (_DyadicBooleanOperation(Self,aParameters,NE))
29069>>>>>>>        End_Function
29070>>>>>>>        Function _fEQ tXPValue[] aParameters Returns tXPValue
29072>>>>>>>            Function_Return (_DyadicBooleanOperation(Self,aParameters,EQ))
29073>>>>>>>        End_Function
29074>>>>>>>        
29074>>>>>>>// String functions
29074>>>>>>>
29074>>>>>>>        Function _fMid tXPValue[] aPar Returns tXPValue // 3 param
29076>>>>>>>            tXPValue strValue
29076>>>>>>>            tXPValue strValue
29076>>>>>>>            Move (Mid(aPar[0].sValue, aPar[1].sValue, aPar[2].sValue)) to strValue.sValue
29077>>>>>>>            Move XP_String to strValue.iValueType
29078>>>>>>>            Function_Return strValue
29079>>>>>>>        End_Function
29080>>>>>>>    
29080>>>>>>>        Function _fLeft tXPValue[] aPar Returns tXPValue // 2 param
29082>>>>>>>            tXPValue strValue
29082>>>>>>>            tXPValue strValue
29082>>>>>>>            Move (Left(aPar[0].sValue, aPar[1].sValue)) to strValue.sValue
29083>>>>>>>            Move XP_String to strValue.iValueType
29084>>>>>>>            Function_Return strValue
29085>>>>>>>        End_Function
29086>>>>>>>    
29086>>>>>>>        Function _fRight tXPValue[] aPar Returns tXPValue // 2 param
29088>>>>>>>            tXPValue strValue
29088>>>>>>>            tXPValue strValue
29088>>>>>>>            Move (Right(aPar[0].sValue, aPar[1].sValue)) to strValue.sValue
29089>>>>>>>            Move XP_String to strValue.iValueType
29090>>>>>>>            Function_Return strValue
29091>>>>>>>        End_Function
29092>>>>>>>    
29092>>>>>>>        Function _fUppercase tXPValue[] aPar Returns tXPValue // 1 param
29094>>>>>>>            tXPValue strValue
29094>>>>>>>            tXPValue strValue
29094>>>>>>>            Move (Uppercase(aPar[0].sValue)) to strValue.sValue
29095>>>>>>>            Move XP_String to strValue.iValueType
29096>>>>>>>            Function_Return strValue
29097>>>>>>>        End_Function
29098>>>>>>>    
29098>>>>>>>        Function _fLowercase tXPValue[] aPar Returns tXPValue // 1 param
29100>>>>>>>            tXPValue strValue
29100>>>>>>>            tXPValue strValue
29100>>>>>>>            Move (Lowercase(aPar[0].sValue)) to strValue.sValue
29101>>>>>>>            Move XP_String to strValue.iValueType
29102>>>>>>>            Function_Return strValue
29103>>>>>>>        End_Function
29104>>>>>>>    
29104>>>>>>>        Function _fLength tXPValue[] aPar Returns tXPValue // 1 param
29106>>>>>>>            tXPValue strValue
29106>>>>>>>            tXPValue strValue
29106>>>>>>>            Move (Length(aPar[0].sValue)) to strValue.sValue
29107>>>>>>>            Move XP_Integer to strValue.iValueType
29108>>>>>>>            Function_Return strValue
29109>>>>>>>        End_Function
29110>>>>>>>    
29110>>>>>>>        Function _fTrim tXPValue[] aPar Returns tXPValue // 1 param
29112>>>>>>>            tXPValue strValue
29112>>>>>>>            tXPValue strValue
29112>>>>>>>            Move (Trim(aPar[0].sValue)) to strValue.sValue
29113>>>>>>>            Move XP_String to strValue.iValueType
29114>>>>>>>            Function_Return strValue
29115>>>>>>>        End_Function
29116>>>>>>>    
29116>>>>>>>        Function _fPos tXPValue[] aPar Returns tXPValue // 2 param
29118>>>>>>>            tXPValue strValue
29118>>>>>>>            tXPValue strValue
29118>>>>>>>            Move (pos(aPar[0].sValue, aPar[1].sValue)) to strValue.sValue
29119>>>>>>>            Move XP_Integer to strValue.iValueType
29120>>>>>>>            Function_Return strValue
29121>>>>>>>        End_Function
29122>>>>>>>
29122>>>>>>>        
29122>>>>>>>            Function _WinningType Integer iTypeLeft Integer iTypeRight Returns Integer
29124>>>>>>>                If (iTypeLeft=XP_String or iTypeRight=XP_String) Function_Return XP_String
29127>>>>>>>                If (iTypeLeft=XP_Numeric or iTypeRight=XP_Numeric) Function_Return XP_Numeric
29130>>>>>>>                If (iTypeLeft=XP_Integer or iTypeRight=XP_Integer) Function_Return XP_Integer
29133>>>>>>>                Function_Return iTypeLeft // ???
29134>>>>>>>            End_Function
29135>>>>>>>        
29135>>>>>>>            Function _DyadicBooleanOperation tXPValue[] aParams Integer iComp Returns tXPValue
29137>>>>>>>                tXPValue strRval strParam1 strParam2
29137>>>>>>>                tXPValue strRval strParam1 strParam2
29137>>>>>>>                Integer iType
29137>>>>>>>                String sLeft sRight
29137>>>>>>>                Number nLeft nRight
29137>>>>>>>                
29137>>>>>>>                Move aParams[0] to strParam1
29138>>>>>>>                Move aParams[1] to strParam2
29139>>>>>>>                If (strParam1.iValueType<>strParam2.iValueType) Begin // Cast them alike:
29141>>>>>>>                    Get _WinningType strParam1.iValueType strParam2.iValueType to iType
29142>>>>>>>                    Get _CastValueAs strParam1 iType to strParam1
29143>>>>>>>                    Get _CastValueAs strParam2 iType to strParam2
29144>>>>>>>                End
29144>>>>>>>>
29144>>>>>>>
29144>>>>>>>                If (strParam1.iValueType=XP_String) Begin
29146>>>>>>>                    Move strParam1.sValue to sLeft
29147>>>>>>>                    Move strParam2.sValue to sRight
29148>>>>>>>                    If (iComp=EQ) Begin
29150>>>>>>>                        Move (sLeft=sRight) to strRval.sValue
29151>>>>>>>                    End
29151>>>>>>>>
29151>>>>>>>                    Else If (iComp=NE) Begin
29154>>>>>>>                        Move (sLeft<>sRight) to strRval.sValue
29155>>>>>>>                    End
29155>>>>>>>>
29155>>>>>>>                    Else If (iComp=GT) Begin
29158>>>>>>>                        Move (sLeft>sRight) to strRval.sValue
29159>>>>>>>                    End
29159>>>>>>>>
29159>>>>>>>                    Else If (iComp=LT) Begin
29162>>>>>>>                        Move (sLeft<sRight) to strRval.sValue
29163>>>>>>>                    End
29163>>>>>>>>
29163>>>>>>>                    Else If (iComp=GE) Begin
29166>>>>>>>                        Move (sLeft>=sRight) to strRval.sValue
29167>>>>>>>                    End
29167>>>>>>>>
29167>>>>>>>                    Else If (iComp=LE) Begin
29170>>>>>>>                        Move (sLeft<=sRight) to strRval.sValue
29171>>>>>>>                    End
29171>>>>>>>>
29171>>>>>>>                End
29171>>>>>>>>
29171>>>>>>>                Else Begin
29172>>>>>>>                    Get StringToNumber of oStringFunctions strParam1.sValue to nLeft
29173>>>>>>>                    Get StringToNumber of oStringFunctions strParam2.sValue to nRight
29174>>>>>>>                    If (iComp=EQ) Begin
29176>>>>>>>                        Move (nLeft=nRight) to strRval.sValue
29177>>>>>>>                    End
29177>>>>>>>>
29177>>>>>>>                    Else If (iComp=NE) Begin
29180>>>>>>>                        Move (nLeft<>nRight) to strRval.sValue
29181>>>>>>>                    End
29181>>>>>>>>
29181>>>>>>>                    Else If (iComp=GT) Begin
29184>>>>>>>                        Move (nLeft>nRight) to strRval.sValue
29185>>>>>>>                    End
29185>>>>>>>>
29185>>>>>>>                    Else If (iComp=LT) Begin
29188>>>>>>>                        Move (nLeft<nRight) to strRval.sValue
29189>>>>>>>                    End
29189>>>>>>>>
29189>>>>>>>                    Else If (iComp=GE) Begin
29192>>>>>>>                        Move (nLeft>=nRight) to strRval.sValue
29193>>>>>>>                    End
29193>>>>>>>>
29193>>>>>>>                    Else If (iComp=LE) Begin
29196>>>>>>>                        Move (nLeft<=nRight) to strRval.sValue
29197>>>>>>>                    End
29197>>>>>>>>
29197>>>>>>>                End
29197>>>>>>>>
29197>>>>>>>                
29197>>>>>>>                Move XP_Boolean to strRval.iValueType
29198>>>>>>>                Function_Return strRval
29199>>>>>>>            End_Function
29200>>>>>>>
29200>>>>>>>    Function _fAnd tXPValue[] aParameters Returns tXPValue
29202>>>>>>>        tXPValue strRval strParameter1 strParameter2
29202>>>>>>>        tXPValue strRval strParameter1 strParameter2
29202>>>>>>>        Number nVal1 nVal2
29202>>>>>>>        Move aParameters[0] to strParameter1
29203>>>>>>>        Move aParameters[1] to strParameter2
29204>>>>>>>        If ((strParameter1.iValueType=XP_Integer or strParameter1.iValueType=XP_Numeric) and (strParameter2.iValueType=XP_Integer or strParameter2.iValueType=XP_Numeric)) Begin
29206>>>>>>>            Move XP_Boolean to strRval.iValueType
29207>>>>>>>            Move strParameter1.sValue to nVal1
29208>>>>>>>            Move strParameter2.sValue to nVal2
29209>>>>>>>            Move (nVal1<>0 and nVal2<>0) to strRval.sValue
29210>>>>>>>        End
29210>>>>>>>>
29210>>>>>>>        Else Begin
29211>>>>>>>            Move XP_Error to strRval.iValueType
29212>>>>>>>            Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'and'"
29213>>>>>>>>
29213>>>>>>>        End
29213>>>>>>>>
29213>>>>>>>        Function_Return strRval
29214>>>>>>>    End_Function
29215>>>>>>>    
29215>>>>>>>    Function _fOr tXPValue[] aParameters Returns tXPValue
29217>>>>>>>        tXPValue strRval strParameter1 strParameter2
29217>>>>>>>        tXPValue strRval strParameter1 strParameter2
29217>>>>>>>        Number nVal1 nVal2
29217>>>>>>>        Move aParameters[0] to strParameter1
29218>>>>>>>        Move aParameters[1] to strParameter2
29219>>>>>>>        If ((strParameter1.iValueType=XP_Integer or strParameter1.iValueType=XP_Numeric) and (strParameter2.iValueType=XP_Integer or strParameter2.iValueType=XP_Numeric)) Begin
29221>>>>>>>            Move XP_Boolean to strRval.iValueType
29222>>>>>>>            Move strParameter1.sValue to nVal1
29223>>>>>>>            Move strParameter2.sValue to nVal2
29224>>>>>>>            Move (nVal1<>0 or nVal2<>0) to strRval.sValue
29225>>>>>>>        End
29225>>>>>>>>
29225>>>>>>>        Else Begin
29226>>>>>>>            Move XP_Error to strRval.iValueType
29227>>>>>>>            Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'or'"
29228>>>>>>>>
29228>>>>>>>        End
29228>>>>>>>>
29228>>>>>>>        Function_Return strRval
29229>>>>>>>    End_Function
29230>>>>>>>    
29230>>>>>>>        Function _fNot tXPValue[] aParameters Returns tXPValue // 1 param
29232>>>>>>>            Number nValue
29232>>>>>>>            tXPValue strParam strRval
29232>>>>>>>            tXPValue strParam strRval
29232>>>>>>>            Move aParameters[0] to strParam
29233>>>>>>>            If (strParam.iValueType=XP_Integer or strParam.iValueType=XP_Numeric or strParam.iValueType=XP_Boolean) Begin
29235>>>>>>>                Move strParam.sValue to nValue
29236>>>>>>>                Move (nValue=0) to strRval.sValue
29237>>>>>>>                Move XP_Boolean to strRval.iValueType
29238>>>>>>>            End
29238>>>>>>>>
29238>>>>>>>            Else Begin
29239>>>>>>>                Move XP_Error to strRval.iValueType
29240>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'not'"
29241>>>>>>>>
29241>>>>>>>            End
29241>>>>>>>>
29241>>>>>>>            Function_Return strRval
29242>>>>>>>        End_Function
29243>>>>>>>
29243>>>>>>>    Function _fSin tXPValue[] aParameters Returns tXPValue
29245>>>>>>>        tXPValue strRval strParameter
29245>>>>>>>        tXPValue strRval strParameter
29245>>>>>>>        Move aParameters[0] to strParameter
29246>>>>>>>        If (strParameter.iValueType=XP_Integer or strParameter.iValueType=XP_Numeric) Begin
29248>>>>>>>            Move XP_Numeric to strRval.iValueType
29249>>>>>>>            Move (Sin(strParameter.sValue)) to strRval.sValue
29250>>>>>>>        End
29250>>>>>>>>
29250>>>>>>>        Else Begin
29251>>>>>>>            Move XP_Error to strRval.iValueType
29252>>>>>>>            Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'sin'"
29253>>>>>>>>
29253>>>>>>>        End
29253>>>>>>>>
29253>>>>>>>        Function_Return strRval
29254>>>>>>>    End_Function
29255>>>>>>>
29255>>>>>>>    Function _fCos tXPValue[] aParameters Returns tXPValue
29257>>>>>>>        tXPValue strRval strParameter
29257>>>>>>>        tXPValue strRval strParameter
29257>>>>>>>        Move aParameters[0] to strParameter
29258>>>>>>>        If (strParameter.iValueType=XP_Integer or strParameter.iValueType=XP_Numeric) Begin
29260>>>>>>>            Move XP_Numeric to strRval.iValueType
29261>>>>>>>            Move (Cos(strParameter.sValue)) to strRval.sValue
29262>>>>>>>        End
29262>>>>>>>>
29262>>>>>>>        Else Begin
29263>>>>>>>            Move XP_Error to strRval.iValueType
29264>>>>>>>            Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'cos'"
29265>>>>>>>>
29265>>>>>>>        End
29265>>>>>>>>
29265>>>>>>>        Function_Return strRval
29266>>>>>>>    End_Function
29267>>>>>>>
29267>>>>>>>    Procedure OnDefineOperators tXPGrammar ByRef strGrammar
29269>>>>>>>        // By insiration from: http://en.cppreference.com/w/cpp/language/operator_precedence
29269>>>>>>>        
29269>>>>>>>// ToDo: Someone ought to take a look at this. It can not be right. The precedense looks suspicious
29269>>>>>>>        Forward Send OnDefineOperators (&strGrammar)
29271>>>>>>>        // Priority 1
29271>>>>>>>        Send DefineOperator (&strGrammar) "^"    2 1 1 (RefFunc(_fExponential))
29272>>>>>>>        // Priority 2
29272>>>>>>>        Send DefineOperator (&strGrammar) "-"    1 2 0 (RefFunc(_fUnaryMinus))
29273>>>>>>>        Send DefineOperator (&strGrammar) "+"    1 2 0 (RefFunc(_fUnaryPlus))
29274>>>>>>>        // Priority 3
29274>>>>>>>        Send DefineOperator (&strGrammar) "*"    2 3 0 (RefFunc(_fMultiply))
29275>>>>>>>        Send DefineOperator (&strGrammar) "/"    2 3 0 (RefFunc(_fDivide))
29276>>>>>>>        Send DefineOperator (&strGrammar) "%"    2 3 0 (RefFunc(_fRemainder))
29277>>>>>>>        // Priority 4        
29277>>>>>>>        Send DefineOperator (&strGrammar) "+"    2 4 0 (RefFunc(_fPlus))
29278>>>>>>>        Send DefineOperator (&strGrammar) "-"    2 4 0 (RefFunc(_fMinus))
29279>>>>>>>        // Priority 6
29279>>>>>>>        Send DefineOperator (&strGrammar) ">"    2 6 0 (RefFunc(_fGT))
29280>>>>>>>        Send DefineOperator (&strGrammar) "<"    2 6 0 (RefFunc(_fLT))
29281>>>>>>>        Send DefineOperator (&strGrammar) ">="   2 6 0 (RefFunc(_fGE))
29282>>>>>>>        Send DefineOperator (&strGrammar) "<="   2 6 0 (RefFunc(_fLE))
29283>>>>>>>        // Priority 7
29283>>>>>>>        Send DefineOperator (&strGrammar) "<>"   2 7 0 (RefFunc(_fNE))
29284>>>>>>>        Send DefineOperator (&strGrammar) "="    2 7 0 (RefFunc(_fEQ))
29285>>>>>>>        // Priority 9
29285>>>>>>>        Send DefineOperator (&strGrammar) "and"  2 9 0 (RefFunc(_fAnd))
29286>>>>>>>        Send DefineOperator (&strGrammar) "or"   2 9 0 (RefFunc(_fOr))
29287>>>>>>>        // Priority ? (I have no idea):
29287>>>>>>>        Send DefineOperator (&strGrammar) "not"  1 0 0 (RefFunc(_fNot))
29288>>>>>>>        Send DefineOperator (&strGrammar) "min"  2 0 0 (RefFunc(_fMin))
29289>>>>>>>        Send DefineOperator (&strGrammar) "max"  2 0 0 (RefFunc(_fMax))
29290>>>>>>>        // Priority nil (they just have to be here)
29290>>>>>>>        Send DefineOperator (&strGrammar) "("   -1 0 0 0 
29291>>>>>>>        Send DefineOperator (&strGrammar) ")"   -1 0 0 0 
29292>>>>>>>        Send DefineOperator (&strGrammar) ","   -1 0 0 0 
29293>>>>>>>//        Send DefineOperator (&strGrammar) "string" 1
29293>>>>>>>//        Send DefineOperator (&strGrammar) "number" 1
29293>>>>>>>//        Send DefineOperator (&strGrammar) "integer" 1
29293>>>>>>>//        Send DefineOperator (&strGrammar) "date" 1
29293>>>>>>>//        Send DefineOperator (&strGrammar) "boolean" 1
29293>>>>>>>    End_Procedure
29294>>>>>>>    
29294>>>>>>>    Procedure OnDefineFunctions tXPGrammar ByRef strGrammar
29296>>>>>>>        Forward Send OnDefineFunctions (&strGrammar)
29298>>>>>>>        Send DefineFunction (&strGrammar) "Round"     1 XP_Numeric (RefFunc(_fRound))
29299>>>>>>>        Send DefineFunction (&strGrammar) "Today"     0 XP_Date    (RefFunc(_fToday))
29300>>>>>>>        Send DefineFunction (&strGrammar) "Month"     1 XP_Integer (RefFunc(_fMonth))
29301>>>>>>>        Send DefineFunction (&strGrammar) "Week"      1 XP_Integer (RefFunc(_fWeek))
29302>>>>>>>        Send DefineFunction (&strGrammar) "Year"      1 XP_Integer (RefFunc(_fYear))
29303>>>>>>>        Send DefineFunction (&strGrammar) "Day"       1 XP_Integer (RefFunc(_fDay))
29304>>>>>>>        Send DefineFunction (&strGrammar) "DayName"   1 XP_String  (RefFunc(_fDayName))
29305>>>>>>>        Send DefineFunction (&strGrammar) "MonthName" 1 XP_String  (RefFunc(_fMonthName))
29306>>>>>>>        Send DefineFunction (&strGrammar) "Sin"       1 XP_Numeric (RefFunc(_fSin))
29307>>>>>>>        Send DefineFunction (&strGrammar) "Cos"       1 XP_Numeric (RefFunc(_fCos))
29308>>>>>>>        Send DefineFunction (&strGrammar) "Mid"       3 XP_String  (RefFunc(_fMid))
29309>>>>>>>        Send DefineFunction (&strGrammar) "Left"      2 XP_String  (RefFunc(_fLeft))
29310>>>>>>>        Send DefineFunction (&strGrammar) "Right"     2 XP_String  (RefFunc(_fRight))
29311>>>>>>>        Send DefineFunction (&strGrammar) "Uppercase" 1 XP_String  (RefFunc(_fUppercase))
29312>>>>>>>        Send DefineFunction (&strGrammar) "Lowercase" 1 XP_String  (RefFunc(_fLowercase))
29313>>>>>>>        Send DefineFunction (&strGrammar) "Length"    1 XP_Integer (RefFunc(_fLength))
29314>>>>>>>        Send DefineFunction (&strGrammar) "Trim"      1 XP_String  (RefFunc(_fTrim))
29315>>>>>>>        Send DefineFunction (&strGrammar) "Pos"       2 XP_Integer (RefFunc(_fPos))
29316>>>>>>>    End_Procedure
29317>>>>>>>    
29317>>>>>>>    Procedure OnDefineConstants tXPGrammar ByRef strGrammar
29319>>>>>>>        Forward Send OnDefineConstants (&strGrammar)
29321>>>>>>>        Send DefineConstant (&strGrammar) "pi" 3.1415926 XP_Numeric
29322>>>>>>>    End_Procedure
29323>>>>>>>
29323>>>>>>>End_Class
29324>>>>>Use TableQueryFunctions.pkg
Including file: TableQueryFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\TableQueryFunctions.pkg)
29324>>>>>>>//> <h1>TableQueryFunctions.pkg</h1>
29324>>>>>>>//>
29324>>>>>>>//> <p>The idea is that you declare a variable of type tTableQuery and tell it what table and what
29324>>>>>>>//> filters you want and what output order you want. TQ then calculates the index to use for the.
29324>>>>>>>//> scan. If it can not find an index in accordance with the desired output it will collect
29324>>>>>>>//> all the sorting information in memory and refind the records in the desired order.
29324>>>>>>>//>
29324>>>>>>>//> If the code happens to be running against an MSSQL backend it will skip all the figuring
29324>>>>>>>//> out and apply embedded SQL to the problem. This gives a potentially huge performance
29324>>>>>>>//> increase at no effort on behalf of the programmer.
29324>>>>>>>//>
29324>>>>>>>//> oTQ is a global object (of class cTableQueryFunctions) that encapsulates a group of
29324>>>>>>>//> functions. Using it to scan all orders in the order table goes like this:</p>
29324>>>>>>>//>
29324>>>>>>>//> <code>
29324>>>>>>>//>     Use TableQueryFunctions.pkg // Define oTableQueryFunctions object
29324>>>>>>>//>
29324>>>>>>>//>     Procedure RunQuery
29324>>>>>>>//>         tTableQuery strQuery // I use the prefix 'str' to signify a struct type variable.
29324>>>>>>>//>
29324>>>>>>>//>         Get NewQuery of oTQ Order.File_Number to strQuery
29324>>>>>>>//>
29324>>>>>>>//>         While (FindRecord(oTQ,&strQuery))
29324>>>>>>>//>             Showln Order.Order_Number
29324>>>>>>>//>         Loop
29324>>>>>>>//>     End_Procedure
29324>>>>>>>//> </code>
29324>>>>>>>//>
29324>>>>>>>//> <p>Note that the strQuery parameter is passed "by reference" to the FindRecord
29324>>>>>>>//> function. That variable maintains the complete state of the scan and it is
29324>>>>>>>//> modified for each iteration. The table query object itself is stateless.
29324>>>>>>>//>
29324>>>>>>>//> For every loop of the FindRecord function the record buffer of the order
29324>>>>>>>//> table will be active with the record found. If you are planning on modifying or
29324>>>>>>>//> deleting these rows you should force a "prefetch" of the rows by inserting</p>
29324>>>>>>>//>
29324>>>>>>>//> <code>
29324>>>>>>>//>     Send ForcePrefetch of oTQ (&strQuery)
29324>>>>>>>//> </code>
29324>>>>>>>//>
29324>>>>>>>//> right after the "Get NewQuery..." line. Transparantly to the FindRecord loop this
29324>>>>>>>//> will find all the rows in advance and store their rowid's in an array. Only
29324>>>>>>>//> then will it start looping through the array finding each record (again) by its rowid.
29324>>>>>>>//>
29324>>>>>>>//>
29324>>>>>>>//> Not having to constantly write 'of oTQ' the code becomes easier to
29324>>>>>>>//> read and therefore this form will be used from here on. But in real life, always
29324>>>>>>>//> use the oTQ object.
29324>>>>>>>//>
29324>>>>>>>//>
29324>>>>>>>//> Now let us say that we wanted (1) all invoices for a particular customer that was (2)
29324>>>>>>>//> payed after a given date. Furthermore this Invoice table has a column called Country
29324>>>>>>>//> and (3) we only want invoices for a subset of countries. And the records should be
29324>>>>>>>//> ordered by the amount on the order, highest amount first (4).
29324>>>>>>>//>
29324>>>>>>>//> <code>
29324>>>>>>>//>     Object oMyQuery is a cTableQueryFunctions
29324>>>>>>>//>         Procedure RunQuery
29324>>>>>>>//>             String[] aCountries
29324>>>>>>>//>             tTableQuery strQuery
29324>>>>>>>//>
29324>>>>>>>//>             Get ListOfCountries to aCountries // Arbitrary list. It's an array of strings. That's what's important.
29324>>>>>>>//>
29324>>>>>>>//>             Get NewQuery Invoice.File_Number to strQuery
29324>>>>>>>//>             Send AddFilterRelate (&strQuery) Customer.File_Number // 1
29324>>>>>>>//>             Send AddFilter (&strQuery) File_Field Invoice.Payed_Date tqGT dSomeDate // 2
29324>>>>>>>//>             Send AddFilterOrlist (&strQuery) File_Field Invoice.Country aCountries // 3 (must be a string array no matter the column data type)
29324>>>>>>>//>
29324>>>>>>>//>             // And we also want it to be ordered backwards by the order total:
29324>>>>>>>//>             Send AddOrderBy (&strQuery) File_Field Invoice.Total True False // 4 (bDescending=True bUppercase=False)
29324>>>>>>>//>             // (add more ordering segments)
29324>>>>>>>//>
29324>>>>>>>//>             While (FindRecord(Self,&strQuery))
29324>>>>>>>//>                 Showln Invoice.Invoice_Number " " Invoice.Total
29324>>>>>>>//>             Loop
29324>>>>>>>//>         End_Procedure
29324>>>>>>>//>     End_Object
29324>>>>>>>//> </code>
29324>>>>>>>//>
29324>>>>>>>//> If you look at filter (2) in the example above you can see that the ">"-comperator is represented by
29324>>>>>>>//> a tqGT symbol. Other comperators that may be used are:
29324>>>>>>>//>
29324>>>>>>>//>              tqLT, tqLE, tqEQ, tqGE, tqGT
29324>>>>>>>//>
29324>>>>>>>//> end then there are these special ones intended for string evaluation and which cannot be used
29324>>>>>>>//> for search optimization:
29324>>>>>>>//>
29324>>>>>>>//>              tqNE, tqMATCH, tqUCMATCH
29324>>>>>>>//>
29324>>>>>>>//> Well, tqNE is not just for string evaluation.
29324>>>>>>>//>  
29324>>>>>>>//>
29324>>>>>>>//> You can run nested queries like this:
29324>>>>>>>//>
29324>>>>>>>//> <code>
29324>>>>>>>//>     Object oMyQuery is a cTableQueryFunctions
29324>>>>>>>//>         Procedure RunQuery
29324>>>>>>>//>             tTableQuery strOrderQ strOrderLineQ
29324>>>>>>>//>
29324>>>>>>>//>             Get NewQuery Order.File_Number to strOrderQ
29324>>>>>>>//>
29324>>>>>>>//>             While (FindRecord(Self,&strOrderQ)) // <-- Go through all orders
29324>>>>>>>//>                 Get NewQuery OrderLine.File_Number to strOrderLineQ
29324>>>>>>>//>                 Send AddFilterRelate (&strOrderLineQ) Order.File_Number
29324>>>>>>>//>
29324>>>>>>>//>                 While (FindRecord(Self,&strOrderLineQ)) // <-- Go through all lines on active order
29324>>>>>>>//>                     // Something
29324>>>>>>>//>                 Loop
29324>>>>>>>//>             Loop
29324>>>>>>>//>         End_Procedure
29324>>>>>>>//>     End_Object
29324>>>>>>>//> </code>
29324>>>>>>>//>
29324>>>>>>>//> If you have a 2 level scan like above, you can save execution time by creating
29324>>>>>>>//> the sub-query only once and then call ReUse to reinitialise it.
29324>>>>>>>//>
29324>>>>>>>//> With the ReUse method you can skip the repeated compilation (of the inner query):
29324>>>>>>>//>
29324>>>>>>>//> <code>
29324>>>>>>>//>     Object oMyQuery is a cTableQueryFunctions
29324>>>>>>>//>         Procedure RunQuery
29324>>>>>>>//>             Open Order
29324>>>>>>>//>             Open OrderLin
29324>>>>>>>//>             tTableQuery strOrderQ strOrderlineQ
29324>>>>>>>//>             Get NewQuery Order.file_number to strOrderQ
29324>>>>>>>//>             Get NewQuery OrderLin.file_number to strOrderlineQ
29324>>>>>>>//>             Send AddFilterRelate (&strOrderlineQ) Order.file_number
29324>>>>>>>//>
29324>>>>>>>//>             While (FindRecord(Self,&strOrderQ))
29324>>>>>>>//>                 Send ReUse (&strOrderlineQ) // Only "compile" once
29324>>>>>>>//>                 While (FindRecord(Self,&strOrderlineQ))
29324>>>>>>>//>                 Loop
29324>>>>>>>//>             Loop
29324>>>>>>>//>         End_Procedure
29324>>>>>>>//>     End_Object
29324>>>>>>>//> </code>
29324>>>>>>>//>
29324>>>>>>>//> You may use the .iLimit member of the tTableQuery value to limit
29324>>>>>>>//> the number of rows returned:
29324>>>>>>>//>
29324>>>>>>>//> <code>
29324>>>>>>>//>     Send SetLimit (&strQuery) 50
29324>>>>>>>//> </code>
29324>>>>>>>//>
29324>>>>>>>//> And finally, to quickly find out if a query will return any rows at all
29324>>>>>>>//> you can call function HasData:
29324>>>>>>>//>
29324>>>>>>>//> <code>
29324>>>>>>>//>     Get HasData strQuery to bContinue // Note that strQuery for once is _not_ byref'ed.
29324>>>>>>>//> </code>
29324>>>>>>>//>
29324>>>>>>>//> Calling HasData could be a lot faster than setting iLimit to 1 since the latter
29324>>>>>>>//> strategy may still force the query machine into generating the whole result-set and
29324>>>>>>>//> sort it some way in order to find out which record is actually the first. Calling
29324>>>>>>>//> HasData does not do that.
29324>>>>>>>//>
29324>>>>>>>//> If the table that you are table querying is an SQL table and it has been "opened as", TableQuery
29324>>>>>>>//> has no way of knowing what table name to use in the select statement. If you prepare the
29324>>>>>>>//> query with this line:
29324>>>>>>>//>
29324>>>>>>>//> <code>
29324>>>>>>>//>     Send ForceSQLTableName (&strQuery) "Customer"
29324>>>>>>>//> </code>
29324>>>>>>>//>
29324>>>>>>>//> that name will be used in the ESQL select statement and you'll be fine.
29324>>>>>>>//>
29324>>>>>>>//> A note on the source code in this package:
29324>>>>>>>//>
29324>>>>>>>//> An "_" character in the beginning of a name indicates that the procedure, property or whatever is
29324>>>>>>>//> meant to be used internally by this package only.
29324>>>>>>>//>
29324>>>>>>>//> Variable names are prefixed by s if string, b if boolean asf. Struct type variables are prefixed
29324>>>>>>>//> 'str' which should make one think 'struct' (not 'string').
29324>>>>>>>//>
29324>>>>>>>//> In order to test the function of TableQueryFunctions.pkg without actually programming you may
29324>>>>>>>//> download VDFXray (a multi-purpose VDF utility) from this address:
29324>>>>>>>//>
29324>>>>>>>//>             ftp.stureaps.dk/software/visualdataflex/vdfxray/
29324>>>>>>>//>
29324>>>>>>>//> Use VDFXray to open a workspace, select a table in the tables list. Right click and select
29324>>>>>>>//> "TableQuery Engine Inspector".
29324>>>>>>>//>
29324>>>>>>>//> You'll notice two panels appearing with the "TableQuery test facility" panel on top. If
29324>>>>>>>//> your screen is large enough try to position that panel so that you can see the list of
29324>>>>>>>//> columns in the panel behind it. If necessary by dragging the second panel partly off
29324>>>>>>>//> screen. You'll see the selection of that list changes as you specify columns to filter by.
29324>>>>>>>
29324>>>>>>>//> pkg.doc.end
29324>>>>>>>
29324>>>>>>>
29324>>>>>>>// DAW packages:
29324>>>>>>>Use VdfBase.pkg
29324>>>>>>>Use cli.pkg
Including file: cli.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\cli.pkg)
29324>>>>>>>>>//*****************************************************************************
29324>>>>>>>>>//*** CLI.PKG                                                               ***
29324>>>>>>>>>//***                                                                       ***
29324>>>>>>>>>//*** Author: Ben Weijers                                                   ***
29324>>>>>>>>>//***         Data Access Nederland                                         ***
29324>>>>>>>>>//***         10 September 1998                                             ***
29324>>>>>>>>>//***                                                                       ***
29324>>>>>>>>>//*** Purpose:                                                              ***
29324>>>>>>>>>//***   CLI specific functionality. There are several connectivity kits     ***
29324>>>>>>>>>//***   based on  SQL/92 CLI. Those are:                                    ***
29324>>>>>>>>>//***    - ODBC_DRV  The Data Access CK for ODBC                            ***
29324>>>>>>>>>//***    - DB2_DRV   The Data Access CK for DB2                             ***
29324>>>>>>>>>//***    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            ***
29324>>>>>>>>>//***                                                                       ***
29324>>>>>>>>>//***   This package defines the common functionality for all CLI based     ***
29324>>>>>>>>>//***   drivers.                                                            ***
29324>>>>>>>>>//***                                                                       ***
29324>>>>>>>>>//***   Updated:  May 23rd 2008 (Current CK build: 5.0.0.53 )               ***
29324>>>>>>>>>//***             Added NULLABLE and DEFAULT attributes for DATETIME type   ***
29324>>>>>>>>>//***   Updated:  Apr  6th 2009 (Current CK build: 5.0.0.61 )               ***
29324>>>>>>>>>//***             Added DF_DRIVER_MATCH_CLIENT_SERVER_VERSION attribute     ***
29324>>>>>>>>>//***                   DF_DRIVER_SQLSERVER_CLIENT_VERSION    attribute     ***
29324>>>>>>>>>//***   Updated:  Mar 30th 2012 (Current CK build: 5.1.0.93 )               ***
29324>>>>>>>>>//***             Added SQLSERVER2012CLIENT return value for                ***
29324>>>>>>>>>//***             DF_DRIVER_SQLSERVER_CLIENT_VERSION attribute              ***
29324>>>>>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
29324>>>>>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
29324>>>>>>>>>//***             mssqldrv.pkg                                              ***
29324>>>>>>>>>//***   Updated:  april 23, 2013 (Current CK build: 6.0.0.4)                ***
29324>>>>>>>>>//***             Added type mappings attributes                            ***
29324>>>>>>>>>//*****************************************************************************
29324>>>>>>>>>
29324>>>>>>>>>//*** We are not using ifndef below because that is not supported in Character Mode
29324>>>>>>>>>//*** Driver attributes
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>//------------------------------------------------------------
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>//-------------------------------------
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>//*** Replacement for logical column number that indicates all columns
29324>>>>>>>>>
29324>>>>>>>>>//*** Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
29324>>>>>>>>>
29324>>>>>>>>>//*** Possible DF_FIELD_READ_ONLY values
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>//*** Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
29324>>>>>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK5        1       
29324>>>>>>>>>// #Replace MAP_DF_TO_SQL_TYPE_CK6        2   
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>// Moved to Mssqldrv.pkg
29324>>>>>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
29324>>>>>>>>>//#REPLACE SQLSERVERUNKNOWNCLIENT  0
29324>>>>>>>>>//#REPLACE SQLSERVER2000CLIENT     8          //   "SQL Server"
29324>>>>>>>>>//#REPLACE SQLSERVER2005CLIENT     9          //   "SQL Native Client"
29324>>>>>>>>>//#REPLACE SQLSERVER2008CLIENT    10          //   "SQL Server Native Client 10.0"
29324>>>>>>>>>//#Replace SQLSERVER2012CLIENT    11          //   "SQL Server Native Client 11.0"
29324>>>>>>>>>
29324>>>>>>>>>//*** Possible SQL Column type values
29324>>>>>>>>>Define SQL_UNKNOWN_TYPE   For    0
29324>>>>>>>>>Define SQL_CHAR           For    1
29324>>>>>>>>>Define SQL_NUMERIC        For    2
29324>>>>>>>>>Define SQL_DECIMAL        For    3
29324>>>>>>>>>Define SQL_INTEGER        For    4
29324>>>>>>>>>Define SQL_SMALLINT       For    5
29324>>>>>>>>>Define SQL_FLOAT          For    6
29324>>>>>>>>>Define SQL_REAL           For    7
29324>>>>>>>>>Define SQL_DOUBLE         For    8
29324>>>>>>>>>Define SQL_DATETIME       For    9
29324>>>>>>>>>Define SQL_VARCHAR        For   12
29324>>>>>>>>>Define SQL_TYPE_DATE      For   91
29324>>>>>>>>>Define SQL_TYPE_TIME      For   92
29324>>>>>>>>>Define SQL_TYPE_TIMESTAMP for   93
29324>>>>>>>>>// Moved to mssqldrv.pkg
29324>>>>>>>>>//Define SQL_TYPE_TIMESTAMP2 for   (-200) //SQL server datetime2 type */
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>Define SQL_DATE           For    9
29324>>>>>>>>>Define SQL_INTERVAL       For   10
29324>>>>>>>>>Define SQL_TIME           For   10
29324>>>>>>>>>Define SQL_TIMESTAMP      For   11
29324>>>>>>>>>Define SQL_LONGVARCHAR    For  (-1)
29324>>>>>>>>>Define SQL_BINARY         For  (-2)
29324>>>>>>>>>Define SQL_VARBINARY      For  (-3)
29324>>>>>>>>>Define SQL_LONGVARBINARY  For  (-4)
29324>>>>>>>>>Define SQL_BIGINT         For  (-5)
29324>>>>>>>>>Define SQL_TINYINT        For  (-6)
29324>>>>>>>>>Define SQL_BIT            For  (-7)
29324>>>>>>>>>Define SQL_WCHAR          For  (-8)
29324>>>>>>>>>Define SQL_WVARCHAR       For  (-9)
29324>>>>>>>>>Define SQL_WLONGVARCHAR   For (-10)
29324>>>>>>>>>Define SQL_GUID           For (-11)
29324>>>>>>>>>
29324>>>>>>>>>//*** Driver level attributes
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>//*** Error number constants
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>//*** Call driver function identifiers
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>//*** Init data source types
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>//*** Dummy strings used in the commands
29324>>>>>>>>>    String  CLI$StrDummy 255
29324>>>>>>>>>    Integer CLI$IntDummy
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>//*****************************************************************************
29324>>>>>>>>>//*** CLI_SetConstraint <FileNum> <NewState>                                ***
29324>>>>>>>>>//***                                                                       ***
29324>>>>>>>>>//***   Setup a constraint for a file.                                      ***
29324>>>>>>>>>//*****************************************************************************
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>//*****************************************************************************
29324>>>>>>>>>//*** CLI_Set_Driver_Atrtribute / CLI_Get_Driver_Attribute                  ***
29324>>>>>>>>>//***                                                                       ***
29324>>>>>>>>>//*** Set or get an attribute at driver level. These attributes, when set,  ***
29324>>>>>>>>>//*** will be set for the remainder of the session or until set again. To   ***
29324>>>>>>>>>//*** permanently set driver level attributes change the driver             ***
29324>>>>>>>>>//*** configuration file.                                                   ***
29324>>>>>>>>>//*****************************************************************************
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>
29324>>>>>>>>>//*****************************************************************************
29324>>>>>>>>>//*** Class  : cCLIHandler                                                  ***
29324>>>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
29324>>>>>>>>>//***          call several CLI releated methods.                           ***
29324>>>>>>>>>//*****************************************************************************
29324>>>>>>>>>
29324>>>>>>>>>Class cCLIHandler Is An Array
29325>>>>>>>>>
29325>>>>>>>>>    Procedure Construct_Object Integer iImage
29327>>>>>>>>>        Forward Send Construct_object iImage
29329>>>>>>>>>
29329>>>>>>>>>        Property String  psDriverID       Public ""
29330>>>>>>>>>    End_Procedure // Construct_Object
29331>>>>>>>>>
29331>>>>>>>>>
29331>>>>>>>>>
29331>>>>>>>>>    //***
29331>>>>>>>>>    //*** Fucntion: CKRevsion
29331>>>>>>>>>    //*** Purpose : The revsion of a CLI Connectivity Kit
29331>>>>>>>>>    //***
29331>>>>>>>>>
29331>>>>>>>>>    Function CKRevision Returns String
29333>>>>>>>>>        Local String  sDriverID
29333>>>>>>>>>        Local String  sRevision
29333>>>>>>>>>        Local String  sVoid
29333>>>>>>>>>        Local Integer iRetval
29333>>>>>>>>>
29333>>>>>>>>>        Get psDriverID To sDriverID
29334>>>>>>>>>        If (sDRiverID <> "") Begin
29336>>>>>>>>>            Move (Repeat(" ", 255)) To sRevision
29337>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
29342>>>>>>>>>        End
29342>>>>>>>>>>
29342>>>>>>>>>
29342>>>>>>>>>        Function_Return sRevision
29343>>>>>>>>>    End_Function // CKRevision
29344>>>>>>>>>
29344>>>>>>>>>
29344>>>>>>>>>
29344>>>>>>>>>    //***
29344>>>>>>>>>    //*** Function: ExtractPartFromRevision
29344>>>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
29344>>>>>>>>>    //***
29344>>>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
29344>>>>>>>>>    //***
29344>>>>>>>>>
29344>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
29346>>>>>>>>>        Local Integer iPartRev
29346>>>>>>>>>        Local Integer iCurrentPart
29346>>>>>>>>>        Local Integer iSeparatorPos
29346>>>>>>>>>
29346>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
29349>>>>>>>>>
29349>>>>>>>>>        Move 0 To iCurrentPart
29350>>>>>>>>>        Repeat
29350>>>>>>>>>>
29350>>>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
29351>>>>>>>>>            If (iSeparatorPos > 0) Begin
29353>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
29354>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
29355>>>>>>>>>                Increment iCurrentPart
29356>>>>>>>>>            End
29356>>>>>>>>>>
29356>>>>>>>>>            Else If (sRevision <> "") Begin
29359>>>>>>>>>                Move sRevision To iPartRev
29360>>>>>>>>>                Move "" To sRevision
29361>>>>>>>>>                Increment iCurrentPart
29362>>>>>>>>>            End
29362>>>>>>>>>>
29362>>>>>>>>>            Else ;                Move -1 To iPartRev
29364>>>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
29366>>>>>>>>>
29366>>>>>>>>>        Function_Return iPartRev
29367>>>>>>>>>    End_Function // EcxtractPartFromRevision
29368>>>>>>>>>
29368>>>>>>>>>
29368>>>>>>>>>
29368>>>>>>>>>    //***
29368>>>>>>>>>    //*** Function: CKMajorRevision
29368>>>>>>>>>    //*** Purpose : Returns the major revision of the CK
29368>>>>>>>>>    //***
29368>>>>>>>>>
29368>>>>>>>>>    Function CKMajorRevision Returns Integer
29370>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
29371>>>>>>>>>    End_Function // CKMajorRevision
29372>>>>>>>>>
29372>>>>>>>>>
29372>>>>>>>>>
29372>>>>>>>>>    //***
29372>>>>>>>>>    //*** Function: CKMinorRevision
29372>>>>>>>>>    //*** Purpose : Returns the minor revision of the CK
29372>>>>>>>>>    //***
29372>>>>>>>>>
29372>>>>>>>>>    Function CKMinorRevision Returns Integer
29374>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
29375>>>>>>>>>    End_Function // CKMinorRevision
29376>>>>>>>>>
29376>>>>>>>>>
29376>>>>>>>>>
29376>>>>>>>>>    //***
29376>>>>>>>>>    //*** Function: CKReleaseRevision
29376>>>>>>>>>    //*** Purpose : Returns the release revision of the CK
29376>>>>>>>>>    //***
29376>>>>>>>>>
29376>>>>>>>>>    Function CKReleaseRevision Returns Integer
29378>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
29379>>>>>>>>>    End_Function // CKReleaseRevision
29380>>>>>>>>>
29380>>>>>>>>>
29380>>>>>>>>>
29380>>>>>>>>>    //***
29380>>>>>>>>>    //*** Function: CKBuildRevision
29380>>>>>>>>>    //*** Purpose : Returns the major revision of the CK
29380>>>>>>>>>    //***
29380>>>>>>>>>
29380>>>>>>>>>    Function CKBuildRevision Returns Integer
29382>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
29383>>>>>>>>>    End_Function // CKBuildRevision
29384>>>>>>>>>
29384>>>>>>>>>
29384>>>>>>>>>
29384>>>>>>>>>    //***
29384>>>>>>>>>    //*** Function: IsMinimalRevision
29384>>>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
29384>>>>>>>>>    //***
29384>>>>>>>>>
29384>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
29386>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
29389>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
29392>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
29395>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
29398>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
29401>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
29405>>>>>>>>>            End
29405>>>>>>>>>>
29405>>>>>>>>>        End
29405>>>>>>>>>>
29405>>>>>>>>>
29405>>>>>>>>>        Function_Return (FALSE)
29406>>>>>>>>>    End_Function // IsMinimalRevision
29407>>>>>>>>>
29407>>>>>>>>>
29407>>>>>>>>>
29407>>>>>>>>>    //***
29407>>>>>>>>>    //*** Function: RegistrationName
29407>>>>>>>>>    //*** Purpose : Returns the Connectiivty Kit registration name.
29407>>>>>>>>>    //***
29407>>>>>>>>>
29407>>>>>>>>>    Function RegistrationName Returns String
29409>>>>>>>>>        Local String  sRegistration
29409>>>>>>>>>        Local String  sDRiverId
29409>>>>>>>>>        Local String  sVoid
29409>>>>>>>>>        Local Integer iRetval
29409>>>>>>>>>
29409>>>>>>>>>        Get psDriverID To sDriverID
29410>>>>>>>>>        If (sDRiverID <> "") Begin
29412>>>>>>>>>            Move (Repeat(" ", 255)) To sRegistration
29413>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
29418>>>>>>>>>        End
29418>>>>>>>>>>
29418>>>>>>>>>
29418>>>>>>>>>        Function_Return sRegistration
29419>>>>>>>>>    End_Function // RegistrationName
29420>>>>>>>>>
29420>>>>>>>>>
29420>>>>>>>>>
29420>>>>>>>>>    //***
29420>>>>>>>>>    //*** Function: SerialNumber
29420>>>>>>>>>    //*** Purpose : Returns the Connectiivty Kit serial number.
29420>>>>>>>>>    //***
29420>>>>>>>>>
29420>>>>>>>>>    Function SerialNumber Returns Integer
29422>>>>>>>>>        Local String  sDRiverId
29422>>>>>>>>>        Local String  sVoid
29422>>>>>>>>>        Local Integer iRetval
29422>>>>>>>>>
29422>>>>>>>>>        Get psDriverID To sDriverID
29423>>>>>>>>>        If (sDRiverID <> "") Begin
29425>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
29430>>>>>>>>>        End
29430>>>>>>>>>>
29430>>>>>>>>>
29430>>>>>>>>>        Function_Return iRetval
29431>>>>>>>>>    End_Function // SerialNumber
29432>>>>>>>>>
29432>>>>>>>>>
29432>>>>>>>>>
29432>>>>>>>>>    //***
29432>>>>>>>>>    //*** Function: MaxUsers
29432>>>>>>>>>    //*** Purpose : Returns the Connectiivty Kit maximum number of users.
29432>>>>>>>>>    //***
29432>>>>>>>>>
29432>>>>>>>>>    Function MaxUsers Returns Integer
29434>>>>>>>>>        Local String  sDRiverId
29434>>>>>>>>>        Local String  sVoid
29434>>>>>>>>>        Local Integer iRetval
29434>>>>>>>>>
29434>>>>>>>>>        Get psDriverID To sDriverID
29435>>>>>>>>>        If (sDRiverID <> "") Begin
29437>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
29442>>>>>>>>>        End
29442>>>>>>>>>>
29442>>>>>>>>>
29442>>>>>>>>>        Function_Return iRetval
29443>>>>>>>>>    End_Function // MaxUsers
29444>>>>>>>>>
29444>>>>>>>>>
29444>>>>>>>>>
29444>>>>>>>>>    //***
29444>>>>>>>>>    //*** Procedure: DumpStatus
29444>>>>>>>>>    //*** Purpose  : Dump the current status of the drver in the passed disk file.
29444>>>>>>>>>    //***
29444>>>>>>>>>
29444>>>>>>>>>    Procedure DumpStatus String sFileName
29446>>>>>>>>>        Local String  sVoid
29446>>>>>>>>>        Local String  sDriverID
29446>>>>>>>>>        Local Integer iVoid
29446>>>>>>>>>
29446>>>>>>>>>        Get psDriverID To sDriverID
29447>>>>>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
29454>>>>>>>>>    End_Procedure // DumpStatus
29455>>>>>>>>>
29455>>>>>>>>>
29455>>>>>>>>>
29455>>>>>>>>>    //***
29455>>>>>>>>>    //*** Procedure: ReadConfiguration
29455>>>>>>>>>    //*** Purpose  : Reset all driver level configurable attributes to the
29455>>>>>>>>>    //***            default value and then reread the configuration.
29455>>>>>>>>>    //***
29455>>>>>>>>>
29455>>>>>>>>>    Procedure ReadConfiguration
29457>>>>>>>>>        Local String  sVoid
29457>>>>>>>>>        Local String  sDriverID
29457>>>>>>>>>        Local Integer iVoid
29457>>>>>>>>>
29457>>>>>>>>>        Get psDriverID To sDriverID
29458>>>>>>>>>        If (sDriverID <> "") ;            Call_driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
29465>>>>>>>>>    End_Procedure // ReadConfiguration
29466>>>>>>>>>
29466>>>>>>>>>
29466>>>>>>>>>
29466>>>>>>>>>    //***
29466>>>>>>>>>    //*** Function: TextToRIMValue
29466>>>>>>>>>    //*** Purpose : Convert a text to the corresponding
29466>>>>>>>>>    //***           Generate_Record_ID_Method attribute value
29466>>>>>>>>>    //***
29466>>>>>>>>>
29466>>>>>>>>>    Function TextToRIMValue String sText Returns Integer
29468>>>>>>>>>        If (sText = "None") ;            Function_return RIM_NONE
29471>>>>>>>>>        Else If (sText = "Identity Column") ;            Function_return RIM_IDENTITY_COLUMN
29475>>>>>>>>>        Else If (sText = "Dispenser Table") ;            Function_return RIM_DISPENSER_TABLE
29479>>>>>>>>>        Else If (sText = "External") ;            Function_return RIM_EXTERNAL
29483>>>>>>>>>    End_Function // TextToRIMValue
29484>>>>>>>>>
29484>>>>>>>>>
29484>>>>>>>>>
29484>>>>>>>>>    //***
29484>>>>>>>>>    //*** Function: RIMValueTotext
29484>>>>>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
29484>>>>>>>>>    //***           corresponding text.
29484>>>>>>>>>    //***
29484>>>>>>>>>
29484>>>>>>>>>    Function RIMValueToText Integer iAttrValue Returns String
29486>>>>>>>>>        If (iAttrValue = RIM_NONE) ;            Function_return "None"
29489>>>>>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_return "Identity Column"
29493>>>>>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_return "Dispenser Table"
29497>>>>>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_return "External"
29501>>>>>>>>>    End_Function // RIMValueToText
29502>>>>>>>>>
29502>>>>>>>>>
29502>>>>>>>>>
29502>>>>>>>>>    //***
29502>>>>>>>>>    //*** Function: TextToROValue
29502>>>>>>>>>    //*** Purpose : Convert a text to the corresponding
29502>>>>>>>>>    //***           Generate_Record_ID_Method attribute value
29502>>>>>>>>>    //***
29502>>>>>>>>>
29502>>>>>>>>>    Function TextToROValue String sText Returns Integer
29504>>>>>>>>>        If (sText = "No") ;            Function_return RO_NO
29507>>>>>>>>>        Else If (sText = "Ignore Change") ;            Function_return RO_IGNORECHANGE
29511>>>>>>>>>        Else If (sText = "Accept Change") ;            Function_return RO_ACCEPTCHANGE
29515>>>>>>>>>        Else If (sText = "Error On Change") ;            Function_return RO_ERRORONCHANGE
29519>>>>>>>>>    End_Function // TextToRIMValue
29520>>>>>>>>>
29520>>>>>>>>>
29520>>>>>>>>>
29520>>>>>>>>>    //***
29520>>>>>>>>>    //*** Function: ROValueTotext
29520>>>>>>>>>    //*** Purpose : Convert a Generate_Record_ID_Method attribute value to the
29520>>>>>>>>>    //***           corresponding text.
29520>>>>>>>>>    //***
29520>>>>>>>>>
29520>>>>>>>>>    Function ROValueToText Integer iAttrValue Returns String
29522>>>>>>>>>        If (iAttrValue = RO_NO) ;            Function_return "No"
29525>>>>>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_return "Ignore Change"
29529>>>>>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_return "Accept Change"
29533>>>>>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_return "Error On Change"
29537>>>>>>>>>    End_Function // RIMValueToText
29538>>>>>>>>>
29538>>>>>>>>>
29538>>>>>>>>>
29538>>>>>>>>>    //***
29538>>>>>>>>>    //*** Function: LastDriverError
29538>>>>>>>>>    //*** Purpose : Return the text f the last error geneated by the driver.
29538>>>>>>>>>    //***
29538>>>>>>>>>
29538>>>>>>>>>    Function LastDriverError Returns String
29540>>>>>>>>>        Local String  sDriverID
29540>>>>>>>>>        Local String  sLastError
29540>>>>>>>>>        Local String  sLastErrorLength
29540>>>>>>>>>        Local Integer iLastErrorLength
29540>>>>>>>>>        Local Integer iVoid
29540>>>>>>>>>
29540>>>>>>>>>        //*** Initialize
29540>>>>>>>>>        Move "" To sLastError
29541>>>>>>>>>
29541>>>>>>>>>        Get psDriverID To sDriverID
29542>>>>>>>>>        If (sDriverID <> "") Begin
29544>>>>>>>>>            //*** Get the text of the last error
29544>>>>>>>>>            Move (Repeat(Character(" "), 14)) To sLastErrorlength
29545>>>>>>>>>            Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
29550>>>>>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) To iLastErrorLength
29551>>>>>>>>>
29551>>>>>>>>>            If (iLastErrorLength > 0) Begin
29553>>>>>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) To sLastError
29554>>>>>>>>>                Call_driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
29559>>>>>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) To sLastError
29560>>>>>>>>>            End
29560>>>>>>>>>>
29560>>>>>>>>>        End
29560>>>>>>>>>>
29560>>>>>>>>>
29560>>>>>>>>>        Function_Return sLastError
29561>>>>>>>>>    End_Function // LastDriverError
29562>>>>>>>>>
29562>>>>>>>>>
29562>>>>>>>>>
29562>>>>>>>>>    //***
29562>>>>>>>>>    //*** Function: EnumerateTables
29562>>>>>>>>>    //*** Purpose : Enumerate the tables in a database
29562>>>>>>>>>    //***
29562>>>>>>>>>
29562>>>>>>>>>    Function EnumerateTables String sLogin Returns Integer
29564>>>>>>>>>        Local String  sDriver
29564>>>>>>>>>        Local String  sVoid
29564>>>>>>>>>        Local Integer iNumTables
29564>>>>>>>>>        Local Integer iVoid
29564>>>>>>>>>
29564>>>>>>>>>        Get psDriverID To sDriver
29565>>>>>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
29572>>>>>>>>>
29572>>>>>>>>>        Function_Return iNumTables
29573>>>>>>>>>    End_Function // EnumerateTables
29574>>>>>>>>>
29574>>>>>>>>>
29574>>>>>>>>>
29574>>>>>>>>>    //***
29574>>>>>>>>>    //*** Function: TableName
29574>>>>>>>>>    //*** Purpose : Returns the name of the table enumerated at the given position
29574>>>>>>>>>    //***
29574>>>>>>>>>
29574>>>>>>>>>    Function TableName Integer iIndex Returns String
29576>>>>>>>>>        Local String  sDriver
29576>>>>>>>>>        Local String  sTableName
29576>>>>>>>>>        Local String  sVoid
29576>>>>>>>>>        Local Integer iVoid
29576>>>>>>>>>
29576>>>>>>>>>        Get psDriverID To sDriver
29577>>>>>>>>>        If (sDriver <> "") Begin
29579>>>>>>>>>            Move (Repeat(" ", 255)) To sTableName
29580>>>>>>>>>            Call_driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
29585>>>>>>>>>        End
29585>>>>>>>>>>
29585>>>>>>>>>
29585>>>>>>>>>        Function_Return sTableName
29586>>>>>>>>>    End_Function // TableName
29587>>>>>>>>>
29587>>>>>>>>>
29587>>>>>>>>>
29587>>>>>>>>>    //***
29587>>>>>>>>>    //*** Function: SchemaName
29587>>>>>>>>>    //*** Purpose : Returns the name of the schema of the table enumerated at the given position
29587>>>>>>>>>    //***
29587>>>>>>>>>
29587>>>>>>>>>    Function SchemaName Integer iIndex Returns String
29589>>>>>>>>>        Local String  sDriver
29589>>>>>>>>>        Local String  sSchemaName
29589>>>>>>>>>        Local String  sVoid
29589>>>>>>>>>        Local Integer iVoid
29589>>>>>>>>>
29589>>>>>>>>>        Get psDriverID To sDriver
29590>>>>>>>>>        If (sDriver <> "") Begin
29592>>>>>>>>>            Move (Repeat(" ", 255)) To sSchemaName
29593>>>>>>>>>            Call_driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
29598>>>>>>>>>        End
29598>>>>>>>>>>
29598>>>>>>>>>
29598>>>>>>>>>        Function_Return sSchemaName
29599>>>>>>>>>    End_Function // SchemaName
29600>>>>>>>>>
29600>>>>>>>>>
29600>>>>>>>>>
29600>>>>>>>>>    //***
29600>>>>>>>>>    //*** Function: TableType
29600>>>>>>>>>    //*** Purpose : Returns the type of the table enumerated at the given position.
29600>>>>>>>>>    //***           Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
29600>>>>>>>>>    //***           "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
29600>>>>>>>>>    //***
29600>>>>>>>>>
29600>>>>>>>>>    Function TableType Integer iIndex Returns String
29602>>>>>>>>>        Local String  sDriver
29602>>>>>>>>>        Local String  sTableType
29602>>>>>>>>>        Local String  sVoid
29602>>>>>>>>>        Local Integer iVoid
29602>>>>>>>>>
29602>>>>>>>>>        Get psDriverID To sDriver
29603>>>>>>>>>        If (sDriver <> "") Begin
29605>>>>>>>>>            Move (Repeat(" ", 25)) To sTableType
29606>>>>>>>>>            Call_driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
29611>>>>>>>>>        End
29611>>>>>>>>>>
29611>>>>>>>>>
29611>>>>>>>>>        Function_Return sTableType
29612>>>>>>>>>    End_Function // TableType
29613>>>>>>>>>
29613>>>>>>>>>
29613>>>>>>>>>
29613>>>>>>>>>    //***
29613>>>>>>>>>    //*** Function: TableComment
29613>>>>>>>>>    //*** Purpose : Returns the comment of the table enumerated at the given position
29613>>>>>>>>>    //***
29613>>>>>>>>>
29613>>>>>>>>>    Function TableComment Integer iIndex Returns String
29615>>>>>>>>>        Local String  sDriver
29615>>>>>>>>>        Local String  sTableComment
29615>>>>>>>>>        Local String  sVoid
29615>>>>>>>>>        Local Integer iVoid
29615>>>>>>>>>
29615>>>>>>>>>        Get psDriverID To sDriver
29616>>>>>>>>>        If (sDriver <> "") Begin
29618>>>>>>>>>            Move (Repeat(" ", 255)) To sTableComment
29619>>>>>>>>>            Call_driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
29624>>>>>>>>>        End
29624>>>>>>>>>>
29624>>>>>>>>>
29624>>>>>>>>>        Function_Return sTableComment
29625>>>>>>>>>    End_Function // TableComment
29626>>>>>>>>>
29626>>>>>>>>>
29626>>>>>>>>>
29626>>>>>>>>>    //***
29626>>>>>>>>>    //*** Function: EnumerateColumns
29626>>>>>>>>>    //*** Purpose : Enumerate the columns in a table
29626>>>>>>>>>    //***
29626>>>>>>>>>
29626>>>>>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
29628>>>>>>>>>        Local String  sDriver
29628>>>>>>>>>        Local Integer iNumColumns
29628>>>>>>>>>        Local Integer iVoid
29628>>>>>>>>>
29628>>>>>>>>>        Get psDriverID To sDriver
29629>>>>>>>>>        If (sDriver <> "") ;            Call_driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
29636>>>>>>>>>
29636>>>>>>>>>        Function_Return iNumColumns
29637>>>>>>>>>    End_Function // EnumerateColumns
29638>>>>>>>>>
29638>>>>>>>>>
29638>>>>>>>>>
29638>>>>>>>>>    //***
29638>>>>>>>>>    //*** Function: ColumnName
29638>>>>>>>>>    //*** Purpose : Returns the name of the column enumerated at the given position
29638>>>>>>>>>    //***
29638>>>>>>>>>
29638>>>>>>>>>    Function ColumnName Integer iIndex Returns String
29640>>>>>>>>>        Local String  sDriver
29640>>>>>>>>>        Local String  sColumnName
29640>>>>>>>>>        Local String  sVoid
29640>>>>>>>>>        Local Integer iVoid
29640>>>>>>>>>
29640>>>>>>>>>        Get psDriverID To sDriver
29641>>>>>>>>>        If (sDriver <> "") Begin
29643>>>>>>>>>            Move (Repeat(" ", 255)) To sColumnName
29644>>>>>>>>>            Call_driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
29649>>>>>>>>>        End
29649>>>>>>>>>>
29649>>>>>>>>>
29649>>>>>>>>>        Function_Return sColumnName
29650>>>>>>>>>    End_Function // ColumnName
29651>>>>>>>>>
29651>>>>>>>>>
29651>>>>>>>>>
29651>>>>>>>>>    //***
29651>>>>>>>>>    //*** Function: CLIDFDateToSQLDate
29651>>>>>>>>>    //*** Purpose : Convert a DataFlex date to a SQL date using the dummy zero date value.
29651>>>>>>>>>    //***
29651>>>>>>>>>
29651>>>>>>>>>    Function CLIDFDateToSQLDate String sDRiver Date dDFDate Returns String
29653>>>>>>>>>        Local String sSQLDate
29653>>>>>>>>>        Local Integer iOrgDateFmt
29653>>>>>>>>>        Local Integer iOrgDateSep
29653>>>>>>>>>
29653>>>>>>>>>        //*** Change date format to military, SQL dates are military dates
29653>>>>>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
29656>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
29659>>>>>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
29662>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
29665>>>>>>>>>
29665>>>>>>>>>        //*** We only need to convert if the date is 0
29665>>>>>>>>>        If (Integer(dDFDate = 0)) ;            CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sSQLDate
29674>>>>>>>>>        Else ;            Move dDFDate To sSQLDate
29676>>>>>>>>>
29676>>>>>>>>>        //*** Change date format back to original
29676>>>>>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
29679>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
29682>>>>>>>>>
29682>>>>>>>>>        Function_Return sSQLDate
29683>>>>>>>>>    End_Function // CLIDFDateToSQLDate
29684>>>>>>>>>
29684>>>>>>>>>
29684>>>>>>>>>
29684>>>>>>>>>    //***
29684>>>>>>>>>    //*** Function: CLISQLDateToDFDate
29684>>>>>>>>>    //*** Purpose : Convert a SQL date to a DataFlex date using the dummy zero date value.
29684>>>>>>>>>    //***
29684>>>>>>>>>
29684>>>>>>>>>    Function CLISQLDateToDFDate String sDRiver String sSQLDate Returns Date
29686>>>>>>>>>        Local Date dDFDate
29686>>>>>>>>>        Local String sDummyDateValue
29686>>>>>>>>>        Local Integer iOrgDateFmt
29686>>>>>>>>>        Local Integer iOrgDateSep
29686>>>>>>>>>
29686>>>>>>>>>        //*** Change date format to military, SQL dates are military dates
29686>>>>>>>>>        Get_Attribute DF_DATE_FORMAT To iOrgDateFmt
29689>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR To iOrgDateSep
29692>>>>>>>>>        Set_Attribute DF_DATE_FORMAT To DF_DATE_MILITARY
29695>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To (Ascii('-'))
29698>>>>>>>>>
29698>>>>>>>>>        //*** We only need to convert if the date is the dummy zero date value
29698>>>>>>>>>        CLI_Get_Driver_Attribute sDRiver DRVR_DUMMY_ZERO_DATE_VALUE To sDummyDateValue
29705>>>>>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 To dDFDate
29708>>>>>>>>>        Else ;            Move sSQLDate To dDFDate
29710>>>>>>>>>
29710>>>>>>>>>        //*** Change date format back to original
29710>>>>>>>>>        Set_Attribute DF_DATE_FORMAT To iOrgDateFmt
29713>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR To iOrgDateSep
29716>>>>>>>>>
29716>>>>>>>>>        Function_Return dDFDate
29717>>>>>>>>>    End_Function // CLISQLDateToDFDate
29718>>>>>>>>>
29718>>>>>>>>>
29718>>>>>>>>>
29718>>>>>>>>>    //***
29718>>>>>>>>>    //*** Function: RedirectConnection
29718>>>>>>>>>    //*** Purpose : Redirect an exisitng connection. The existing connection
29718>>>>>>>>>    //***           will point to another database but all tables will stay
29718>>>>>>>>>    //***           open!
29718>>>>>>>>>    //***
29718>>>>>>>>>
29718>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
29720>>>>>>>>>        Local String  sDriver
29720>>>>>>>>>        Local String  sVoid
29720>>>>>>>>>        Local Integer iResult
29720>>>>>>>>>        Local Integer iVoid
29720>>>>>>>>>
29720>>>>>>>>>        Get psDriverID To sDriver
29721>>>>>>>>>        If (sDriver <> "") Begin
29723>>>>>>>>>            Call_driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
29728>>>>>>>>>        End
29728>>>>>>>>>>
29728>>>>>>>>>        Function_Return iResult
29729>>>>>>>>>    End_Function // RedirectConnect
29730>>>>>>>>>
29730>>>>>>>>>
29730>>>>>>>>>
29730>>>>>>>>>    //***
29730>>>>>>>>>    //*** Function: CreateConnectionID
29730>>>>>>>>>    //*** Purpose : Create a DataFlex side connection id that can be used later on.
29730>>>>>>>>>    //***
29730>>>>>>>>>
29730>>>>>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
29732>>>>>>>>>        Local String  sDriver
29732>>>>>>>>>        Local Integer iResult
29732>>>>>>>>>        Local Integer iOptions
29732>>>>>>>>>
29732>>>>>>>>>        Get psDriverID to sDriver
29733>>>>>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
29736>>>>>>>>>        Else ;            Move iOpt to iOptions
29738>>>>>>>>>        If (sDriver <> "") Begin
29740>>>>>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
29745>>>>>>>>>        End
29745>>>>>>>>>>
29745>>>>>>>>>        Function_Return iResult
29746>>>>>>>>>    End_Function // CreateConnectionID
29747>>>>>>>>>
29747>>>>>>>>>
29747>>>>>>>>>
29747>>>>>>>>>    //***
29747>>>>>>>>>    //*** Function: DeleteConnectionID
29747>>>>>>>>>    //*** Purpose : Delete a DataFlex side connection id.
29747>>>>>>>>>    //***
29747>>>>>>>>>
29747>>>>>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
29749>>>>>>>>>        Local String  sDriver
29749>>>>>>>>>        Local Integer iResult
29749>>>>>>>>>        Local String sVoid
29749>>>>>>>>>
29749>>>>>>>>>        Get psDriverID To sDriver
29750>>>>>>>>>        If (sDriver <> "") Begin
29752>>>>>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
29757>>>>>>>>>        End
29757>>>>>>>>>>
29757>>>>>>>>>        Function_Return iResult
29758>>>>>>>>>    End_Function // DeleteConnectionID
29759>>>>>>>>>
29759>>>>>>>>>End_Class // cCLIHandler
29760>>>>>>>Use sql.pkg
Including file: sql.pkg    (C:\Program Files (x86)\Visual DataFlex 17.1\Pkg\sql.pkg)
29760>>>>>>>>>//*****************************************************************************
29760>>>>>>>>>//*** SQL.pkg                                                               ***
29760>>>>>>>>>//***                                                                       ***
29760>>>>>>>>>//*** Author: Ben Weijers                                                   ***
29760>>>>>>>>>//***         Data Access Wordwide                                          ***
29760>>>>>>>>>//***         14 February 2000                                              ***
29760>>>>>>>>>//***                                                                       ***
29760>>>>>>>>>//*** Purpose:                                                              ***
29760>>>>>>>>>//***   Embedded SQL manager.                                               ***
29760>>>>>>>>>//***                                                                       ***
29760>>>>>>>>>//*** Changes:                                                              ***
29760>>>>>>>>>//***                                                                       ***
29760>>>>>>>>>//***   March 14, 2001. CLI Connectivity Kits 2.0.0.13                      ***
29760>>>>>>>>>//***       Allocate memory before call_driver command with spaces instead  ***
29760>>>>>>>>>//***       of binary zeroes.                                               ***
29760>>>>>>>>>//***                                                                       ***
29760>>>>>>>>>//***   June 18, 2010. CLI Connectivity Kits 5.1.0.76                       ***
29760>>>>>>>>>//***       Made a change to reserve space for a decimal point when getting ***
29760>>>>>>>>>//***       decimal date through embeded SQL.                               ***
29760>>>>>>>>>//***                                                                       ***
29760>>>>>>>>>//*****************************************************************************
29760>>>>>>>>>
29760>>>>>>>>>Use CLI.pkg
29760>>>>>>>>>Use Case.mac
29760>>>>>>>>>
29760>>>>>>>>>//*** Global object handle for the manager
29760>>>>>>>>>Integer _embsqlghoSQLHandleMngr
29760>>>>>>>>>
29760>>>>>>>>>//*** Global stroage for results
29760>>>>>>>>>Integer SQLResult
29760>>>>>>>>>
29760>>>>>>>>>//*** Embedded SQL function constants
29760>>>>>>>>>Define FUNC_SQLCONNECT             For 1000000
29760>>>>>>>>>Define FUNC_SQLFILECONNECT         For 1000001
29760>>>>>>>>>Define FUNC_SQLDISCONNECT          For 1000002
29760>>>>>>>>>Define FUNC_SQLOPEN                For 1000003
29760>>>>>>>>>Define FUNC_SQLCLOSE               For 1000004
29760>>>>>>>>>Define FUNC_SQLPREPARE             For 1000005
29760>>>>>>>>>Define FUNC_SQLEXECUTE             For 1000006
29760>>>>>>>>>Define FUNC_SQLEXECDIRECT          For 1000007
29760>>>>>>>>>Define FUNC_SQLFETCH               For 1000008
29760>>>>>>>>>Define FUNC_SQLCOLUMNINFO          For 1000009
29760>>>>>>>>>Define FUNC_SQLCOLUMNVALUE         For 1000010
29760>>>>>>>>>Define FUNC_SQLBINDFILE            For 1000011
29760>>>>>>>>>Define FUNC_SQLGETDATA             For 1000012
29760>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIBLEN  For 1000013
29760>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIB     For 1000014
29760>>>>>>>>>Define FUNC_SQLCOLINTATTRIB        For 1000015
29760>>>>>>>>>Define FUNC_SQLSTMTINTATTRIB       For 1000016
29760>>>>>>>>>Define FUNC_SQLSETPROCNAME         For 1000017
29760>>>>>>>>>DEfine FUNC_SQLSETPROCARG          For 1000018
29760>>>>>>>>>Define FUNC_SQLCALL                For 1000019
29760>>>>>>>>>Define FUNC_SQLGETPROCARGLEN       For 1000020
29760>>>>>>>>>Define FUNC_SQLGETPROCARG          For 1000021
29760>>>>>>>>>Define FUNC_SQLGETPROCRETVALLEN    For 1000022
29760>>>>>>>>>Define FUNC_SQLGETPROCRETVAL       For 1000023
29760>>>>>>>>>Define FUNC_SQLNEXTRESULTSET       For 1000024
29760>>>>>>>>>Define FUNC_SQLBUFFERSTATUS        For 1000025
29760>>>>>>>>>Define FUNC_SQLSETPROCSCHEMA       For 1000026
29760>>>>>>>>>Define FUNC_SQLGETMESSAGE          For 1000027
29760>>>>>>>>>
29760>>>>>>>>>//*** Embedded SQL statement attribute constants
29760>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    For 1
29760>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       For 2
29760>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  For 3
29760>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    For 4
29760>>>>>>>>>
29760>>>>>>>>>//*** Embedded SQL column attribute constants
29760>>>>>>>>>Define SQLCOLATTRIB_SIZE           For 1
29760>>>>>>>>>Define SQLCOLATTRIB_LENGTH         For 1
29760>>>>>>>>>Define SQLCOLATTRIB_PRECISION      For 2
29760>>>>>>>>>Define SQLCOLATTRIB_LABEL          For 3
29760>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME For 4
29760>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  For 5
29760>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        For 6
29760>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       For 7
29760>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         For 8
29760>>>>>>>>>
29760>>>>>>>>>
29760>>>>>>>>>
29760>>>>>>>>>//*****************************************************************************
29760>>>>>>>>>//*** Class  : cSQLStatement                                                ***
29760>>>>>>>>>//*** Purpose: Statement object for embedded sql                            ***
29760>>>>>>>>>//***                                                                       ***
29760>>>>>>>>>//*** Description:                                                          ***
29760>>>>>>>>>//***   An object is created for each statement. These will be children     ***
29760>>>>>>>>>//***   of cSQLConnection objects which manage the create and destruction   ***
29760>>>>>>>>>//***   of these.                                                           ***
29760>>>>>>>>>//*****************************************************************************
29760>>>>>>>>>
29760>>>>>>>>>Class cSQLStatement is an Array
29761>>>>>>>>>
29761>>>>>>>>>    Procedure Construct_object Integer Image
29763>>>>>>>>>        Forward Send Construct_object Image
29765>>>>>>>>>
29765>>>>>>>>>        Property Integer phCLIHandle      public 0
29766>>>>>>>>>        Property String  psDriverID       Public ""
29767>>>>>>>>>        Property Integer phStmtConnection Public 0
29768>>>>>>>>>        Property Integer piLastColumn     Public 0
29769>>>>>>>>>        Property Integer piLastArgument   Public 0
29770>>>>>>>>>        Property Integer piBindFile       Public 0
29771>>>>>>>>>
29771>>>>>>>>>        Set Delegation_mode To NO_Delegation
29772>>>>>>>>>    End_procedure // Construct_object
29773>>>>>>>>>
29773>>>>>>>>>
29773>>>>>>>>>
29773>>>>>>>>>    //***
29773>>>>>>>>>    //*** Procedure: StoreHandleInfo
29773>>>>>>>>>    //*** Purpose  : Store basic information about the statement handle.
29773>>>>>>>>>    //***
29773>>>>>>>>>
29773>>>>>>>>>    Procedure StoreHandleInfo Integer iCLIHandle String sDrvrId Integer iParentHandle
29775>>>>>>>>>        Set phCLIHandle      To iCLIHandle
29776>>>>>>>>>        Set psDriverID       To sDrvrId
29777>>>>>>>>>        Set phStmtConnection To iParentHandle
29778>>>>>>>>>    End_Procedure // StoreHandleInfo
29779>>>>>>>>>
29779>>>>>>>>>
29779>>>>>>>>>
29779>>>>>>>>>    //***
29779>>>>>>>>>    //*** Procedure: FreeHandle
29779>>>>>>>>>    //*** Purpose  : Free a handle. Since a handle is stored in an
29779>>>>>>>>>    //***            cSQLStatement object, we destroy the object.
29779>>>>>>>>>    //***
29779>>>>>>>>>
29779>>>>>>>>>    Procedure FreeHandle
29781>>>>>>>>>        Send Destroy_Object
29782>>>>>>>>>    End_Procedure // FreeHandle
29783>>>>>>>>>
29783>>>>>>>>>
29783>>>>>>>>>
29783>>>>>>>>>    //***
29783>>>>>>>>>    //*** Procedure: HandleError
29783>>>>>>>>>    //*** Puprose  : Handle an error that has occured while checking properties.
29783>>>>>>>>>    //***
29783>>>>>>>>>
29783>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
29785>>>>>>>>>        Local Integer iErrHandle
29785>>>>>>>>>        Local Integer iErrNum
29785>>>>>>>>>        Local String  sLocationInfo
29785>>>>>>>>>
29785>>>>>>>>>        //*** Get the DataFlex statement identifier
29785>>>>>>>>>        Move Current_object To iErrHandle
29786>>>>>>>>>
29786>>>>>>>>>        //*** Determine error number
29786>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE To iErrNum
29789>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE To iErrNum
29793>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID To iErrNum
29797>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR To iErrNum
29799>>>>>>>>>
29799>>>>>>>>>        //*** Create location ifnormation
29799>>>>>>>>>        Move "[" To sLocationInfo
29800>>>>>>>>>        If (sOriginMsg <> "") Begin
29802>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) To sLocationInfo
29803>>>>>>>>>            Move (Append(sLocationInfo, ", "))       To sLocationInfo
29804>>>>>>>>>        End
29804>>>>>>>>>>
29804>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) To sLocationInfo
29805>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          To sLocationInfo
29806>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 To sLocationInfo
29807>>>>>>>>>
29807>>>>>>>>>        //*** Generate the error
29807>>>>>>>>>        Error iErrNum sLocationInfo
29808>>>>>>>>>>
29808>>>>>>>>>    End_Procedure // HandleError
29809>>>>>>>>>
29809>>>>>>>>>
29809>>>>>>>>>
29809>>>>>>>>>    //***
29809>>>>>>>>>    //*** Procedure: StmtError
29809>>>>>>>>>    //*** Purpose  : Handle general error not related to the properties
29809>>>>>>>>>    //***
29809>>>>>>>>>
29809>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
29811>>>>>>>>>        Local Integer iErrHandle
29811>>>>>>>>>        Local String  sLocationInfo
29811>>>>>>>>>
29811>>>>>>>>>        //*** Get the DataFlex statement identifier
29811>>>>>>>>>        Move Current_object To iErrHandle
29812>>>>>>>>>
29812>>>>>>>>>
29812>>>>>>>>>        //*** Create location information
29812>>>>>>>>>        Move "[" To sLocationInfo
29813>>>>>>>>>        If (sOriginMsg <> "") Begin
29815>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) To sLocationInfo
29816>>>>>>>>>            Move (Append(sLocationInfo, ", "))       To sLocationInfo
29817>>>>>>>>>        End
29817>>>>>>>>>>
29817>>>>>>>>>        If (sErrtext <> "") Begin
29819>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) To sLocationInfo
29820>>>>>>>>>            Move (Append(sLocationInfo, ", "))     To sLocationInfo
29821>>>>>>>>>        End
29821>>>>>>>>>>
29821>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) To sLocationInfo
29822>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          To sLocationInfo
29823>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 To sLocationInfo
29824>>>>>>>>>
29824>>>>>>>>>        //*** Generate the error
29824>>>>>>>>>        Error iErrNum sLocationInfo
29825>>>>>>>>>>
29825>>>>>>>>>    End_Procedure // StmtError
29826>>>>>>>>>
29826>>>>>>>>>
29826>>>>>>>>>
29826>>>>>>>>>    //***
29826>>>>>>>>>    //*** Procedure: SQLIllegalAttribute
29826>>>>>>>>>    //*** Purpose  : Handle an illegal attribute error
29826>>>>>>>>>    //***
29826>>>>>>>>>
29826>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
29828>>>>>>>>>        Local Integer bReport
29828>>>>>>>>>
29828>>>>>>>>>        Get_attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES To bReport
29831>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
29834>>>>>>>>>    End_Procedure // SQLIllegalAttribute
29835>>>>>>>>>
29835>>>>>>>>>
29835>>>>>>>>>
29835>>>>>>>>>    //***
29835>>>>>>>>>    //*** Function: SQLPrivateColumnIsLegal
29835>>>>>>>>>    //*** Purpose : Check if a column number is legal
29835>>>>>>>>>    //***
29835>>>>>>>>>
29835>>>>>>>>>    Function SQLPrivateColumnIsLegal Integer ihdbc String sDrvrId Integer ihstmt Integer iCol Returns Integer
29837>>>>>>>>>        Local Integer bLegal
29837>>>>>>>>>        Local Integer iNumColumns
29837>>>>>>>>>
29837>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt To iNumColumns
29838>>>>>>>>>        If (iCol > 0 And iCol <= iNumColumns) ;            Move DFTRUE To bLegal
29841>>>>>>>>>        Else ;            Move DFFALSE To bLegal
29843>>>>>>>>>
29843>>>>>>>>>        Function_Return bLegal
29844>>>>>>>>>    End_Function // SQLPrivateColumnIsLegal
29845>>>>>>>>>
29845>>>>>>>>>
29845>>>>>>>>>
29845>>>>>>>>>    //***
29845>>>>>>>>>    //*** Procedure: SQLClose
29845>>>>>>>>>    //*** Purpose  : Close a statement and free all alllocated resources
29845>>>>>>>>>    //***
29845>>>>>>>>>
29845>>>>>>>>>    Procedure SQLClose
29847>>>>>>>>>        Local Integer ihdbc
29847>>>>>>>>>        Local Integer ihstmt
29847>>>>>>>>>        Local Integer iVoid
29847>>>>>>>>>        Local String  sDrvrId
29847>>>>>>>>>        Local String  sEmpty
29847>>>>>>>>>
29847>>>>>>>>>        //*** Initialize
29847>>>>>>>>>        Move "" To sEmpty
29848>>>>>>>>>
29848>>>>>>>>>        //*** Get the cli handle to the connection
29848>>>>>>>>>        Get phCLIHandle        To ihstmt
29849>>>>>>>>>        Get psDriverId         To sDrvrId
29850>>>>>>>>>        Get phStmtConnection   To ihdbc
29851>>>>>>>>>
29851>>>>>>>>>        //*** Free the CLI handle
29851>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
29853>>>>>>>>>            //*** Call the driver function to close
29853>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCLOSE ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
29858>>>>>>>>>
29858>>>>>>>>>            //*** Free the DataFlex handle
29858>>>>>>>>>            Send FreeHandle
29859>>>>>>>>>        End
29859>>>>>>>>>>
29859>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLClose"
29861>>>>>>>>>    End_procedure // SQLClose
29862>>>>>>>>>
29862>>>>>>>>>
29862>>>>>>>>>
29862>>>>>>>>>    //***
29862>>>>>>>>>    //*** Procedure: SQLPrepare
29862>>>>>>>>>    //*** Purpose  : Prepare a statement for execution
29862>>>>>>>>>    //***
29862>>>>>>>>>
29862>>>>>>>>>    Procedure SQLPrepare String sStatement
29864>>>>>>>>>        Local Integer ihdbc
29864>>>>>>>>>        Local Integer ihstmt
29864>>>>>>>>>        Local Integer iVoid
29864>>>>>>>>>        Local String  sDrvrId
29864>>>>>>>>>
29864>>>>>>>>>        //*** Get the cli handle to the connection
29864>>>>>>>>>        Get phCLIHandle       To ihstmt
29865>>>>>>>>>        Get psDriverId        To sDrvrId
29866>>>>>>>>>        Get phStmtConnection  To ihdbc
29867>>>>>>>>>
29867>>>>>>>>>        //*** Prepare
29867>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
29869>>>>>>>>>            //*** Call the driver function to prepare
29869>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLPREPARE ;                        Callback Current_Object ;                        Passing ihdbc sStatement ihstmt ;                        Result iVoid
29874>>>>>>>>>        End
29874>>>>>>>>>>
29874>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrepare"
29876>>>>>>>>>    End_procedure // SQLPrepare
29877>>>>>>>>>
29877>>>>>>>>>
29877>>>>>>>>>
29877>>>>>>>>>    //***
29877>>>>>>>>>    //*** Procedure: SQLExecute
29877>>>>>>>>>    //*** Purpose  : Execute a prepared statement
29877>>>>>>>>>    //***
29877>>>>>>>>>
29877>>>>>>>>>    Procedure SQLExecute
29879>>>>>>>>>        Local Integer ihdbc
29879>>>>>>>>>        Local Integer ihstmt
29879>>>>>>>>>        Local Integer iVoid
29879>>>>>>>>>        Local String  sDrvrId
29879>>>>>>>>>        Local String  sEmpty
29879>>>>>>>>>
29879>>>>>>>>>        //*** Initialize
29879>>>>>>>>>        Move "" To sEmpty
29880>>>>>>>>>
29880>>>>>>>>>        //*** Get the cli handle to the connection
29880>>>>>>>>>        Get phCLIHandle       To ihstmt
29881>>>>>>>>>        Get psDriverId        To sDrvrId
29882>>>>>>>>>        Get phStmtConnection  To ihdbc
29883>>>>>>>>>
29883>>>>>>>>>        //*** Execute
29883>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
29885>>>>>>>>>            //*** Call the driver function to execute
29885>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLEXECUTE ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
29890>>>>>>>>>        End
29890>>>>>>>>>>
29890>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecute"
29892>>>>>>>>>    End_Procedure // SQLExecute
29893>>>>>>>>>
29893>>>>>>>>>
29893>>>>>>>>>
29893>>>>>>>>>    //***
29893>>>>>>>>>    //*** Procedure: SQLExecDirect
29893>>>>>>>>>    //*** Purpose  : Prepare and execute a statement
29893>>>>>>>>>    //***
29893>>>>>>>>>
29893>>>>>>>>>    Procedure SQLExecDirect String sStatement
29895>>>>>>>>>        Local Integer ihdbc
29895>>>>>>>>>        Local Integer ihstmt
29895>>>>>>>>>        Local Integer iVoid
29895>>>>>>>>>        Local String  sDrvrId
29895>>>>>>>>>
29895>>>>>>>>>        //*** Get the cli handle to the connection
29895>>>>>>>>>        Get phCLIHandle        To ihstmt
29896>>>>>>>>>        Get psDriverId         To sDrvrId
29897>>>>>>>>>        Get phStmtConnection   To ihdbc
29898>>>>>>>>>
29898>>>>>>>>>        //*** ExecDirect
29898>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
29900>>>>>>>>>            //*** Call the driver function to execdirect
29900>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLEXECDIRECT ;                        Callback Current_Object ;                        Passing ihdbc sStatement ihstmt ;                        Result iVoid
29905>>>>>>>>>        End
29905>>>>>>>>>>
29905>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecDirect"
29907>>>>>>>>>    End_procedure // SQLExecDirect
29908>>>>>>>>>
29908>>>>>>>>>
29908>>>>>>>>>
29908>>>>>>>>>    //***
29908>>>>>>>>>    //*** Procedure: SQLFetch
29908>>>>>>>>>    //*** Purpose  : Fetch the next row
29908>>>>>>>>>    //*** Returns  : 0   = No more data
29908>>>>>>>>>    //***            <>0 = Success
29908>>>>>>>>>    //***
29908>>>>>>>>>
29908>>>>>>>>>    Function SQLFetch Returns Integer
29910>>>>>>>>>        Local Integer ihdbc
29910>>>>>>>>>        Local Integer ihstmt
29910>>>>>>>>>        Local Integer iResult
29910>>>>>>>>>        Local String  sDrvrId
29910>>>>>>>>>        Local String  sEmpty
29910>>>>>>>>>
29910>>>>>>>>>        //*** Initialize
29910>>>>>>>>>        Move "" To sEmpty
29911>>>>>>>>>        Move 0  To iResult
29912>>>>>>>>>
29912>>>>>>>>>        //*** Get the cli handle to the connection
29912>>>>>>>>>        Get phCLIHandle        To ihstmt
29913>>>>>>>>>        Get psDriverId         To sDrvrId
29914>>>>>>>>>        Get phStmtConnection   To ihdbc
29915>>>>>>>>>
29915>>>>>>>>>        //*** Fetch
29915>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
29917>>>>>>>>>            Indicate Err False
29918>>>>>>>>>
29918>>>>>>>>>            //*** Call the driver function to fetch
29918>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLFETCH ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt ;                        Result iResult
29923>>>>>>>>>
29923>>>>>>>>>            //*** If something went wrong, adjust the result
29923>>>>>>>>>            If (Err) ;                Move 0 To iResult
29926>>>>>>>>>
29926>>>>>>>>>            Set piLastcolumn To 0
29927>>>>>>>>>        End
29927>>>>>>>>>>
29927>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetch"
29929>>>>>>>>>
29929>>>>>>>>>        Function_return iResult
29930>>>>>>>>>    End_Function // SQLFetch
29931>>>>>>>>>
29931>>>>>>>>>
29931>>>>>>>>>
29931>>>>>>>>>    //***
29931>>>>>>>>>    //*** Function: SQLNextColumn
29931>>>>>>>>>    //*** Purpose : Get the next column
29931>>>>>>>>>    //***
29931>>>>>>>>>
29931>>>>>>>>>    Function SQLNextColumn Returns String
29933>>>>>>>>>        Local Integer iCol
29933>>>>>>>>>        Local String  sResult
29933>>>>>>>>>
29933>>>>>>>>>        Get piLastColumn To iCol
29934>>>>>>>>>        Increment iCol
29935>>>>>>>>>        Get SQLColumnValue iCol To sResult
29936>>>>>>>>>        Set piLastColumn To iCol
29937>>>>>>>>>
29937>>>>>>>>>        Function_return sResult
29938>>>>>>>>>    End_Function // SQLNextColumn
29939>>>>>>>>>
29939>>>>>>>>>
29939>>>>>>>>>
29939>>>>>>>>>    //***
29939>>>>>>>>>    //*** Function: SQLColumnValue
29939>>>>>>>>>    //*** Purpose : Return the value of a column in a fetched row of a given
29939>>>>>>>>>    //***           statement.
29939>>>>>>>>>    //***
29939>>>>>>>>>
29939>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
29941>>>>>>>>>        Local Integer ihdbc
29941>>>>>>>>>        Local Integer ihstmt
29941>>>>>>>>>        Local String  sDrvrId
29941>>>>>>>>>        Local String  sResult
29941>>>>>>>>>
29941>>>>>>>>>        //*** Initialize
29941>>>>>>>>>        Move "" To sResult
29942>>>>>>>>>
29942>>>>>>>>>        //*** Get the cli handle to the connection
29942>>>>>>>>>        Get phCLIHandle       To ihstmt
29943>>>>>>>>>        Get psDriverId        To sDrvrId
29944>>>>>>>>>        Get phStmtConnection  To ihdbc
29945>>>>>>>>>
29945>>>>>>>>>        //*** Get the value
29945>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateColumnValue iCol ihdbc sDRvrId ihstmt To sResult
29948>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnValue"
29950>>>>>>>>>
29950>>>>>>>>>        Function_return sResult
29951>>>>>>>>>    End_Function // SQLColumnValue
29952>>>>>>>>>
29952>>>>>>>>>    Function SQLPrivateColumnValue Integer iCol Integer ihdbc String sDrvrId Integer ihstmt Returns String
29954>>>>>>>>>        Local Integer iVoid
29954>>>>>>>>>        Local Integer iColSize
29954>>>>>>>>>        Local Integer iColPrecision
29954>>>>>>>>>        Local String  sResult
29954>>>>>>>>>        Local String  sEmpty
29954>>>>>>>>>        Local Integer bLegalColumn
29954>>>>>>>>>
29954>>>>>>>>>        //*** Initialize
29954>>>>>>>>>        Move "" To sEmpty
29955>>>>>>>>>
29955>>>>>>>>>        //*** Get the value
29955>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
29957>>>>>>>>>            //*** Check if the column exists
29957>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol To bLegalColumn
29958>>>>>>>>>            If (bLegalColumn) Begin
29960>>>>>>>>>                //*** Determine the column size
29960>>>>>>>>>                Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SIZE ihdbc sDrvrId ihstmt to iColSize
29961>>>>>>>>>                Get SQLPrivateColAttribute iCol SQLCOLATTRIB_PRECISION ihdbc sDrvrId ihstmt to iColPrecision
29962>>>>>>>>>                If (iColSize > 0) Begin
29964>>>>>>>>>
29964>>>>>>>>>                    // Account for positions for a decimal point and a sign
29964>>>>>>>>>                    Move (iColSize + 1 + If(iColPrecision, iColPrecision + 1, 0)) to iColSize
29965>>>>>>>>>
29965>>>>>>>>>                    //*** Setup function arguments
29965>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                Callback Current_Object ;                                Passing ihdbc iCol ihstmt ;                                Result iVoid
29970>>>>>>>>>
29970>>>>>>>>>                    //*** Allocate
29970>>>>>>>>>                    Move (Repeat(' ', iColSize)) To sResult
29971>>>>>>>>>
29971>>>>>>>>>                    //*** Call the driver function to get the value
29971>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                                Callback Current_Object ;                                Passing sResult sEmpty 0 ;                                Result iVoid
29976>>>>>>>>>                End
29976>>>>>>>>>>
29976>>>>>>>>>            End
29976>>>>>>>>>>
29976>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColumnValue"
29978>>>>>>>>>        End
29978>>>>>>>>>>
29978>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColumnValue"
29980>>>>>>>>>
29980>>>>>>>>>        Function_return sResult
29981>>>>>>>>>    End_Function // SQLColumnValue
29982>>>>>>>>>
29982>>>>>>>>>
29982>>>>>>>>>
29982>>>>>>>>>    //***
29982>>>>>>>>>    //*** Procedure: SQLBindFile
29982>>>>>>>>>    //*** Purpose  : Add a file to the files used to place the statement result in.
29982>>>>>>>>>    //***
29982>>>>>>>>>
29982>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
29984>>>>>>>>>        Local Integer ihdbc
29984>>>>>>>>>        Local Integer ihstmt
29984>>>>>>>>>        Local Integer iVoid
29984>>>>>>>>>        Local String  sDrvrId
29984>>>>>>>>>        Local String  sFileType
29984>>>>>>>>>        Local Integer bIsOpen
29984>>>>>>>>>
29984>>>>>>>>>        //*** Get the cli handle to the connection
29984>>>>>>>>>        Get phCLIHandle       To ihstmt
29985>>>>>>>>>        Get psDriverId        To sDrvrId
29986>>>>>>>>>        Get phStmtConnection  To ihdbc
29987>>>>>>>>>
29987>>>>>>>>>        //*** If a file number is not passed see if we can use the statement's
29987>>>>>>>>>        //*** default file number which is usually set with SetFileConnection
29987>>>>>>>>>        If (iFileNum = 0) Begin
29989>>>>>>>>>            Get piBindFile To iFileNum
29990>>>>>>>>>            If (iFileNum = 0) Begin
29992>>>>>>>>>                //*** Logic error, if 0 is passed as filenumber, piBindFile should be set.
29992>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_BIND_FILE "piBindFile should be set" "SQLBindFile"
29993>>>>>>>>>
29993>>>>>>>>>                Move 0 to SQLResult
29994>>>>>>>>>                Procedure_Return
29995>>>>>>>>>            End
29995>>>>>>>>>>
29995>>>>>>>>>        End
29995>>>>>>>>>>
29995>>>>>>>>>
29995>>>>>>>>>        //*** Bind the file
29995>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
29997>>>>>>>>>            //*** Chek if the file is open
29997>>>>>>>>>            Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
30000>>>>>>>>>            If (bIsOpen) Begin
30002>>>>>>>>>                //*** Check if the file has the correct type
30002>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sFileType
30005>>>>>>>>>                If (sFileType = sDrvrId) Begin
30007>>>>>>>>>                    //*** Call the driver function to add a file to a statement
30007>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLBINDFILE ;                                Callback Current_Object ;                                Passing ihdbc iFileNum ihstmt ;                                Result iVoid
30012>>>>>>>>>                End
30012>>>>>>>>>>
30012>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
30014>>>>>>>>>            End
30014>>>>>>>>>>
30014>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File not open (number =" * String(iFileNum) + ")") "SQLBindFile"
30016>>>>>>>>>        End
30016>>>>>>>>>>
30016>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLBindFile"
30018>>>>>>>>>    End_Procedure // SQLBindFile
30019>>>>>>>>>
30019>>>>>>>>>
30019>>>>>>>>>
30019>>>>>>>>>    //*************************************************************************
30019>>>>>>>>>    //*** Function: SQLGetData                                              ***
30019>>>>>>>>>    //*** Purpose : Get data of a column.                                   ***
30019>>>>>>>>>    //*************************************************************************
30019>>>>>>>>>
30019>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
30021>>>>>>>>>        Local Integer ihdbc
30021>>>>>>>>>        Local Integer ihstmt
30021>>>>>>>>>        Local Integer iVoid
30021>>>>>>>>>        Local Integer iColSize
30021>>>>>>>>>        Local Integer iResult
30021>>>>>>>>>        Local String  sDrvrId
30021>>>>>>>>>        Local String  sResult
30021>>>>>>>>>        Local String  sEmpty
30021>>>>>>>>>        Local Integer bLegalColumn
30021>>>>>>>>>
30021>>>>>>>>>        //*** Initialize
30021>>>>>>>>>        Move "" To sEmpty
30022>>>>>>>>>        Move 0 To iResult
30023>>>>>>>>>
30023>>>>>>>>>        //*** Get the cli handle to the connection
30023>>>>>>>>>        Get phCLIHandle       To ihstmt
30024>>>>>>>>>        Get psDriverId        To sDrvrId
30025>>>>>>>>>        Get phStmtConnection  To ihdbc
30026>>>>>>>>>
30026>>>>>>>>>        //*** Get the data
30026>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
30028>>>>>>>>>            //*** Check if the column exists
30028>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol To bLegalColumn
30029>>>>>>>>>            If (bLegalColumn) Begin
30031>>>>>>>>>                If (iLen = 0) ;                    Get SQLPrivateColumnValue iCol ihdbc sDrvrId ihstmt To sResult
30034>>>>>>>>>                Else Begin
30035>>>>>>>>>                    //*** Setup function arguments
30035>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                Callback Current_Object ;                                Passing ihdbc iCol ihstmt ;                                Result iVoid
30040>>>>>>>>>
30040>>>>>>>>>                    //*** Allocate
30040>>>>>>>>>                    Move (Repeat(' ', iLen)) To sResult
30041>>>>>>>>>
30041>>>>>>>>>                    Indicate Err False
30042>>>>>>>>>
30042>>>>>>>>>                    //*** Call the driver function to get the data
30042>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLGETDATA ;                                Callback Current_Object ;                                Passing sResult sEmpty iLen ;                                Result iResult
30047>>>>>>>>>
30047>>>>>>>>>                    //*** If something went wrong, adjust the result
30047>>>>>>>>>                    If (Err) ;                        Move 0 To iResult
30050>>>>>>>>>                End
30050>>>>>>>>>>
30050>>>>>>>>>            End
30050>>>>>>>>>>
30050>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
30052>>>>>>>>>        End
30052>>>>>>>>>>
30052>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
30054>>>>>>>>>
30054>>>>>>>>>        //*** Fill global result
30054>>>>>>>>>        Move iResult To SQLResult
30055>>>>>>>>>
30055>>>>>>>>>        Function_Return sResult
30056>>>>>>>>>    End_Function // SQLGetData
30057>>>>>>>>>
30057>>>>>>>>>
30057>>>>>>>>>
30057>>>>>>>>>    //***
30057>>>>>>>>>    //*** Function: SQLColumnMap
30057>>>>>>>>>    //*** Purpose : Map a column name to a number, if the name id not found no
30057>>>>>>>>>    //***           error is generated the returned number will be 0 (zero) in
30057>>>>>>>>>    //***           that case
30057>>>>>>>>>    //***
30057>>>>>>>>>
30057>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
30059>>>>>>>>>        Local Integer ihdbc
30059>>>>>>>>>        Local Integer ihstmt
30059>>>>>>>>>        Local Integer iNumColumns
30059>>>>>>>>>        Local Integer iColCount
30059>>>>>>>>>        Local Integer iColNum
30059>>>>>>>>>        Local String  sDrvrId
30059>>>>>>>>>        Local String  sCurColName
30059>>>>>>>>>
30059>>>>>>>>>        //*** Get the cli handle to the connection
30059>>>>>>>>>        Get phCLIHandle       To ihstmt
30060>>>>>>>>>        Get psDriverId        To sDrvrId
30061>>>>>>>>>        Get phStmtConnection  To ihdbc
30062>>>>>>>>>
30062>>>>>>>>>        //*** Get the number by looping through the column names
30062>>>>>>>>>        Move 0 To iColNum
30063>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt To iNumColumns
30064>>>>>>>>>        For iColCount From 1 To iNumColumns
30070>>>>>>>>>>
30070>>>>>>>>>            Get SQLPrivateColAttribute iColCount SQLCOLATTRIB_LABEL ihdbc sDrvrId ihstmt To sCurColName
30071>>>>>>>>>            If (Uppercase(Trim(sColName)) = Uppercase(Trim(sCurColName))) ;                Move iColCount To iColNum
30074>>>>>>>>>
30074>>>>>>>>>            If (iColNum) ;                Break
30077>>>>>>>>>        Loop
30078>>>>>>>>>>
30078>>>>>>>>>
30078>>>>>>>>>        Function_return iColNum
30079>>>>>>>>>    End_Function // SQLColumnMap
30080>>>>>>>>>
30080>>>>>>>>>
30080>>>>>>>>>
30080>>>>>>>>>    //***
30080>>>>>>>>>    //*** Function: SQLStmtAttribute
30080>>>>>>>>>    //*** Purpose : Get a statement attribute
30080>>>>>>>>>    //***
30080>>>>>>>>>
30080>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
30082>>>>>>>>>        Local Integer ihdbc
30082>>>>>>>>>        Local Integer ihstmt
30082>>>>>>>>>        Local String  sResult
30082>>>>>>>>>        Local String  sDrvrId
30082>>>>>>>>>
30082>>>>>>>>>        //*** Initialize
30082>>>>>>>>>        Move "" To sResult
30083>>>>>>>>>
30083>>>>>>>>>        //*** Get the cli handle to the connection
30083>>>>>>>>>        Get phCLIHandle       To ihstmt
30084>>>>>>>>>        Get psDriverId        To sDrvrId
30085>>>>>>>>>        Get phStmtConnection  To ihdbc
30086>>>>>>>>>
30086>>>>>>>>>        //*** Get the attribute
30086>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateStmtAttribute iAttribId ihdbc sDrvrId ihstmt To sResult
30089>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLStmtAttribute"
30091>>>>>>>>>
30091>>>>>>>>>        Function_Return sResult
30092>>>>>>>>>    End_Function // SQLStmtAttibute
30093>>>>>>>>>
30093>>>>>>>>>    Function SQLPrivateStmtAttribute Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
30095>>>>>>>>>        Local String  sResult
30095>>>>>>>>>        Local Integer iLen
30095>>>>>>>>>        Local Integer bLegalAttrib
30095>>>>>>>>>
30095>>>>>>>>>        //*** Initialize
30095>>>>>>>>>        Move ""     To sResult
30096>>>>>>>>>
30096>>>>>>>>>        //*** Get the attribute
30096>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
30098>>>>>>>>>            Case Begin
30098>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
30100>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
30103>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
30106>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
30109>>>>>>>>>                    Move DFTRUE To bLegalAttrib
30110>>>>>>>>>                    Break
30111>>>>>>>>>
30111>>>>>>>>>                Case Else
30111>>>>>>>>>                    Move DFFALSE To bLegalAttrib
30112>>>>>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateStmtAttribute"
30113>>>>>>>>>            Case End
30113>>>>>>>>>
30113>>>>>>>>>            If (bLegalAttrib) Begin
30115>>>>>>>>>                //*** Setup function arguments
30115>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLSTMTINTATTRIB ;                            Callback Current_Object ;                            Passing ihdbc iAttribId ihstmt ;                            Result sResult
30120>>>>>>>>>            End
30120>>>>>>>>>>
30120>>>>>>>>>        End
30120>>>>>>>>>>
30120>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
30122>>>>>>>>>
30122>>>>>>>>>        Function_Return sResult
30123>>>>>>>>>    End_Function // SQLPrivateStmtAttribute
30124>>>>>>>>>
30124>>>>>>>>>
30124>>>>>>>>>
30124>>>>>>>>>    //***
30124>>>>>>>>>    //*** Function: SQLColAttribute
30124>>>>>>>>>    //*** Purpose : Get a column's attribute
30124>>>>>>>>>    //***
30124>>>>>>>>>
30124>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
30126>>>>>>>>>        Local Integer ihdbc
30126>>>>>>>>>        Local Integer ihstmt
30126>>>>>>>>>        Local String  sResult
30126>>>>>>>>>        Local String  sDrvrId
30126>>>>>>>>>
30126>>>>>>>>>        //*** Initialize
30126>>>>>>>>>        Move "" To sResult
30127>>>>>>>>>
30127>>>>>>>>>        //*** Get the cli handle to the connection
30127>>>>>>>>>        Get phCLIHandle       To ihstmt
30128>>>>>>>>>        Get psDriverId        To sDrvrId
30129>>>>>>>>>        Get phStmtConnection  To ihdbc
30130>>>>>>>>>
30130>>>>>>>>>        //*** Get the attribute
30130>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") ;            Get SQLPrivateColAttribute iCol iAttribId ihdbc sDrvrId ihstmt To sResult
30133>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColAttribute"
30135>>>>>>>>>
30135>>>>>>>>>        Function_Return sResult
30136>>>>>>>>>    End_Function // SQLColAttribute
30137>>>>>>>>>
30137>>>>>>>>>    Function SQLPrivateColAttribute Integer iCol Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
30139>>>>>>>>>        Local String  sResult
30139>>>>>>>>>        Local String  sEmpty
30139>>>>>>>>>        Local Integer bIsStringAttribute
30139>>>>>>>>>        Local Integer iLen
30139>>>>>>>>>        Local Integer iVoid
30139>>>>>>>>>        Local Integer bLegalAttrib
30139>>>>>>>>>        Local Integer bLegalColumn
30139>>>>>>>>>
30139>>>>>>>>>        //*** Initialize
30139>>>>>>>>>        Move "" To sResult
30140>>>>>>>>>        Move "" To sEmpty
30141>>>>>>>>>        MOve 0  To iLen
30142>>>>>>>>>
30142>>>>>>>>>        //*** Get the attribute
30142>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
30144>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol To bLegalColumn
30145>>>>>>>>>            If (bLegalColumn) Begin
30147>>>>>>>>>                //*** Determine the atributes type
30147>>>>>>>>>                Case Begin
30147>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SIZE)
30149>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LENGTH)
30152>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_PRECISION)
30155>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
30158>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_NULLABLE)
30161>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_DFTYPE)
30164>>>>>>>>>                        Move DFFALSE To bIsStringAttribute
30165>>>>>>>>>                        Move DFTRUE To bLegalAttrib
30166>>>>>>>>>                        Break
30167>>>>>>>>>
30167>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LABEL)
30170>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
30173>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
30176>>>>>>>>>                        Move DFTRUE To bIsStringAttribute
30177>>>>>>>>>                        Move DFTRUE To bLegalAttrib
30178>>>>>>>>>                        Break
30179>>>>>>>>>
30179>>>>>>>>>                    Case Else
30179>>>>>>>>>                        Move DFFALSE To bLegalAttrib
30180>>>>>>>>>                        Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateColAttribute"
30181>>>>>>>>>                Case End
30181>>>>>>>>>
30181>>>>>>>>>                If (bLegalAttrib) Begin
30183>>>>>>>>>                    //*** Setup function arguments
30183>>>>>>>>>                    Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                                Callback Current_Object ;                                Passing ihdbc iCol ihstmt ;                                Result iVoid
30188>>>>>>>>>
30188>>>>>>>>>                    If (bIsStringAttribute) Begin
30190>>>>>>>>>                        //*** Call the driver function to get the data length
30190>>>>>>>>>                        Call_driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIBLEN ;                                    Callback Current_Object ;                                    Passing sEmpty sEmpty iAttribId ;                                    Result iLen
30195>>>>>>>>>
30195>>>>>>>>>                        If (iLen) Begin
30197>>>>>>>>>                            //*** Allocate
30197>>>>>>>>>                            Move (Repeat(' ', iLen)) To sResult
30198>>>>>>>>>
30198>>>>>>>>>                            //*** Call the driver function to get the name
30198>>>>>>>>>                            Call_driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIB ;                                        Callback Current_Object ;                                        Passing sResult sEmpty iAttribId ;                                        Result iVoid
30203>>>>>>>>>                        End
30203>>>>>>>>>>
30203>>>>>>>>>                    End
30203>>>>>>>>>>
30203>>>>>>>>>                    Else Begin
30204>>>>>>>>>                        //*** get the attribute
30204>>>>>>>>>                        Call_driver 0 sDrvrId Function FUNC_SQLCOLINTATTRIB ;                                    Callback Current_Object ;                                    Passing sEmpty sEmpty iAttribId ;                                    Result sResult
30209>>>>>>>>>                    End
30209>>>>>>>>>>
30209>>>>>>>>>                End
30209>>>>>>>>>>
30209>>>>>>>>>            End
30209>>>>>>>>>>
30209>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColAttribute"
30211>>>>>>>>>        End
30211>>>>>>>>>>
30211>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColAttribute"
30213>>>>>>>>>
30213>>>>>>>>>        Function_Return sResult
30214>>>>>>>>>    End_Function // SQLPrivateColAttribute
30215>>>>>>>>>
30215>>>>>>>>>
30215>>>>>>>>>
30215>>>>>>>>>    //***
30215>>>>>>>>>    //*** Procedure: SQLSetProcedureName
30215>>>>>>>>>    //*** Purpsoe  : Preapre for calling a stored procedure, pass the procedure name.
30215>>>>>>>>>    //***
30215>>>>>>>>>
30215>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
30217>>>>>>>>>        Local Integer ihdbc
30217>>>>>>>>>        Local Integer ihstmt
30217>>>>>>>>>        Local String  sDrvrId
30217>>>>>>>>>        Local Integer iVoid
30217>>>>>>>>>        Local String  sSchema
30217>>>>>>>>>        Local String  sEmpty
30217>>>>>>>>>
30217>>>>>>>>>        //*** Initialize
30217>>>>>>>>>        Move "" To sEmpty
30218>>>>>>>>>
30218>>>>>>>>>        //*** Get the cli handle to the connection
30218>>>>>>>>>        Get phCLIHandle       To ihstmt
30219>>>>>>>>>        Get psDriverId        To sDrvrId
30220>>>>>>>>>        Get phStmtConnection  To ihdbc
30221>>>>>>>>>
30221>>>>>>>>>        //*** Call the procedure
30221>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
30223>>>>>>>>>            If (Num_Arguments >= 2) ;                Move sSchemaArg To sSchema
30226>>>>>>>>>            Else ;                Move "" To sSchema
30228>>>>>>>>>
30228>>>>>>>>>            If (sSchema <> "") Begin
30230>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLSETPROCSCHEMA ;                            Callback Current_Object ;                            Passing ihdbc sSchema ihstmt ;                            Result iVoid
30235>>>>>>>>>            End
30235>>>>>>>>>>
30235>>>>>>>>>
30235>>>>>>>>>            //*** Call the procedure
30235>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLSETPROCNAME ;                        Callback Current_Object ;                        Passing ihdbc sProcName ihstmt ;                        Result iVoid
30240>>>>>>>>>
30240>>>>>>>>>            Set piLastArgument To 0
30241>>>>>>>>>        End
30241>>>>>>>>>>
30241>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetProcedurename"
30243>>>>>>>>>    End_Procedure // SQLSetProcedureName
30244>>>>>>>>>
30244>>>>>>>>>
30244>>>>>>>>>
30244>>>>>>>>>    //***
30244>>>>>>>>>    //*** Function: SQLSetNextArgument
30244>>>>>>>>>    //*** Purpose : Pass the next argument
30244>>>>>>>>>    //***
30244>>>>>>>>>
30244>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
30246>>>>>>>>>        Local Integer iArgnum
30246>>>>>>>>>
30246>>>>>>>>>        Get piLastArgument To iArgnum
30247>>>>>>>>>        Increment iArgnum
30248>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
30249>>>>>>>>>        Set piLastArgument To iArgnum
30250>>>>>>>>>    End_Procedure // SQLSetNextArgument
30251>>>>>>>>>
30251>>>>>>>>>
30251>>>>>>>>>
30251>>>>>>>>>    //***
30251>>>>>>>>>    //*** Procedure: SQLSetArgument
30251>>>>>>>>>    //*** Purpose  : Set the next argument
30251>>>>>>>>>    //***
30251>>>>>>>>>
30251>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
30253>>>>>>>>>        Local Integer ihdbc
30253>>>>>>>>>        Local Integer ihstmt
30253>>>>>>>>>        Local String  sDrvrId
30253>>>>>>>>>        Local Integer iVoid
30253>>>>>>>>>        Local String  sEmpty
30253>>>>>>>>>
30253>>>>>>>>>        //*** Initialize
30253>>>>>>>>>        Move "" To sEmpty
30254>>>>>>>>>
30254>>>>>>>>>        //*** Get the cli handle to the connection
30254>>>>>>>>>        Get phCLIHandle       To ihstmt
30255>>>>>>>>>        Get psDriverId        To sDrvrId
30256>>>>>>>>>        Get phStmtConnection  To ihdbc
30257>>>>>>>>>
30257>>>>>>>>>        //*** Call the procedure
30257>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
30259>>>>>>>>>            //*** Pass the information
30259>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Current_Object ;                        Passing ihdbc iArgnum ihstmt ;                        Result iVoid
30264>>>>>>>>>
30264>>>>>>>>>            //*** Pass the argument
30264>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                        Callback Current_Object ;                        Passing sArgument sEmpty 0 ;                        Result iVoid
30269>>>>>>>>>        End
30269>>>>>>>>>>
30269>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetArgument"
30271>>>>>>>>>    End_Procedure // SQLSetArgument
30272>>>>>>>>>
30272>>>>>>>>>
30272>>>>>>>>>
30272>>>>>>>>>    //***
30272>>>>>>>>>    //*** Procedure: SQLCall
30272>>>>>>>>>    //*** Purpose  : Call a stored procedure
30272>>>>>>>>>    //***
30272>>>>>>>>>
30272>>>>>>>>>    Procedure SQLCall
30274>>>>>>>>>        Local Integer ihdbc
30274>>>>>>>>>        Local Integer ihstmt
30274>>>>>>>>>        Local String  sDrvrId
30274>>>>>>>>>        Local Integer iVoid
30274>>>>>>>>>        Local String  sEmpty
30274>>>>>>>>>
30274>>>>>>>>>        //*** Initialize
30274>>>>>>>>>        Move "" To sEmpty
30275>>>>>>>>>
30275>>>>>>>>>        //*** Get the cli handle to the connection
30275>>>>>>>>>        Get phCLIHandle       To ihstmt
30276>>>>>>>>>        Get psDriverId        To sDrvrId
30277>>>>>>>>>        Get phStmtConnection  To ihdbc
30278>>>>>>>>>
30278>>>>>>>>>        //*** Call the procedure
30278>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
30280>>>>>>>>>            //*** Call the procedure
30280>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCALL ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt ;                        Result iVoid
30285>>>>>>>>>
30285>>>>>>>>>            Set piLastArgument To 0
30286>>>>>>>>>        End
30286>>>>>>>>>>
30286>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLCall"
30288>>>>>>>>>    End_Procedure // SQLCall
30289>>>>>>>>>
30289>>>>>>>>>
30289>>>>>>>>>
30289>>>>>>>>>    //***
30289>>>>>>>>>    //*** Function: SQLGetNextArgument
30289>>>>>>>>>    //*** Purpose : Get the next argument
30289>>>>>>>>>    //***
30289>>>>>>>>>
30289>>>>>>>>>    Function SQLGetNextArgument Returns String
30291>>>>>>>>>        Local Integer iArgnum
30291>>>>>>>>>        Local String  sResult
30291>>>>>>>>>
30291>>>>>>>>>        Get piLastArgument To iArgnum
30292>>>>>>>>>        Increment iArgnum
30293>>>>>>>>>        Get SQLGetArgument iArgnum To sResult
30294>>>>>>>>>        Set piLastArgument To iArgnum
30295>>>>>>>>>
30295>>>>>>>>>        Function_return sResult
30296>>>>>>>>>    End_Function // SQLGetNextArgument
30297>>>>>>>>>
30297>>>>>>>>>
30297>>>>>>>>>
30297>>>>>>>>>    //***
30297>>>>>>>>>    //*** Function: SQLGetArgument
30297>>>>>>>>>    //*** Purpose : Get the specified argument from a procedure
30297>>>>>>>>>    //***
30297>>>>>>>>>
30297>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
30299>>>>>>>>>        Local Integer ihdbc
30299>>>>>>>>>        Local Integer ihstmt
30299>>>>>>>>>        Local String  sDrvrId
30299>>>>>>>>>        Local Integer iVoid
30299>>>>>>>>>        Local String  sEmpty
30299>>>>>>>>>        Local String  sArgument
30299>>>>>>>>>        Local Integer iLen
30299>>>>>>>>>
30299>>>>>>>>>        //*** Initialize
30299>>>>>>>>>        Move "" To sEmpty
30300>>>>>>>>>        Move "" To sArgument
30301>>>>>>>>>
30301>>>>>>>>>        //*** Get the cli handle to the connection
30301>>>>>>>>>        Get phCLIHandle       To ihstmt
30302>>>>>>>>>        Get psDriverId        To sDrvrId
30303>>>>>>>>>        Get phStmtConnection  To ihdbc
30304>>>>>>>>>
30304>>>>>>>>>        //*** Call the procedure
30304>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
30306>>>>>>>>>            //*** Pass the information
30306>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Current_Object ;                        Passing ihdbc iArgnum ihstmt ;                        Result iVoid
30311>>>>>>>>>
30311>>>>>>>>>            //*** Get the length
30311>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETPROCARGLEN ;                        Callback Current_Object ;                        Passing sEmpty sEmpty 0 ;                        Result iLen
30316>>>>>>>>>
30316>>>>>>>>>            If (iLen) Begin
30318>>>>>>>>>                //*** Allocate
30318>>>>>>>>>                Move (Repeat(' ', iLen)) To sArgument
30319>>>>>>>>>
30319>>>>>>>>>                //*** Pass the argument
30319>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLGETPROCARG ;                            Callback Current_Object ;                            Passing sArgument sEmpty 0 ;                            Result iVoid
30324>>>>>>>>>            End
30324>>>>>>>>>>
30324>>>>>>>>>        End
30324>>>>>>>>>>
30324>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetArgument"
30326>>>>>>>>>
30326>>>>>>>>>        Function_Return sArgument
30327>>>>>>>>>    End_Function // SQLGetArgument
30328>>>>>>>>>
30328>>>>>>>>>
30328>>>>>>>>>
30328>>>>>>>>>    //***
30328>>>>>>>>>    //*** Function: SQLReturnValue
30328>>>>>>>>>    //*** Purpose : Get the reutn value of a stored function
30328>>>>>>>>>    //***
30328>>>>>>>>>
30328>>>>>>>>>    Function SQLReturnValue Returns String
30330>>>>>>>>>        Local Integer ihdbc
30330>>>>>>>>>        Local Integer ihstmt
30330>>>>>>>>>        Local String  sDrvrId
30330>>>>>>>>>        Local Integer iVoid
30330>>>>>>>>>        Local String  sEmpty
30330>>>>>>>>>        Local String  sRetval
30330>>>>>>>>>        Local Integer iLen
30330>>>>>>>>>
30330>>>>>>>>>        //*** Initialize
30330>>>>>>>>>        Move "" To sEmpty
30331>>>>>>>>>        Move "" To sRetval
30332>>>>>>>>>
30332>>>>>>>>>        //*** Get the cli handle to the connection
30332>>>>>>>>>        Get phCLIHandle       To ihstmt
30333>>>>>>>>>        Get psDriverId        To sDrvrId
30334>>>>>>>>>        Get phStmtConnection  To ihdbc
30335>>>>>>>>>
30335>>>>>>>>>        //*** Call the procedure
30335>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
30337>>>>>>>>>            //*** Get the length
30337>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETPROCRETVALLEN ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt  ;                        Result iLen
30342>>>>>>>>>
30342>>>>>>>>>            If (iLen) Begin
30344>>>>>>>>>                //*** Allocate
30344>>>>>>>>>                Move (Repeat(' ', iLen)) To sRetval
30345>>>>>>>>>
30345>>>>>>>>>                //*** Pass the argument
30345>>>>>>>>>                Call_driver 0 sDrvrId Function FUNC_SQLGETPROCRETVAL ;                            Callback Current_Object ;                            Passing ihdbc sRetval ihstmt ;                            Result iVoid
30350>>>>>>>>>            End
30350>>>>>>>>>>
30350>>>>>>>>>        End
30350>>>>>>>>>>
30350>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLReturnValue"
30352>>>>>>>>>
30352>>>>>>>>>        Function_Return sRetval
30353>>>>>>>>>    End_Function // SQLReturnValue
30354>>>>>>>>>
30354>>>>>>>>>
30354>>>>>>>>>
30354>>>>>>>>>    //***
30354>>>>>>>>>    //*** Function: SQLNextResultSet
30354>>>>>>>>>    //*** Purpose : Switch to the next set
30354>>>>>>>>>    //*** Returns : 0   = No more result sets
30354>>>>>>>>>    //***           <>0 = Switched to next set
30354>>>>>>>>>    //***
30354>>>>>>>>>
30354>>>>>>>>>    Function SQLNextResultSet Returns Integer
30356>>>>>>>>>        Local Integer ihdbc
30356>>>>>>>>>        Local Integer ihstmt
30356>>>>>>>>>        Local String  sDrvrId
30356>>>>>>>>>        Local Integer iResult
30356>>>>>>>>>        Local String  sEmpty
30356>>>>>>>>>
30356>>>>>>>>>        //*** Initialize
30356>>>>>>>>>        Move "" To sEmpty
30357>>>>>>>>>        Move 0  To iResult
30358>>>>>>>>>
30358>>>>>>>>>        //*** Get the cli handle to the connection
30358>>>>>>>>>        Get phCLIHandle       To ihstmt
30359>>>>>>>>>        Get psDriverId        To sDrvrId
30360>>>>>>>>>        Get phStmtConnection  To ihdbc
30361>>>>>>>>>
30361>>>>>>>>>        //*** Call the procedure
30361>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
30363>>>>>>>>>            //*** Get the length
30363>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLNEXTRESULTSET ;                        Callback Current_Object ;                        Passing ihdbc sEmpty ihstmt  ;                        Result iResult
30368>>>>>>>>>
30368>>>>>>>>>            Set piLastArgument To 0
30369>>>>>>>>>        End
30369>>>>>>>>>>
30369>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLNextResultSet"
30371>>>>>>>>>
30371>>>>>>>>>        Function_Return iResult
30372>>>>>>>>>    End_Function // SQLNextResultSet
30373>>>>>>>>>
30373>>>>>>>>>
30373>>>>>>>>>
30373>>>>>>>>>    //***
30373>>>>>>>>>    //*** Procedure: SQLFetchActivatesBuffer
30373>>>>>>>>>    //*** Purpose  : Setup a file that will be acivated after a succesfull
30373>>>>>>>>>    //***            fetch on the statement
30373>>>>>>>>>    //***
30373>>>>>>>>>
30373>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
30375>>>>>>>>>        Local Integer ihdbc
30375>>>>>>>>>        Local Integer ihstmt
30375>>>>>>>>>        Local String  sDrvrId
30375>>>>>>>>>        Local Integer iResult
30375>>>>>>>>>        Local Integer bIsOpen
30375>>>>>>>>>        Local Integer iVoid
30375>>>>>>>>>        Local String  sFileType
30375>>>>>>>>>
30375>>>>>>>>>        //*** Check if file is open
30375>>>>>>>>>        Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
30378>>>>>>>>>        If (bIsOpen) Begin
30380>>>>>>>>>            //*** Get the cli handle to the connection
30380>>>>>>>>>            Get phCLIHandle       To ihstmt
30381>>>>>>>>>            Get psDriverId        To sDrvrId
30382>>>>>>>>>            Get phStmtConnection  To ihdbc
30383>>>>>>>>>
30383>>>>>>>>>            //*** Call the procedure
30383>>>>>>>>>            If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
30385>>>>>>>>>                //*** Check if the file has the correct type
30385>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sFileType
30388>>>>>>>>>                If (sFileType = sDrvrId) Begin
30390>>>>>>>>>                    //*** Setup the buffer
30390>>>>>>>>>                    Call_driver iFileNum sDrvrId Function FUNC_SQLBUFFERSTATUS ;                                Callback Current_Object ;                                Passing ihdbc bState ihstmt  ;                                Result iVoid
30395>>>>>>>>>                End
30395>>>>>>>>>>
30395>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
30397>>>>>>>>>            End
30397>>>>>>>>>>
30397>>>>>>>>>            Else ;                Send HandleError ihstmt ihdbc sDrvrId "SQLFetchActivatesBuffer"
30399>>>>>>>>>        End
30399>>>>>>>>>>
30399>>>>>>>>>        Else ;            Send StmtError CLIERR_SQLINVALID_BUFFER ("File not open (number =" * String(iFileNum) + ")") "SQLFetchActivatesBuffer"
30401>>>>>>>>>    End_Procedure // SQLFetchActivatesBuffer
30402>>>>>>>>>
30402>>>>>>>>>
30402>>>>>>>>>
30402>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
30404>>>>>>>>>        Local Integer ihdbc
30404>>>>>>>>>        Local Integer ihstmt
30404>>>>>>>>>        Local String  sDrvrId
30404>>>>>>>>>        Local String  sMessage
30404>>>>>>>>>        Local Integer iVoid
30404>>>>>>>>>
30404>>>>>>>>>        //*** Initialize
30404>>>>>>>>>        Move "" To sMessage
30405>>>>>>>>>
30405>>>>>>>>>        //*** Get the cli handle to the connection
30405>>>>>>>>>        Get phCLIHandle       To ihstmt
30406>>>>>>>>>        Get psDriverId        To sDrvrId
30407>>>>>>>>>        Get phStmtConnection  To ihdbc
30408>>>>>>>>>
30408>>>>>>>>>        //*** Call the procedure
30408>>>>>>>>>        If (ihstmt <> 0 And ihdbc <> 0 And sDrvrId <> "") Begin
30410>>>>>>>>>            //*** Setup function arguments
30410>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Current_Object ;                        Passing ihdbc iMessageNum ihstmt ;                        Result iVoid
30415>>>>>>>>>
30415>>>>>>>>>            Move (Repeat(' ', 1024)) To sMessage
30416>>>>>>>>>            //*** Get the length
30416>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLGETMESSAGE ;                        Callback Current_Object ;                        Passing iVoid sMessage iVoid ;                        Result iVoid
30421>>>>>>>>>        End
30421>>>>>>>>>>
30421>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetDiagRec"
30423>>>>>>>>>
30423>>>>>>>>>        Function_Return sMessage
30424>>>>>>>>>    End_Function // SQLGetMessage
30425>>>>>>>>>
30425>>>>>>>>>
30425>>>>>>>>>
30425>>>>>>>>>    //***
30425>>>>>>>>>    //*** Function: RemoveComponentIdentifier
30425>>>>>>>>>    //*** Purpose : Remove the component identifier from a diagnostic message
30425>>>>>>>>>    //***
30425>>>>>>>>>
30425>>>>>>>>>    Function RemoveComponentIdentifier String sDiagMessage Returns String
30427>>>>>>>>>        While (Left(sDiagMessage, 1) = "[")
30431>>>>>>>>>            Move (Right(sDiagMessage, Length(sDiagMessage) - Pos("]", sDiagMessage))) To sDiagMessage
30432>>>>>>>>>        End
30433>>>>>>>>>>
30433>>>>>>>>>
30433>>>>>>>>>        Function_Return sDiagMessage
30434>>>>>>>>>    End_Function
30435>>>>>>>>>
30435>>>>>>>>>
30435>>>>>>>>>
30435>>>>>>>>>    //***
30435>>>>>>>>>    //*** Function: DFDateToSQLDate
30435>>>>>>>>>    //*** Purpose : Convert a DataFlex date to a SQL Date. Use dummy zero dates.
30435>>>>>>>>>    //***
30435>>>>>>>>>
30435>>>>>>>>>    Function DFDateToSQLDate Date dDFDate Returns String
30437>>>>>>>>>        Local Integer hoCLIHandler
30437>>>>>>>>>        Local String sSQLDate
30437>>>>>>>>>
30437>>>>>>>>>        //*** Create a CLI handler object
30437>>>>>>>>>        Object oDFSQLCLIHandler Is A cCLIHandler
30439>>>>>>>>>            Move Current_Object To hoCLIHandler
30440>>>>>>>>>        End_object // oCLIHandler
30441>>>>>>>>>
30441>>>>>>>>>        //*** Convert the date
30441>>>>>>>>>        Get CLIDFDateToSQLDate Of hoCLIHandler (psDRiverID(Current_Object)) dDFDate To sSQLDate
30442>>>>>>>>>
30442>>>>>>>>>        //*** Destroy the object
30442>>>>>>>>>        Send Destroy_Object To hoCLIHandler
30443>>>>>>>>>
30443>>>>>>>>>        Function_Return sSQLDate
30444>>>>>>>>>    End_Function // DFDateToSQLDate
30445>>>>>>>>>
30445>>>>>>>>>
30445>>>>>>>>>
30445>>>>>>>>>    //***
30445>>>>>>>>>    //*** Function: SQLDateToDFDate
30445>>>>>>>>>    //*** Purpose : Convert a SQL date to a DataFlex Date. Use dummy zero dates.
30445>>>>>>>>>    //***
30445>>>>>>>>>
30445>>>>>>>>>    // { Visibility=Private }
30445>>>>>>>>>    Function SQLDateToDFDate String sSQLDate Returns String
30447>>>>>>>>>        Local Integer hoCLIHandler
30447>>>>>>>>>        Local Date dDFDate
30447>>>>>>>>>
30447>>>>>>>>>        //*** Create a CLI handler object
30447>>>>>>>>>        Object oSQLDFCLIHandler Is A cCLIHandler
30449>>>>>>>>>            Move Current_Object To hoCLIHandler
30450>>>>>>>>>        End_object // oCLIHandler
30451>>>>>>>>>
30451>>>>>>>>>        //*** Convert the date
30451>>>>>>>>>        Get CLISQLDateToDFDate Of hoCLIHandler (psDRiverID(Current_Object)) sSQLDate To dDFDate
30452>>>>>>>>>
30452>>>>>>>>>        //*** Destroy the object
30452>>>>>>>>>        Send Destroy_Object To hoCLIHandler
30453>>>>>>>>>
30453>>>>>>>>>        Function_Return dDFDate
30454>>>>>>>>>    End_Function // SQLDateToDFDate
30455>>>>>>>>>
30455>>>>>>>>>End_Class // cSQLStatement
30456>>>>>>>>>
30456>>>>>>>>>
30456>>>>>>>>>//*****************************************************************************
30456>>>>>>>>>//*** Class  : cSQLConnection                                               ***
30456>>>>>>>>>//*** Purpose: Connection object for embedded SQL                           ***
30456>>>>>>>>>//***                                                                       ***
30456>>>>>>>>>//*** Description:                                                          ***
30456>>>>>>>>>//***   This provides the ability to create a connection for a driver.      ***
30456>>>>>>>>>//***   It will contain child statement objects                             ***
30456>>>>>>>>>//*****************************************************************************
30456>>>>>>>>>
30456>>>>>>>>>Class cSQLConnection is an Array
30457>>>>>>>>>
30457>>>>>>>>>    Procedure Construct_object Integer Image
30459>>>>>>>>>        Forward Send Construct_object Image
30461>>>>>>>>>
30461>>>>>>>>>        Property Integer phCLIHandle      Public 0
30462>>>>>>>>>        Property String  psDriverID       Public ""
30463>>>>>>>>>        Property Integer piBindFile       Public 0
30464>>>>>>>>>
30464>>>>>>>>>        Set Delegation_mode to NO_Delegation
30465>>>>>>>>>    End_procedure // COnstruct_object
30466>>>>>>>>>
30466>>>>>>>>>
30466>>>>>>>>>
30466>>>>>>>>>    //***
30466>>>>>>>>>    //*** Procedure: StoreHandleInfo
30466>>>>>>>>>    //*** Purpose  : Store basic information about the statement handle.
30466>>>>>>>>>    //***
30466>>>>>>>>>
30466>>>>>>>>>    Procedure StoreHandleInfo Integer iCLIHandle String sDrvrId Integer iParentHandle
30468>>>>>>>>>        Set phCLIHandle      To iCLIHandle
30469>>>>>>>>>        Set psDriverID       To sDrvrId
30470>>>>>>>>>    End_Procedure // StoreHandleInfo
30471>>>>>>>>>
30471>>>>>>>>>
30471>>>>>>>>>
30471>>>>>>>>>    //***
30471>>>>>>>>>    //*** Procedure: FreeHandle
30471>>>>>>>>>    //*** Purpose : Destroys handle object and all child statement objects
30471>>>>>>>>>    //***
30471>>>>>>>>>
30471>>>>>>>>>    Procedure FreeHandle
30473>>>>>>>>>        Send Destroy_Object
30474>>>>>>>>>    End_Procedure // FreeHandle
30475>>>>>>>>>
30475>>>>>>>>>
30475>>>>>>>>>
30475>>>>>>>>>    //***
30475>>>>>>>>>    //*** Function: SQLConnect
30475>>>>>>>>>    //*** Purpose : Make a connectin to an embedded SQL server
30475>>>>>>>>>    //*** Returns : The DataFlex handle to the connection
30475>>>>>>>>>    //***
30475>>>>>>>>>
30475>>>>>>>>>    Function SQLConnect string sDrvrID String sConnect Returns Integer
30477>>>>>>>>>        Local Integer ihdbc
30477>>>>>>>>>        Local String  sEmpty
30477>>>>>>>>>
30477>>>>>>>>>        //*** Initialize
30477>>>>>>>>>        Move "" To sEmpty
30478>>>>>>>>>        Move 0  To ihdbc
30479>>>>>>>>>
30479>>>>>>>>>        Indicate Err False
30480>>>>>>>>>
30480>>>>>>>>>        //*** Call the driver function to connect
30480>>>>>>>>>        Call_driver 0 sDrvrId Function FUNC_SQLCONNECT ;                    Callback current_object ;                    Passing sConnect sEmpty Current_object ;                    Result ihdbc
30485>>>>>>>>>
30485>>>>>>>>>        //*** If there was an error, make result invalid
30485>>>>>>>>>        If (Err) ;            Move 0 To ihdbc
30488>>>>>>>>>
30488>>>>>>>>>        //*** Check result and store it
30488>>>>>>>>>        If (ihdbc <> 0) ;            Send StoreHandleInfo ihdbc sDrvrId 0
30491>>>>>>>>>
30491>>>>>>>>>        //*** Return success status
30491>>>>>>>>>        Function_Return (ihdbc <> 0)
30492>>>>>>>>>    End_function // SQLConnect
30493>>>>>>>>>
30493>>>>>>>>>
30493>>>>>>>>>
30493>>>>>>>>>    //***
30493>>>>>>>>>    //*** Function: SQLFileConnect
30493>>>>>>>>>    //*** Purpose : Use a connection of an already open file
30493>>>>>>>>>    //***
30493>>>>>>>>>
30493>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
30495>>>>>>>>>        Local Integer ihdbc
30495>>>>>>>>>        Local Integer bIsOpen
30495>>>>>>>>>        Local String  sDrvrId
30495>>>>>>>>>        Local String  sEmpty
30495>>>>>>>>>
30495>>>>>>>>>        //*** Initialize
30495>>>>>>>>>        Move "" To sEmpty
30496>>>>>>>>>        Move 0  To ihdbc
30497>>>>>>>>>
30497>>>>>>>>>        //*** Check if file is open
30497>>>>>>>>>        Get_attribute DF_FILE_OPENED Of iFileNum To bIsOpen
30500>>>>>>>>>        If (bIsOpen) Begin
30502>>>>>>>>>            //*** Fill the driver id, assume longest is 255 characters
30502>>>>>>>>>            Move (Repeat(' ', 255)) To sDrvrId
30503>>>>>>>>>            Get_attribute DF_FILE_DRIVER Of iFileNum To sDrvrId
30506>>>>>>>>>
30506>>>>>>>>>            Indicate Err False
30507>>>>>>>>>
30507>>>>>>>>>            //*** Call the driver function to connect
30507>>>>>>>>>            Call_driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;                        Callback current_object ;                        Passing sEmpty sEmpty 0 ;                        Result ihdbc
30512>>>>>>>>>
30512>>>>>>>>>            //*** If there was an error, make result invalid
30512>>>>>>>>>            If (Err) ;                Move 0 To ihdbc
30515>>>>>>>>>
30515>>>>>>>>>            //*** Check result and store it
30515>>>>>>>>>            If (ihdbc <> 0) Begin
30517>>>>>>>>>                //*** Somehow Call_driver overwrites the sDrvrId variable, restore it here
30517>>>>>>>>>                Get_attribute DF_FILE_DRIVER Of iFileNum To sDrvrId
30520>>>>>>>>>                Send StoreHandleInfo ihdbc sDrvrId 0
30521>>>>>>>>>
30521>>>>>>>>>                //*** Set filenum so it can be used for fetching
30521>>>>>>>>>                Set piBindFile To iFileNum
30522>>>>>>>>>            End
30522>>>>>>>>>>
30522>>>>>>>>>        End
30522>>>>>>>>>>
30522>>>>>>>>>
30522>>>>>>>>>        //*** Return success status
30522>>>>>>>>>        Function_Return (ihdbc <> 0)
30523>>>>>>>>>    End_Function // SQLFileConnect
30524>>>>>>>>>
30524>>>>>>>>>
30524>>>>>>>>>
30524>>>>>>>>>    //***
30524>>>>>>>>>    //*** Procedure: SQLDisconnect
30524>>>>>>>>>    //*** Purpose  : Disconnect from an embedded SQL server and free allocated
30524>>>>>>>>>    //***            resources
30524>>>>>>>>>    //***
30524>>>>>>>>>
30524>>>>>>>>>    Procedure SQLDisconnect
30526>>>>>>>>>        Local Integer ihdbc
30526>>>>>>>>>        Local Integer iVoid
30526>>>>>>>>>        Local String  sDrvrId
30526>>>>>>>>>        Local String  sEmpty
30526>>>>>>>>>
30526>>>>>>>>>        //*** Initialize
30526>>>>>>>>>        Move "" To sEmpty
30527>>>>>>>>>
30527>>>>>>>>>        //*** Get the cli handle
30527>>>>>>>>>        Get phCLIHandle To ihdbc
30528>>>>>>>>>        Get psDriverId To sDrvrId
30529>>>>>>>>>
30529>>>>>>>>>        //*** Free the CLI handle
30529>>>>>>>>>        If (ihdbc <> 0) Begin
30531>>>>>>>>>            //*** Call the driver function to disconnect
30531>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLDISCONNECT ;                        Callback Current_object ;                        Passing sEmpty sEmpty ihdbc ;                        Result iVoid
30536>>>>>>>>>
30536>>>>>>>>>            //*** Free the DataFlex handle
30536>>>>>>>>>            Send FreeHandle
30537>>>>>>>>>        End
30537>>>>>>>>>>
30537>>>>>>>>>    End_Procedure // SQLDisconnect
30538>>>>>>>>>
30538>>>>>>>>>
30538>>>>>>>>>
30538>>>>>>>>>    //***
30538>>>>>>>>>    //*** Function: CreateHandle
30538>>>>>>>>>    //*** Purpose : Creates a child statement handle
30538>>>>>>>>>    //***
30538>>>>>>>>>
30538>>>>>>>>>    Function CreateHandle Returns Integer
30540>>>>>>>>>        Local Integer hSQL
30540>>>>>>>>>
30540>>>>>>>>>        Object oSQLStatement Is A cSQLStatement
30542>>>>>>>>>            Move current_object To hSQL
30543>>>>>>>>>        End_Object // oSQLStatement
30544>>>>>>>>>
30544>>>>>>>>>        //*** If the connection has a default Bind File, assign it to the
30544>>>>>>>>>        //*** statement object. The default is set when you open a file with a
30544>>>>>>>>>        //*** SetFileConnection command.
30544>>>>>>>>>        Set piBindFile Of hSQL To (piBindFile(Current_object))
30545>>>>>>>>>
30545>>>>>>>>>        Function_Return hSQL
30546>>>>>>>>>    End_Function // CreateHandle
30547>>>>>>>>>
30547>>>>>>>>>
30547>>>>>>>>>
30547>>>>>>>>>    //***
30547>>>>>>>>>    //*** Function: SQLOpen
30547>>>>>>>>>    //*** Prupose : Open a statement for use
30547>>>>>>>>>    //***
30547>>>>>>>>>
30547>>>>>>>>>    Function SQLOpen Returns Integer
30549>>>>>>>>>        Local Integer hDFHandle
30549>>>>>>>>>        Local Integer ihdbc
30549>>>>>>>>>        Local Integer ihstmt
30549>>>>>>>>>        Local Integer iVoid
30549>>>>>>>>>        Local String  sDrvrId
30549>>>>>>>>>        Local String  sEmpty
30549>>>>>>>>>
30549>>>>>>>>>        //*** Initialize
30549>>>>>>>>>        Move "" To sEmpty
30550>>>>>>>>>
30550>>>>>>>>>        //*** Get the cli handle to the connection
30550>>>>>>>>>        Get phCLIHandle To ihdbc
30551>>>>>>>>>        Get psDriverId  To sDrvrId
30552>>>>>>>>>
30552>>>>>>>>>        //*** Allocate a new handle and populate it
30552>>>>>>>>>        If (ihdbc <> 0) Begin
30554>>>>>>>>>            //**** Create a new DataFlex handle
30554>>>>>>>>>            Get CreateHandle To hDFHandle
30555>>>>>>>>>
30555>>>>>>>>>            //*** Call the driver function to allocate a statement handle
30555>>>>>>>>>            Call_driver 0 sDrvrId Function FUNC_SQLOPEN ;                        Callback Current_object ;                        Passing hDFHandle sEmpty ihdbc ;                        Result ihstmt
30560>>>>>>>>>
30560>>>>>>>>>            //*** If unsuccessful destroy DF side info
30560>>>>>>>>>            If (ihstmt = 0) Begin
30562>>>>>>>>>                Send FreeHandle to hDFHandle
30563>>>>>>>>>                Move 0 to hDFHandle
30564>>>>>>>>>            End
30564>>>>>>>>>>
30564>>>>>>>>>            Else ;                Send StoreHandleInfo to hDFHandle ihstmt sDrvrId ihdbc
30566>>>>>>>>>        End
30566>>>>>>>>>>
30566>>>>>>>>>
30566>>>>>>>>>        Function_return hDFHandle
30567>>>>>>>>>    End_function // SQLOpen
30568>>>>>>>>>
30568>>>>>>>>>End_Class // cSQLConnection
30569>>>>>>>>>
30569>>>>>>>>>
30569>>>>>>>>>
30569>>>>>>>>>//*****************************************************************************
30569>>>>>>>>>//*** Class  : cSQLHandlemanager                                            ***
30569>>>>>>>>>//*** Purpose: Manager for embedded SQL handles.                            ***
30569>>>>>>>>>//***                                                                       ***
30569>>>>>>>>>//*** Description:                                                          ***
30569>>>>>>>>>//***   We want to be able to use multiple drivers and multiple             ***
30569>>>>>>>>>//***   connections within a driver and multiple statements within a        ***
30569>>>>>>>>>//***   connection. To allow this we have palced our own handle logic on    ***
30569>>>>>>>>>//***   top of the driver handle logic. This way we can handle the          ***
30569>>>>>>>>>//***   situation where two driver handles may be equal.                    ***
30569>>>>>>>>>//*****************************************************************************
30569>>>>>>>>>
30569>>>>>>>>>Class cSQLHandleManager Is A Array
30570>>>>>>>>>
30570>>>>>>>>>    Procedure Construct_object Integer Image
30572>>>>>>>>>        Forward Send Construct_object Image
30574>>>>>>>>>
30574>>>>>>>>>        Property String  psDefaultDriver     Public ""
30575>>>>>>>>>        Property String  psDefaultConnection Public ""
30576>>>>>>>>>
30576>>>>>>>>>        Set Delegation_mode to NO_Delegation
30577>>>>>>>>>    End_procedure // COnstruct_object
30578>>>>>>>>>
30578>>>>>>>>>
30578>>>>>>>>>
30578>>>>>>>>>    //***
30578>>>>>>>>>    //*** Function: CreateHandle
30578>>>>>>>>>    //*** Purpose : Allocate memory for the desired type of handle
30578>>>>>>>>>    //***
30578>>>>>>>>>
30578>>>>>>>>>    Function CreateHandle Returns Integer
30580>>>>>>>>>        Local Integer hSQL
30580>>>>>>>>>
30580>>>>>>>>>        //*** Create a connection object
30580>>>>>>>>>        Object oSQLConnection Is A cSQLConnection
30582>>>>>>>>>            Move current_object To hSQL
30583>>>>>>>>>        End_Object // oSQLConnection
30584>>>>>>>>>
30584>>>>>>>>>        Function_Return hSQL
30585>>>>>>>>>    End_Function // CreateHandle
30586>>>>>>>>>
30586>>>>>>>>>
30586>>>>>>>>>
30586>>>>>>>>>    //***
30586>>>>>>>>>    //*** Procedure: SQLSetConnect
30586>>>>>>>>>    //*** Purpose  : Store default connection information
30586>>>>>>>>>    //***
30586>>>>>>>>>
30586>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
30588>>>>>>>>>        Set psDefaultDriver      To sDriver
30589>>>>>>>>>        Set psDefaultConnection  To sConnect
30590>>>>>>>>>    End_Procedure // SQLSetConnect
30591>>>>>>>>>
30591>>>>>>>>>
30591>>>>>>>>>
30591>>>>>>>>>    //***
30591>>>>>>>>>    //*** Function: SQLConnect
30591>>>>>>>>>    //*** Purpose : Make a connectin to an embedded SQL server
30591>>>>>>>>>    //*** Returns : The DataFlex handle to the connection
30591>>>>>>>>>    //***
30591>>>>>>>>>
30591>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns integer
30593>>>>>>>>>        Local Integer hDFHandle
30593>>>>>>>>>        Local Integer bOK
30593>>>>>>>>>
30593>>>>>>>>>        //*** Check arguments
30593>>>>>>>>>        If (sDrvrID = "" And sConnect = "") Begin
30595>>>>>>>>>            Get psDefaultDriver      To sDrvrId
30596>>>>>>>>>            Get psDefaultConnection  To sConnect
30597>>>>>>>>>        End
30597>>>>>>>>>>
30597>>>>>>>>>
30597>>>>>>>>>        //*** Allocate a new handle
30597>>>>>>>>>        Get CreateHandle To hDFHandle
30598>>>>>>>>>        Get SQLConnect of hDFHandle sDrvrID sConnect To bOK
30599>>>>>>>>>
30599>>>>>>>>>        //*** If failure, kill the handle and return a 0 handle
30599>>>>>>>>>        If (Not(bOK)) Begin
30601>>>>>>>>>            Send FreeHandle to hDFHandle
30602>>>>>>>>>            Move 0 to hDFHandle
30603>>>>>>>>>        End
30603>>>>>>>>>>
30603>>>>>>>>>
30603>>>>>>>>>        Function_return hDFHandle
30604>>>>>>>>>    End_function // SQLConnect
30605>>>>>>>>>
30605>>>>>>>>>
30605>>>>>>>>>
30605>>>>>>>>>    //***
30605>>>>>>>>>    //*** Function: SQLFileConnect
30605>>>>>>>>>    //*** Purpose : Make an existing connection available for use with Embedded
30605>>>>>>>>>    //***           SQL. The connection is identified by the number opf a file
30605>>>>>>>>>    //***           that is open for that connection.
30605>>>>>>>>>    //***
30605>>>>>>>>>
30605>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
30607>>>>>>>>>        Local Integer hDFHandle
30607>>>>>>>>>        Local Integer bOK
30607>>>>>>>>>
30607>>>>>>>>>        //*** Allocate a new handle
30607>>>>>>>>>        Get CreateHandle To hDFHandle
30608>>>>>>>>>        Get SQLFileConnect of hDFHandle iFileNum To bOK
30609>>>>>>>>>
30609>>>>>>>>>        //*** If failure, kill the handle and return a 0 handle
30609>>>>>>>>>        If (Not(bOK)) Begin
30611>>>>>>>>>            Send FreeHandle to hDFHandle
30612>>>>>>>>>            Move 0 to hDFHandle
30613>>>>>>>>>        End
30613>>>>>>>>>>
30613>>>>>>>>>
30613>>>>>>>>>        Function_return hDFHandle
30614>>>>>>>>>    End_Function // SQLFileConnect
30615>>>>>>>>>
30615>>>>>>>>>End_Class // cSQLHandleManager
30616>>>>>>>>>
30616>>>>>>>>>//***
30616>>>>>>>>>//*** Function: CreateSQLManager
30616>>>>>>>>>//*** Purpose : Create the embedded SQL manager, this is an internal function!
30616>>>>>>>>>//***
30616>>>>>>>>>
30616>>>>>>>>>
30616>>>>>>>>>
30616>>>>>>>>>Function CreateSQLmanager For cDesktop Returns Integer
30618>>>>>>>>>    Local Integer hoSQlMngr
30618>>>>>>>>>
30618>>>>>>>>>    Object oSQLHandleManager Is A cSQLHandleManager
30620>>>>>>>>>        MOve Current_object To hoSQLMngr
30621>>>>>>>>>    End_Object // oSQLHandleManager
30622>>>>>>>>>
30622>>>>>>>>>    Function_Return hoSQLMngr
30623>>>>>>>>>End_Function // CreateSQLMngr
30624>>>>>>>>>
30624>>>>>>>>>
30624>>>>>>>>>//*** Make sure the object is global by creating it under DESKTOP
30624>>>>>>>>>Get CreateSQLManager Of Desktop To _embsqlghoSQLHandleMngr
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLSetConnect                                                ***
30625>>>>>>>>>//*** Purpose: Setup default connection information for embedded SQL.       ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLSetConnect sSDriverId sConnectString                      ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLConnect                                                   ***
30625>>>>>>>>>//*** Purpose: Connect to a server for embedded SQL usage.                  ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLConnect To hdbc                                           ***
30625>>>>>>>>>//***          SQLConnect [sDriverId sConnectString] To hdbc                ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLFileConnect                                               ***
30625>>>>>>>>>//*** Purpsoe: Return the handle to a connection of an open file. This      ***
30625>>>>>>>>>//***          connection is (obviously) already opened. We are just using  ***
30625>>>>>>>>>//***          the same connection for Embedded SQL. This allows the        ***
30625>>>>>>>>>//***          programmer not to know connection details.                   ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLFileConnect Filex To hdbc                                 ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLDisconnect                                                ***
30625>>>>>>>>>//*** Purpose: Connect to a server for embedded SQL usage.                  ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLDisConnect hdbc                                           ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLOpen                                                      ***
30625>>>>>>>>>//*** Purpose: Allocate the memory to stroe statement information.          ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLOpen hdbc To hstmt                                        ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLClose                                                     ***
30625>>>>>>>>>//*** Purpose: Close a statement and free all associated memory.            ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLClose hstmt                                               ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLPrepare                                                   ***
30625>>>>>>>>>//*** Purpose: Prepare a statement for execution.                           ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLPrepare hstmt sStatement                                  ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLExecute                                                   ***
30625>>>>>>>>>//*** Purpose: Execute a prepared statement                                 ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLExecute hstmt                                             ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLExecDirect                                                ***
30625>>>>>>>>>//*** Purpose: Prepare and execute a statement.                             ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLExecDirect hstmt sStatement                               ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLFileFetch                                                 ***
30625>>>>>>>>>//*** Purpose: Get a row from a statement result set.                       ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLFileFetch hstmt [To File1 [File2 ...]]                    ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLBindFetchFile                                             ***
30625>>>>>>>>>//*** Purpose: Binds a file number to a statement so it can be used for     ***
30625>>>>>>>>>//***          fetching data. Only needed in non fileconnect. Note that     ***
30625>>>>>>>>>//***          can be assigned to the connection or the statement handle    ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLBindFileForFetch hstmt|hdbc FileName|FileNumber           ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLFetch                                                     ***
30625>>>>>>>>>//*** Purpose: Get a row from a statement result set.                       ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLFetch hstmt [To Var1 [Var2 ...]]                          ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLGetData                                                   ***
30625>>>>>>>>>//*** Purpose: Get a column's data.                                         ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLGetData hstmt iColumnNUmber [Length iLen] To Var          ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLColumnMap                                                 ***
30625>>>>>>>>>//*** Purpose: Determine the column number based on the column name.        ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLColumnMap hstmt sColName To iColNumber                    ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLColAttribute                                              ***
30625>>>>>>>>>//*** Purpose: Get an attribute of a column in a statements result set.     ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLColAttribute hstmt iCol iAttrId To sAttrib                ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLStmtAttribute                                             ***
30625>>>>>>>>>//*** Purpose: Get an atribute of a statement.                              ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLStmtAttribute hstmt iAttribId To sAttrib                  ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLCall                                                      ***
30625>>>>>>>>>//*** Purpose: Call a stored procedure.                                     ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLCall hstmt ProcedureName SchemaName [Arg1 ...] [To Var]   ***
30625>>>>>>>>>//***          You can pass "" for SchemaName.                              ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLGetArguments                                              ***
30625>>>>>>>>>//*** Purpsoe: Get the arguments of a stored procedure. This command should ***
30625>>>>>>>>>//***          be used when a procedure has multiple result sets. Some      ***
30625>>>>>>>>>//***          backends (SQL SErver for example) will return these as the   ***
30625>>>>>>>>>//***          last result set. This emans you first process all other      ***
30625>>>>>>>>>//***          result sets and then get the arguments and return value.     ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLGetArguments hstmt [Arg1...] [To Var]                     ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLNextResultSet                                             ***
30625>>>>>>>>>//*** Purpose: Go the the next result set. This command should be used when ***
30625>>>>>>>>>//***          a procedure call results in multiple result sets. Processing ***
30625>>>>>>>>>//***          such procedures can be done by loping through the result     ***
30625>>>>>>>>>//***          sets.                                                        ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLNextResultSet hstmt                                       ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>//*** Command: SQLFetchActivatesBuffer                                      ***
30625>>>>>>>>>//*** Purpose: Setup fetch behavior for a file. When set to true a          ***
30625>>>>>>>>>//***          succesfull fetch of the statement resutl set will            ***
30625>>>>>>>>>//***          automatically set the status of the file's bufer to          ***
30625>>>>>>>>>//***          DF_FILE_ACTIVE.                                              ***
30625>>>>>>>>>//***                                                                       ***
30625>>>>>>>>>//*** Syntax : SQLFetchActivatesBuffer hstmt FileNUmber|FileName sState     ***
30625>>>>>>>>>//*****************************************************************************
30625>>>>>>>>>
30625>>>>>>>>>
30625>>>>>>>
30625>>>>>>>// StureApsPublicLib packages
30625>>>>>>>Use DateFunctions.pkg   // oDateFunctions object
30625>>>>>>>Use StringFunctions.pkg // oStringFunctions object
30625>>>>>>>Use IndexFunctions.pkg
Including file: IndexFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\IndexFunctions.pkg)
30625>>>>>>>>>Use VdfBase.pkg
30625>>>>>>>>>
30625>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
30625>>>>>>>>>Use DateFunctions.pkg // Define oDateFunctions object
30625>>>>>>>>>Use _OverlapColumnFunctions.pkg
Including file: _OverlapColumnFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\_OverlapColumnFunctions.pkg)
30625>>>>>>>>>>>Use VdfBase.pkg
30625>>>>>>>>>>>
30625>>>>>>>>>>>// The next three structs are used for creating a bank
30625>>>>>>>>>>>Struct tocIndexSegment
30625>>>>>>>>>>>    Integer iColumn
30625>>>>>>>>>>>    Boolean bUppercase
30625>>>>>>>>>>>    Boolean bDescending
30625>>>>>>>>>>>End_Struct
30625>>>>>>>>>>>
30625>>>>>>>>>>>Struct tocIndex
30625>>>>>>>>>>>    Integer iIndex
30625>>>>>>>>>>>    Boolean bOnline
30625>>>>>>>>>>>    tocIndexSegment[] aSegments
30625>>>>>>>>>>>    tocIndexSegment[] aSegments
30625>>>>>>>>>>>End_Struct
30625>>>>>>>>>>>
30625>>>>>>>>>>>Struct tocColumn
30625>>>>>>>>>>>    Boolean bOverlap
30625>>>>>>>>>>>    Integer[] aOverlappingColumns
30625>>>>>>>>>>>End_Struct
30625>>>>>>>>>>>
30625>>>>>>>>>>>Struct tocTable
30625>>>>>>>>>>>    String sPhysName
30625>>>>>>>>>>>    tocColumn[] aColumns
30625>>>>>>>>>>>    tocColumn[] aColumns
30625>>>>>>>>>>>    tocIndex[] aIndices
30625>>>>>>>>>>>    tocIndex[] aIndices
30625>>>>>>>>>>>    Integer iShortestUniqueIndex
30625>>>>>>>>>>>End_Struct
30625>>>>>>>>>>>
30625>>>>>>>>>>>Global_Variable tOCTable[] gaOCIndexBank
30625>>>>>>>>>>>
30625>>>>>>>>>>>Class cOverlapColumnFunctions is a cObject
30626>>>>>>>>>>>
30626>>>>>>>>>>>    Procedure _AppendIndexSegment tocIndex ByRef strIndex Integer iColumnType Integer iColumn Boolean bUppercase Boolean bDescending
30628>>>>>>>>>>>        Integer iSegment
30628>>>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)) to iSegment
30629>>>>>>>>>>>        If (iColumnType<>DF_ASCII) Begin
30631>>>>>>>>>>>            Move False to bUppercase
30632>>>>>>>>>>>        End
30632>>>>>>>>>>>>
30632>>>>>>>>>>>        Move iColumn to strIndex.aSegments[iSegment].iColumn
30633>>>>>>>>>>>        Move bUppercase to strIndex.aSegments[iSegment].bUppercase
30634>>>>>>>>>>>        Move bDescending to strIndex.aSegments[iSegment].bDescending
30635>>>>>>>>>>>    End_Procedure
30636>>>>>>>>>>>
30636>>>>>>>>>>>    Procedure _HandleIndexSegment tocTable strTable tocIndex ByRef strIndex Integer iTable Integer iSourceColumn Boolean bUppercase Boolean bDescending
30638>>>>>>>>>>>        Integer iColumnType i iMax iColumn
30638>>>>>>>>>>>        Integer[] aColumns
30639>>>>>>>>>>>        tocIndexSegment[] aSegments
30639>>>>>>>>>>>        tocIndexSegment[] aSegments
30640>>>>>>>>>>>        Move strTable.aColumns[iSourceColumn].aOverlappingColumns to aColumns
30641>>>>>>>>>>>        Move (SizeOfArray(aColumns)-1) to iMax
30642>>>>>>>>>>>        For i from 0 to iMax
30648>>>>>>>>>>>>
30648>>>>>>>>>>>            Move aColumns[i] to iColumn
30649>>>>>>>>>>>            Get_Attribute DF_FIELD_TYPE of iTable iColumn to iColumnType
30652>>>>>>>>>>>            Send _AppendIndexSegment (&strIndex) iColumnType iColumn bUppercase bDescending
30653>>>>>>>>>>>        Loop
30654>>>>>>>>>>>>
30654>>>>>>>>>>>//        
30654>>>>>>>>>>>//        If (iColumnType=DF_OVERLAP) Begin
30654>>>>>>>>>>>//            Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iColumns
30654>>>>>>>>>>>//            For iColumn from 1 to iColumns
30654>>>>>>>>>>>//                Get_Attribute DF_FIELD_OVERLAP of iTable iSourceColumn iColumn to bOverlaps
30654>>>>>>>>>>>//                If (bOverlaps) Begin
30654>>>>>>>>>>>//                    Get_Attribute DF_FIELD_TYPE of iTable iColumn to iColumnType // Overload
30654>>>>>>>>>>>//                    If (iColumnType<>DF_OVERLAP) Begin
30654>>>>>>>>>>>//                        Send _AppendIndexSegment (&strIndex) iColumnType iColumn bUppercase bDescending
30654>>>>>>>>>>>//                    End
30654>>>>>>>>>>>//                End
30654>>>>>>>>>>>//            Loop
30654>>>>>>>>>>>//        End
30654>>>>>>>>>>>//        Else Begin
30654>>>>>>>>>>>//            Send _AppendIndexSegment (&strIndex) iColumnType iColumn bUppercase bDescending
30654>>>>>>>>>>>//        End
30654>>>>>>>>>>>    End_Procedure
30655>>>>>>>>>>>    
30655>>>>>>>>>>>    Procedure _ReadIndex tocTable ByRef strTable Integer iTable Integer iIndex Integer ByRef iBestLength
30657>>>>>>>>>>>        Integer iSegments iSegment iKeyLength
30657>>>>>>>>>>>        Integer iCase iDirection iColumn iType 
30657>>>>>>>>>>>        Boolean bUppercase bDescending bUnique
30657>>>>>>>>>>>        tocIndex strIndex
30657>>>>>>>>>>>        tocIndex strIndex
30657>>>>>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iTable iIndex to iSegments
30660>>>>>>>>>>>        If (iSegments>0) Begin
30662>>>>>>>>>>>            Move iIndex to strIndex.iIndex
30663>>>>>>>>>>>            Get_Attribute DF_INDEX_TYPE of iTable iIndex to iType
30666>>>>>>>>>>>            Move (iType=DF_INDEX_TYPE_ONLINE) to strIndex.bOnline
30667>>>>>>>>>>>            Move True to bUnique
30668>>>>>>>>>>>            For iSegment from 1 to iSegments
30674>>>>>>>>>>>>
30674>>>>>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD of iTable iIndex iSegment to iColumn
30677>>>>>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE of iTable iIndex iSegment to iCase
30680>>>>>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of iTable iIndex iSegment to iDirection
30683>>>>>>>>>>>                Move (iCase=DF_CASE_IGNORED) to bUppercase
30684>>>>>>>>>>>                Move (iDirection=DF_DESCENDING) to bDescending
30685>>>>>>>>>>>                Send _HandleIndexSegment strTable (&strIndex) iTable iColumn bUppercase bDescending
30686>>>>>>>>>>>                If (iColumn=0) Begin
30688>>>>>>>>>>>                    Move False to bUnique
30689>>>>>>>>>>>                End
30689>>>>>>>>>>>>
30689>>>>>>>>>>>            Loop
30690>>>>>>>>>>>>
30690>>>>>>>>>>>            Move strIndex to strTable.aIndices[iIndex]
30691>>>>>>>>>>>            
30691>>>>>>>>>>>            If (bUnique) Begin
30693>>>>>>>>>>>                Get_Attribute DF_INDEX_KEY_LENGTH of iTable iIndex to iKeyLength
30696>>>>>>>>>>>                If (iKeyLength<iBestLength) Begin
30698>>>>>>>>>>>                    Move iIndex to strTable.iShortestUniqueIndex
30699>>>>>>>>>>>                    Move iKeyLength to iBestLength
30700>>>>>>>>>>>                End
30700>>>>>>>>>>>>
30700>>>>>>>>>>>            End
30700>>>>>>>>>>>>
30700>>>>>>>>>>>        End
30700>>>>>>>>>>>>
30700>>>>>>>>>>>    End_Procedure
30701>>>>>>>>>>>    
30701>>>>>>>>>>>    Function _ReadOverlapTranslation Integer iTable Integer iOverlapColumn Returns Integer[]
30703>>>>>>>>>>>        Boolean bOverlaps
30703>>>>>>>>>>>        Integer iColumn iColumns iColumnType
30703>>>>>>>>>>>        Integer[] aColumns
30704>>>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iColumns
30707>>>>>>>>>>>        For iColumn from 0 to iColumns
30713>>>>>>>>>>>>
30713>>>>>>>>>>>            Get_Attribute DF_FIELD_TYPE of iTable iColumn to iColumnType
30716>>>>>>>>>>>            If (iColumnType<>DF_OVERLAP) Begin
30718>>>>>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of iTable iOverlapColumn iColumn to bOverlaps
30721>>>>>>>>>>>                If (bOverlaps) Begin
30723>>>>>>>>>>>                    Move iColumn to aColumns[SizeOfArray(aColumns)]
30724>>>>>>>>>>>                End
30724>>>>>>>>>>>>
30724>>>>>>>>>>>            End
30724>>>>>>>>>>>>
30724>>>>>>>>>>>        Loop
30725>>>>>>>>>>>>
30725>>>>>>>>>>>        Function_Return aColumns
30726>>>>>>>>>>>    End_Function
30727>>>>>>>>>>>    
30727>>>>>>>>>>>    Procedure ReadTableDefinition Integer iTable
30729>>>>>>>>>>>        Integer iIndex iMax
30729>>>>>>>>>>>        Integer iColumn iColumns iColumnType
30729>>>>>>>>>>>        Integer iBestLength
30729>>>>>>>>>>>        String sPhysName
30729>>>>>>>>>>>        tocTable strTable
30729>>>>>>>>>>>        tocTable strTable
30729>>>>>>>>>>>
30729>>>>>>>>>>>        // We only do something if the table definition hasn't been read before
30729>>>>>>>>>>>        // or if a new table has been opened in the same place.
30729>>>>>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of iTable to sPhysName
30732>>>>>>>>>>>        If (iTable>=SizeOfArray(gaOCIndexBank) or sPhysName<>gaOCIndexBank[iTable].sPhysName) Begin
30734>>>>>>>>>>>
30734>>>>>>>>>>>            // Build column overlap information
30734>>>>>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iColumns
30737>>>>>>>>>>>            For iColumn from 0 to iColumns // Obs
30743>>>>>>>>>>>>
30743>>>>>>>>>>>                Get_Attribute DF_FIELD_TYPE of iTable iColumn to iColumnType
30746>>>>>>>>>>>                If (iColumnType=DF_OVERLAP) Begin
30748>>>>>>>>>>>                    Move True to strTable.aColumns[iColumn].bOverlap
30749>>>>>>>>>>>                    Get _ReadOverlapTranslation iTable iColumn to strTable.aColumns[iColumn].aOverlappingColumns
30750>>>>>>>>>>>                End
30750>>>>>>>>>>>>
30750>>>>>>>>>>>                Else Begin // It's not an overlap column. Therefore it corresponds to itself:
30751>>>>>>>>>>>                    Move False to strTable.aColumns[iColumn].bOverlap
30752>>>>>>>>>>>                    Move iColumn to strTable.aColumns[iColumn].aOverlappingColumns[0]
30753>>>>>>>>>>>                End
30753>>>>>>>>>>>>
30753>>>>>>>>>>>            Loop
30754>>>>>>>>>>>>
30754>>>>>>>>>>>
30754>>>>>>>>>>>            // Build index overlap information
30754>>>>>>>>>>>            Move 999 to iBestLength
30755>>>>>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iTable to iMax
30758>>>>>>>>>>>            For iIndex from 1 to iMax
30764>>>>>>>>>>>>
30764>>>>>>>>>>>                Send _ReadIndex (&strTable) iTable iIndex (&iBestLength)
30765>>>>>>>>>>>            Loop
30766>>>>>>>>>>>>
30766>>>>>>>>>>>            
30766>>>>>>>>>>>            Move (SizeOfArray(strTable.aIndices)-1) to iMax
30767>>>>>>>>>>>            For iIndex from 1 to iMax
30773>>>>>>>>>>>>
30773>>>>>>>>>>>                If (SizeOfArray(strTable.aIndices[iIndex].aSegments)>0 and strTable.aIndices[iIndex].bOnline ;                    and strTable.aIndices[iIndex].aSegments[SizeOfArray(strTable.aIndices[iIndex].aSegments)-1].iColumn<>0) Begin
30775>>>>>>>>>>>                    
30775>>>>>>>>>>>                End
30775>>>>>>>>>>>>
30775>>>>>>>>>>>            Loop
30776>>>>>>>>>>>>
30776>>>>>>>>>>>
30776>>>>>>>>>>>
30776>>>>>>>>>>>            
30776>>>>>>>>>>>            // Update cache information
30776>>>>>>>>>>>            Move strTable to gaOCIndexBank[iTable]
30777>>>>>>>>>>>            Move sPhysName to gaOCIndexBank[iTable].sPhysName
30778>>>>>>>>>>>        End
30778>>>>>>>>>>>>
30778>>>>>>>>>>>    End_Procedure
30779>>>>>>>>>>>    
30779>>>>>>>>>>>    Function TableDefinition Integer iTable Returns tOCTable
30781>>>>>>>>>>>        Send ReadTableDefinition iTable
30782>>>>>>>>>>>        Function_Return gaOCIndexBank[iTable]
30783>>>>>>>>>>>    End_Function
30784>>>>>>>>>>>
30784>>>>>>>>>>>    Function IndexDefinition Integer iTable Integer iIndex Returns tOCIndex
30786>>>>>>>>>>>        tOCIndex strIndex
30786>>>>>>>>>>>        tOCIndex strIndex
30786>>>>>>>>>>>        Send ReadTableDefinition iTable
30787>>>>>>>>>>>        If (SizeOfArray(gaOCIndexBank[iTable].aIndices)>iIndex) Begin
30789>>>>>>>>>>>            Move gaOCIndexBank[iTable].aIndices[iIndex] to strIndex
30790>>>>>>>>>>>        End
30790>>>>>>>>>>>>
30790>>>>>>>>>>>        Function_Return strIndex
30791>>>>>>>>>>>    End_Function
30792>>>>>>>>>>>    
30792>>>>>>>>>>>    Function IndexDefinitionColumnNumbers Integer iTable Integer iIndex Returns Integer[]
30794>>>>>>>>>>>        Integer iSegment iSegments
30794>>>>>>>>>>>        Integer[] aColumns
30795>>>>>>>>>>>        tOCIndex strIndex
30795>>>>>>>>>>>        tOCIndex strIndex
30795>>>>>>>>>>>        Get IndexDefinition iTable iIndex to strIndex
30796>>>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
30797>>>>>>>>>>>        For iSegment from 0 to iSegments
30803>>>>>>>>>>>>
30803>>>>>>>>>>>            Move strIndex.aSegments[iSegment].iColumn to aColumns[iSegment]
30804>>>>>>>>>>>        Loop
30805>>>>>>>>>>>>
30805>>>>>>>>>>>        Function_Return aColumns
30806>>>>>>>>>>>    End_Function
30807>>>>>>>>>>>
30807>>>>>>>>>>>    Function TranslateOverlap Integer iTable Integer iColumn Returns Integer[]
30809>>>>>>>>>>>        Send ReadTableDefinition iTable
30810>>>>>>>>>>>        Function_Return gaOCIndexBank[iTable].aColumns[iColumn].aOverlappingColumns
30811>>>>>>>>>>>    End_Function
30812>>>>>>>>>>>    
30812>>>>>>>>>>>    Procedure AppendArrays Variant[] ByRef aArray1 Variant[] aArray2
30814>>>>>>>>>>>        Integer iIndex1 iIndex2 iMax2
30814>>>>>>>>>>>        Move (SizeOfArray(aArray1)) to iIndex1
30815>>>>>>>>>>>        Move (SizeOfArray(aArray2)-1) to iMax2
30816>>>>>>>>>>>        For iIndex2 from 0 to iMax2
30822>>>>>>>>>>>>
30822>>>>>>>>>>>            Move aArray2[iIndex2] to aArray1[iIndex1]
30823>>>>>>>>>>>            Increment iIndex1
30824>>>>>>>>>>>        Loop
30825>>>>>>>>>>>>
30825>>>>>>>>>>>    End_Procedure
30826>>>>>>>>>>>
30826>>>>>>>>>>>    Function TranslateOverlaps Integer iTable Integer[] aColumns Returns Integer[]
30828>>>>>>>>>>>        Integer iMax iItem
30828>>>>>>>>>>>        Integer[] aColumnsWithoutOverlaps
30829>>>>>>>>>>>        Integer[] aTranslatedColumns
30830>>>>>>>>>>>        Move (SizeOfArray(aColumns)-1) to iMax
30831>>>>>>>>>>>        For iItem from 0 to iMax
30837>>>>>>>>>>>>
30837>>>>>>>>>>>            Get TranslateOverlap iTable aColumns[iItem] to aTranslatedColumns
30838>>>>>>>>>>>            Send AppendArrays (&aColumnsWithoutOverlaps) aTranslatedColumns
30839>>>>>>>>>>>        Loop
30840>>>>>>>>>>>>
30840>>>>>>>>>>>        Function_Return aColumnsWithoutOverlaps
30841>>>>>>>>>>>    End_Function
30842>>>>>>>>>>>    
30842>>>>>>>>>>>    Function TableColumnsRelatingBetweenTables Integer iSourceTable Integer iTargetTable Integer[] ByRef aSourceColumns Integer[] ByRef aTargetColumns Returns Boolean
30844>>>>>>>>>>>        Integer iMaxColumn iSourceColumn iTargetColumn iTest 
30844>>>>>>>>>>>        Integer[] aColumns aSourceTest aTargetTest
30847>>>>>>>>>>>        Move (ResizeArray(aSourceColumns,0)) to aSourceColumns
30848>>>>>>>>>>>        Move (ResizeArray(aTargetColumns,0)) to aTargetColumns
30849>>>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iSourceTable to iMaxColumn
30852>>>>>>>>>>>        For iSourceColumn from 1 to iMaxColumn
30858>>>>>>>>>>>>
30858>>>>>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of iSourceTable iSourceColumn to iTest
30861>>>>>>>>>>>            If (iTest=iTargetTable) Begin
30863>>>>>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of iSourceTable iSourceColumn to iTargetColumn
30866>>>>>>>>>>>                Get TranslateOverlap iSourceTable iSourceColumn to aSourceTest
30867>>>>>>>>>>>                Get TranslateOverlap iTargetTable iTargetColumn to aTargetTest
30868>>>>>>>>>>>                Send AppendArrays (&aSourceColumns) (&aSourceTest)
30869>>>>>>>>>>>                Send AppendArrays (&aTargetColumns) (&aTargetTest)
30870>>>>>>>>>>>            End
30870>>>>>>>>>>>>
30870>>>>>>>>>>>        Loop
30871>>>>>>>>>>>>
30871>>>>>>>>>>>        Function_Return (SizeOfArray(aSourceColumns)>0 and SizeOfArray(aSourceColumns)=SizeOfArray(aTargetColumns))
30872>>>>>>>>>>>    End_Function
30873>>>>>>>>>>>    
30873>>>>>>>>>>>    Function IsOverlap Integer iTable Integer iColumn Returns Boolean
30875>>>>>>>>>>>        Function_Return gaOCIndexBank[iTable].aColumns[iColumn].bOverlap
30876>>>>>>>>>>>    End_Function
30877>>>>>>>>>>>    
30877>>>>>>>>>>>    // This procedure would be used in a well behaved program that is
30877>>>>>>>>>>>    // both capable of changing a tables definition on the fly, and at the
30877>>>>>>>>>>>    // same time use this package for something clever. In that case Reset
30877>>>>>>>>>>>    // should be sent to wipe out cached data now invalid. 
30877>>>>>>>>>>>    Procedure Reset
30879>>>>>>>>>>>        tocTable[] strEmpty
30879>>>>>>>>>>>        tocTable[] strEmpty
30880>>>>>>>>>>>        Move strEmpty to gaOCIndexBank
30881>>>>>>>>>>>    End_Procedure
30882>>>>>>>>>>>    
30882>>>>>>>>>>>End_Class // cOverlapColumnFunctions
30883>>>>>>>>>>>
30883>>>>>>>>>>>Global_Variable Integer oOverlapColumnFunctions
30883>>>>>>>>>>>
30883>>>>>>>>>>>Object _oOverlapColumnFunctions is a cOverlapColumnFunctions
30885>>>>>>>>>>>    Move Self to oOverlapColumnFunctions
30886>>>>>>>>>>>End_Object
30887>>>>>>>>>Use DataDictionaryFunctions.pkg
Including file: DataDictionaryFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\DataDictionaryFunctions.pkg)
30887>>>>>>>>>>>// DAW packages
30887>>>>>>>>>>>Use VdfBase.pkg
30887>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
30887>>>>>>>>>>>Use Datadict.pkg
30887>>>>>>>>>>>
30887>>>>>>>>>>>// StureAps packages
30887>>>>>>>>>>>Use StackFunctions.pkg // Define oStackFunctions object
30887>>>>>>>>>>>Use RelationMapStruct.pkg // tRelationsDrawingMapItem struct
Including file: RelationMapStruct.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\RelationMapStruct.pkg)
30887>>>>>>>>>>>>>Struct tRelationsDrawingMapItem
30887>>>>>>>>>>>>>    Integer iItemId
30887>>>>>>>>>>>>>    Integer iLevel
30887>>>>>>>>>>>>>    Boolean[] aVerticalLines
30887>>>>>>>>>>>>>    Integer iAlreadyMappedAtRow
30887>>>>>>>>>>>>>    Boolean bFirst 
30887>>>>>>>>>>>>>    Boolean bLast 
30887>>>>>>>>>>>>>    Boolean bParent 
30887>>>>>>>>>>>>>    Boolean bChild
30887>>>>>>>>>>>>>End_Struct
30887>>>>>>>>>>>>>
30887>>>>>>>>>>>Use yUML.pkg
Including file: yUML.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\yUML.pkg)
30887>>>>>>>>>>>>>// yuml.me (Create and share simple UML diagrams in your blogs, wikis, forums, bug-trackers and emails.)
30887>>>>>>>>>>>>>// http://yuml.me/diagram/class/samples
30887>>>>>>>>>>>>>
30887>>>>>>>>>>>>>// To do:
30887>>>>>>>>>>>>>//
30887>>>>>>>>>>>>>// * Dotted lines between alias tables
30887>>>>>>>>>>>>>
30887>>>>>>>>>>>>>Use cHttpTransfer.pkg
30887>>>>>>>>>>>>>
30887>>>>>>>>>>>>>Use VdfBase.pkg
30887>>>>>>>>>>>>>Use UrlFunctions.pkg
Including file: UrlFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\UrlFunctions.pkg)
30887>>>>>>>>>>>>>>>//> From the point of view of the URL string manipulation functions an URL
30887>>>>>>>>>>>>>>>//> is composed of the following items:
30887>>>>>>>>>>>>>>>//>
30887>>>>>>>>>>>>>>>//>    * Protocol      "http:"
30887>>>>>>>>>>>>>>>//>    * User ID       "sture"
30887>>>>>>>>>>>>>>>//>    * Password      "headset"
30887>>>>>>>>>>>>>>>//>    * Host          "www.sture.dk"
30887>>>>>>>>>>>>>>>//>    * Port          80
30887>>>>>>>>>>>>>>>//>    * Path          "/Images/EDUC2001"
30887>>>>>>>>>>>>>>>//>    * Type          "type=xml"
30887>>>>>>>>>>>>>>>//>
30887>>>>>>>>>>>>>>>//> function URL_ParseURL global string sUrl returns integer
30887>>>>>>>>>>>>>>>//>
30887>>>>>>>>>>>>>>>//> To have a URL decomposed into the items above use the URL_ParseURL
30887>>>>>>>>>>>>>>>//> function. The function returns TRUE if a host could be identidfied
30887>>>>>>>>>>>>>>>//> as part of the sUrl string and FALSE if not.
30887>>>>>>>>>>>>>>>//>
30887>>>>>>>>>>>>>>>//>
30887>>>>>>>>>>>>>>>//> function URL_Value global integer liSegment returns string
30887>>>>>>>>>>>>>>>//>
30887>>>>>>>>>>>>>>>//> After having used the URL_ParseURL to decompose an URL you should use
30887>>>>>>>>>>>>>>>//> the URL_Value function to obtain the value of each component in the
30887>>>>>>>>>>>>>>>//> URL. For example, to obtain the 'Path' part of the URL you would write
30887>>>>>>>>>>>>>>>//>
30887>>>>>>>>>>>>>>>//>   get URL_Value URL_SEGMENT_PATH to lsPath
30887>>>>>>>>>>>>>>>//>
30887>>>>>>>>>>>>>>>//> The URL_SEGMENT_PATH symbol is a constant defined by the URL.nui package.
30887>>>>>>>>>>>>>>>//> You may pass the following segment identifiers to the function:
30887>>>>>>>>>>>>>>>//>
30887>>>>>>>>>>>>>>>//>    URL_SEGMENT_PROTOCOL, URL_SEGMENT_USER, URL_SEGMENT_PASSWORD,
30887>>>>>>>>>>>>>>>//>    URL_SEGMENT_HOST, URL_SEGMENT_PORT, URL_SEGMENT_PATH and
30887>>>>>>>>>>>>>>>//>    URL_SEGMENT_TYPE
30887>>>>>>>>>>>>>>>//>
30887>>>>>>>>>>>>>>>//> These symbols may also be used as arguments to a the 'set URL_Value'
30887>>>>>>>>>>>>>>>//> procedure anabling you to set the value of each individual before
30887>>>>>>>>>>>>>>>//> calling this function:
30887>>>>>>>>>>>>>>>//>
30887>>>>>>>>>>>>>>>//> function URL_Compose global returns string
30887>>>>>>>>>>>>>>>//>
30887>>>>>>>>>>>>>>>//> This function combines all the segments setup via the 'set URL_Value'
30887>>>>>>>>>>>>>>>//> procedure (and possebly leftovers from the most recent call to
30887>>>>>>>>>>>>>>>//> URL_ParseURL) and returns a URL.
30887>>>>>>>>>>>>>>>//>
30887>>>>>>>>>>>>>>>//>
30887>>>>>>>>>>>>>>>//> Note that the URL functions decribed here are merely string manipulations.
30887>>>>>>>>>>>>>>>//> They do not interact with any internet componenents locally on the machine
30887>>>>>>>>>>>>>>>//> or on the internet itself.
30887>>>>>>>>>>>>>>>//>
30887>>>>>>>>>>>>>>>//> pkg.doc.end
30887>>>>>>>>>>>>>>>
30887>>>>>>>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
30887>>>>>>>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
30887>>>>>>>>>>>>>>>
30887>>>>>>>>>>>>>>>Struct tUrl
30887>>>>>>>>>>>>>>>    String sProtocol //> Protocol
30887>>>>>>>>>>>>>>>    String sUser     //> User identification
30887>>>>>>>>>>>>>>>    String sPassword //> Password
30887>>>>>>>>>>>>>>>    String sHost     //> Host
30887>>>>>>>>>>>>>>>    String sPort     //> Port
30887>>>>>>>>>>>>>>>    String sPath     //> Path
30887>>>>>>>>>>>>>>>    String sType     //> Type
30887>>>>>>>>>>>>>>>End_Struct
30887>>>>>>>>>>>>>>>
30887>>>>>>>>>>>>>>>Global_Variable Integer oUrlFunctions
30887>>>>>>>>>>>>>>>
30887>>>>>>>>>>>>>>>Class cUrlFunctions is a cObject
30888>>>>>>>>>>>>>>>
30888>>>>>>>>>>>>>>>        // Private
30888>>>>>>>>>>>>>>>        Function _FindUrlToken String sToken String sValue Returns Integer
30890>>>>>>>>>>>>>>>            Integer iPos iLen iTokenLen
30890>>>>>>>>>>>>>>>            String sString
30890>>>>>>>>>>>>>>>            Move (length(sToken)) to iTokenLen
30891>>>>>>>>>>>>>>>            Move (length(sValue)) to iLen
30892>>>>>>>>>>>>>>>            For iPos from 1 to iLen
30898>>>>>>>>>>>>>>>>
30898>>>>>>>>>>>>>>>                Move (left(sValue,iPos)) to sString
30899>>>>>>>>>>>>>>>                If (right(sString,iTokenLen)=sToken) Function_Return iPos
30902>>>>>>>>>>>>>>>            Loop
30903>>>>>>>>>>>>>>>>
30903>>>>>>>>>>>>>>>            Function_Return 0
30904>>>>>>>>>>>>>>>        End_Function
30905>>>>>>>>>>>>>>>
30905>>>>>>>>>>>>>>>    //> ftp://<user>:<password>@<host>:<port>/<url-path>;type=<typecode>
30905>>>>>>>>>>>>>>>    //> If the Host member of the returns value is empty, the decoding was unsuccessful.
30905>>>>>>>>>>>>>>>    Function Decompose String sUrl Returns tUrl
30907>>>>>>>>>>>>>>>        Integer iPos
30907>>>>>>>>>>>>>>>        String sValue sValue2 sHost
30907>>>>>>>>>>>>>>>        tUrl sStructUrl
30907>>>>>>>>>>>>>>>        tUrl sStructUrl
30907>>>>>>>>>>>>>>>
30907>>>>>>>>>>>>>>>        Get _FindUrlToken ("/"+"/") sUrl to iPos // Protokol?
30908>>>>>>>>>>>>>>>        If iPos Begin // Protokol
30910>>>>>>>>>>>>>>>            Move (left(sUrl,iPos)) to sValue
30911>>>>>>>>>>>>>>>            Move (replace(sValue,sUrl,"")) to sUrl
30912>>>>>>>>>>>>>>>            Get rRemove of oStringFunctions sValue 2 to sStructUrl.sProtocol
30913>>>>>>>>>>>>>>>        End
30913>>>>>>>>>>>>>>>>
30913>>>>>>>>>>>>>>>
30913>>>>>>>>>>>>>>>        Get _FindUrlToken "@" sUrl to iPos // User ?
30914>>>>>>>>>>>>>>>        If iPos Begin // User
30916>>>>>>>>>>>>>>>            Move (left(sUrl,iPos)) to sValue
30917>>>>>>>>>>>>>>>            Move (replace(sValue,sUrl,"")) to sUrl
30918>>>>>>>>>>>>>>>            Get _FindUrlToken ":" sValue to iPos
30919>>>>>>>>>>>>>>>            If iPos Begin // User and Password
30921>>>>>>>>>>>>>>>                Move (left(sValue,iPos)) to sValue2
30922>>>>>>>>>>>>>>>                Get rRemove of oStringFunctions sValue2 1 to sStructUrl.sUser
30923>>>>>>>>>>>>>>>                Move (replace(sValue2,sValue,"")) to sValue
30924>>>>>>>>>>>>>>>                Get rRemove of oStringFunctions sValue 1 to sStructUrl.sPassword
30925>>>>>>>>>>>>>>>            End
30925>>>>>>>>>>>>>>>>
30925>>>>>>>>>>>>>>>            Else Begin // User without password
30926>>>>>>>>>>>>>>>                Get rRemove of oStringFunctions sValue 1 to sStructUrl.sUser
30927>>>>>>>>>>>>>>>            End
30927>>>>>>>>>>>>>>>>
30927>>>>>>>>>>>>>>>        End
30927>>>>>>>>>>>>>>>>
30927>>>>>>>>>>>>>>>
30927>>>>>>>>>>>>>>>        //   ftp://<user>:<password>@<host>:<port>/<url-path>;type=<typecode>
30927>>>>>>>>>>>>>>>
30927>>>>>>>>>>>>>>>        Get _FindUrlToken ";" sUrl to iPos // Type ?
30928>>>>>>>>>>>>>>>        If iPos Begin // Type!
30930>>>>>>>>>>>>>>>            Move (left(sUrl,iPos)) to sValue
30931>>>>>>>>>>>>>>>            Move (replace(sValue,sUrl,"")) to sUrl
30932>>>>>>>>>>>>>>>            Move sUrl to sStructUrl.sType
30933>>>>>>>>>>>>>>>            Get rRemove of oStringFunctions sValue 1 to sValue
30934>>>>>>>>>>>>>>>            Get _FindUrlToken "/" sValue to iPos // Path ?
30935>>>>>>>>>>>>>>>            If iPos Begin // Path! www.dataaccess.dk:80/magicpath/Images
30937>>>>>>>>>>>>>>>                Move (left(sValue,iPos-1)) to sValue2
30938>>>>>>>>>>>>>>>                Move (replace(sValue2,sValue,"")) to sStructUrl.sPath
30939>>>>>>>>>>>>>>>                Move sValue2 to sValue
30940>>>>>>>>>>>>>>>            End
30940>>>>>>>>>>>>>>>>
30940>>>>>>>>>>>>>>>            Get _FindUrlToken ":" sValue to iPos // Port ?
30941>>>>>>>>>>>>>>>            If iPos Begin // Port !  Dataaccess.kn:80
30943>>>>>>>>>>>>>>>                Move (left(sValue,iPos)) to sHost
30944>>>>>>>>>>>>>>>                Move (rRemove(oStringFunctions,sHost,1)) to sStructUrl.sHost
30945>>>>>>>>>>>>>>>                Move (replace(sHost,sValue,"")) to sStructUrl.sPort
30946>>>>>>>>>>>>>>>            End
30946>>>>>>>>>>>>>>>>
30946>>>>>>>>>>>>>>>            Else Move sValue to sStructUrl.sHost
30948>>>>>>>>>>>>>>>        End
30948>>>>>>>>>>>>>>>>
30948>>>>>>>>>>>>>>>        Else Begin
30949>>>>>>>>>>>>>>>            Get _FindUrlToken "/" sUrl to iPos // Path ?
30950>>>>>>>>>>>>>>>            If iPos Begin
30952>>>>>>>>>>>>>>>                Move sUrl to sValue
30953>>>>>>>>>>>>>>>
30953>>>>>>>>>>>>>>>                If iPos Begin // Path! www.dataaccess.dk:80/magicpath/Images
30955>>>>>>>>>>>>>>>                    Move (left(sValue,iPos-1)) to sValue2
30956>>>>>>>>>>>>>>>                    Move (replace(sValue2,sValue,"")) to sStructUrl.sPath
30957>>>>>>>>>>>>>>>                    Move sValue2 to sValue
30958>>>>>>>>>>>>>>>                End
30958>>>>>>>>>>>>>>>>
30958>>>>>>>>>>>>>>>                Get _FindUrlToken ":" sValue to iPos // Port ?
30959>>>>>>>>>>>>>>>                If iPos Begin // Port!  Dataaccess.kn:80
30961>>>>>>>>>>>>>>>                    Move (left(sValue,iPos)) to sHost
30962>>>>>>>>>>>>>>>                    Move (rRemove(oStringFunctions,sHost,1)) to sStructUrl.sHost
30963>>>>>>>>>>>>>>>                    Move (replace(sHost,sValue,"")) to sStructUrl.sPort
30964>>>>>>>>>>>>>>>                End
30964>>>>>>>>>>>>>>>>
30964>>>>>>>>>>>>>>>                Else Move sValue to sStructUrl.sHost
30966>>>>>>>>>>>>>>>            End
30966>>>>>>>>>>>>>>>>
30966>>>>>>>>>>>>>>>            Else Begin
30967>>>>>>>>>>>>>>>                Get _FindUrlToken ":" sUrl to iPos // Port?
30968>>>>>>>>>>>>>>>                If iPos Begin
30970>>>>>>>>>>>>>>>                    Move (left(sUrl,iPos)) to sValue
30971>>>>>>>>>>>>>>>                    Move (replace(sValue,sUrl,"")) to sUrl
30972>>>>>>>>>>>>>>>                    Move (rRemove(oStringFunctions,sValue,1)) to sStructUrl.sHost
30973>>>>>>>>>>>>>>>                    Move sUrl to sStructUrl.sPort
30974>>>>>>>>>>>>>>>                End
30974>>>>>>>>>>>>>>>>
30974>>>>>>>>>>>>>>>                Else Begin
30975>>>>>>>>>>>>>>>                    Move sUrl to sStructUrl.sHost
30976>>>>>>>>>>>>>>>                End
30976>>>>>>>>>>>>>>>>
30976>>>>>>>>>>>>>>>            End
30976>>>>>>>>>>>>>>>>
30976>>>>>>>>>>>>>>>        End
30976>>>>>>>>>>>>>>>>
30976>>>>>>>>>>>>>>>        Function_Return sStructUrl
30977>>>>>>>>>>>>>>>    End_Function
30978>>>>>>>>>>>>>>>
30978>>>>>>>>>>>>>>>    Function Compose tUrl sStructUrl Returns String
30980>>>>>>>>>>>>>>>        String sRval
30980>>>>>>>>>>>>>>>        If (sStructUrl.sProtocol<>"") Begin
30982>>>>>>>>>>>>>>>            Move (sStructUrl.sProtocol+"//") to sRval
30983>>>>>>>>>>>>>>>        End
30983>>>>>>>>>>>>>>>>
30983>>>>>>>>>>>>>>>
30983>>>>>>>>>>>>>>>        If (sStructUrl.sUser<>"") Begin
30985>>>>>>>>>>>>>>>            Move (sRval+sStructUrl.sUser) to sRval
30986>>>>>>>>>>>>>>>            If (sStructUrl.sPassword<>"") Move (sRval+":"+sStructUrl.sPassword) to sRval
30989>>>>>>>>>>>>>>>            Move (sRval+"@") to sRval
30990>>>>>>>>>>>>>>>        End
30990>>>>>>>>>>>>>>>>
30990>>>>>>>>>>>>>>>        Move (sRval+sStructUrl.sHost) to sRval
30991>>>>>>>>>>>>>>>        If (sStructUrl.sPort<>0) begin
30993>>>>>>>>>>>>>>>            Move (sRval+":"+String(sStructUrl.sPort)) to sRval
30994>>>>>>>>>>>>>>>        End
30994>>>>>>>>>>>>>>>>
30994>>>>>>>>>>>>>>>        If (sStructUrl.sPath<>"") Begin
30996>>>>>>>>>>>>>>>            If (left(sStructUrl.sPath,1)="/") Move (sRval+sStructUrl.sPath) to sRval
30999>>>>>>>>>>>>>>>            Else Move (sRval+"/"+sStructUrl.sPath) to sRval
31001>>>>>>>>>>>>>>>        End
31001>>>>>>>>>>>>>>>>
31001>>>>>>>>>>>>>>>        If (sStructUrl.sType<>"") Move (sRval+";"+sStructUrl.sType) to sRval
31004>>>>>>>>>>>>>>>        Function_Return sRval
31005>>>>>>>>>>>>>>>    End_Function
31006>>>>>>>>>>>>>>>
31006>>>>>>>>>>>>>>>    Function UrlCharacterEncode String sUrl Returns String
31008>>>>>>>>>>>>>>>        Integer iLen iPos
31008>>>>>>>>>>>>>>>        String sChar sHex sRval sOk
31008>>>>>>>>>>>>>>>        Move "0123456789" to sOk
31009>>>>>>>>>>>>>>>        Move (sOk+"abcdefghijklmnopqrstuvwxyz") to sOk
31010>>>>>>>>>>>>>>>        Move (sOk+"ABCDEFGHIJKLMNOPQRSTUVWXYZ") to sOk
31011>>>>>>>>>>>>>>>        Move (sOk+".-:;/+&#=?_") to sOk
31012>>>>>>>>>>>>>>>        Move (Length(sUrl)) to iLen
31013>>>>>>>>>>>>>>>        Move "" to sRval
31014>>>>>>>>>>>>>>>        For iPos from 1 to iLen
31020>>>>>>>>>>>>>>>>
31020>>>>>>>>>>>>>>>            Move (Mid(sUrl,1,iPos)) to sChar
31021>>>>>>>>>>>>>>>            If not (sOk contains sChar) Begin
31023>>>>>>>>>>>>>>>                Get ByteToHex of oStringFunctions (Ascii(sChar)) to sChar
31024>>>>>>>>>>>>>>>                Move ("%"+sChar) to sChar
31025>>>>>>>>>>>>>>>            End
31025>>>>>>>>>>>>>>>>
31025>>>>>>>>>>>>>>>            Move (sRval+sChar) to sRval
31026>>>>>>>>>>>>>>>        Loop
31027>>>>>>>>>>>>>>>>
31027>>>>>>>>>>>>>>>        Function_Return sRval
31028>>>>>>>>>>>>>>>    End_Function
31029>>>>>>>>>>>>>>>
31029>>>>>>>>>>>>>>>    //>
31029>>>>>>>>>>>>>>>    Function UrlCharacterDecode String sUrl Returns String
31031>>>>>>>>>>>>>>>        Integer iLen iPos
31031>>>>>>>>>>>>>>>        String sChar sHex sRval
31031>>>>>>>>>>>>>>>        Move (Length(sUrl)) to iLen
31032>>>>>>>>>>>>>>>        Move "" to sRval
31033>>>>>>>>>>>>>>>        Move 1 to iPos
31034>>>>>>>>>>>>>>>        While (iPos<=iLen)
31038>>>>>>>>>>>>>>>            Move (Mid(sUrl,1,iPos)) to sChar
31039>>>>>>>>>>>>>>>            Increment iPos
31040>>>>>>>>>>>>>>>            If (sChar="%") Begin
31042>>>>>>>>>>>>>>>                Move (Mid(sUrl,2,iPos)) to sHex
31043>>>>>>>>>>>>>>>                If (IsHex(oStringFunctions,sHex)) Begin
31045>>>>>>>>>>>>>>>                    Move (character(HexToByte(oStringFunctions,sHex))) to sChar
31046>>>>>>>>>>>>>>>                    Move (iPos+2) to iPos
31047>>>>>>>>>>>>>>>                End
31047>>>>>>>>>>>>>>>>
31047>>>>>>>>>>>>>>>            End
31047>>>>>>>>>>>>>>>>
31047>>>>>>>>>>>>>>>            Move (sRval+sChar) to sRval
31048>>>>>>>>>>>>>>>        Loop
31049>>>>>>>>>>>>>>>>
31049>>>>>>>>>>>>>>>        Function_Return sRval
31050>>>>>>>>>>>>>>>    End_Function
31051>>>>>>>>>>>>>>>
31051>>>>>>>>>>>>>>>    Function FileNameToUrl String sPath Returns String
31053>>>>>>>>>>>>>>>        Integer iItem iMax
31053>>>>>>>>>>>>>>>        String[] asPath
31054>>>>>>>>>>>>>>>        String sRval
31054>>>>>>>>>>>>>>>        Send SplitString of oStringFunctions sPath "\" True False (&asPath)
31055>>>>>>>>>>>>>>>        Move (SizeOfArray(asPath)) to iMax
31056>>>>>>>>>>>>>>>        If iMax Begin
31058>>>>>>>>>>>>>>>            Move asPath[0] to sRval // Should be the server
31059>>>>>>>>>>>>>>>            Decrement iMax
31060>>>>>>>>>>>>>>>            For iItem from 1 to iMax
31066>>>>>>>>>>>>>>>>
31066>>>>>>>>>>>>>>>                If (iItem<>iMax) begin
31068>>>>>>>>>>>>>>>                    Move (sRval+"/"+asPath[iItem]) to sRval
31069>>>>>>>>>>>>>>>                End
31069>>>>>>>>>>>>>>>>
31069>>>>>>>>>>>>>>>                Else begin
31070>>>>>>>>>>>>>>>                    Move (sRval+"/"+HexToString(oStringFunctions,asPath[iItem])) to sRval
31071>>>>>>>>>>>>>>>                End
31071>>>>>>>>>>>>>>>>
31071>>>>>>>>>>>>>>>            Loop
31072>>>>>>>>>>>>>>>>
31072>>>>>>>>>>>>>>>        End
31072>>>>>>>>>>>>>>>>
31072>>>>>>>>>>>>>>>        If (iMax<=0) begin
31074>>>>>>>>>>>>>>>            Move "" to sRval // There MUST be something more than the server
31075>>>>>>>>>>>>>>>        End
31075>>>>>>>>>>>>>>>>
31075>>>>>>>>>>>>>>>        Function_Return sRval
31076>>>>>>>>>>>>>>>    End_Function
31077>>>>>>>>>>>>>>>
31077>>>>>>>>>>>>>>>    Function UrlToFileName String sUrl Returns String
31079>>>>>>>>>>>>>>>        tUrl stUrl
31079>>>>>>>>>>>>>>>        tUrl stUrl
31079>>>>>>>>>>>>>>>        Integer iItem iMax
31079>>>>>>>>>>>>>>>        String[] asPath
31080>>>>>>>>>>>>>>>        String sRval
31080>>>>>>>>>>>>>>>        // First remove, protocol, user, pw and port
31080>>>>>>>>>>>>>>>        Get Decompose sUrl to stUrl
31081>>>>>>>>>>>>>>>        Move "" to stUrl.sProtocol
31082>>>>>>>>>>>>>>>        Move "" to stUrl.sPassword
31083>>>>>>>>>>>>>>>        Move "" to stUrl.sUser
31084>>>>>>>>>>>>>>>        Move "" to stUrl.sPort
31085>>>>>>>>>>>>>>>        Move "" to stUrl.sType
31086>>>>>>>>>>>>>>>        Get Compose stUrl to sUrl
31087>>>>>>>>>>>>>>>        // Then split value according to "/"'s
31087>>>>>>>>>>>>>>>        Send SplitString of oStringFunctions sUrl "/" True False (&asPath)
31088>>>>>>>>>>>>>>>        Move (SizeOfArray(asPath)) to iMax
31089>>>>>>>>>>>>>>>        If iMax Begin
31091>>>>>>>>>>>>>>>            Move asPath[0] to sRval // Should be the server
31092>>>>>>>>>>>>>>>            Decrement iMax
31093>>>>>>>>>>>>>>>            For iItem from 1 to iMax
31099>>>>>>>>>>>>>>>>
31099>>>>>>>>>>>>>>>                If (iItem<>iMax) begin
31101>>>>>>>>>>>>>>>                    Move (sRval+"\"+asPath[iItem]) to sRval
31102>>>>>>>>>>>>>>>                End
31102>>>>>>>>>>>>>>>>
31102>>>>>>>>>>>>>>>                Else begin
31103>>>>>>>>>>>>>>>                    Move (sRval+"\"+StringToHex(oStringFunctions,asPath[iItem])) to sRval
31104>>>>>>>>>>>>>>>                End
31104>>>>>>>>>>>>>>>>
31104>>>>>>>>>>>>>>>            Loop
31105>>>>>>>>>>>>>>>>
31105>>>>>>>>>>>>>>>        End
31105>>>>>>>>>>>>>>>>
31105>>>>>>>>>>>>>>>        If (iMax=0) begin
31107>>>>>>>>>>>>>>>            Move "" to sRval // There MUST be something more than the server
31108>>>>>>>>>>>>>>>        End
31108>>>>>>>>>>>>>>>>
31108>>>>>>>>>>>>>>>        Function_Return sRval
31109>>>>>>>>>>>>>>>    End_Function
31110>>>>>>>>>>>>>>>
31110>>>>>>>>>>>>>>>    Function SetOfUrls_IsMember String sUrl String[] aSetOfUrls Returns Integer
31112>>>>>>>>>>>>>>>        Integer iMax iUrl
31112>>>>>>>>>>>>>>>        Move (lowercase(sUrl)) to sUrl
31113>>>>>>>>>>>>>>>        Move (SizeOfArray(aSetOfUrls)) to iMax
31114>>>>>>>>>>>>>>>        Decrement iMax
31115>>>>>>>>>>>>>>>        For iUrl from 0 to iMax
31121>>>>>>>>>>>>>>>>
31121>>>>>>>>>>>>>>>            If (sUrl=lowercase(aSetOfUrls[iUrl])) Begin
31123>>>>>>>>>>>>>>>                Function_Return iUrl
31124>>>>>>>>>>>>>>>            End
31124>>>>>>>>>>>>>>>>
31124>>>>>>>>>>>>>>>        Loop
31125>>>>>>>>>>>>>>>>
31125>>>>>>>>>>>>>>>        Function_Return -1 // not found
31126>>>>>>>>>>>>>>>    End_Function
31127>>>>>>>>>>>>>>>
31127>>>>>>>>>>>>>>>    Procedure SetOfUrls_AddMember String sUrl String[] ByRef aSetOfUrls
31129>>>>>>>>>>>>>>>        If (SetOfUrls_IsMember(Self,sUrl,aSetOfUrls)<>-1) Begin
31131>>>>>>>>>>>>>>>            Move sUrl to aSetOfUrls[SizeOfArray(aSetOfUrls)]
31132>>>>>>>>>>>>>>>        End
31132>>>>>>>>>>>>>>>>
31132>>>>>>>>>>>>>>>    End_Procedure
31133>>>>>>>>>>>>>>>End_Class
31134>>>>>>>>>>>>>>>
31134>>>>>>>>>>>>>>>Object _oUrlFunctions is a cUrlFunctions
31136>>>>>>>>>>>>>>>    Move Self to oUrlFunctions
31137>>>>>>>>>>>>>>>End_Object
31138>>>>>>>>>>>>>
31138>>>>>>>>>>>>>Struct tYumlClass
31138>>>>>>>>>>>>>    String sLabel // Label of the entity
31138>>>>>>>>>>>>>    String sColor // Although faithfully carried around it is used for nothing
31138>>>>>>>>>>>>>End_Struct
31138>>>>>>>>>>>>>
31138>>>>>>>>>>>>>Struct tYumlClassRelation
31138>>>>>>>>>>>>>    Integer iType // 0=1:N, 1=1:N dotted, 2=1:1
31138>>>>>>>>>>>>>    Integer iFrom // From class (array index)
31138>>>>>>>>>>>>>    Integer iTo   // To class (array index)
31138>>>>>>>>>>>>>    Boolean bMark // Mark the relation with an *. I use that to mark constrained relations
31138>>>>>>>>>>>>>End_Struct
31138>>>>>>>>>>>>>
31138>>>>>>>>>>>>>Struct tYumlClassDiagram
31138>>>>>>>>>>>>>    Integer iScalePct
31138>>>>>>>>>>>>>    Integer iForceDirection  // 0=no force, 1=left-right, 2=top-down
31138>>>>>>>>>>>>>    Integer iImageType       // 1=jpg 2=pdf
31138>>>>>>>>>>>>>    Boolean bScruffy         // makes it look a little hand drawn. but just a little
31138>>>>>>>>>>>>>    String sNote             // A note that is inserted into the diagram
31138>>>>>>>>>>>>>    tYumlClass[] aClasses            // The classes (entities)
31138>>>>>>>>>>>>>    tYumlClass[] aClasses            // The classes (entities)
31138>>>>>>>>>>>>>    tYumlClassRelation[] aRelations  // And the relations between them.
31138>>>>>>>>>>>>>    tYumlClassRelation[] aRelations  // And the relations between them.
31138>>>>>>>>>>>>>End_Struct
31138>>>>>>>>>>>>>
31138>>>>>>>>>>>>>Class cYumlFunctions is a cObject
31139>>>>>>>>>>>>>    Procedure Construct_Object
31141>>>>>>>>>>>>>        Forward Send Construct_Object
31143>>>>>>>>>>>>>        Object oHttpTransfer is a cHttpTransfer
31145>>>>>>>>>>>>>            Set psRemoteHost to "yuml.me"
31146>>>>>>>>>>>>>        End_Object
31147>>>>>>>>>>>>>    End_Procedure
31148>>>>>>>>>>>>>    
31148>>>>>>>>>>>>>    Function NewDiagram Returns tYumlClassDiagram
31150>>>>>>>>>>>>>        tYumlClassDiagram strDiagram
31150>>>>>>>>>>>>>        tYumlClassDiagram strDiagram
31150>>>>>>>>>>>>>        Move 100 to strDiagram.iScalePct
31151>>>>>>>>>>>>>        Move 0 to strDiagram.iForceDirection
31152>>>>>>>>>>>>>        Move 0 to strDiagram.iImageType
31153>>>>>>>>>>>>>        Move False to strDiagram.bScruffy
31154>>>>>>>>>>>>>        Function_Return strDiagram
31155>>>>>>>>>>>>>    End_Function
31156>>>>>>>>>>>>>    
31156>>>>>>>>>>>>>        Function _FindClassLabelIndex tYumlClassDiagram strDiagram String sLabel Returns Integer
31158>>>>>>>>>>>>>            Integer iMax iIndex
31158>>>>>>>>>>>>>            Move (SizeOfArray(strDiagram.aClasses)-1) to iMax
31159>>>>>>>>>>>>>            For iIndex from 0 to iMax
31165>>>>>>>>>>>>>>
31165>>>>>>>>>>>>>                If (sLabel=strDiagram.aClasses[iIndex].sLabel) Begin
31167>>>>>>>>>>>>>                    Function_Return iIndex
31168>>>>>>>>>>>>>                End
31168>>>>>>>>>>>>>>
31168>>>>>>>>>>>>>            Loop
31169>>>>>>>>>>>>>>
31169>>>>>>>>>>>>>            Function_Return -1
31170>>>>>>>>>>>>>        End_Function
31171>>>>>>>>>>>>>        
31171>>>>>>>>>>>>>    Procedure SetClassColor tYumlClassDiagram ByRef strDiagram String sLabel String sColor
31173>>>>>>>>>>>>>        Integer iIndex
31173>>>>>>>>>>>>>        Get _FindClassLabelIndex strDiagram sLabel to iIndex
31174>>>>>>>>>>>>>        If (iIndex<>-1) Begin
31176>>>>>>>>>>>>>            Move sColor to strDiagram.aClasses[iIndex].sColor
31177>>>>>>>>>>>>>        End
31177>>>>>>>>>>>>>>
31177>>>>>>>>>>>>>        Else Begin
31178>>>>>>>>>>>>>            Error DFERR_PROGRAM ("yUML class label not found ("+sLabel+")")
31179>>>>>>>>>>>>>>
31179>>>>>>>>>>>>>        End
31179>>>>>>>>>>>>>>
31179>>>>>>>>>>>>>    End_Procedure
31180>>>>>>>>>>>>>    
31180>>>>>>>>>>>>>    Procedure AddClass tYumlClassDiagram ByRef strDiagram String sLabel
31182>>>>>>>>>>>>>        Integer iIndex
31182>>>>>>>>>>>>>        Get _FindClassLabelIndex strDiagram sLabel to iIndex
31183>>>>>>>>>>>>>        If (iIndex=-1) Begin
31185>>>>>>>>>>>>>            Move (SizeOfArray(strDiagram.aClasses)) to iIndex
31186>>>>>>>>>>>>>            Move sLabel to strDiagram.aClasses[iIndex].sLabel
31187>>>>>>>>>>>>>        End
31187>>>>>>>>>>>>>>
31187>>>>>>>>>>>>>    End_Procedure
31188>>>>>>>>>>>>>    
31188>>>>>>>>>>>>>    Procedure AddRelation tYumlClassDiagram ByRef strDiagram String sFrom String sTo Boolean bMark
31190>>>>>>>>>>>>>        Integer iFromIndex iToIndex iIndex
31190>>>>>>>>>>>>>        Send AddClass (&strDiagram) sFrom
31191>>>>>>>>>>>>>        Send AddClass (&strDiagram) sTo
31192>>>>>>>>>>>>>        Get _FindClassLabelIndex strDiagram sFrom to iFromIndex
31193>>>>>>>>>>>>>        Get _FindClassLabelIndex strDiagram sTo to iToIndex
31194>>>>>>>>>>>>>        Move (SizeOfArray(strDiagram.aRelations)) to iIndex
31195>>>>>>>>>>>>>        Move iFromIndex to strDiagram.aRelations[iIndex].iFrom
31196>>>>>>>>>>>>>        Move iToIndex to strDiagram.aRelations[iIndex].iTo
31197>>>>>>>>>>>>>        If (num_arguments>3) Begin
31199>>>>>>>>>>>>>            Move bMark to strDiagram.aRelations[iIndex].bMark
31200>>>>>>>>>>>>>        End
31200>>>>>>>>>>>>>>
31200>>>>>>>>>>>>>    End_Procedure
31201>>>>>>>>>>>>>    
31201>>>>>>>>>>>>>//        Function _DiagramUrlRelation tYumlClassDiagram strDiagram Integer iRelIndex Returns String
31201>>>>>>>>>>>>>//            String sLabelFrom sLabelTo sRval
31201>>>>>>>>>>>>>//
31201>>>>>>>>>>>>>//            Move ("["+strDiagram.aClasses[strDiagram.aRelations[iRelIndex].iFrom].sLabel+"]") to sRval
31201>>>>>>>>>>>>>//
31201>>>>>>>>>>>>>//            If (strDiagram.aRelations[iRelIndex].iType=0) Begin // 1:N
31201>>>>>>>>>>>>>//                Move (sRval+"->") to sRval
31201>>>>>>>>>>>>>//            End
31201>>>>>>>>>>>>>//            Else If (strDiagram.aRelations[iRelIndex].iType=1) Begin // 1:N dotted
31201>>>>>>>>>>>>>//                Move (sRval+"-.->") to sRval
31201>>>>>>>>>>>>>//            End
31201>>>>>>>>>>>>>//
31201>>>>>>>>>>>>>//            Move (sRval+"["+strDiagram.aClasses[strDiagram.aRelations[iRelIndex].iTo].sLabel+"]") to sRval
31201>>>>>>>>>>>>>//
31201>>>>>>>>>>>>>//            Function_Return sRval
31201>>>>>>>>>>>>>//        End_Function
31201>>>>>>>>>>>>>    
31201>>>>>>>>>>>>>        Function _DiagramUrlRelation tYumlClassDiagram strDiagram Integer iRelIndex Returns String
31203>>>>>>>>>>>>>            String sLabelFrom sLabelTo sRval
31203>>>>>>>>>>>>>
31203>>>>>>>>>>>>>
31203>>>>>>>>>>>>>            Move ("["+strDiagram.aClasses[strDiagram.aRelations[iRelIndex].iTo].sLabel+"]") to sRval
31204>>>>>>>>>>>>>
31204>>>>>>>>>>>>>            If (strDiagram.aRelations[iRelIndex].iType=0) Begin // 1:N
31206>>>>>>>>>>>>>                Move (sRval+"^-") to sRval
31207>>>>>>>>>>>>>            End
31207>>>>>>>>>>>>>>
31207>>>>>>>>>>>>>            Else If (strDiagram.aRelations[iRelIndex].iType=1) Begin // 1:N dotted
31210>>>>>>>>>>>>>//                Move (sRval+"-.->") to sRval
31210>>>>>>>>>>>>>            End
31210>>>>>>>>>>>>>>
31210>>>>>>>>>>>>>            If (strDiagram.aRelations[iRelIndex].bMark) Begin
31212>>>>>>>>>>>>>                Move (sRval+"*") to sRval
31213>>>>>>>>>>>>>            End
31213>>>>>>>>>>>>>>
31213>>>>>>>>>>>>>
31213>>>>>>>>>>>>>            Move (sRval+"["+strDiagram.aClasses[strDiagram.aRelations[iRelIndex].iFrom].sLabel+"]") to sRval
31214>>>>>>>>>>>>>
31214>>>>>>>>>>>>>            Function_Return sRval
31215>>>>>>>>>>>>>        End_Function
31216>>>>>>>>>>>>>    
31216>>>>>>>>>>>>>    Function DiagramUrl tYumlClassDiagram strDiagram Returns String
31218>>>>>>>>>>>>>        Integer iRelIndex iRelMax
31218>>>>>>>>>>>>>        String sUrl
31218>>>>>>>>>>>>>        
31218>>>>>>>>>>>>>        If (strDiagram.bScruffy) Begin
31220>>>>>>>>>>>>>            Move "http://yuml.me/diagram/scruffy/class/" to sUrl
31221>>>>>>>>>>>>>        End
31221>>>>>>>>>>>>>>
31221>>>>>>>>>>>>>        Else Begin    
31222>>>>>>>>>>>>>            Move "http://yuml.me/diagram/dir:td/class/" to sUrl
31223>>>>>>>>>>>>>        End
31223>>>>>>>>>>>>>>
31223>>>>>>>>>>>>>        
31223>>>>>>>>>>>>>        If (strDiagram.sNote<>"") Begin
31225>>>>>>>>>>>>>            Move (sUrl+"[note:"+strDiagram.sNote+"],") to sUrl
31226>>>>>>>>>>>>>        End
31226>>>>>>>>>>>>>>
31226>>>>>>>>>>>>>        
31226>>>>>>>>>>>>>        // Add all relations
31226>>>>>>>>>>>>>        Move (SizeOfArray(strDiagram.aRelations)-1) to iRelMax
31227>>>>>>>>>>>>>        For iRelIndex from 0 to iRelMax
31233>>>>>>>>>>>>>>
31233>>>>>>>>>>>>>            Move (sUrl+_DiagramUrlRelation(Self,strDiagram,iRelIndex)) to sUrl
31234>>>>>>>>>>>>>            If (iRelIndex<>iRelMax) Begin
31236>>>>>>>>>>>>>                Move (sUrl+",") to sUrl
31237>>>>>>>>>>>>>            End
31237>>>>>>>>>>>>>>
31237>>>>>>>>>>>>>        Loop
31238>>>>>>>>>>>>>>
31238>>>>>>>>>>>>>        
31238>>>>>>>>>>>>>        // Add alias file indications here
31238>>>>>>>>>>>>>        
31238>>>>>>>>>>>>>        
31238>>>>>>>>>>>>>        If (strDiagram.iImageType=1) Begin
31240>>>>>>>>>>>>>            Move (sUrl+".jpg") to sUrl
31241>>>>>>>>>>>>>        End
31241>>>>>>>>>>>>>>
31241>>>>>>>>>>>>>        Else If (strDiagram.iImageType=2) Begin
31244>>>>>>>>>>>>>            Move (sUrl+".pdf") to sUrl
31245>>>>>>>>>>>>>        End
31245>>>>>>>>>>>>>>
31245>>>>>>>>>>>>>        
31245>>>>>>>>>>>>>//        Get UrlCharacterEncode of oUrlFunctions sUrl to sUrl
31245>>>>>>>>>>>>>        
31245>>>>>>>>>>>>>        Function_Return sUrl
31246>>>>>>>>>>>>>    End_Function
31247>>>>>>>>>>>>>    
31247>>>>>>>>>>>>>    Function SaveJpgAs tYumlClassDiagram strDiagram String sJpgFileName Returns Boolean
31249>>>>>>>>>>>>>        Integer iVal
31249>>>>>>>>>>>>>        String sUrl
31249>>>>>>>>>>>>>        Set psSaveAsFile of oHttpTransfer to sJpgFileName
31250>>>>>>>>>>>>>        Get DiagramUrl strDiagram to sUrl
31251>>>>>>>>>>>>>        Get HTTPGetRequest of oHttpTransfer (Replace("http://yuml.me",sUrl,"")) to iVal
31252>>>>>>>>>>>>>        Function_Return (iVal<>0)
31253>>>>>>>>>>>>>    End_Function
31254>>>>>>>>>>>>>    
31254>>>>>>>>>>>>>End_Class // cYumlFunctions
31255>>>>>>>>>>>>>
31255>>>>>>>>>>>>>Global_Variable Integer oYumlFunctions
31255>>>>>>>>>>>>>
31255>>>>>>>>>>>>>Object _oYumlFunctions is a cYumlFunctions
31257>>>>>>>>>>>>>    Move Self to oYumlFunctions
31258>>>>>>>>>>>>>End_Object
31259>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
Including file: FileFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\FileFunctions.pkg)
31259>>>>>>>>>>>>>// File functions encapsulated in oFileFunctions (SturesPublicLib)
31259>>>>>>>>>>>>>
31259>>>>>>>>>>>>>//> The oFileFunctions object contains methods for handling input/output and for manipulating file and folder names.
31259>>>>>>>>>>>>>//> pkg.doc.end
31259>>>>>>>>>>>>>
31259>>>>>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
31259>>>>>>>>>>>>>
31259>>>>>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
31259>>>>>>>>>>>>>Use WindowsInfo.pkg     // NetworkUserName function
Including file: WindowsInfo.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\WindowsInfo.pkg)
31259>>>>>>>>>>>>>>>//> The WindowsInfo object contains methods for querying Windows about this and that.
31259>>>>>>>>>>>>>>>//> pkg.doc.end
31259>>>>>>>>>>>>>>>
31259>>>>>>>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
31259>>>>>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
31259>>>>>>>>>>>>>>>
31259>>>>>>>>>>>>>>>External_Function wi_WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
31260>>>>>>>>>>>>>>>
31260>>>>>>>>>>>>>>>External_Function wi_InternetGetConnectedState "InternetGetConnectedState" WinInet.dll Pointer lpdwFlags Integer dwReserved Returns Integer
31261>>>>>>>>>>>>>>>
31261>>>>>>>>>>>>>>>External_Function wi_WinAPI_GetDefaultPrinter "GetDefaultPrinterA" Winspool.Drv Address pszBuffer UInteger pcchBuffer Returns Boolean
31262>>>>>>>>>>>>>>>External_Function wi_WinAPI_SetDefaultPrinter "SetDefaultPrinterA" Winspool.Drv Address pszBuffer Returns Boolean
31263>>>>>>>>>>>>>>>External_Function wi_WinAPI_GetComputerName   "GetComputerNameA"   Kernel32.dll Pointer lpBuffer Pointer lpnSize Returns Integer
31264>>>>>>>>>>>>>>>
31264>>>>>>>>>>>>>>>
31264>>>>>>>>>>>>>>>Global_Variable Integer oWindowsInfo
31264>>>>>>>>>>>>>>>
31264>>>>>>>>>>>>>>>Object _oWindowsInfo is a cObject
31266>>>>>>>>>>>>>>>    Move Self to oWindowsInfo
31267>>>>>>>>>>>>>>>
31267>>>>>>>>>>>>>>>    // All of the printer stuff has been copied (and modified) from Vincents: http://www.dataaccess.com/kbasepublic/KBPrint.asp?ArticleID=2322
31267>>>>>>>>>>>>>>>
31267>>>>>>>>>>>>>>>    Function Printer_Default Returns String
31270>>>>>>>>>>>>>>>        String sPrinterName
31270>>>>>>>>>>>>>>>        Integer iBufferSize
31270>>>>>>>>>>>>>>>        Boolean bSuccess
31270>>>>>>>>>>>>>>>
31270>>>>>>>>>>>>>>>        Move 0 to iBufferSize
31271>>>>>>>>>>>>>>>        Move (wi_WinAPI_GetDefaultPrinter(0,AddressOf(iBufferSize))) to bSuccess
31272>>>>>>>>>>>>>>>        If (not (bSuccess)) Begin
31274>>>>>>>>>>>>>>>            ZeroString iBufferSize to sPrinterName
31275>>>>>>>>>>>>>>>            Move (wi_WinAPI_GetDefaultPrinter(AddressOf(sPrinterName),AddressOf(iBufferSize))) to bSuccess
31276>>>>>>>>>>>>>>>        End
31276>>>>>>>>>>>>>>>>
31276>>>>>>>>>>>>>>>
31276>>>>>>>>>>>>>>>        Move (CString(sPrinterName)) to sPrinterName
31277>>>>>>>>>>>>>>>        Move (ToOEM(sPrinterName)) to sPrinterName // Sture
31278>>>>>>>>>>>>>>>        Function_Return sPrinterName
31279>>>>>>>>>>>>>>>    End_Function
31280>>>>>>>>>>>>>>>
31280>>>>>>>>>>>>>>>    Function Printer_SetDefault String sPrinterName Returns Boolean
31283>>>>>>>>>>>>>>>        Boolean bSuccess
31283>>>>>>>>>>>>>>>        Move (ToANSI(sPrinterName)) to sPrinterName // Sture
31284>>>>>>>>>>>>>>>        Move (wi_WinAPI_SetDefaultPrinter(AddressOf(sPrinterName))) to bSuccess
31285>>>>>>>>>>>>>>>        Function_Return bSuccess
31286>>>>>>>>>>>>>>>    End_Function
31287>>>>>>>>>>>>>>>
31287>>>>>>>>>>>>>>>    Function NetworkUserName Returns String // Stolen from Dfabout.pkg
31290>>>>>>>>>>>>>>>        String sName
31290>>>>>>>>>>>>>>>        Integer iRetval iLength
31290>>>>>>>>>>>>>>>        ZeroString 255 to sName
31291>>>>>>>>>>>>>>>        Move 255 to iLength
31292>>>>>>>>>>>>>>>        Move (wi_WNetGetUser (0, AddressOf (sName), AddressOf (iLength))) to iRetval
31293>>>>>>>>>>>>>>>        If (iRetval = 0) Begin
31295>>>>>>>>>>>>>>>            Function_Return (CString (sName))
31296>>>>>>>>>>>>>>>        End
31296>>>>>>>>>>>>>>>>
31296>>>>>>>>>>>>>>>        Else Begin
31297>>>>>>>>>>>>>>>            Function_Return "User unknown"
31298>>>>>>>>>>>>>>>        End
31298>>>>>>>>>>>>>>>>
31298>>>>>>>>>>>>>>>    End_Function // Network_User_Name
31299>>>>>>>>>>>>>>>
31299>>>>>>>>>>>>>>>    Define wi_INTERNET_CONNECTION_MODEM        For 1
31299>>>>>>>>>>>>>>>    Define wi_INTERNET_CONNECTION_LAN          For 2
31299>>>>>>>>>>>>>>>    Define wi_INTERNET_CONNECTION_PROXY        For 4
31299>>>>>>>>>>>>>>>    Define wi_INTERNET_CONNECTION_MODEM_BUSY   For 8
31299>>>>>>>>>>>>>>>
31299>>>>>>>>>>>>>>>    Function InternetConnectedState Returns Integer
31302>>>>>>>>>>>>>>>        // Thanks to Raveen Ryan Sundram!
31302>>>>>>>>>>>>>>>
31302>>>>>>>>>>>>>>>        Integer iFlags iRet
31302>>>>>>>>>>>>>>>        Pointer lpdwFlags
31302>>>>>>>>>>>>>>>
31302>>>>>>>>>>>>>>>        Move 0 To iFlags
31303>>>>>>>>>>>>>>>        GetAddress Of iFlags To lpdwFlags
31304>>>>>>>>>>>>>>>        Move (wi_InternetGetConnectedState(lpdwFlags,0)) To iRet
31305>>>>>>>>>>>>>>>        If (iRet) Begin // Connected!
31307>>>>>>>>>>>>>>>          If (iFlags Iand wi_INTERNET_CONNECTION_MODEM) Begin
31309>>>>>>>>>>>>>>>              Function_Return wi_INTERNET_CONNECTION_MODEM      //  'Connection via MODEM'
31310>>>>>>>>>>>>>>>          End
31310>>>>>>>>>>>>>>>>
31310>>>>>>>>>>>>>>>          If (iFlags Iand wi_INTERNET_CONNECTION_LAN) Begin
31312>>>>>>>>>>>>>>>              Function_Return wi_INTERNET_CONNECTION_LAN        //  'Connection via LAN'
31313>>>>>>>>>>>>>>>          End
31313>>>>>>>>>>>>>>>>
31313>>>>>>>>>>>>>>>          If (iFlags Iand wi_INTERNET_CONNECTION_PROXY) Begin
31315>>>>>>>>>>>>>>>              Function_Return wi_INTERNET_CONNECTION_PROXY      //  'Connection via PROXY'
31316>>>>>>>>>>>>>>>          End
31316>>>>>>>>>>>>>>>>
31316>>>>>>>>>>>>>>>          If (iFlags Iand wi_INTERNET_CONNECTION_MODEM_BUSY) Begin
31318>>>>>>>>>>>>>>>              Function_Return wi_INTERNET_CONNECTION_MODEM_BUSY //  'Connection via MODEM but modem is BUSY'
31319>>>>>>>>>>>>>>>          End
31319>>>>>>>>>>>>>>>>
31319>>>>>>>>>>>>>>>        End
31319>>>>>>>>>>>>>>>>
31319>>>>>>>>>>>>>>>        Function_Return 0 // Not connected
31320>>>>>>>>>>>>>>>    End_Function
31321>>>>>>>>>>>>>>>
31321>>>>>>>>>>>>>>>    Function ComputerName Returns String
31324>>>>>>>>>>>>>>>        String sMachineName
31324>>>>>>>>>>>>>>>        Integer iSize iResult
31324>>>>>>>>>>>>>>>
31324>>>>>>>>>>>>>>>        Move 16 to iSize //Maximum Computer name length + 1
31325>>>>>>>>>>>>>>>        Move (repeat(Character(0),iSize)) to sMachineName
31326>>>>>>>>>>>>>>>
31326>>>>>>>>>>>>>>>        Move (wi_WinAPI_GetComputerName(AddressOf(sMachineName), AddressOf(iSize))) to iResult
31327>>>>>>>>>>>>>>>        
31327>>>>>>>>>>>>>>>        Move (CString(sMachineName)) to sMachineName
31328>>>>>>>>>>>>>>>        
31328>>>>>>>>>>>>>>>        Function_Return sMachineName
31329>>>>>>>>>>>>>>>    End_Function
31330>>>>>>>>>>>>>>>
31330>>>>>>>>>>>>>>>
31330>>>>>>>>>>>>>>>End_Object
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg // Global functions by DAW
31331>>>>>>>>>>>>>Use Seq_Chnl // Defines global sequential device management operations (DAW)
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>// File attributes
31331>>>>>>>>>>>>>Define C_MAX_PATH                 for 260
31331>>>>>>>>>>>>>Define C_MAXDWORD                 for |CI$FFFFFFFF
31331>>>>>>>>>>>>>Define C_INVALID_HANDLE_VALUE     for -1
31331>>>>>>>>>>>>>Define C_FILE_ATTRIBUTE_READONLY  for |CI$00000001
31331>>>>>>>>>>>>>Define C_FILE_ATTRIBUTE_HIDDEN    for |CI$00000002
31331>>>>>>>>>>>>>Define C_FILE_ATTRIBUTE_SYSTEM    for |CI$00000004
31331>>>>>>>>>>>>>Define C_FILE_ATTRIBUTE_DIRECTORY for |CI$00000010
31331>>>>>>>>>>>>>Define C_FILE_ATTRIBUTE_ARCHIVE   for |CI$00000020
31331>>>>>>>>>>>>>Define C_FILE_ATTRIBUTE_NORMAL    for |CI$00000080
31331>>>>>>>>>>>>>Define C_FILE_ATTRIBUTE_TEMPORARY for |CI$00000100
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>// File operations flag
31331>>>>>>>>>>>>>Define C_MULTIDESTFILES    for |CI$0001  // The Destination property specifies multiple destination files (one for each source file) rather than one directory where all source files are to be deposited.
31331>>>>>>>>>>>>>Define C_CONFIRMMOUSE      for |CI$0002
31331>>>>>>>>>>>>>Define C_SILENT            for |CI$0004  // Do not display a progress dialog box.
31331>>>>>>>>>>>>>Define C_RENAMEONCOLLISION for |CI$0008
31331>>>>>>>>>>>>>Define C_NOCONFIRMATION    for |CI$0010  // Respond with "Yes to All" for any dialog box that is displayed.
31331>>>>>>>>>>>>>Define C_WANTMAPPINGHANDLE for |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings (must be freed using SHFreeNameMappings)
31331>>>>>>>>>>>>>Define C_ALLOWUNDO         for |CI$0040  // Preserve Undo information, if possible. If Source property does not contain fully qualified path and file names, this flag is ignored.
31331>>>>>>>>>>>>>Define C_FILESONLY         for |CI$0080  // Perform the operation on files only if a wildcard file name (*.*) is specified.
31331>>>>>>>>>>>>>Define C_SIMPLEPROGRESS    for |CI$0100  // Display a progress dialog box but do not show the file names.
31331>>>>>>>>>>>>>Define C_NOCONFIRMMKDIR    for |CI$0200  // Do not confirm the creation of a new directory if the operation requires one to be created.
31331>>>>>>>>>>>>>Define C_NOERRORUI         for |CI$0400  // Do not display a user interface if an error occurs.
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>// File operations
31331>>>>>>>>>>>>>Define CFO_MOVE            for |CI$0001
31331>>>>>>>>>>>>>Define CFO_COPY            for |CI$0002
31331>>>>>>>>>>>>>Define CFO_DELETE          for |CI$0003
31331>>>>>>>>>>>>>Define CFO_RENAME          for |CI$0004
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>//> The CSIDL symbols correspond to either file system or virtual folders.
31331>>>>>>>>>>>>>//> Where the CSIDL identifies a file system folder, a commonly used path
31331>>>>>>>>>>>>>//> is given as an example. Other paths may be used. Some CSIDLs can be
31331>>>>>>>>>>>>>//> mapped to an equivalent %VariableName% environment variable.
31331>>>>>>>>>>>>>//> CSIDLs are much more reliable, however, and should be used if at all possible.
31331>>>>>>>>>>>>>//>
31331>>>>>>>>>>>>>//> The symbols are used as parameter to the WinFolderPath function (WinFolderPath).
31331>>>>>>>>>>>>>Enum_List
31331>>>>>>>>>>>>>    Define CSIDL_ADMINTOOLS              for |CI$0030 //> File system directory that is used to store administrative tools for an individual user. The Microsoft Management Console will save customized consoles to this directory and it will roam with the user. (Version 5.0)
31331>>>>>>>>>>>>>    Define CSIDL_ALTSTARTUP              for |CI$001D //> File system directory that corresponds to the user's nonlocalized Startup program group.
31331>>>>>>>>>>>>>    Define CSIDL_APPDATA                 for |CI$001A //> File system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\username\Application Data. This CSIDL is supported by the redistributable ShFolder.dll for systems that do not have the Internet Explorer 4.0 integrated shell installed. (Version 4.71)
31331>>>>>>>>>>>>>    Define CSIDL_BITBUCKET               for |CI$000A //> Virtual folder containing the objects in the user's Recycle Bin.
31331>>>>>>>>>>>>>    Define CSIDL_COMMON_ADMINTOOLS       for |CI$002F //> File system directory containing containing administrative tools for all users of the computer. Version 5
31331>>>>>>>>>>>>>    Define CSIDL_COMMON_ALTSTARTUP       for |CI$001E //> File system directory that corresponds to the nonlocalized Startup program group for all users. Valid only for Windows NT systems.
31331>>>>>>>>>>>>>    Define CSIDL_COMMON_APPDATA          for |CI$0023 //> Application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data. Version 5
31331>>>>>>>>>>>>>    Define CSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 //> File system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop. Valid only for Windows NT systems.
31331>>>>>>>>>>>>>    Define CSIDL_COMMON_DOCUMENTS        for |CI$002E //> File system directory that contains documents that are common to all users. A typical path is C:\Documents and Settings\All Users\Documents. Valid for Windows NT systems and Windows 95 and Windows 98 systems with Shfolder.dll installed.
31331>>>>>>>>>>>>>    Define CSIDL_COMMON_FAVORITES        for |CI$001F //> File system directory that serves as a common repository for all users' favorite items. Valid only for Windows NT systems.
31331>>>>>>>>>>>>>    Define CSIDL_COMMON_PROGRAMS         for |CI$0017 //> File system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs. Valid only for Windows NT systems.
31331>>>>>>>>>>>>>    Define CSIDL_COMMON_STARTMENU        for |CI$0016 //> File system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu. Valid only for Windows NT systems.
31331>>>>>>>>>>>>>    Define CSIDL_COMMON_STARTUP          for |CI$0018 //> File system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup. Valid only for Windows NT systems.
31331>>>>>>>>>>>>>    Define CSIDL_COMMON_TEMPLATES        for |CI$002D //> File system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates. Valid only for Windows NT systems.
31331>>>>>>>>>>>>>    Define CSIDL_CONTROLS                for |CI$0003 //> Virtual folder containing icons for the Control Panel applications.
31331>>>>>>>>>>>>>    Define CSIDL_COOKIES                 for |CI$0021 //> File system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies.
31331>>>>>>>>>>>>>    Define CSIDL_DESKTOP                 for |CI$0000 //> Windows Desktop-virtual folder that is the root of the namespace..
31331>>>>>>>>>>>>>    Define CSIDL_DESKTOPDIRECTORY        for |CI$0010 //> File system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). a typical path is C:\Documents and Settings\username\Desktop
31331>>>>>>>>>>>>>    Define CSIDL_DRIVES                  for |CI$0011 //> My Computer-virtual folder containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives.
31331>>>>>>>>>>>>>    Define CSIDL_FAVORITES               for |CI$0006 //> File system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites.
31331>>>>>>>>>>>>>    Define CSIDL_FONTS                   for |CI$0014 //> Virtual folder containing fonts. A typical path is C:\WINNT\Fonts.
31331>>>>>>>>>>>>>    Define CSIDL_HISTORY                 for |CI$0022 //> File system directory that serves as a common repository for Internet history items.
31331>>>>>>>>>>>>>    Define CSIDL_INTERNET                for |CI$0001 //> Virtual folder representing the Internet.
31331>>>>>>>>>>>>>    Define CSIDL_INTERNET_CACHE          for |CI$0020 //> File system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Temporary Internet Files.
31331>>>>>>>>>>>>>    Define CSIDL_LOCAL_APPDATA           for |CI$001C //> File system directory that serves as a data repository for local (non-roaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data. Version 5
31331>>>>>>>>>>>>>    Define CSIDL_MYPICTURES              for |CI$0027 //> My Pictures folder. A typical path is C:\Documents and Settings\username\My Documents\My Pictures. Version 5
31331>>>>>>>>>>>>>    Define CSIDL_NETHOOD                 for |CI$0013 //> A file system folder containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood.
31331>>>>>>>>>>>>>    Define CSIDL_NETWORK                 for |CI$0012 //> Network Neighborhood-virtual folder representing the root of the network namespace hierarchy.
31331>>>>>>>>>>>>>    Define CSIDL_PERSONAL                for |CI$0005 //> File system directory that serves as a common repository for documents. A typical path is C:\Documents and Settings\username\My Documents.
31331>>>>>>>>>>>>>    Define CSIDL_PRINTERS                for |CI$0004 //> Virtual folder containing installed printers.
31331>>>>>>>>>>>>>    Define CSIDL_PRINTHOOD               for |CI$001B //> File system directory that contains the link objects that may exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood.
31331>>>>>>>>>>>>>    Define CSIDL_PROFILE                 for |CI$0028 //> User's profile folder. Version 5
31331>>>>>>>>>>>>>    Define CSIDL_PROGRAM_FILES           for |CI$002A //> Program Files folder. A typical path is C:\Program Files. Version 5
31331>>>>>>>>>>>>>    Define CSIDL_PROGRAM_FILES_COMMON    for |CI$002B //> A folder for components that are shared across applications. A typical path is C:\Program Files\Common. Valid only for Windows NT and Windows 2000 systems. Version 5
31331>>>>>>>>>>>>>    Define CSIDL_PROGRAM_FILES_COMMONX86 for |CI$002C //> Program Files folder that is common to all users for x86 applications on RISC systems. A typical path is C:\Program Files (x86)\Common. Version 5
31331>>>>>>>>>>>>>    Define CSIDL_PROGRAMS                for |CI$0002 //> File system directory that contains the user's program groups (which are also file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs.
31331>>>>>>>>>>>>>    Define CSIDL_RECENT                  for |CI$0008 //> File system directory that contains the user's most recently used documents. A typical path is C:\Documents and Settings\username\Recent. To create a shortcut in this folder, use SHAddToRecentDocs. In addition to creating the shortcut, this function updates the shell's list of recent documents and adds the shortcut to the Documents submenu of the Start menu.
31331>>>>>>>>>>>>>    Define CSIDL_SENDTO                  for |CI$0009 //> File system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo.
31331>>>>>>>>>>>>>    Define CSIDL_STARTMENU               for |CI$000B //> File system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu.
31331>>>>>>>>>>>>>    Define CSIDL_STARTUP                 for |CI$0007 //> File system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup.
31331>>>>>>>>>>>>>    Define CSIDL_SYSTEM                  for |CI$0025 //> System folder. A typical path is C:\WINNT\SYSTEM32. Version 5
31331>>>>>>>>>>>>>    Define CSIDL_SYSTEMX86               for |CI$0029 //> System folder for x86 applications on RISC systems. A typical path is C:\WINNT\SYS32X86. Version 5
31331>>>>>>>>>>>>>    Define CSIDL_TEMPLATES               for |CI$0015 //> File system directory that serves as a common repository for document templates.
31331>>>>>>>>>>>>>    Define CSIDL_WINDOWS                 for |CI$0024 //> Version 5.0. Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\WINNT.
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>    Define CSIDL_CDBURN_AREA             for |CI$003B
31331>>>>>>>>>>>>>    Define CSIDL_COMMON_MUSIC            for |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
31331>>>>>>>>>>>>>    Define CSIDL_COMMON_PICTURES         for |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
31331>>>>>>>>>>>>>    Define CSIDL_COMMON_VIDEO            for |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
31331>>>>>>>>>>>>>    Define CSIDL_COMPUTERSNEARME         for |CI$003D // The folder representing other machines in your workgroup
31331>>>>>>>>>>>>>    Define CSIDL_CONNECTIONS             for |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
31331>>>>>>>>>>>>>    Define CSIDL_MYDOCUMENTS             for |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
31331>>>>>>>>>>>>>    Define CSIDL_MYMUSIC                 for |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
31331>>>>>>>>>>>>>    Define CSIDL_MYVIDEO                 for |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
31331>>>>>>>>>>>>>    Define CSIDL_PHOTOALBUMS             for |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
31331>>>>>>>>>>>>>    Define CSIDL_PLAYLISTS               for |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
31331>>>>>>>>>>>>>    Define CSIDL_RESOURCES               for |CI$0038 // undocumented
31331>>>>>>>>>>>>>    Define CSIDL_SAMPLE_MUSIC            for |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
31331>>>>>>>>>>>>>    Define CSIDL_SAMPLE_PLAYLISTS        for |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
31331>>>>>>>>>>>>>    Define CSIDL_SAMPLE_PICTURES         for |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
31331>>>>>>>>>>>>>    Define CSIDL_SAMPLE_VIDEOS           for |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>//  Define CSIDL_FLAG_CREATE             for |CI$8000 //> If a special folder does not exist, you can force it to be created by using the following special CSIDL. (Version 5.0) Combine this CSIDL with any of the CSIDLs listed below to force the creation of the associated folder.
31331>>>>>>>>>>>>>End_Enum_List
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>Struct tFileTimeStamp
31331>>>>>>>>>>>>>    DWord dwLowDateTime
31331>>>>>>>>>>>>>    DWord dwHighDateTime
31331>>>>>>>>>>>>>End_Struct
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>Struct tFileSize
31331>>>>>>>>>>>>>    DWord dwHighSize
31331>>>>>>>>>>>>>    DWord dwLowSize
31331>>>>>>>>>>>>>End_Struct
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>Struct tSystemTime
31331>>>>>>>>>>>>>    Short iYear
31331>>>>>>>>>>>>>    Short iMonth
31331>>>>>>>>>>>>>    Short iDayOfWeek
31331>>>>>>>>>>>>>    Short iDay
31331>>>>>>>>>>>>>    Short iHour
31331>>>>>>>>>>>>>    Short iMinute
31331>>>>>>>>>>>>>    Short iSecond
31331>>>>>>>>>>>>>    Short iMilliSeconds
31331>>>>>>>>>>>>>End_Struct
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>Struct _tFileFindData
31331>>>>>>>>>>>>>    DWord dwFileAttributes
31331>>>>>>>>>>>>>    tFileTimeStamp ftCreation
31331>>>>>>>>>>>>>    tFileTimeStamp ftCreation
31331>>>>>>>>>>>>>    tFileTimeStamp ftLastAccess
31331>>>>>>>>>>>>>    tFileTimeStamp ftLastAccess
31331>>>>>>>>>>>>>    tFileTimeStamp ftLastWrite
31331>>>>>>>>>>>>>    tFileTimeStamp ftLastWrite
31331>>>>>>>>>>>>>    tFileSize fsFileSize
31331>>>>>>>>>>>>>    tFileSize fsFileSize
31331>>>>>>>>>>>>>    DWord dwReserved0
31331>>>>>>>>>>>>>    DWord dwReserved1
31331>>>>>>>>>>>>>    Char[C_MAX_PATH] csFileName// MAX_PATH=260
31331>>>>>>>>>>>>>    Char[14] csAlternateFileName
31331>>>>>>>>>>>>>End_Struct
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>Struct tFileData
31331>>>>>>>>>>>>>    String sFileName // This is the filename stripped of its path
31331>>>>>>>>>>>>>    String sAlternateFileName // This is the 8.3 filename equivalent (DOS name)
31331>>>>>>>>>>>>>    DWord dwFileAttributes
31331>>>>>>>>>>>>>    DateTime dtCreation
31331>>>>>>>>>>>>>    DateTime dtLastAccess
31331>>>>>>>>>>>>>    DateTime dtLastWrite
31331>>>>>>>>>>>>>    Boolean bIsFolder
31331>>>>>>>>>>>>>    Boolean bSelfReference
31331>>>>>>>>>>>>>    Number nFileSize
31331>>>>>>>>>>>>>    Integer iAuxData
31331>>>>>>>>>>>>>    tFileData[] aFolderContent // if (sFileData.dwFileAttributes iand C_FILE_ATTRIBUTE_DIRECTORY) this member _may_ hold the content of a sub-folder
31331>>>>>>>>>>>>>    tFileData[] aFolderContent // if (sFileData.dwFileAttributes iand C_FILE_ATTRIBUTE_DIRECTORY) this member _may_ hold the content of a sub-folder
31331>>>>>>>>>>>>>End_Struct
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>Struct _tFileBrowseInfo
31331>>>>>>>>>>>>>    Handle  hWndOwner
31331>>>>>>>>>>>>>    Pointer pIDLRoot
31331>>>>>>>>>>>>>    Pointer pszDisplayName
31331>>>>>>>>>>>>>    Pointer lpszTitle
31331>>>>>>>>>>>>>    dWord   ulFlags
31331>>>>>>>>>>>>>    Pointer lpfnCallback
31331>>>>>>>>>>>>>    dWord   lParam
31331>>>>>>>>>>>>>    dWord   iImage
31331>>>>>>>>>>>>>End_Struct
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>Struct _tFileOperation
31331>>>>>>>>>>>>>    Handle  hWnd
31331>>>>>>>>>>>>>    Integer wFunc
31331>>>>>>>>>>>>>    Pointer pFrom
31331>>>>>>>>>>>>>    Pointer pTo
31331>>>>>>>>>>>>>    Short   fFlags
31331>>>>>>>>>>>>>    Short   fAnyOperationsAborted
31331>>>>>>>>>>>>>    Pointer hNameMappings
31331>>>>>>>>>>>>>    Pointer lpszProgressTitle // only used if C_SIMPLEPROGRESS
31331>>>>>>>>>>>>>End_Struct
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>Struct tFileChop
31331>>>>>>>>>>>>>    Integer iLen
31331>>>>>>>>>>>>>    String  sContent
31331>>>>>>>>>>>>>End_Struct
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>Struct tFileInChops
31331>>>>>>>>>>>>>    String sPath
31331>>>>>>>>>>>>>    Integer eEncoding // 0=0one, 1=hex, 2=base64.pkg, 3=base64.dll
31331>>>>>>>>>>>>>    tFileChop[] aSegments
31331>>>>>>>>>>>>>    tFileChop[] aSegments
31331>>>>>>>>>>>>>End_Struct
31331>>>>>>>>>>>>>
31331>>>>>>>>>>>>>// lpFileName      : address of name of file to search for
31331>>>>>>>>>>>>>// lpFindFileData  : address of returned information
31331>>>>>>>>>>>>>External_Function ff_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName Pointer lpFindFileData Returns Handle
31332>>>>>>>>>>>>>
31332>>>>>>>>>>>>>// hFindFile       : handle of search
31332>>>>>>>>>>>>>// lpFindFileData  : address of structure for data on found file
31332>>>>>>>>>>>>>External_Function ff_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile Pointer lpFindFileData Returns Integer
31333>>>>>>>>>>>>>
31333>>>>>>>>>>>>>//  hFindFile      : file search handle
31333>>>>>>>>>>>>>External_Function ff_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
31334>>>>>>>>>>>>>
31334>>>>>>>>>>>>>//  lpFileTime     : pointer to file time to convert
31334>>>>>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
31334>>>>>>>>>>>>>External_Function ff_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll Pointer lpFileTime Pointer lpSystemTime Returns Integer
31335>>>>>>>>>>>>>
31335>>>>>>>>>>>>>External_Function ff_SHGetSpecialFolderPath "SHGetSpecialFolderPathA" Shell32.dll Integer i1 Integer i2 Integer i3 Integer i4 Returns Integer
31336>>>>>>>>>>>>>
31336>>>>>>>>>>>>>External_Function ff_ShellExecute "ShellExecuteA" Shell32.Dll Handle hwnd String sOperation String sFile String sParameters String sDirectory Integer nShowCmd Returns VOID_TYPE
31337>>>>>>>>>>>>>
31337>>>>>>>>>>>>>External_Function ff_CreateDirectory "CreateDirectoryA" Kernel32.dll Pointer lpFileName Pointer lpSecurityAttributes Returns Integer
31338>>>>>>>>>>>>>
31338>>>>>>>>>>>>>External_Function ff_RemoveDirectory "RemoveDirectoryA" Kernel32.dll Pointer lpFileName Returns Integer
31339>>>>>>>>>>>>>
31339>>>>>>>>>>>>>External_Function ff_SHBrowseForFolder   "SHBrowseForFolder"   Shell32.dll Pointer lpdWordx Returns DWord
31340>>>>>>>>>>>>>External_Function ff_SHGetPathFromIDList "SHGetPathFromIDList" Shell32.dll Pointer pidList Pointer lpBuffer Returns DWord
31341>>>>>>>>>>>>>External_Function ff_CoTaskMemFree       "CoTaskMemFree"       Ole32.dll   Pointer pv Returns Integer
31342>>>>>>>>>>>>>
31342>>>>>>>>>>>>>// From msdn: Returns zero if successful; otherwise nonzero. Applications normally should simply check for zero or nonzero.
31342>>>>>>>>>>>>>External_Function ff_SHFileOperation "SHFileOperationA" Shell32.dll Pointer lpFileOp Returns Integer
31343>>>>>>>>>>>>>
31343>>>>>>>>>>>>>External_Function ff_SetFileAttributes "SetFileAttributesA" Kernel32.dll Pointer lpFileName DWord dwFileAttributes Returns Integer
31344>>>>>>>>>>>>>External_Function ff_GetFileAttributes "GetFileAttributesA" Kernel32.dll Pointer lpFileName Returns DWord
31345>>>>>>>>>>>>>
31345>>>>>>>>>>>>>External_Function ff_TempPath "GetTempPathA" Kernel32.dll DWord nBufferLength Pointer lpBuffer Returns Integer
31346>>>>>>>>>>>>>
31346>>>>>>>>>>>>>External_Function ff_GetLongPathName "GetLongPathNameA" Kernel32.Dll Pointer lpszShortPath Pointer lpszLongPath DWord cchBuffer Returns DWord
31347>>>>>>>>>>>>>
31347>>>>>>>>>>>>>// This can be a file or a folder.
31347>>>>>>>>>>>>>
31347>>>>>>>>>>>>>Define FF_KILOBYTE for 1024
31347>>>>>>>>>>>>>Define FF_MEGABYTE for 1048576
31347>>>>>>>>>>>>>Define FF_GIGABYTE for 1073741824
31347>>>>>>>>>>>>>
31347>>>>>>>>>>>>>Enum_List
31347>>>>>>>>>>>>>    Define FF_ALL
31347>>>>>>>>>>>>>    Define FF_FILE
31347>>>>>>>>>>>>>    Define FF_FOLDER
31347>>>>>>>>>>>>>End_Enum_List
31347>>>>>>>>>>>>>
31347>>>>>>>>>>>>>Class cFileFunctions is a cObject
31348>>>>>>>>>>>>>    
31348>>>>>>>>>>>>>    Procedure Construct_Object
31350>>>>>>>>>>>>>        Forward Send Construct_Object
31352>>>>>>>>>>>>>        Property Boolean _pbCreateVDFXRayFolderOnReq False
31353>>>>>>>>>>>>>    End_Procedure
31354>>>>>>>>>>>>>
31354>>>>>>>>>>>>>    // Parameter naming convensions:
31354>>>>>>>>>>>>>    //
31354>>>>>>>>>>>>>    //  string sFileName   : A filename excluding folder path
31354>>>>>>>>>>>>>    //  string sPath       : Filename including absolute path
31354>>>>>>>>>>>>>    //  string sFolder     : The absolute path of a folder
31354>>>>>>>>>>>>>    //  string sFolderList : A list of folders separated by ; characters
31354>>>>>>>>>>>>>
31354>>>>>>>>>>>>>    //> Function IsLegalFileName will return the position of the first illegal character found
31354>>>>>>>>>>>>>    //> in the sFileName parameter. If sFileName contains the empty string or a string
31354>>>>>>>>>>>>>    //> beginning or ending with a space character, -1 is returned. If sFileName contains a
31354>>>>>>>>>>>>>    //> legal filename 0 is returned.
31354>>>>>>>>>>>>>    //>
31354>>>>>>>>>>>>>    //> The function does not check with the OS file system. It simply checks that
31354>>>>>>>>>>>>>    //> there are no illegal characters in the filename for our purpose (which is?)
31354>>>>>>>>>>>>>    
31354>>>>>>>>>>>>>    Function IsLegalFileName String sFileName Returns Integer
31356>>>>>>>>>>>>>        Integer iPos iLen
31356>>>>>>>>>>>>>        String sIllegalChars sChar
31356>>>>>>>>>>>>>        
31356>>>>>>>>>>>>>        Move (Length(sFileName)) to iLen
31357>>>>>>>>>>>>>        If (Trim(sFileName)<>sFileName or iLen=0) begin
31359>>>>>>>>>>>>>            Function_Return -1
31360>>>>>>>>>>>>>        End
31360>>>>>>>>>>>>>>
31360>>>>>>>>>>>>>
31360>>>>>>>>>>>>>        // These *are* legal:  ; ( )
31360>>>>>>>>>>>>>        Move ':\/"<>|' to sIllegalChars
31361>>>>>>>>>>>>>
31361>>>>>>>>>>>>>        For iPos from 1 to iLen
31367>>>>>>>>>>>>>>
31367>>>>>>>>>>>>>            Move (Mid(sFileName,1,iPos)) to sChar
31368>>>>>>>>>>>>>            If (sIllegalChars contains sChar) Function_Return iPos
31371>>>>>>>>>>>>>            If (Ascii(sChar)<32) Function_Return iPos
31374>>>>>>>>>>>>>        Loop
31375>>>>>>>>>>>>>>
31375>>>>>>>>>>>>>
31375>>>>>>>>>>>>>        Function_Return 0 // sFileName is valid as is far as characters are concerned.
31376>>>>>>>>>>>>>    End_Function
31377>>>>>>>>>>>>>
31377>>>>>>>>>>>>>    Function IsPathAbsolute String sPath Returns Boolean
31379>>>>>>>>>>>>>        Boolean bAbsolute
31379>>>>>>>>>>>>>        Move (Left(sPath,2)="\\") to bAbsolute
31380>>>>>>>>>>>>>        If (not(bAbsolute)) Begin
31382>>>>>>>>>>>>>            Move (Mid(sPath,1,2)=":") to bAbsolute
31383>>>>>>>>>>>>>        End
31383>>>>>>>>>>>>>>
31383>>>>>>>>>>>>>        Function_Return bAbsolute
31384>>>>>>>>>>>>>    End_Function
31385>>>>>>>>>>>>>
31385>>>>>>>>>>>>>    //> The AppendPath function takes a folder and a file name (without a path) and returns
31385>>>>>>>>>>>>>    //> a file name including path. Its purpose is to insert or remove a folder separator
31385>>>>>>>>>>>>>    //> if necessary.
31385>>>>>>>>>>>>>    Function AppendPath String sFolder ; //> The folder to be appended to                        String sItem ; //> The item to be appended                        Returns String
31387>>>>>>>>>>>>>        Boolean bFin
31387>>>>>>>>>>>>>        Move (Trim(sFolder)) to sFolder
31388>>>>>>>>>>>>>        Move (Trim(sItem)) to sItem
31389>>>>>>>>>>>>>
31389>>>>>>>>>>>>>        If (IsPathAbsolute(Self,sItem)) Begin
31391>>>>>>>>>>>>>            Function_Return sItem
31392>>>>>>>>>>>>>        End
31392>>>>>>>>>>>>>>
31392>>>>>>>>>>>>>
31392>>>>>>>>>>>>>        Move False to bFin
31393>>>>>>>>>>>>>        Repeat // This loop takes into account that sItem may be something like "..\Programs\*.exe".
31393>>>>>>>>>>>>>>
31393>>>>>>>>>>>>>            If (Left(sItem,2)=".\") Begin // Remove self reference
31395>>>>>>>>>>>>>                Move (Replace(".\",sItem,"")) to sItem
31396>>>>>>>>>>>>>            End
31396>>>>>>>>>>>>>>
31396>>>>>>>>>>>>>            Else If (Left(sItem,3)="..\") Begin //
31399>>>>>>>>>>>>>                Move (Replace("..\",sItem,"")) to sItem
31400>>>>>>>>>>>>>                Get PathToFolder sFolder to sFolder
31401>>>>>>>>>>>>>            End
31401>>>>>>>>>>>>>>
31401>>>>>>>>>>>>>            Else Begin
31402>>>>>>>>>>>>>                Move True to bFin
31403>>>>>>>>>>>>>            End
31403>>>>>>>>>>>>>>
31403>>>>>>>>>>>>>        Until (bFin)
31405>>>>>>>>>>>>>
31405>>>>>>>>>>>>>        If (Right(sFolder,1)="\" and Left(sItem,1)="\") Begin
31407>>>>>>>>>>>>>            Move (Replace("\",sItem,"")) to sItem
31408>>>>>>>>>>>>>        End
31408>>>>>>>>>>>>>>
31408>>>>>>>>>>>>>        If (sFolder<>"" and sItem<>"" and Right(sFolder,1)<>"\" and Left(sItem,1)<>"\") Begin
31410>>>>>>>>>>>>>            Move ("\"+sItem) to sItem
31411>>>>>>>>>>>>>        End
31411>>>>>>>>>>>>>>
31411>>>>>>>>>>>>>        Function_Return (Append(sFolder,sItem))
31412>>>>>>>>>>>>>    End_Function
31413>>>>>>>>>>>>>
31413>>>>>>>>>>>>>    //> Example: x:\vdf12\pkg\dfallent.prp -> x:\vdf12\pkg
31413>>>>>>>>>>>>>    //>          x:\windows\system32 -> x:\windows
31413>>>>>>>>>>>>>    Function PathToFolder String sPath Returns String
31415>>>>>>>>>>>>>        Integer iPos
31415>>>>>>>>>>>>>        If (Right(sPath,1)="\") Get rRemove of oStringFunctions sPath 1 to sPath
31418>>>>>>>>>>>>>        Get rPos of oStringFunctions "\" sPath to iPos
31419>>>>>>>>>>>>>        If not iPos Move (pos(":",sPath)) to iPos
31422>>>>>>>>>>>>>        If iPos Move (Left(sPath,iPos-1)) to sPath
31425>>>>>>>>>>>>>        Else Move "" to sPath
31427>>>>>>>>>>>>>        Function_Return sPath
31428>>>>>>>>>>>>>    End_Function
31429>>>>>>>>>>>>>
31429>>>>>>>>>>>>>    //> Example: x:\vdf12\pkg\dfallent.prp -> prp
31429>>>>>>>>>>>>>    Function PathToType String sPath Returns String
31431>>>>>>>>>>>>>        Integer iPos
31431>>>>>>>>>>>>>        Get rPos of oStringFunctions "\" sPath to iPos
31432>>>>>>>>>>>>>        If (iPos<>0) begin
31434>>>>>>>>>>>>>            Move (Remove(sPath,1,iPos)) to sPath
31435>>>>>>>>>>>>>        End
31435>>>>>>>>>>>>>>
31435>>>>>>>>>>>>>        Get rPos of oStringFunctions "." sPath to iPos
31436>>>>>>>>>>>>>        If (iPos<>0) begin
31438>>>>>>>>>>>>>            Move (Remove(sPath,1,iPos)) to sPath
31439>>>>>>>>>>>>>        End
31439>>>>>>>>>>>>>>
31439>>>>>>>>>>>>>        Else begin
31440>>>>>>>>>>>>>            Move "" to sPath
31441>>>>>>>>>>>>>        End
31441>>>>>>>>>>>>>>
31441>>>>>>>>>>>>>        Function_Return sPath
31442>>>>>>>>>>>>>    End_Function
31443>>>>>>>>>>>>>
31443>>>>>>>>>>>>>    //> Example: x:\vdf12\pkg\dfallent.prp --> x:\vdf12\pkg\dfallent
31443>>>>>>>>>>>>>    Function PathStripType String sPath Returns String
31445>>>>>>>>>>>>>        String sType
31445>>>>>>>>>>>>>        Get PathToType sPath to sType
31446>>>>>>>>>>>>>        If (sType<>"") Begin
31448>>>>>>>>>>>>>            Move (Left(sPath,Length(sPath)-Length(sType)-1)) to sPath
31449>>>>>>>>>>>>>        End
31449>>>>>>>>>>>>>>
31449>>>>>>>>>>>>>        Function_Return sPath
31450>>>>>>>>>>>>>    End_Function
31451>>>>>>>>>>>>>
31451>>>>>>>>>>>>>    //> Example: x:\vdf12\pkg\dfallent.prp -> dfallent.prp
31451>>>>>>>>>>>>>    Function PathToFileName String sPath Returns String
31453>>>>>>>>>>>>>        Integer iPos
31453>>>>>>>>>>>>>        If (Right(sPath,1)="\") Get rRemove of oStringFunctions sPath 1 to sPath
31456>>>>>>>>>>>>>        Get rPos of oStringFunctions "\" sPath to iPos
31457>>>>>>>>>>>>>        If not iPos Get rPos of oStringFunctions ":" sPath to iPos
31460>>>>>>>>>>>>>        If iPos Move (Remove(sPath,1,iPos)) to sPath
31463>>>>>>>>>>>>>        Function_Return sPath
31464>>>>>>>>>>>>>    End_Function
31465>>>>>>>>>>>>>
31465>>>>>>>>>>>>>    //> Example: x:\vdf12\pkg\dfallent.prp -> dfallent
31465>>>>>>>>>>>>>    Function PathToFileRootName String sPath Returns String
31467>>>>>>>>>>>>>        Integer iPos
31467>>>>>>>>>>>>>        Get PathToFileName sPath to sPath
31468>>>>>>>>>>>>>        Get rPos of oStringFunctions "." sPath to iPos
31469>>>>>>>>>>>>>        If (iPos>0) begin
31471>>>>>>>>>>>>>            Move (left(sPath,iPos-1)) to sPath
31472>>>>>>>>>>>>>        End
31472>>>>>>>>>>>>>>
31472>>>>>>>>>>>>>        Function_Return sPath
31473>>>>>>>>>>>>>    End_Function
31474>>>>>>>>>>>>>
31474>>>>>>>>>>>>>        Function _FileTime2SystemTime tFileTimeStamp stValue Returns DateTime // Private
31476>>>>>>>>>>>>>            tSystemTime stTime
31476>>>>>>>>>>>>>            tSystemTime stTime
31476>>>>>>>>>>>>>            DateTime dtRval
31476>>>>>>>>>>>>>            If (ff_FileTimeToSystemTime(AddressOf(stValue),AddressOf(stTime))) Begin
31478>>>>>>>>>>>>>                Move (DateSetSecond(dtRval,stTime.iSecond)) to dtRval
31479>>>>>>>>>>>>>                Move (DateSetMinute(dtRval,stTime.iMinute)) to dtRval
31480>>>>>>>>>>>>>                Move (DateSetHour(dtRval,stTime.iHour)) to dtRval
31481>>>>>>>>>>>>>                Move (DateSetDay(dtRval,stTime.iDay)) to dtRval
31482>>>>>>>>>>>>>                Move (DateSetMonth(dtRval,stTime.iMonth)) to dtRval
31483>>>>>>>>>>>>>                Move (DateSetYear(dtRval,stTime.iYear)) to dtRval
31484>>>>>>>>>>>>>            End
31484>>>>>>>>>>>>>>
31484>>>>>>>>>>>>>            Function_Return dtRval
31485>>>>>>>>>>>>>        End_Function
31486>>>>>>>>>>>>>
31486>>>>>>>>>>>>>        Function _FileData _tFileFindData stValue Returns tFileData // Private
31488>>>>>>>>>>>>>            tFileData stRval
31488>>>>>>>>>>>>>            tFileData stRval
31488>>>>>>>>>>>>>            String sTmp
31488>>>>>>>>>>>>>            Move stValue.dwFileAttributes to stRval.dwFileAttributes
31489>>>>>>>>>>>>>            Move (stRval.dwFileAttributes iand C_FILE_ATTRIBUTE_DIRECTORY) to stRval.bIsFolder
31490>>>>>>>>>>>>>            Get _FileTime2SystemTime stValue.ftCreation to stRval.dtCreation      // This converts the timestamps to UTC time. So 
31491>>>>>>>>>>>>>            Get _FileTime2SystemTime stValue.ftLastAccess to stRval.dtLastAccess  // they'll need converting back if their values
31492>>>>>>>>>>>>>            Get _FileTime2SystemTime stValue.ftLastWrite to stRval.dtLastWrite    // are displayed to human beings.
31493>>>>>>>>>>>>>            Move (Number(stValue.fsFileSize.dwHighSize)*C_MAXDWORD+stValue.fsFileSize.dwLowSize) to stRval.nFileSize
31494>>>>>>>>>>>>>
31494>>>>>>>>>>>>>            Move (AddressOf(stValue.csFileName)) to sTmp
31495>>>>>>>>>>>>>            Move (ToOEM(sTmp)) to stRval.sFileName
31496>>>>>>>>>>>>>
31496>>>>>>>>>>>>>            Move (sTmp="." or sTmp="..") to stRval.bSelfReference
31497>>>>>>>>>>>>>
31497>>>>>>>>>>>>>            Move (AddressOf(stValue.csAlternateFileName)) to sTmp
31498>>>>>>>>>>>>>            Move (ToOEM(sTmp)) to stRval.sAlternateFileName
31499>>>>>>>>>>>>>            Function_Return stRval
31500>>>>>>>>>>>>>        End_Function
31501>>>>>>>>>>>>>
31501>>>>>>>>>>>>>    Function ReadFileData String sPath tFileData ByRef stFileData Returns Boolean
31503>>>>>>>>>>>>>        Integer iVoid
31503>>>>>>>>>>>>>        Handle hFindFile
31503>>>>>>>>>>>>>        _tFileFindData stFileFindData
31503>>>>>>>>>>>>>        _tFileFindData stFileFindData
31503>>>>>>>>>>>>>        Move (ToAnsi(sPath)) to sPath
31504>>>>>>>>>>>>>        Move (ff_FindFirstFile(AddressOf(sPath),AddressOf(stFileFindData))) to hFindFile
31505>>>>>>>>>>>>>        If (hFindFile<>C_INVALID_HANDLE_VALUE) begin
31507>>>>>>>>>>>>>            Move (ff_FindClose(hFindFile)) to iVoid
31508>>>>>>>>>>>>>        End
31508>>>>>>>>>>>>>>
31508>>>>>>>>>>>>>        Get _FileData stFileFindData to stFileData
31509>>>>>>>>>>>>>        Function_Return (hFindFile<>C_INVALID_HANDLE_VALUE)
31510>>>>>>>>>>>>>    End_Function
31511>>>>>>>>>>>>>
31511>>>>>>>>>>>>>    Procedure ReadFileDataArray String sPath tFileData[] ByRef aFileData Integer iMode // iMode: 0:All 1:Files 2:Folders
31513>>>>>>>>>>>>>        Integer iVoid iFindNext iSize
31513>>>>>>>>>>>>>        Handle hFindFile
31513>>>>>>>>>>>>>        Boolean bFolder
31513>>>>>>>>>>>>>        _tFileFindData strFindFileData
31513>>>>>>>>>>>>>        _tFileFindData strFindFileData
31513>>>>>>>>>>>>>        Move (ToAnsi(sPath)) to sPath
31514>>>>>>>>>>>>>        Move (ff_FindFirstFile(AddressOf(sPath),AddressOf(strFindFileData))) to hFindFile
31515>>>>>>>>>>>>>        If (hFindFile<>C_INVALID_HANDLE_VALUE) Begin
31517>>>>>>>>>>>>>            Move (SizeOfArray(aFileData)) to iSize
31518>>>>>>>>>>>>>            Repeat
31518>>>>>>>>>>>>>>
31518>>>>>>>>>>>>>                Move (strFindFileData.dwFileAttributes iand C_FILE_ATTRIBUTE_DIRECTORY) to bFolder
31519>>>>>>>>>>>>>                If ((bFolder and (iMode<>FF_FILE)) or (not(bFolder) and (iMode<>FF_FOLDER))) Begin
31521>>>>>>>>>>>>>                    Get _FileData strFindFileData to aFileData[iSize]
31522>>>>>>>>>>>>>                    Increment iSize
31523>>>>>>>>>>>>>                End
31523>>>>>>>>>>>>>>
31523>>>>>>>>>>>>>                Move (ff_FindNextFile(hFindFile,AddressOf(strFindFileData))) to iFindNext
31524>>>>>>>>>>>>>            Until (iFindNext=0)
31526>>>>>>>>>>>>>            Move (ff_FindClose(hFindFile)) to iVoid // Presumably ok to call this even if hFindFile is -1
31527>>>>>>>>>>>>>        End
31527>>>>>>>>>>>>>>
31527>>>>>>>>>>>>>    End_Procedure
31528>>>>>>>>>>>>>
31528>>>>>>>>>>>>>    Procedure FileDataArraySize tFileData[] aFileData ;                                Integer ByRef iFileCount ;                                Integer ByRef iFolderCount ;                                Number ByRef nBytes
31530>>>>>>>>>>>>>        Integer iMax iIndex
31530>>>>>>>>>>>>>        Move (SizeOfArray(aFileData)-1) to iMax
31531>>>>>>>>>>>>>        For iIndex from 0 to iMax
31537>>>>>>>>>>>>>>
31537>>>>>>>>>>>>>            If (not(aFileData[iIndex].bSelfReference)) Begin
31539>>>>>>>>>>>>>                If (aFileData[iIndex].bIsFolder) Begin
31541>>>>>>>>>>>>>                    Increment iFolderCount
31542>>>>>>>>>>>>>                    Send FileDataArraySize aFileData[iIndex].aFolderContent (&iFileCount) (&iFolderCount) (&nBytes)
31543>>>>>>>>>>>>>                End
31543>>>>>>>>>>>>>>
31543>>>>>>>>>>>>>                Else Begin
31544>>>>>>>>>>>>>                    Increment iFileCount
31545>>>>>>>>>>>>>                    Move (nBytes+aFileData[iIndex].nFileSize) to nBytes
31546>>>>>>>>>>>>>                End
31546>>>>>>>>>>>>>>
31546>>>>>>>>>>>>>            End
31546>>>>>>>>>>>>>>
31546>>>>>>>>>>>>>        Loop
31547>>>>>>>>>>>>>>
31547>>>>>>>>>>>>>    End_Procedure
31548>>>>>>>>>>>>>
31548>>>>>>>>>>>>>    Function GetAttribute String sFileName Integer iAttr Returns DWord
31550>>>>>>>>>>>>>        DWord dwAttr
31550>>>>>>>>>>>>>        Pointer pAddress
31550>>>>>>>>>>>>>
31550>>>>>>>>>>>>>        Move (ToAnsi(sFileName) + Character(0)) to sFileName
31551>>>>>>>>>>>>>        Move (AddressOf(sFileName)) to pAddress
31552>>>>>>>>>>>>>        Move (ff_GetFileAttributes(pAddress)) to dwAttr
31553>>>>>>>>>>>>>        Function_Return (dwAttr iand iAttr)
31554>>>>>>>>>>>>>    End_Function
31555>>>>>>>>>>>>>
31555>>>>>>>>>>>>>    Function SetAttribute String sFileName Integer iAttr Returns Integer
31557>>>>>>>>>>>>>        Integer bOk
31557>>>>>>>>>>>>>        DWord dwAttr
31557>>>>>>>>>>>>>        Pointer pAddress
31557>>>>>>>>>>>>>
31557>>>>>>>>>>>>>        Move (ToAnsi(sFileName)+Character(0)) to sFileName
31558>>>>>>>>>>>>>        Move (AddressOf(sFileName)) to pAddress
31559>>>>>>>>>>>>>        Move (ff_GetFileAttributes(pAddress)) to dwAttr
31560>>>>>>>>>>>>>        Move (ff_SetFileAttributes(pAddress,dwAttr ior iAttr)) to bOk
31561>>>>>>>>>>>>>        Function_Return bOk
31562>>>>>>>>>>>>>    End_Function
31563>>>>>>>>>>>>>
31563>>>>>>>>>>>>>    Function RemoveAttribute String sFileName Integer iAttr Returns Integer
31565>>>>>>>>>>>>>        Integer bOk
31565>>>>>>>>>>>>>        DWord dwAttr
31565>>>>>>>>>>>>>        Pointer pAddress
31565>>>>>>>>>>>>>
31565>>>>>>>>>>>>>        Move (ToAnsi(sFileName)+Character(0)) to sFileName
31566>>>>>>>>>>>>>        Move (AddressOf(sFileName)) to pAddress
31567>>>>>>>>>>>>>        If (GetAttribute(Self,sFileName,iAttr)) Begin
31569>>>>>>>>>>>>>            Move (ff_GetFileAttributes(pAddress)) to dwAttr
31570>>>>>>>>>>>>>            Move (ff_SetFileAttributes(pAddress,dwAttr-iAttr)) to bOk
31571>>>>>>>>>>>>>        End
31571>>>>>>>>>>>>>>
31571>>>>>>>>>>>>>        Function_Return bOk
31572>>>>>>>>>>>>>    End_Function
31573>>>>>>>>>>>>>
31573>>>>>>>>>>>>>    Procedure ReadFolder String sFolder String sMask tFileData[] ByRef aFileData Integer iMode // iMode: 0:All 1:Files 2:Folders
31575>>>>>>>>>>>>>        String sPath
31575>>>>>>>>>>>>>        If (sMask="") Move "*" to sMask
31578>>>>>>>>>>>>>        Get AppendPath sFolder sMask to sPath
31579>>>>>>>>>>>>>        Send ReadFileDataArray sPath (&aFileData) iMode
31580>>>>>>>>>>>>>    End_Procedure
31581>>>>>>>>>>>>>
31581>>>>>>>>>>>>>    Function IsFolderEmpty String sFolder Returns Boolean
31583>>>>>>>>>>>>>        Integer iMax iIndex
31583>>>>>>>>>>>>>        tFileData[] aFileData
31583>>>>>>>>>>>>>        tFileData[] aFileData
31584>>>>>>>>>>>>>        Send ReadFolder sFolder "*" (&aFileData) 0 // 0: both files and folders
31585>>>>>>>>>>>>>        Move (SizeOfArray(aFileData)-1) to iMax
31586>>>>>>>>>>>>>        For iIndex from 0 to iMax
31592>>>>>>>>>>>>>>
31592>>>>>>>>>>>>>            If (not(aFileData[iIndex].bSelfReference)) Begin
31594>>>>>>>>>>>>>                Function_Return False
31595>>>>>>>>>>>>>            End
31595>>>>>>>>>>>>>>
31595>>>>>>>>>>>>>        Loop
31596>>>>>>>>>>>>>>
31596>>>>>>>>>>>>>        Function_Return True
31597>>>>>>>>>>>>>    End_Function
31598>>>>>>>>>>>>>
31598>>>>>>>>>>>>>    Procedure ReadFolderRecursive String sFolder String sMask tFileData[] ByRef aFileData Integer iMode Integer iMaxDepth //
31600>>>>>>>>>>>>>        Integer iIndex iMax
31600>>>>>>>>>>>>>        String sPath sName
31600>>>>>>>>>>>>>        If (sMask="") begin
31602>>>>>>>>>>>>>            Move "*" to sMask
31603>>>>>>>>>>>>>        End
31603>>>>>>>>>>>>>>
31603>>>>>>>>>>>>>        Get AppendPath sFolder sMask to sPath
31604>>>>>>>>>>>>>        Send ReadFileDataArray sPath (&aFileData) iMode
31605>>>>>>>>>>>>>        If (iMode=1) Begin // Files only
31607>>>>>>>>>>>>>            Get AppendPath sFolder "*" to sPath
31608>>>>>>>>>>>>>            Send ReadFileDataArray sPath (&aFileData) 2 // 2=>folders only
31609>>>>>>>>>>>>>        End
31609>>>>>>>>>>>>>>
31609>>>>>>>>>>>>>        If (iMaxDepth>0) Begin
31611>>>>>>>>>>>>>            Move (SizeOfArray(aFileData)-1) to iMax
31612>>>>>>>>>>>>>            For iIndex from 0 to iMax
31618>>>>>>>>>>>>>>
31618>>>>>>>>>>>>>                If (aFileData[iIndex].dwFileAttributes iand C_FILE_ATTRIBUTE_DIRECTORY) Begin
31620>>>>>>>>>>>>>                    Move aFileData[iIndex].sFileName to sName
31621>>>>>>>>>>>>>                    If (sName<>"." and sName<>"..") begin
31623>>>>>>>>>>>>>                        Send ReadFolderRecursive (AppendPath(Self,sFolder,sName)) sMask (&aFileData[iIndex].aFolderContent) iMode (iMaxDepth-1)
31624>>>>>>>>>>>>>                    End
31624>>>>>>>>>>>>>>
31624>>>>>>>>>>>>>                End
31624>>>>>>>>>>>>>>
31624>>>>>>>>>>>>>            Loop
31625>>>>>>>>>>>>>>
31625>>>>>>>>>>>>>        End
31625>>>>>>>>>>>>>>
31625>>>>>>>>>>>>>    End_Procedure
31626>>>>>>>>>>>>>
31626>>>>>>>>>>>>>    // ******************************************************************************************************
31626>>>>>>>>>>>>>    //
31626>>>>>>>>>>>>>
31626>>>>>>>>>>>>>    Procedure CallbackFileData String sFolder tFileData[] aFileData Integer iMode Integer hMsg Integer hObj // iMode: 0:Both  1:Files only  2:Folders only
31628>>>>>>>>>>>>>        // callback: Procedure HandleFileData String sFullPath tFileData stFileData
31628>>>>>>>>>>>>>        Integer iMax iIndex
31628>>>>>>>>>>>>>        String sFullPath
31628>>>>>>>>>>>>>        Move (SizeOfArray(aFileData)-1) to iMax
31629>>>>>>>>>>>>>        For iIndex from 0 to iMax
31635>>>>>>>>>>>>>>
31635>>>>>>>>>>>>>            If (aFileData[iIndex].bIsFolder) Begin
31637>>>>>>>>>>>>>                Get AppendPath sFolder aFileData[iIndex].sFileName to sFullPath
31638>>>>>>>>>>>>>                If (iMode<>1) Begin // If not "files only"
31640>>>>>>>>>>>>>                    Send hMsg of hObj sFullPath aFileData[iIndex]
31641>>>>>>>>>>>>>                End
31641>>>>>>>>>>>>>>
31641>>>>>>>>>>>>>                Send CallbackFileData sFullPath aFileData[iIndex].aFolderContent iMode hMsg hObj
31642>>>>>>>>>>>>>            End
31642>>>>>>>>>>>>>>
31642>>>>>>>>>>>>>            Else Begin
31643>>>>>>>>>>>>>                If (iMode<>2) Begin // If not "folders only"
31645>>>>>>>>>>>>>                    Get AppendPath sFolder aFileData[iIndex].sFileName to sFullPath
31646>>>>>>>>>>>>>                    Send hMsg of hObj sFullPath aFileData[iIndex]
31647>>>>>>>>>>>>>                End
31647>>>>>>>>>>>>>>
31647>>>>>>>>>>>>>            End
31647>>>>>>>>>>>>>>
31647>>>>>>>>>>>>>        Loop
31648>>>>>>>>>>>>>>
31648>>>>>>>>>>>>>    End_Procedure
31649>>>>>>>>>>>>>
31649>>>>>>>>>>>>>    // ******************************************************************************************************
31649>>>>>>>>>>>>>
31649>>>>>>>>>>>>>    Function FindFileDataIndex tFileData[] aFileData String sFileName Returns Integer
31651>>>>>>>>>>>>>        Integer iIndex iMax
31651>>>>>>>>>>>>>        Move (SizeOfArray(aFileData)-1) to iMax
31652>>>>>>>>>>>>>        Move (Uppercase(sFileName)) to sFileName
31653>>>>>>>>>>>>>        For iIndex from 0 to iMax
31659>>>>>>>>>>>>>>
31659>>>>>>>>>>>>>            If (sFileName=Uppercase(aFileData[iIndex].sFileName)) Function_Return iIndex
31662>>>>>>>>>>>>>        Loop
31663>>>>>>>>>>>>>>
31663>>>>>>>>>>>>>        Function_Return -1 // Not found
31664>>>>>>>>>>>>>    End_Function
31665>>>>>>>>>>>>>
31665>>>>>>>>>>>>>        Procedure _BuildFileDataCursor tFileData[] aFileData String sPath Integer[] ByRef aCursor
31667>>>>>>>>>>>>>            Integer iIndex
31667>>>>>>>>>>>>>            String[] aValues
31668>>>>>>>>>>>>>            If (sPath<>"") Begin
31670>>>>>>>>>>>>>                Send SplitString of oStringFunctions sPath "\" True False (&aValues)
31671>>>>>>>>>>>>>                If (SizeOfArray(aValues)>0) Begin // Not really necessary, since we have already checked that sPath is not blank
31673>>>>>>>>>>>>>                    Get FindFileDataIndex aFileData aValues[0] to iIndex
31674>>>>>>>>>>>>>                    If (iIndex<>-1) Begin
31676>>>>>>>>>>>>>                        Move iIndex to aCursor[SizeOfArray(aCursor)]
31677>>>>>>>>>>>>>                        Send _BuildFileDataCursor aFileData[iIndex].aFolderContent (JoinString(oStringFunctions,aValues,"\",1,0)) (&aCursor)
31678>>>>>>>>>>>>>                    End
31678>>>>>>>>>>>>>>
31678>>>>>>>>>>>>>                    Else Begin // Path not found => Reset the cursor
31679>>>>>>>>>>>>>                        Move (ResizeArray(aCursor,0)) to aCursor
31680>>>>>>>>>>>>>                    End
31680>>>>>>>>>>>>>>
31680>>>>>>>>>>>>>                End
31680>>>>>>>>>>>>>>
31680>>>>>>>>>>>>>            End
31680>>>>>>>>>>>>>>
31680>>>>>>>>>>>>>        End_Procedure
31681>>>>>>>>>>>>>
31681>>>>>>>>>>>>>    // This function combines a path like "subfolder1\subfolder2\subfolder3" with an
31681>>>>>>>>>>>>>    // array of tFileData (a recursive definition) and translates it into a
31681>>>>>>>>>>>>>    // "cursor" that is an array of integers. This array may be used to index your way
31681>>>>>>>>>>>>>    // to a specific tFileData item. If the sPath can be resolved with respect to
31681>>>>>>>>>>>>>    // aFileData True will be returned, otherwise False.
31681>>>>>>>>>>>>>    Function FileDataPathToCursor tFileData[] aFileData String sPath Integer[] ByRef aCursor Returns Boolean
31683>>>>>>>>>>>>>        If (sPath="") Begin
31685>>>>>>>>>>>>>            Function_Return False // Not legal to call with empty path.
31686>>>>>>>>>>>>>        End
31686>>>>>>>>>>>>>>
31686>>>>>>>>>>>>>        Send _BuildFileDataCursor aFileData sPath (&aCursor)
31687>>>>>>>>>>>>>        Function_Return (SizeOfArray(aCursor)<>0)
31688>>>>>>>>>>>>>    End_Function
31689>>>>>>>>>>>>>
31689>>>>>>>>>>>>>    // Function FileDataAtCursor takes a tFileData array and a "cursor" and delivers the
31689>>>>>>>>>>>>>    // corresponding tFileData element via ByRef parameter stResult. If the cursor "points
31689>>>>>>>>>>>>>    // out of" the aFileData the function will return False. Calling the function with an
31689>>>>>>>>>>>>>    // empty cursor (of length 0) is considered illegal and will also return False. Otherwise
31689>>>>>>>>>>>>>    // True is returned and parameter stResult will contain the referenced element.
31689>>>>>>>>>>>>>    Function FileDataAtCursor tFileData[] aFileData Integer[] aCursor tFileData ByRef stResult Returns Boolean
31691>>>>>>>>>>>>>        Integer iCursorMax iCursorIndex iIndex
31691>>>>>>>>>>>>>
31691>>>>>>>>>>>>>        Move (SizeOfArray(aCursor)-1) to iCursorMax
31692>>>>>>>>>>>>>        If (iCursorMax>=0) Begin
31694>>>>>>>>>>>>>            For iCursorIndex from 0 to iCursorMax
31700>>>>>>>>>>>>>>
31700>>>>>>>>>>>>>                Move aCursor[iCursorIndex] to iIndex
31701>>>>>>>>>>>>>                If (iIndex<SizeOfArray(aFileData)) Begin // We're inside the index range => ok
31703>>>>>>>>>>>>>                    If (iCursorIndex=iCursorMax) Begin
31705>>>>>>>>>>>>>                        Move aFileData[iIndex] to stResult
31706>>>>>>>>>>>>>                    End
31706>>>>>>>>>>>>>>
31706>>>>>>>>>>>>>                    Else Begin
31707>>>>>>>>>>>>>                        Move aFileData[iIndex].aFolderContent to aFileData
31708>>>>>>>>>>>>>                    End
31708>>>>>>>>>>>>>>
31708>>>>>>>>>>>>>                End
31708>>>>>>>>>>>>>>
31708>>>>>>>>>>>>>                Else Begin // Cursor points outside of aFileData => failure
31709>>>>>>>>>>>>>                    Function_Return False
31710>>>>>>>>>>>>>                End
31710>>>>>>>>>>>>>>
31710>>>>>>>>>>>>>            Loop
31711>>>>>>>>>>>>>>
31711>>>>>>>>>>>>>            Function_Return True
31712>>>>>>>>>>>>>        End
31712>>>>>>>>>>>>>>
31712>>>>>>>>>>>>>        Function_Return False
31713>>>>>>>>>>>>>    End_Function
31714>>>>>>>>>>>>>
31714>>>>>>>>>>>>>    Enum_List // sort by's
31714>>>>>>>>>>>>>        Define SB_NAME
31714>>>>>>>>>>>>>        Define SB_CREATED
31714>>>>>>>>>>>>>        Define SB_ACCESSED
31714>>>>>>>>>>>>>        Define SB_CHANGED
31714>>>>>>>>>>>>>        Define SB_SIZE
31714>>>>>>>>>>>>>    End_Enum_List
31714>>>>>>>>>>>>>
31714>>>>>>>>>>>>>            Function _CompareFileDataByName tFileData stVal1 tFileData stVal2 Returns Integer
31716>>>>>>>>>>>>>                String sValue1 sValue2
31716>>>>>>>>>>>>>                Move (Uppercase(stVal1.sFileName)) to sValue1
31717>>>>>>>>>>>>>                Move (Uppercase(stVal2.sFileName)) to sValue2
31718>>>>>>>>>>>>>                If (sValue1<sValue2) Function_Return (LT)
31721>>>>>>>>>>>>>                If (sValue1>sValue2) Function_Return (GT)
31724>>>>>>>>>>>>>                Function_Return (EQ)
31725>>>>>>>>>>>>>            End_Function
31726>>>>>>>>>>>>>            Function _CompareFileDataByCreated tFileData stVal1 tFileData stVal2 Returns Integer
31728>>>>>>>>>>>>>                If (stVal1.dtCreation<stVal2.dtCreation) Function_Return (LT)
31731>>>>>>>>>>>>>                If (stVal1.dtCreation>stVal2.dtCreation) Function_Return (GT)
31734>>>>>>>>>>>>>                Function_Return (EQ)
31735>>>>>>>>>>>>>            End_Function
31736>>>>>>>>>>>>>            Function _CompareFileDataByAccessed tFileData stVal1 tFileData stVal2 Returns Integer
31738>>>>>>>>>>>>>                If (stVal1.dtLastAccess<stVal2.dtLastAccess) Function_Return (LT)
31741>>>>>>>>>>>>>                If (stVal1.dtLastAccess>stVal2.dtLastAccess) Function_Return (GT)
31744>>>>>>>>>>>>>                Function_Return (EQ)
31745>>>>>>>>>>>>>            End_Function
31746>>>>>>>>>>>>>            Function _CompareFileDataByChanged tFileData stVal1 tFileData stVal2 Returns Integer
31748>>>>>>>>>>>>>                If (stVal1.dtLastWrite<stVal2.dtLastWrite) Function_Return (LT)
31751>>>>>>>>>>>>>                If (stVal1.dtLastWrite>stVal2.dtLastWrite) Function_Return (GT)
31754>>>>>>>>>>>>>                Function_Return (EQ)
31755>>>>>>>>>>>>>            End_Function
31756>>>>>>>>>>>>>            Function _CompareFileDataBySize tFileData stVal1 tFileData stVal2 Returns Integer
31758>>>>>>>>>>>>>                If (stVal1.nFileSize<stVal2.nFileSize) Function_Return (LT)
31761>>>>>>>>>>>>>                If (stVal1.nFileSize>stVal2.nFileSize) Function_Return (GT)
31764>>>>>>>>>>>>>                Function_Return (EQ)
31765>>>>>>>>>>>>>            End_Function
31766>>>>>>>>>>>>>
31766>>>>>>>>>>>>>    Procedure SortFileDataArray tFileData[] ByRef aFileData Integer iByWhat
31768>>>>>>>>>>>>>        If (iByWhat=SB_NAME)     Move (SortArray(aFileData,Self,GET__CompareFileDataByName)) to aFileData
31771>>>>>>>>>>>>>        If (iByWhat=SB_CREATED)  Move (SortArray(aFileData,Self,GET__CompareFileDataByCreated)) to aFileData
31774>>>>>>>>>>>>>        If (iByWhat=SB_ACCESSED) Move (SortArray(aFileData,Self,GET__CompareFileDataByAccessed)) to aFileData
31777>>>>>>>>>>>>>        If (iByWhat=SB_CHANGED)  Move (SortArray(aFileData,Self,GET__CompareFileDataByChanged)) to aFileData
31780>>>>>>>>>>>>>        If (iByWhat=SB_SIZE)     Move (SortArray(aFileData,Self,GET__CompareFileDataBySize)) to aFileData
31783>>>>>>>>>>>>>    End_Procedure
31784>>>>>>>>>>>>>
31784>>>>>>>>>>>>>    //> Function FileExists returns 0 if not, 1 if file and 2 if folder
31784>>>>>>>>>>>>>    Function FileExists String sPath Returns Integer
31786>>>>>>>>>>>>>        Integer iRval
31786>>>>>>>>>>>>>        tFileData strFileData
31786>>>>>>>>>>>>>        tFileData strFileData
31786>>>>>>>>>>>>>        If (Length(sPath)=2 and Right(sPath,1)=":") Begin
31788>>>>>>>>>>>>>            Valid_Drive sPath iRval
31789>>>>>>>>>>>>>            If (iRval=-1) Begin
31791>>>>>>>>>>>>>                Move 0 to iRval // Folder does not exist
31792>>>>>>>>>>>>>            End
31792>>>>>>>>>>>>>>
31792>>>>>>>>>>>>>            Else If (iRval=0) Begin
31795>>>>>>>>>>>>>                Move 2 to iRval // The drive exists => 'Folder' exists
31796>>>>>>>>>>>>>            End
31796>>>>>>>>>>>>>>
31796>>>>>>>>>>>>>            Else Begin
31797>>>>>>>>>>>>>                Move 0 to iRval // Unknown value => folder does not exist
31798>>>>>>>>>>>>>            End
31798>>>>>>>>>>>>>>
31798>>>>>>>>>>>>>        End
31798>>>>>>>>>>>>>>
31798>>>>>>>>>>>>>        Else Begin
31799>>>>>>>>>>>>>            If (ReadFileData(Self,sPath,&strFileData)) Begin
31801>>>>>>>>>>>>>                If (strFileData.dwFileAttributes iand C_FILE_ATTRIBUTE_DIRECTORY) Begin
31803>>>>>>>>>>>>>                    Move 2 to iRval
31804>>>>>>>>>>>>>                End
31804>>>>>>>>>>>>>>
31804>>>>>>>>>>>>>                Else Begin
31805>>>>>>>>>>>>>                    Move 1 to iRval
31806>>>>>>>>>>>>>                End
31806>>>>>>>>>>>>>>
31806>>>>>>>>>>>>>            End
31806>>>>>>>>>>>>>>
31806>>>>>>>>>>>>>            Else Begin
31807>>>>>>>>>>>>>                Move 0 to iRval
31808>>>>>>>>>>>>>            End
31808>>>>>>>>>>>>>>
31808>>>>>>>>>>>>>        End
31808>>>>>>>>>>>>>>
31808>>>>>>>>>>>>>        Function_Return iRval
31809>>>>>>>>>>>>>    End_Function
31810>>>>>>>>>>>>>
31810>>>>>>>>>>>>>    Function FindFile String sFileName String sFolderList Returns String
31812>>>>>>>>>>>>>        Integer iMax iIndex
31812>>>>>>>>>>>>>        String[] aFolders
31813>>>>>>>>>>>>>        String sFolder
31813>>>>>>>>>>>>>        Move (Replaces('"',sFolderList,'')) to sFolderList
31814>>>>>>>>>>>>>        Send SplitString of oStringFunctions sFolderList ";" True False (&aFolders)
31815>>>>>>>>>>>>>        Move (SizeOfArray(aFolders)-1) to iMax
31816>>>>>>>>>>>>>        For iIndex from 0 to iMax
31822>>>>>>>>>>>>>>
31822>>>>>>>>>>>>>            If (FileExists(Self,AppendPath(Self,aFolders[iIndex],sFileName))<>0) Begin
31824>>>>>>>>>>>>>                Function_Return aFolders[iIndex]
31825>>>>>>>>>>>>>            End
31825>>>>>>>>>>>>>>
31825>>>>>>>>>>>>>        Loop
31826>>>>>>>>>>>>>>
31826>>>>>>>>>>>>>        Function_Return "" // not found
31827>>>>>>>>>>>>>    End_Function
31828>>>>>>>>>>>>>
31828>>>>>>>>>>>>>    Function DirectOutput String sPath Returns Integer
31830>>>>>>>>>>>>>        Integer iChannel
31830>>>>>>>>>>>>>        Get Seq_New_Channel to iChannel
31831>>>>>>>>>>>>>        Move (ToAnsi(sPath)) to sPath
31832>>>>>>>>>>>>>        Direct_Output channel iChannel sPath
31834>>>>>>>>>>>>>        Function_Return iChannel
31835>>>>>>>>>>>>>    End_Function
31836>>>>>>>>>>>>>
31836>>>>>>>>>>>>>    Function AppendOutput String sPath Returns Integer
31838>>>>>>>>>>>>>        Integer iChannel
31838>>>>>>>>>>>>>        Get Seq_New_Channel to iChannel
31839>>>>>>>>>>>>>        Move (ToAnsi(sPath)) to sPath
31840>>>>>>>>>>>>>        Append_Output channel iChannel sPath
31842>>>>>>>>>>>>>        Function_Return iChannel
31843>>>>>>>>>>>>>    End_Function
31844>>>>>>>>>>>>>
31844>>>>>>>>>>>>>    //> Close output channel iChannel
31844>>>>>>>>>>>>>    Procedure CloseOutput Integer iChannel
31846>>>>>>>>>>>>>        Close_Output channel iChannel
31848>>>>>>>>>>>>>        Send Seq_Release_Channel iChannel
31849>>>>>>>>>>>>>    End_Procedure
31850>>>>>>>>>>>>>
31850>>>>>>>>>>>>>    //> The function attempts to open the file fn# for sequential reading.
31850>>>>>>>>>>>>>    //> If it succeeds a channel number will be returned, if it fails -1
31850>>>>>>>>>>>>>    //> will be returned. If the function succeeds it is the responsability
31850>>>>>>>>>>>>>    //> of the caller to release the channel (by sending the CloseInput
31850>>>>>>>>>>>>>    //> message) when done with it.
31850>>>>>>>>>>>>>    Function DirectInput String sPath Returns Integer
31852>>>>>>>>>>>>>        Integer iChannel
31852>>>>>>>>>>>>>        Get Seq_New_Channel to iChannel
31853>>>>>>>>>>>>>        Move (ToAnsi(sPath)) to sPath
31854>>>>>>>>>>>>>        Direct_Input channel iChannel sPath
31856>>>>>>>>>>>>>        If (SeqEof) Begin
31858>>>>>>>>>>>>>            Send Seq_Release_Channel iChannel
31859>>>>>>>>>>>>>            Move -1 to iChannel
31860>>>>>>>>>>>>>        End
31860>>>>>>>>>>>>>>
31860>>>>>>>>>>>>>        Function_Return iChannel
31861>>>>>>>>>>>>>    End_Function
31862>>>>>>>>>>>>>
31862>>>>>>>>>>>>>    Function DirectInputTableField Integer iTable Integer iField Returns Integer
31864>>>>>>>>>>>>>        Function_Return (DirectInput(Self,"DBMS:"+String(iTable)+","+String(iField)))
31865>>>>>>>>>>>>>    End_Function
31866>>>>>>>>>>>>>
31866>>>>>>>>>>>>>    //> Close input channel iChannel.
31866>>>>>>>>>>>>>    Procedure CloseInput Integer iChannel
31868>>>>>>>>>>>>>        Close_Input channel iChannel
31870>>>>>>>>>>>>>        Send Seq_Release_Channel iChannel
31871>>>>>>>>>>>>>    End_Procedure
31872>>>>>>>>>>>>>
31872>>>>>>>>>>>>>    //> Sometimes it's nice not to have to declare a variable just to read
31872>>>>>>>>>>>>>    //> a line in a file. Global indicator SeqEof will be False after calling
31872>>>>>>>>>>>>>    //> this function if an EOF has been reached. (What? I hope I mean True)
31872>>>>>>>>>>>>>    Function Readln Integer iChannel Returns String
31874>>>>>>>>>>>>>        String sRval
31874>>>>>>>>>>>>>        Readln channel iChannel sRval
31876>>>>>>>>>>>>>        Function_Return sRval
31877>>>>>>>>>>>>>    End_Function
31878>>>>>>>>>>>>>
31878>>>>>>>>>>>>>    //> Reads sequential channel liChannel until the value lsValue is found.
31878>>>>>>>>>>>>>    //> Return value True: Found!,  False : Value not found before end of file.
31878>>>>>>>>>>>>>    //> The function may be used to skip parts of a text file of a known format.
31878>>>>>>>>>>>>>    Function ReadLnUntilValue Integer iChannel String sValue Returns Boolean
31880>>>>>>>>>>>>>        String sLine
31880>>>>>>>>>>>>>        Repeat
31880>>>>>>>>>>>>>>
31880>>>>>>>>>>>>>          Readln channel iChannel sLine
31882>>>>>>>>>>>>>          If (SeqEof) Function_Return False
31885>>>>>>>>>>>>>          If (sLine=sValue) Function_Return True
31888>>>>>>>>>>>>>        Loop
31889>>>>>>>>>>>>>>
31889>>>>>>>>>>>>>    End_Function
31890>>>>>>>>>>>>>
31890>>>>>>>>>>>>>    //> Function ReadLnProbe reads a line from input channel iChannel without
31890>>>>>>>>>>>>>    //> affecting the current channel position of that channel. The return
31890>>>>>>>>>>>>>    //> value is of type string and will be the line read. The function sets
31890>>>>>>>>>>>>>    //> indicator SeqEof as a sideeffect.
31890>>>>>>>>>>>>>    Function ReadLnProbe Integer iChannel Returns String
31892>>>>>>>>>>>>>        Integer iPos
31892>>>>>>>>>>>>>        Boolean bSeqEof bSneakMode
31892>>>>>>>>>>>>>        String sRval sValue
31892>>>>>>>>>>>>>        Get_Channel_Position iChannel to iPos
31893>>>>>>>>>>>>>>
31893>>>>>>>>>>>>>        Readln channel iChannel sRval
31895>>>>>>>>>>>>>        Move (SeqEof) to bSeqEof
31896>>>>>>>>>>>>>        Move (iPos>0) to bSneakMode
31897>>>>>>>>>>>>>        If bSneakMode Decrement iPos
31900>>>>>>>>>>>>>        Set_Channel_Position iChannel to iPos
31901>>>>>>>>>>>>>>
31901>>>>>>>>>>>>>        If bSneakMode Read_Block channel iChannel sValue 1
31905>>>>>>>>>>>>>        indicate SeqEof as bSeqEof ne 0
31906>>>>>>>>>>>>>        Function_Return sRval
31907>>>>>>>>>>>>>    End_Function
31908>>>>>>>>>>>>>
31908>>>>>>>>>>>>>    //> This function reads a file (of whatever type) and returns its contents as a
31908>>>>>>>>>>>>>    //> String. If the file is larger than the max arg size currently Set by the
31908>>>>>>>>>>>>>    //> program, an error is declared.
31908>>>>>>>>>>>>>    Function FileAsString String sPath Returns String
31910>>>>>>>>>>>>>        Integer iChannel iArgSize
31910>>>>>>>>>>>>>        Number nSize
31910>>>>>>>>>>>>>        String sRval sError
31910>>>>>>>>>>>>>        tFileData strFileData
31910>>>>>>>>>>>>>        tFileData strFileData
31910>>>>>>>>>>>>>
31910>>>>>>>>>>>>>        Move "" to sRval
31911>>>>>>>>>>>>>        If (ReadFileData(Self,sPath,&strFileData)) Begin
31913>>>>>>>>>>>>>            Move strFileData.nFileSize to nSize
31914>>>>>>>>>>>>>            Get_Argument_Size to iArgSize
31915>>>>>>>>>>>>>
31915>>>>>>>>>>>>>            If (iArgSize<nSize) begin
31917>>>>>>>>>>>>>                Move "File too big. Adjust max arg size. (File: # MAS: #)" to sError
31918>>>>>>>>>>>>>                Move (Replace("#",sError,string(nSize))) to sError
31919>>>>>>>>>>>>>                Move (Replace("#",sError,string(iArgSize))) to sError
31920>>>>>>>>>>>>>                Error 421 sError
31921>>>>>>>>>>>>>>
31921>>>>>>>>>>>>>            end
31921>>>>>>>>>>>>>>
31921>>>>>>>>>>>>>            Get DirectInput ("binary:"+sPath) to iChannel
31922>>>>>>>>>>>>>            If (iChannel>=0) Begin
31924>>>>>>>>>>>>>                Read_Block channel iChannel sRval nSize
31926>>>>>>>>>>>>>                Send CloseInput iChannel
31927>>>>>>>>>>>>>            End
31927>>>>>>>>>>>>>>
31927>>>>>>>>>>>>>        End
31927>>>>>>>>>>>>>>
31927>>>>>>>>>>>>>        Function_Return sRval
31928>>>>>>>>>>>>>    End_Function
31929>>>>>>>>>>>>>    
31929>>>>>>>>>>>>>    Function StringAsFile String sPath String sFileContent Returns Boolean
31931>>>>>>>>>>>>>        Integer iChannel
31931>>>>>>>>>>>>>        Number nLength
31931>>>>>>>>>>>>>        Move (Length(sFileContent)) to nLength
31932>>>>>>>>>>>>>        Get DirectOutput ("binary:"+sPath) to iChannel
31933>>>>>>>>>>>>>        If (iChannel>=0) Begin
31935>>>>>>>>>>>>>            Write channel iChannel sFileContent
31937>>>>>>>>>>>>>            Send CloseOutput iChannel
31938>>>>>>>>>>>>>            Function_Return True
31939>>>>>>>>>>>>>        End
31939>>>>>>>>>>>>>>
31939>>>>>>>>>>>>>        Function_Return False
31940>>>>>>>>>>>>>    End_Function
31941>>>>>>>>>>>>>    
31941>>>>>>>>>>>>>    Function SplitFile String sPath tFileInChops ByRef strFileInChops Integer iBlockSize Returns Boolean
31943>>>>>>>>>>>>>        Integer iChannel
31943>>>>>>>>>>>>>        Integer iIndex
31943>>>>>>>>>>>>>        Integer iBytesLeft
31943>>>>>>>>>>>>>        String sBlock
31943>>>>>>>>>>>>>        tFileInChops strEmpty
31943>>>>>>>>>>>>>        tFileInChops strEmpty
31943>>>>>>>>>>>>>        Move strEmpty to strFileInChops
31944>>>>>>>>>>>>>        Get DirectInput ("binary:"+sPath) to iChannel
31945>>>>>>>>>>>>>        If (iChannel>=0) Begin
31947>>>>>>>>>>>>>            Move sPath to strFileInChops.sPath
31948>>>>>>>>>>>>>            Move 0 to iIndex
31949>>>>>>>>>>>>>            Get FileSizeBytes sPath to iBytesLeft
31950>>>>>>>>>>>>>            While (iBytesLeft>0)
31954>>>>>>>>>>>>>                Move (iBytesLeft min iBlockSize) to iBlockSize
31955>>>>>>>>>>>>>                Read_Block channel iChannel sBlock iBlockSize
31957>>>>>>>>>>>>>                Move iBlockSize to strFileInChops.aSegments[iIndex].iLen
31958>>>>>>>>>>>>>                Move sBlock to strFileInChops.aSegments[iIndex].sContent
31959>>>>>>>>>>>>>                Move (iBytesLeft-iBlockSize) to iBytesLeft
31960>>>>>>>>>>>>>                Increment iIndex
31961>>>>>>>>>>>>>            Loop
31962>>>>>>>>>>>>>>
31962>>>>>>>>>>>>>            Send CloseInput iChannel
31963>>>>>>>>>>>>>            Function_Return True
31964>>>>>>>>>>>>>        End
31964>>>>>>>>>>>>>>
31964>>>>>>>>>>>>>        Function_Return False
31965>>>>>>>>>>>>>    End_Function
31966>>>>>>>>>>>>>    
31966>>>>>>>>>>>>>    Function JoinFile String sPath tFileInChops strFileInChops Returns Boolean
31968>>>>>>>>>>>>>        Integer iChannel iIndex iMax
31968>>>>>>>>>>>>>        String sBlock
31968>>>>>>>>>>>>>        Get DirectOutput ("binary:"+sPath) to iChannel
31969>>>>>>>>>>>>>        If (iChannel>=0) Begin
31971>>>>>>>>>>>>>            Move (SizeOfArray(strFileInChops.aSegments)-1) to iMax
31972>>>>>>>>>>>>>            For iIndex from 0 to iMax
31978>>>>>>>>>>>>>>
31978>>>>>>>>>>>>>                Move strFileInChops.aSegments[iIndex].sContent to sBlock
31979>>>>>>>>>>>>>                Write channel iChannel sBlock // strFileInChops.aSegments[iIndex].sContent
31981>>>>>>>>>>>>>            Loop
31982>>>>>>>>>>>>>>
31982>>>>>>>>>>>>>            Send CloseOutput iChannel
31983>>>>>>>>>>>>>            Function_Return True
31984>>>>>>>>>>>>>        End
31984>>>>>>>>>>>>>>
31984>>>>>>>>>>>>>        Function_Return False
31985>>>>>>>>>>>>>    End_Function
31986>>>>>>>>>>>>>
31986>>>>>>>>>>>>>    Function TextFileAsArray String sPath Returns String[]
31988>>>>>>>>>>>>>        Boolean bEof
31988>>>>>>>>>>>>>        Integer iLineCount iChannel
31988>>>>>>>>>>>>>        String sLine
31988>>>>>>>>>>>>>        String[] aValues
31989>>>>>>>>>>>>>        Get DirectInput sPath to iChannel
31990>>>>>>>>>>>>>        If (iChannel>=0) Begin
31992>>>>>>>>>>>>>            Move 0 to iLineCount
31993>>>>>>>>>>>>>            Repeat
31993>>>>>>>>>>>>>>
31993>>>>>>>>>>>>>                Readln channel iChannel sLine
31995>>>>>>>>>>>>>                Move (SeqEof) to bEof
31996>>>>>>>>>>>>>                If (not(bEof)) Begin
31998>>>>>>>>>>>>>                    Move sLine to aValues[iLineCount]
31999>>>>>>>>>>>>>                    Increment iLineCount
32000>>>>>>>>>>>>>                End
32000>>>>>>>>>>>>>>
32000>>>>>>>>>>>>>            Until (bEof)
32002>>>>>>>>>>>>>            Send CloseInput iChannel
32003>>>>>>>>>>>>>        End
32003>>>>>>>>>>>>>>
32003>>>>>>>>>>>>>        Function_Return aValues
32004>>>>>>>>>>>>>    End_Function
32005>>>>>>>>>>>>>
32005>>>>>>>>>>>>>    Function FileSizeBytes String sPath Returns Number
32007>>>>>>>>>>>>>        tFileData sFileData
32007>>>>>>>>>>>>>        tFileData sFileData
32007>>>>>>>>>>>>>        If (ReadFileData(Self,sPath,&sFileData)) Begin
32009>>>>>>>>>>>>>            Function_Return sFileData.nFileSize
32010>>>>>>>>>>>>>        End
32010>>>>>>>>>>>>>>
32010>>>>>>>>>>>>>        Function_Return -1
32011>>>>>>>>>>>>>    End_Function
32012>>>>>>>>>>>>>
32012>>>>>>>>>>>>>            // (stolen from Wil van Antwerpen)
32012>>>>>>>>>>>>>            // Read about it here: http://msdn.microsoft.com/en-us/library/windows/desktop/bb762164(v=vs.85).aspx
32012>>>>>>>>>>>>>            // Remarks: You should Use fully qualified path names with this function. Using it with relative path names is not thread safe.
32012>>>>>>>>>>>>>            Function _FileOperation String sSource String sDestination Integer iOperation Integer iFlags Returns Integer
32014>>>>>>>>>>>>>                Integer iRval
32014>>>>>>>>>>>>>                _tFileOperation stOperation
32014>>>>>>>>>>>>>                _tFileOperation stOperation
32014>>>>>>>>>>>>>                
32014>>>>>>>>>>>>>                Move (ToAnsi(sSource)+Character(0)+Character(0)) to sSource // Double null termination
32015>>>>>>>>>>>>>                Move (ToAnsi(sDestination)+Character(0)+Character(0)) to sDestination // Double null termination
32016>>>>>>>>>>>>>                Move iOperation to stOperation.wFunc
32017>>>>>>>>>>>>>
32017>>>>>>>>>>>>>                Move (AddressOf(sSource)) to stOperation.pFrom
32018>>>>>>>>>>>>>                Move (AddressOf(sDestination)) to stOperation.pTo
32019>>>>>>>>>>>>>                Move iFlags to stOperation.fFlags
32020>>>>>>>>>>>>>
32020>>>>>>>>>>>>>                Move (ff_SHFileOperation(AddressOf(stOperation))) to iRval
32021>>>>>>>>>>>>>                If (stOperation.fAnyOperationsAborted<>0) begin
32023>>>>>>>>>>>>>                    Move 1 to iRval // Should be DE_OPCANCELLED really, but we haven't defined these constants anyway
32024>>>>>>>>>>>>>                End
32024>>>>>>>>>>>>>>
32024>>>>>>>>>>>>>                Function_Return iRval
32025>>>>>>>>>>>>>            End_Function
32026>>>>>>>>>>>>>
32026>>>>>>>>>>>>>    Function CopyFileNew String sPath1 String sPath2 Returns Boolean
32028>>>>>>>>>>>>>        Integer iFlags iError
32028>>>>>>>>>>>>>        Move (C_NOCONFIRMMKDIR ior C_NOCONFIRMATION) to iFlags
32029>>>>>>>>>>>>>            Move (iFlags ior C_NOERRORUI ior C_SILENT) to iFlags // If webapp: No user interface!
32030>>>>>>>>>>>>>        Get _FileOperation sPath1 sPath2 CFO_COPY iFlags to iError
32031>>>>>>>>>>>>>        Function_Return (iError=0)
32032>>>>>>>>>>>>>    End_Function
32033>>>>>>>>>>>>>
32033>>>>>>>>>>>>>    // Delete file or folder
32033>>>>>>>>>>>>>    Function DeleteFileNew String sPath Boolean bToBin Returns Boolean
32035>>>>>>>>>>>>>        Integer iFlags iError
32035>>>>>>>>>>>>>        Move (C_SILENT ior C_NOCONFIRMATION) to iFlags
32036>>>>>>>>>>>>>        If (bToBin) Move (iFlags ior C_ALLOWUNDO) to iFlags
32039>>>>>>>>>>>>>            Move (iFlags ior C_NOERRORUI) to iFlags // If webapp: No user interface!
32040>>>>>>>>>>>>>        Get _FileOperation sPath "" CFO_DELETE iFlags to iError
32041>>>>>>>>>>>>>        Function_Return (iError=0)
32042>>>>>>>>>>>>>    End_Function
32043>>>>>>>>>>>>>
32043>>>>>>>>>>>>>    Function RenameFileNew String sFileName1 String sFileName2 Returns Boolean
32045>>>>>>>>>>>>>        Integer iFlags iError
32045>>>>>>>>>>>>>        Move (C_SILENT ior C_NOCONFIRMATION) to iFlags
32046>>>>>>>>>>>>>            Move (iFlags ior C_NOERRORUI) to iFlags // If webapp: No user interface!
32047>>>>>>>>>>>>>        Get _FileOperation sFileName1 sFileName2 CFO_RENAME iFlags to iError
32048>>>>>>>>>>>>>        Function_Return (iError=0)
32049>>>>>>>>>>>>>    End_Function
32050>>>>>>>>>>>>>
32050>>>>>>>>>>>>>    Function MoveFileNew String sPath1 String sPath2 Returns Boolean
32052>>>>>>>>>>>>>        Integer iFlags iError
32052>>>>>>>>>>>>>        Move (C_NOCONFIRMMKDIR ior C_NOCONFIRMATION) to iFlags
32053>>>>>>>>>>>>>            Move (iFlags ior C_NOERRORUI) to iFlags // If webapp: No user interface!
32054>>>>>>>>>>>>>        Get _FileOperation sPath1 sPath2 CFO_MOVE iFlags to iError
32055>>>>>>>>>>>>>        Function_Return (iError=0)
32056>>>>>>>>>>>>>    End_Function
32057>>>>>>>>>>>>>
32057>>>>>>>>>>>>>    // If sNewFolder already exists the function will return False (failure)
32057>>>>>>>>>>>>>    Function CreateFolderNew String sNewFolder Returns Boolean
32059>>>>>>>>>>>>>        Integer iRval
32059>>>>>>>>>>>>>        Move (ToAnsi(sNewFolder)) to sNewFolder
32060>>>>>>>>>>>>>        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa363855(v=vs.85).aspx
32060>>>>>>>>>>>>>        Move (ff_CreateDirectory(AddressOf(sNewFolder),0)) to iRval
32061>>>>>>>>>>>>>        // If the Function succeeds, the return value is nonzero.
32061>>>>>>>>>>>>>        // If the Function fails, the return value is zero. 
32061>>>>>>>>>>>>>        // To get extended Error information, call GetLastError. 
32061>>>>>>>>>>>>>        Function_Return (iRval<>0)
32062>>>>>>>>>>>>>    End_Function
32063>>>>>>>>>>>>>    
32063>>>>>>>>>>>>>    //> Returns True on success
32063>>>>>>>>>>>>>    Function CreateFolderIfNotExist String sFolder Returns Boolean
32065>>>>>>>>>>>>>        Integer iExist
32065>>>>>>>>>>>>>        Boolean bExist
32065>>>>>>>>>>>>>        Get FileExists sFolder to iExist
32066>>>>>>>>>>>>>        Move (iExist=2) to bExist // Does folder exist?
32067>>>>>>>>>>>>>        If (not(bExist)) Begin
32069>>>>>>>>>>>>>            If (iExist=0) Begin // If not, and also no file of that name exists:
32071>>>>>>>>>>>>>                Move (CreateFolderNew(Self,sFolder)) to bExist
32072>>>>>>>>>>>>>                Get FileExists sFolder to iExist
32073>>>>>>>>>>>>>                Move (iExist=2) to bExist
32074>>>>>>>>>>>>>            End
32074>>>>>>>>>>>>>>
32074>>>>>>>>>>>>>        End
32074>>>>>>>>>>>>>>
32074>>>>>>>>>>>>>        Function_Return bExist
32075>>>>>>>>>>>>>    End_Function
32076>>>>>>>>>>>>>
32076>>>>>>>>>>>>>    // sRootFolder must already exist. Returns True if the sRootFolder\sSubFolderPath can be accessed after calling the function
32076>>>>>>>>>>>>>    Function CreateFolderMultiLevel String sRootFolder String sSubFolderPath Returns Boolean
32078>>>>>>>>>>>>>        Boolean bSuccess
32078>>>>>>>>>>>>>        Integer iFolderIndex iFolderMax iExists
32078>>>>>>>>>>>>>        String[] aFolderPath
32079>>>>>>>>>>>>>
32079>>>>>>>>>>>>>        If (FileExists(Self,sRootFolder)=2) Begin
32081>>>>>>>>>>>>>
32081>>>>>>>>>>>>>            Send SplitString of oStringFunctions sSubFolderPath "\" False True (&aFolderPath)
32082>>>>>>>>>>>>>            Move (SizeOfArray(aFolderPath)-1) to iFolderMax
32083>>>>>>>>>>>>>            Move True to bSuccess
32084>>>>>>>>>>>>>            For iFolderIndex from 0 to iFolderMax
32090>>>>>>>>>>>>>>
32090>>>>>>>>>>>>>                If (bSuccess) Begin
32092>>>>>>>>>>>>>                    Get AppendPath sRootFolder aFolderPath[iFolderIndex] to sRootFolder
32093>>>>>>>>>>>>>                    Get FileExists sRootFolder to iExists
32094>>>>>>>>>>>>>                    If (iExists=0) Begin // Does not exist
32096>>>>>>>>>>>>>                        Get CreateFolderNew sRootFolder to bSuccess
32097>>>>>>>>>>>>>                    End
32097>>>>>>>>>>>>>>
32097>>>>>>>>>>>>>                    If (iExists=1) Begin // It exists and it's a file (not good)
32099>>>>>>>>>>>>>                        Move False to bSuccess
32100>>>>>>>>>>>>>                        Error 821 ("Can't create folder ('"+sRootFolder+"' is a file)")
32101>>>>>>>>>>>>>>
32101>>>>>>>>>>>>>                    End
32101>>>>>>>>>>>>>>
32101>>>>>>>>>>>>>                    If (iExists=2) Begin // It Exists and it's a folder (fine)
32103>>>>>>>>>>>>>                        // Do nothing
32103>>>>>>>>>>>>>                    End
32103>>>>>>>>>>>>>>
32103>>>>>>>>>>>>>                End
32103>>>>>>>>>>>>>>
32103>>>>>>>>>>>>>            Loop
32104>>>>>>>>>>>>>>
32104>>>>>>>>>>>>>        End
32104>>>>>>>>>>>>>>
32104>>>>>>>>>>>>>        Else Begin
32105>>>>>>>>>>>>>            Move False to bSuccess
32106>>>>>>>>>>>>>        End
32106>>>>>>>>>>>>>>
32106>>>>>>>>>>>>>        Function_Return bSuccess
32107>>>>>>>>>>>>>    End_Function
32108>>>>>>>>>>>>>
32108>>>>>>>>>>>>>    // Folder must be empty and have no sub-folders
32108>>>>>>>>>>>>>    Function DeleteFolderNew String sPath Returns Boolean
32110>>>>>>>>>>>>>        Integer iRval
32110>>>>>>>>>>>>>        Move (ToAnsi(sPath)) to sPath
32111>>>>>>>>>>>>>        Move (ff_RemoveDirectory(AddressOf(sPath))) to iRval // If the function succeeds, the return value is nonzero.
32112>>>>>>>>>>>>>        Function_Return (iRval<>0)
32113>>>>>>>>>>>>>    End_Function
32114>>>>>>>>>>>>>
32114>>>>>>>>>>>>>    Function DeleteAllFilesInFolderNew String sPath Returns Boolean
32116>>>>>>>>>>>>>        Integer iIndex iMax iFailure
32116>>>>>>>>>>>>>        String sFileName
32116>>>>>>>>>>>>>        tFileData[] aFileData
32116>>>>>>>>>>>>>        tFileData[] aFileData
32117>>>>>>>>>>>>>        Send ReadFolder sPath "*" (&aFileData) 1 // 1 means files (and not folders)
32118>>>>>>>>>>>>>        Move (SizeOfArray(aFileData)-1) to iMax
32119>>>>>>>>>>>>>        Move 0 to iFailure
32120>>>>>>>>>>>>>        For iIndex from 0 to iMax
32126>>>>>>>>>>>>>>
32126>>>>>>>>>>>>>            If (iFailure=0) Begin
32128>>>>>>>>>>>>>                Get AppendPath sPath aFileData[iIndex].sFileName to sFileName
32129>>>>>>>>>>>>>                If (not(DeleteFileNew(Self,sFileName,False))) Begin
32131>>>>>>>>>>>>>                    Error 392 ("Could not delete file "+sFileName)
32132>>>>>>>>>>>>>>
32132>>>>>>>>>>>>>                End
32132>>>>>>>>>>>>>>
32132>>>>>>>>>>>>>            End
32132>>>>>>>>>>>>>>
32132>>>>>>>>>>>>>        Loop
32133>>>>>>>>>>>>>>
32133>>>>>>>>>>>>>        Function_Return (iFailure=0)
32134>>>>>>>>>>>>>    End_Function
32135>>>>>>>>>>>>>
32135>>>>>>>>>>>>>    // Delete recursively all files and remove folders. SUPER POWERFUL AND THUS DANGEROUS!
32135>>>>>>>>>>>>>    Function DeleteFolderRecursiveNew String sPath Returns Boolean
32137>>>>>>>>>>>>>        Boolean bSuccess
32137>>>>>>>>>>>>>        Integer iIndex iMax
32137>>>>>>>>>>>>>        tFileData[] aFileData
32137>>>>>>>>>>>>>        tFileData[] aFileData
32138>>>>>>>>>>>>>        String sSubFolder
32138>>>>>>>>>>>>>        // Get rid of all files
32138>>>>>>>>>>>>>        Get DeleteAllFilesInFolderNew sPath to bSuccess
32139>>>>>>>>>>>>>        If (bSuccess) Begin
32141>>>>>>>>>>>>>            Send ReadFolder sPath "*" (&aFileData) 2 // 2 means folders (and not files)
32142>>>>>>>>>>>>>            Move (SizeOfArray(aFileData)-1) to iMax
32143>>>>>>>>>>>>>            For iIndex from 0 to iMax
32149>>>>>>>>>>>>>>
32149>>>>>>>>>>>>>                If (bSuccess and aFileData[iIndex].sFileName<>"." and aFileData[iIndex].sFileName<>"..") Begin
32151>>>>>>>>>>>>>                    Get AppendPath sPath aFileData[iIndex].sFileName to sSubFolder
32152>>>>>>>>>>>>>                    Get DeleteFolderRecursiveNew sSubFolder to bSuccess
32153>>>>>>>>>>>>>                    If (not(bSuccess)) Begin
32155>>>>>>>>>>>>>                        Error 392 ("Could not delete folder "+sSubFolder)
32156>>>>>>>>>>>>>>
32156>>>>>>>>>>>>>                    End
32156>>>>>>>>>>>>>>
32156>>>>>>>>>>>>>                End
32156>>>>>>>>>>>>>>
32156>>>>>>>>>>>>>            Loop
32157>>>>>>>>>>>>>>
32157>>>>>>>>>>>>>        End
32157>>>>>>>>>>>>>>
32157>>>>>>>>>>>>>        If (bSuccess) Begin // Remove the folder
32159>>>>>>>>>>>>>            Get DeleteFolderNew sPath to bSuccess
32160>>>>>>>>>>>>>        End
32160>>>>>>>>>>>>>>
32160>>>>>>>>>>>>>        Function_Return (bSuccess)
32161>>>>>>>>>>>>>    End_Function
32162>>>>>>>>>>>>>
32162>>>>>>>>>>>>>        Function _CopyFileDataArray tFileData[] aFileData String sSourceFolder String sTargetFolder Integer hMsg Integer hObj Returns Boolean
32164>>>>>>>>>>>>>            Boolean bSuccess
32164>>>>>>>>>>>>>            Integer iMax iIndex
32164>>>>>>>>>>>>>            String sSourceItem sTargetItem
32164>>>>>>>>>>>>>
32164>>>>>>>>>>>>>            If (CreateFolderIfNotExist(Self,sTargetFolder)) Begin
32166>>>>>>>>>>>>>                Move True to bSuccess
32167>>>>>>>>>>>>>                Move (SizeOfArray(aFileData)-1) to iMax
32168>>>>>>>>>>>>>                For iIndex from 0 to iMax
32174>>>>>>>>>>>>>>
32174>>>>>>>>>>>>>                    If (bSuccess and not(aFileData[iIndex].bSelfReference)) Begin
32176>>>>>>>>>>>>>                        Get AppendPath sSourceFolder aFileData[iIndex].sFileName to sSourceItem
32177>>>>>>>>>>>>>                        Get AppendPath sTargetFolder aFileData[iIndex].sFileName to sTargetItem
32178>>>>>>>>>>>>>                        If (aFileData[iIndex].bIsFolder) Begin // Folder
32180>>>>>>>>>>>>>                            Get _CopyFileDataArray aFileData[iIndex].aFolderContent sSourceItem sTargetItem hMsg hObj to bSuccess
32181>>>>>>>>>>>>>                        End
32181>>>>>>>>>>>>>>
32181>>>>>>>>>>>>>                        Else Begin // File
32182>>>>>>>>>>>>>                            Move (CopyFileNew(Self,sSourceItem,sTargetItem)) to bSuccess
32183>>>>>>>>>>>>>                        End
32183>>>>>>>>>>>>>>
32183>>>>>>>>>>>>>                    End
32183>>>>>>>>>>>>>>
32183>>>>>>>>>>>>>                Loop
32184>>>>>>>>>>>>>>
32184>>>>>>>>>>>>>            End
32184>>>>>>>>>>>>>>
32184>>>>>>>>>>>>>            Else Begin
32185>>>>>>>>>>>>>                Move False to bSuccess
32186>>>>>>>>>>>>>            End
32186>>>>>>>>>>>>>>
32186>>>>>>>>>>>>>
32186>>>>>>>>>>>>>            Function_Return bSuccess
32187>>>>>>>>>>>>>        End_Function
32188>>>>>>>>>>>>>
32188>>>>>>>>>>>>>    // Returns True on success. I don't think hMSG and hObj are used for anything. Set to 0
32188>>>>>>>>>>>>>    Function CopyFileDataArray tFileData[] aFileData String sSourceFolder String sTargetFolder Integer hMsg Integer hObj Returns Boolean
32190>>>>>>>>>>>>>        Function_Return (_CopyFileDataArray(Self,aFileData,sSourceFolder,sTargetFolder,hMsg,hObj))
32191>>>>>>>>>>>>>    End_Function
32192>>>>>>>>>>>>>
32192>>>>>>>>>>>>>    Function LongPathName String sShortPath Returns String
32194>>>>>>>>>>>>>        Pointer lpszShortPath lpszLongPath
32194>>>>>>>>>>>>>        Integer iVoid
32194>>>>>>>>>>>>>        String sLongPath
32194>>>>>>>>>>>>>        ZeroString C_MAX_PATH to sLongPath
32195>>>>>>>>>>>>>        Move (ToANSI(sShortPath)) to sShortPath
32196>>>>>>>>>>>>>        GetAddress of sLongPath  to lpszLongPath
32197>>>>>>>>>>>>>        GetAddress of sShortPath to lpszShortPath
32198>>>>>>>>>>>>>        Move (ff_GetLongPathName(lpszShortPath,lpszLongPath,C_MAX_PATH)) to iVoid
32199>>>>>>>>>>>>>        Function_Return (Cstring(ToOEM(sLongPath)))
32200>>>>>>>>>>>>>    End_Function // IsLongPathName
32201>>>>>>>>>>>>>
32201>>>>>>>>>>>>>    // Returns the temp folder of the system
32201>>>>>>>>>>>>>    Function UserTempFolder Returns String // published by Clayton Schirmer, 22-03-2002 on NGs
32203>>>>>>>>>>>>>        String sPath
32203>>>>>>>>>>>>>        Pointer pPath
32203>>>>>>>>>>>>>        Integer iRet
32203>>>>>>>>>>>>>        Move (Repeat(Character(0),255)) to sPath
32204>>>>>>>>>>>>>        GetAddress of sPath to pPath
32205>>>>>>>>>>>>>        Move (ff_TempPath(255,pPath)) to iRet
32206>>>>>>>>>>>>>        Function_Return (LongPathName(Self,CString(ToOEM(sPath))))
32207>>>>>>>>>>>>>    End_Function
32208>>>>>>>>>>>>>
32208>>>>>>>>>>>>>    // Use this function to obtain Windows specific folder. Parameter iWinFolderId is one of the
32208>>>>>>>>>>>>>    // "CSIDL_" defined in the top of this file. Be aware that not all folders are defined on all windows
32208>>>>>>>>>>>>>    // systems.
32208>>>>>>>>>>>>>    Function WinFolderPath Integer iWinFolderId Returns String
32210>>>>>>>>>>>>>        // This function I found on WASP (by Frank Cheng).
32210>>>>>>>>>>>>>        Integer iVoid
32210>>>>>>>>>>>>>        String sPath
32210>>>>>>>>>>>>>        ZeroString C_MAX_PATH to sPath
32211>>>>>>>>>>>>>        Move (ff_SHGetSpecialFolderPath(0,AddressOf(sPath),iWinFolderID,1)) to iVoid
32212>>>>>>>>>>>>>        If (iVoid=0) Function_Return ""
32215>>>>>>>>>>>>>        Function_Return (ToOEM(CString(sPath)))
32216>>>>>>>>>>>>>    End_Function
32217>>>>>>>>>>>>>
32217>>>>>>>>>>>>>    Enum_List //> VDF Folder id's. Used as parameter for the VdfFolderPath function (iVdfFolderId parameter).
32217>>>>>>>>>>>>>        Define VDF_ROOT     //> Root of the VDF runtime, for example "C:\VDF12".
32217>>>>>>>>>>>>>        Define VDF_HTML     //> Path to the AppHtml folder of the current work space.
32217>>>>>>>>>>>>>        Define VDF_FILELIST //> Path to Filelist.cfg of the current work space
32217>>>>>>>>>>>>>        Define VDF_OPENPATH //> Path used when opening tables via Filelist.cfg
32217>>>>>>>>>>>>>        Define VDF_PROGRAM  //> Path to the folder of the current program
32217>>>>>>>>>>>>>        Define VDF_DDSRC    //> Path of the DD source folder (if present)
32217>>>>>>>>>>>>>        Define VDF_APPSRC   //> Path of the source folder (if present)
32217>>>>>>>>>>>>>        Define VDF_BITMAPS  //> Path of bitmaps folder
32217>>>>>>>>>>>>>        Define VDF_VDFXRAY  //> Folder for VDFXRay configuration
32217>>>>>>>>>>>>>        Define VDF_APPHTML  //> Folder to AppHtml folder
32217>>>>>>>>>>>>>    End_Enum_List
32217>>>>>>>>>>>>>
32217>>>>>>>>>>>>>    Function VdfFolderPath Integer iVdfFolderId Returns String
32219>>>>>>>>>>>>>        Integer hoWorkSpace
32219>>>>>>>>>>>>>        String sFolder sOpenPath
32219>>>>>>>>>>>>>        If (iVdfFolderId=VDF_ROOT) Begin
32221>>>>>>>>>>>>>            get_profile_string "Defaults" "VdfRootDir" to sFolder
32224>>>>>>>>>>>>>        End
32224>>>>>>>>>>>>>>
32224>>>>>>>>>>>>>        If (iVdfFolderId=VDF_HTML) Begin
32226>>>>>>>>>>>>>            If (ghoApplication<>0) Begin
32228>>>>>>>>>>>>>                Get phoWorkspace of ghoApplication to hoWorkSpace
32229>>>>>>>>>>>>>                If (hoWorkSpace<>0) Begin
32231>>>>>>>>>>>>>                    Get psAppHtmlPath of hoWorkSpace to sFolder
32232>>>>>>>>>>>>>                End
32232>>>>>>>>>>>>>>
32232>>>>>>>>>>>>>            End
32232>>>>>>>>>>>>>>
32232>>>>>>>>>>>>>        End
32232>>>>>>>>>>>>>>
32232>>>>>>>>>>>>>        If (iVdfFolderId=VDF_FILELIST) Begin
32234>>>>>>>>>>>>>            Get_Attribute DF_FILELIST_NAME to sFolder
32237>>>>>>>>>>>>>            If (sFolder contains "\") Begin
32239>>>>>>>>>>>>>                // Absolute path of filelist.cfg => we must strip the "filelist.cfg" to get the folder.
32239>>>>>>>>>>>>>                Get PathToFolder sFolder to sFolder
32240>>>>>>>>>>>>>            End
32240>>>>>>>>>>>>>>
32240>>>>>>>>>>>>>            Else Begin
32241>>>>>>>>>>>>>                // Absolute path not specified => we must look for it along VDF's "open_path"
32241>>>>>>>>>>>>>                Get_Attribute DF_OPEN_PATH to sOpenPath  // This is the path we want dbquery to use
32244>>>>>>>>>>>>>                Get FindFile sFolder sOpenPath to sFolder
32245>>>>>>>>>>>>>            End
32245>>>>>>>>>>>>>>
32245>>>>>>>>>>>>>        End
32245>>>>>>>>>>>>>>
32245>>>>>>>>>>>>>        If (iVdfFolderId=VDF_OPENPATH) Begin
32247>>>>>>>>>>>>>            Get_Attribute DF_OPEN_PATH to sFolder
32250>>>>>>>>>>>>>        End
32250>>>>>>>>>>>>>>
32250>>>>>>>>>>>>>        If (iVdfFolderId=VDF_PROGRAM) Begin
32252>>>>>>>>>>>>>            If (ghoApplication<>0) Begin
32254>>>>>>>>>>>>>                Get phoWorkspace of ghoApplication to hoWorkSpace
32255>>>>>>>>>>>>>                If (hoWorkSpace<>0) Begin
32257>>>>>>>>>>>>>                    Get psProgramPath of hoWorkSpace to sFolder
32258>>>>>>>>>>>>>                End
32258>>>>>>>>>>>>>>
32258>>>>>>>>>>>>>            End
32258>>>>>>>>>>>>>>
32258>>>>>>>>>>>>>        End
32258>>>>>>>>>>>>>>
32258>>>>>>>>>>>>>        If (iVdfFolderId=VDF_BITMAPS) Begin
32260>>>>>>>>>>>>>            If (ghoApplication<>0) Begin
32262>>>>>>>>>>>>>                Get phoWorkspace of ghoApplication to hoWorkSpace
32263>>>>>>>>>>>>>                If (hoWorkSpace<>0) Begin
32265>>>>>>>>>>>>>                    Get psBitmapPath of hoWorkSpace to sFolder
32266>>>>>>>>>>>>>                    If (FileExists(Self,sFolder)=0) Begin
32268>>>>>>>>>>>>>                        Move "" to sFolder
32269>>>>>>>>>>>>>                    End
32269>>>>>>>>>>>>>>
32269>>>>>>>>>>>>>                End
32269>>>>>>>>>>>>>>
32269>>>>>>>>>>>>>            End
32269>>>>>>>>>>>>>>
32269>>>>>>>>>>>>>        End
32269>>>>>>>>>>>>>>
32269>>>>>>>>>>>>>        If (iVdfFolderId=VDF_APPHTML) Begin
32271>>>>>>>>>>>>>            If (ghoApplication<>0) Begin
32273>>>>>>>>>>>>>                Get phoWorkspace of ghoApplication to hoWorkSpace
32274>>>>>>>>>>>>>                If (hoWorkSpace<>0) Begin
32276>>>>>>>>>>>>>                    Get psAppHtmlPath of hoWorkSpace to sFolder
32277>>>>>>>>>>>>>                    If (FileExists(Self,sFolder)=0) Begin
32279>>>>>>>>>>>>>                        Move "" to sFolder
32280>>>>>>>>>>>>>                    End
32280>>>>>>>>>>>>>>
32280>>>>>>>>>>>>>                End
32280>>>>>>>>>>>>>>
32280>>>>>>>>>>>>>            End
32280>>>>>>>>>>>>>>
32280>>>>>>>>>>>>>        End
32280>>>>>>>>>>>>>>
32280>>>>>>>>>>>>>        If (iVdfFolderId=VDF_APPSRC) Begin
32282>>>>>>>>>>>>>            If (ghoApplication<>0) Begin
32284>>>>>>>>>>>>>                Get phoWorkspace of ghoApplication to hoWorkSpace
32285>>>>>>>>>>>>>                If (hoWorkSpace<>0) Begin
32287>>>>>>>>>>>>>                    Get psAppSrcPath of hoWorkSpace to sFolder
32288>>>>>>>>>>>>>                    If (FileExists(Self,sFolder)=0) Begin
32290>>>>>>>>>>>>>                        Move "" to sFolder
32291>>>>>>>>>>>>>                    End
32291>>>>>>>>>>>>>>
32291>>>>>>>>>>>>>                End
32291>>>>>>>>>>>>>>
32291>>>>>>>>>>>>>            End
32291>>>>>>>>>>>>>>
32291>>>>>>>>>>>>>        End
32291>>>>>>>>>>>>>>
32291>>>>>>>>>>>>>        If (iVdfFolderId=VDF_DDSRC) Begin
32293>>>>>>>>>>>>>            If (ghoApplication<>0) Begin
32295>>>>>>>>>>>>>                Get phoWorkspace of ghoApplication to hoWorkSpace
32296>>>>>>>>>>>>>                If (hoWorkSpace<>0) Begin
32298>>>>>>>>>>>>>                    Get psDdSrcPath of hoWorkSpace to sFolder
32299>>>>>>>>>>>>>                    If (FileExists(Self,sFolder)=0) Begin
32301>>>>>>>>>>>>>                        Move "" to sFolder
32302>>>>>>>>>>>>>                    End
32302>>>>>>>>>>>>>>
32302>>>>>>>>>>>>>                End
32302>>>>>>>>>>>>>>
32302>>>>>>>>>>>>>            End
32302>>>>>>>>>>>>>>
32302>>>>>>>>>>>>>        End
32302>>>>>>>>>>>>>>
32302>>>>>>>>>>>>>        If (iVdfFolderId=VDF_VDFXRAY) Begin
32304>>>>>>>>>>>>>            Get VdfFolderPath VDF_FILELIST to sFolder
32305>>>>>>>>>>>>>            Get PathToFolder sFolder to sFolder
32306>>>>>>>>>>>>>            Get AppendPath sFolder "VDFXRay_cfg" to sFolder
32307>>>>>>>>>>>>>            If (FileExists(Self,sFolder)<>2) Begin
32309>>>>>>>>>>>>>                If (_pbCreateVDFXRayFolderOnReq(Self)) Begin
32311>>>>>>>>>>>>>                    If (not(CreateFolderNew(Self,sFolder))) Begin
32313>>>>>>>>>>>>>                        Move "" to sFolder
32314>>>>>>>>>>>>>                    End
32314>>>>>>>>>>>>>>
32314>>>>>>>>>>>>>                End
32314>>>>>>>>>>>>>>
32314>>>>>>>>>>>>>                Else Begin
32315>>>>>>>>>>>>>                    Move "" to sFolder
32316>>>>>>>>>>>>>                End
32316>>>>>>>>>>>>>>
32316>>>>>>>>>>>>>            End
32316>>>>>>>>>>>>>>
32316>>>>>>>>>>>>>        End
32316>>>>>>>>>>>>>>
32316>>>>>>>>>>>>>        Function_Return sFolder
32317>>>>>>>>>>>>>    End_Function
32318>>>>>>>>>>>>>    
32318>>>>>>>>>>>>>    Function CreateVDFXrayConfigurationFolder Returns Boolean
32320>>>>>>>>>>>>>        String sFolder
32320>>>>>>>>>>>>>        Set _pbCreateVDFXRayFolderOnReq to True
32321>>>>>>>>>>>>>        Get VdfFolderPath VDF_VDFXRAY to sFolder
32322>>>>>>>>>>>>>        Set _pbCreateVDFXRayFolderOnReq to False
32323>>>>>>>>>>>>>        Function_Return (sFolder<>"")
32324>>>>>>>>>>>>>    End_Function
32325>>>>>>>>>>>>>    
32325>>>>>>>>>>>>>    //> Translate absolute disk folder (or file) into relative HTML folder (or file).
32325>>>>>>>>>>>>>    Function DiskFolderToHtml String sDiskFolder Returns String
32327>>>>>>>>>>>>>        String sHtmlRootFolder sRelativeFolder
32327>>>>>>>>>>>>>        Get VdfFolderPath VDF_HTML to sHtmlRootFolder
32328>>>>>>>>>>>>>        Move (Lowercase(sDiskFolder)) to sDiskFolder
32329>>>>>>>>>>>>>        Move (Lowercase(sHtmlRootFolder)) to sHtmlRootFolder
32330>>>>>>>>>>>>>        Move (Replace(sHtmlRootFolder,sDiskFolder,"")) to sRelativeFolder
32331>>>>>>>>>>>>>
32331>>>>>>>>>>>>>        If (Left(sRelativeFolder,1)="\") Move (replace("\",sRelativeFolder,"")) to sRelativeFolder
32334>>>>>>>>>>>>>        Move (Replaces("\",sRelativeFolder,"/")) to sRelativeFolder
32335>>>>>>>>>>>>>        Function_Return sRelativeFolder
32336>>>>>>>>>>>>>    End_Function
32337>>>>>>>>>>>>>
32337>>>>>>>>>>>>>    //> Returns a string containing the drive letters that are valid for the system.
32337>>>>>>>>>>>>>    Function ValidDriveLetters Returns String
32339>>>>>>>>>>>>>        Integer iLen iPos
32339>>>>>>>>>>>>>        Boolean bErr
32339>>>>>>>>>>>>>        String sDrives sDrive sValidDrives
32339>>>>>>>>>>>>>        Move "ABCDEFGHIJKLMNOPQRSTUVWXYZ" to sDrives
32340>>>>>>>>>>>>>        Move "" to sValidDrives
32341>>>>>>>>>>>>>        Move (Length(sDrives)) to iLen
32342>>>>>>>>>>>>>        For iPos from 1 to iLen
32348>>>>>>>>>>>>>>
32348>>>>>>>>>>>>>            Move (Mid(sDrives,1,iPos)) to sDrive
32349>>>>>>>>>>>>>            Valid_Drive sDrive bErr
32350>>>>>>>>>>>>>            If (not(bErr)) Move (sValidDrives+sDrive) to sValidDrives
32353>>>>>>>>>>>>>        Loop
32354>>>>>>>>>>>>>>
32354>>>>>>>>>>>>>        Function_Return sValidDrives
32355>>>>>>>>>>>>>    End_Function
32356>>>>>>>>>>>>>
32356>>>>>>>>>>>>>    //> Function DataSubFolder returns the value of sSubFolderName appended to
32356>>>>>>>>>>>>>    //> the folder name in which filelist.cfg resides.
32356>>>>>>>>>>>>>    Function DataSubFolder String sSubFolderName Boolean bCreate Returns String
32358>>>>>>>>>>>>>        String sRval
32358>>>>>>>>>>>>>        Boolean bCreateTmp
32358>>>>>>>>>>>>>        If (num_arguments>1) Begin
32360>>>>>>>>>>>>>            Move bCreate to bCreateTmp
32361>>>>>>>>>>>>>        End
32361>>>>>>>>>>>>>>
32361>>>>>>>>>>>>>        Else Begin
32362>>>>>>>>>>>>>            Move False to bCreateTmp
32363>>>>>>>>>>>>>        End
32363>>>>>>>>>>>>>>
32363>>>>>>>>>>>>>        Get VdfFolderPath VDF_FILELIST to sRval
32364>>>>>>>>>>>>>        Get AppendPath sRval sSubFolderName to sRval
32365>>>>>>>>>>>>>        If (bCreateTmp) Begin
32367>>>>>>>>>>>>>            If (FileExists(Self,sRval)=0) Begin
32369>>>>>>>>>>>>>                Get CreateFolderNew sRval to bCreateTmp
32370>>>>>>>>>>>>>            End
32370>>>>>>>>>>>>>>
32370>>>>>>>>>>>>>        End
32370>>>>>>>>>>>>>>
32370>>>>>>>>>>>>>        Function_Return sRval
32371>>>>>>>>>>>>>    End_Function
32372>>>>>>>>>>>>>
32372>>>>>>>>>>>>>    Function DataSubFolderPersonal String sSubFolderName Boolean bCreate Returns String
32374>>>>>>>>>>>>>        String sFolder
32374>>>>>>>>>>>>>        Boolean bCreateTmp
32374>>>>>>>>>>>>>        If (num_arguments>1) Begin
32376>>>>>>>>>>>>>            Move bCreate to bCreateTmp
32377>>>>>>>>>>>>>        End
32377>>>>>>>>>>>>>>
32377>>>>>>>>>>>>>        Else Begin
32378>>>>>>>>>>>>>            Move False to bCreateTmp
32379>>>>>>>>>>>>>        End
32379>>>>>>>>>>>>>>
32379>>>>>>>>>>>>>        Get DataSubFolder sSubFolderName bCreateTmp to sFolder
32380>>>>>>>>>>>>>        Get AppendPath sFolder (NetworkUserName(oWindowsInfo)) to sFolder
32381>>>>>>>>>>>>>        If (bCreateTmp) Begin
32383>>>>>>>>>>>>>            If (FileExists(Self,sFolder)=0) Begin
32385>>>>>>>>>>>>>                Get CreateFolderNew sFolder to bCreateTmp
32386>>>>>>>>>>>>>            End
32386>>>>>>>>>>>>>>
32386>>>>>>>>>>>>>        End
32386>>>>>>>>>>>>>>
32386>>>>>>>>>>>>>        Function_Return sFolder
32387>>>>>>>>>>>>>    End_Function
32388>>>>>>>>>>>>>
32388>>>>>>>>>>>>>    Function DataSubFolderFindFile String sSubFolderName String sFileName Returns String
32390>>>>>>>>>>>>>        String sRval sFolder
32390>>>>>>>>>>>>>        Get DataSubFolderPersonal sSubFolderName to sFolder
32391>>>>>>>>>>>>>        Get AppendPath sFolder sFileName to sRval
32392>>>>>>>>>>>>>        If (FileExists(Self,sRval)<>1) Begin // Is it in the personal folder?
32394>>>>>>>>>>>>>            Get DataSubFolder sSubFolderName to sFolder
32395>>>>>>>>>>>>>            Get AppendPath sFolder sFileName to sRval
32396>>>>>>>>>>>>>            If (FileExists(Self,sRval)<>1) Begin
32398>>>>>>>>>>>>>                Move "" to sRval // Not found
32399>>>>>>>>>>>>>            End
32399>>>>>>>>>>>>>>
32399>>>>>>>>>>>>>        End
32399>>>>>>>>>>>>>>
32399>>>>>>>>>>>>>        Function_Return sRval
32400>>>>>>>>>>>>>    End_Function
32401>>>>>>>>>>>>>
32401>>>>>>>>>>>>>    Function ImageTextAsString Integer iImg Returns String
32403>>>>>>>>>>>>>        Integer iChannel
32403>>>>>>>>>>>>>        String sRval sLine sChar10
32403>>>>>>>>>>>>>        Boolean bSeqEof
32403>>>>>>>>>>>>>
32403>>>>>>>>>>>>>        Move "" to sRval
32404>>>>>>>>>>>>>        Move (Character(10)) to sChar10
32405>>>>>>>>>>>>>
32405>>>>>>>>>>>>>        Get DirectInput ("image:"+String(iImg)) to iChannel
32406>>>>>>>>>>>>>        If (iChannel>=0) Begin
32408>>>>>>>>>>>>>            Repeat
32408>>>>>>>>>>>>>>
32408>>>>>>>>>>>>>                Readln sLine
32409>>>>>>>>>>>>>                Move (SeqEof) to bSeqEof
32410>>>>>>>>>>>>>                If (not(bSeqEof)) Begin
32412>>>>>>>>>>>>>                     Move (sRval+sLine+sChar10) to sRval
32413>>>>>>>>>>>>>                End
32413>>>>>>>>>>>>>>
32413>>>>>>>>>>>>>            Until (bSeqEof)
32415>>>>>>>>>>>>>
32415>>>>>>>>>>>>>            Send CloseInput iChannel
32416>>>>>>>>>>>>>        End
32416>>>>>>>>>>>>>>
32416>>>>>>>>>>>>>        Function_Return sRval
32417>>>>>>>>>>>>>    End_Function
32418>>>>>>>>>>>>>
32418>>>>>>>>>>>>>    Procedure WriteIntegerArray Integer[] aValues Integer iChannel
32420>>>>>>>>>>>>>        Integer iItem iItemMax
32420>>>>>>>>>>>>>        Move (SizeOfArray(aValues)-1) to iItemMax
32421>>>>>>>>>>>>>        Writeln channel iChannel iItemMax
32424>>>>>>>>>>>>>        For iItem from 0 to iItemMax
32430>>>>>>>>>>>>>>
32430>>>>>>>>>>>>>            Writeln aValues[iItem]
32432>>>>>>>>>>>>>        Loop
32433>>>>>>>>>>>>>>
32433>>>>>>>>>>>>>    End_Procedure
32434>>>>>>>>>>>>>
32434>>>>>>>>>>>>>    Function ReadIntegerArray Integer iChannel Returns Integer[]
32436>>>>>>>>>>>>>        Integer iItem iItemMax
32436>>>>>>>>>>>>>        Integer[] aValues
32437>>>>>>>>>>>>>        Readln channel iChannel iItemMax
32439>>>>>>>>>>>>>        For iItem from 0 to iItemMax
32445>>>>>>>>>>>>>>
32445>>>>>>>>>>>>>            Readln aValues[iItem]
32446>>>>>>>>>>>>>        Loop
32447>>>>>>>>>>>>>>
32447>>>>>>>>>>>>>        Function_Return aValues
32448>>>>>>>>>>>>>    End_Function
32449>>>>>>>>>>>>>
32449>>>>>>>>>>>>>    Procedure WriteNumberArray Number[] aValues Integer iChannel
32451>>>>>>>>>>>>>        Integer iItem iItemMax
32451>>>>>>>>>>>>>        Move (SizeOfArray(aValues)-1) to iItemMax
32452>>>>>>>>>>>>>        Writeln channel iChannel iItemMax
32455>>>>>>>>>>>>>        For iItem from 0 to iItemMax
32461>>>>>>>>>>>>>>
32461>>>>>>>>>>>>>            Writeln aValues[iItem]
32463>>>>>>>>>>>>>        Loop
32464>>>>>>>>>>>>>>
32464>>>>>>>>>>>>>    End_Procedure
32465>>>>>>>>>>>>>
32465>>>>>>>>>>>>>    Function ReadNumberArray Integer iChannel Returns Number[]
32467>>>>>>>>>>>>>        Integer iItem iItemMax
32467>>>>>>>>>>>>>        Number[] aValues
32468>>>>>>>>>>>>>        Readln channel iChannel iItemMax
32470>>>>>>>>>>>>>        For iItem from 0 to iItemMax
32476>>>>>>>>>>>>>>
32476>>>>>>>>>>>>>            Readln aValues[iItem]
32477>>>>>>>>>>>>>        Loop
32478>>>>>>>>>>>>>>
32478>>>>>>>>>>>>>        Function_Return aValues
32479>>>>>>>>>>>>>    End_Function
32480>>>>>>>>>>>>>
32480>>>>>>>>>>>>>    Procedure WriteStringArray String[] aValues Integer iChannel
32482>>>>>>>>>>>>>        Integer iItem iItemMax
32482>>>>>>>>>>>>>        Move (SizeOfArray(aValues)-1) to iItemMax
32483>>>>>>>>>>>>>        Writeln channel iChannel iItemMax
32486>>>>>>>>>>>>>        For iItem from 0 to iItemMax
32492>>>>>>>>>>>>>>
32492>>>>>>>>>>>>>            Writeln aValues[iItem]
32494>>>>>>>>>>>>>        Loop
32495>>>>>>>>>>>>>>
32495>>>>>>>>>>>>>    End_Procedure
32496>>>>>>>>>>>>>
32496>>>>>>>>>>>>>    Function ReadStringArray Integer iChannel Returns String[]
32498>>>>>>>>>>>>>        Integer iItem iItemMax
32498>>>>>>>>>>>>>        String[] aValues
32499>>>>>>>>>>>>>        Readln channel iChannel iItemMax
32501>>>>>>>>>>>>>        For iItem from 0 to iItemMax
32507>>>>>>>>>>>>>>
32507>>>>>>>>>>>>>            Readln aValues[iItem]
32508>>>>>>>>>>>>>        Loop
32509>>>>>>>>>>>>>>
32509>>>>>>>>>>>>>        Function_Return aValues
32510>>>>>>>>>>>>>    End_Function
32511>>>>>>>>>>>>>
32511>>>>>>>>>>>>>    Procedure WriteBooleanArray Boolean[] aValues Integer iChannel
32513>>>>>>>>>>>>>        Integer iItem iItemMax
32513>>>>>>>>>>>>>        Move (SizeOfArray(aValues)-1) to iItemMax
32514>>>>>>>>>>>>>        Writeln channel iChannel iItemMax
32517>>>>>>>>>>>>>        For iItem from 0 to iItemMax
32523>>>>>>>>>>>>>>
32523>>>>>>>>>>>>>            Writeln aValues[iItem]
32525>>>>>>>>>>>>>        Loop
32526>>>>>>>>>>>>>>
32526>>>>>>>>>>>>>    End_Procedure
32527>>>>>>>>>>>>>
32527>>>>>>>>>>>>>    Function ReadBooleanArray Integer iChannel Returns Boolean[]
32529>>>>>>>>>>>>>        Integer iItem iItemMax
32529>>>>>>>>>>>>>        Boolean[] aValues
32530>>>>>>>>>>>>>        Readln channel iChannel iItemMax
32532>>>>>>>>>>>>>        For iItem from 0 to iItemMax
32538>>>>>>>>>>>>>>
32538>>>>>>>>>>>>>            Readln aValues[iItem]
32539>>>>>>>>>>>>>        Loop
32540>>>>>>>>>>>>>>
32540>>>>>>>>>>>>>        Function_Return aValues
32541>>>>>>>>>>>>>    End_Function
32542>>>>>>>>>>>>>
32542>>>>>>>>>>>>>    Function AreFilesIdentical String sFile1Name String sFile2Name Boolean bBinaryCompare Returns Boolean
32544>>>>>>>>>>>>>        Integer iPos iBlockSize
32544>>>>>>>>>>>>>        Boolean bIdentical
32544>>>>>>>>>>>>>        Integer iFile1Size iFile2Size
32544>>>>>>>>>>>>>        Integer iCh1 iCh2
32544>>>>>>>>>>>>>        String sBlock1 sBlock2
32544>>>>>>>>>>>>>
32544>>>>>>>>>>>>>        If (not(bBinaryCompare)) Begin
32546>>>>>>>>>>>>>            Error 666 "Text compare not implemented"
32547>>>>>>>>>>>>>>
32547>>>>>>>>>>>>>        End
32547>>>>>>>>>>>>>>
32547>>>>>>>>>>>>>
32547>>>>>>>>>>>>>        Move True to bIdentical
32548>>>>>>>>>>>>>        Get FileSizeBytes sFile1Name to iFile1Size
32549>>>>>>>>>>>>>        Get FileSizeBytes sFile2Name to iFile2Size
32550>>>>>>>>>>>>>        If (iFile1Size=iFile2Size) Begin
32552>>>>>>>>>>>>>            Get DirectInput ("binary:"+sFile1Name) to iCh1
32553>>>>>>>>>>>>>            Get DirectInput ("binary:"+sFile2Name) to iCh2
32554>>>>>>>>>>>>>            Move 0 to iPos
32555>>>>>>>>>>>>>            While (iPos<iFile1Size)
32559>>>>>>>>>>>>>                Move ((iFile1Size-iPos) min 8192) to iBlockSize
32560>>>>>>>>>>>>>                Read_Block channel iCh1 sBlock1
32562>>>>>>>>>>>>>                Read_Block channel iCh2 sBlock2
32564>>>>>>>>>>>>>                If (sBlock1<>sBlock2) Begin
32566>>>>>>>>>>>>>                    Move False to bIdentical
32567>>>>>>>>>>>>>                    Move 0 to iFile1Size // stop the loop
32568>>>>>>>>>>>>>                End
32568>>>>>>>>>>>>>>
32568>>>>>>>>>>>>>                Move (iPos+iBlockSize) to iPos
32569>>>>>>>>>>>>>            Loop
32570>>>>>>>>>>>>>>
32570>>>>>>>>>>>>>            Send CloseInput iCh1
32571>>>>>>>>>>>>>            Send CloseInput iCh2
32572>>>>>>>>>>>>>        End
32572>>>>>>>>>>>>>>
32572>>>>>>>>>>>>>        Else Begin
32573>>>>>>>>>>>>>            Move False to bIdentical
32574>>>>>>>>>>>>>        End
32574>>>>>>>>>>>>>>
32574>>>>>>>>>>>>>        Function_Return bIdentical
32575>>>>>>>>>>>>>    End_Function
32576>>>>>>>>>>>>>    
32576>>>>>>>>>>>>>End_Class
32577>>>>>>>>>>>>>
32577>>>>>>>>>>>>>//> Handle to the current cFileFunctions object.
32577>>>>>>>>>>>>>Global_Variable Integer oFileFunctions
32577>>>>>>>>>>>>>//> And this is an object
32577>>>>>>>>>>>>>Object _oFileFunctions is a cFileFunctions
32579>>>>>>>>>>>>>    Move Self to oFileFunctions
32580>>>>>>>>>>>>>End_Object
32581>>>>>>>>>>>>>
32581>>>>>>>>>>>>>//#IFNDEF Is$WebApp // If Windows application
32581>>>>>>>>>>>>>//Object oTest is a ModalPanel
32581>>>>>>>>>>>>>//    Set Size to 170 201
32581>>>>>>>>>>>>>//
32581>>>>>>>>>>>>>//    Object oTreeView1 is a TreeView
32581>>>>>>>>>>>>>//        Set Size to 147 172
32581>>>>>>>>>>>>>//        Set Location to 13 13
32581>>>>>>>>>>>>>//
32581>>>>>>>>>>>>>//        Procedure OnCreateTree
32581>>>>>>>>>>>>>//            // Add tree items here, via the AddTreeItem function.
32581>>>>>>>>>>>>>//
32581>>>>>>>>>>>>>//            // Get AddTreeItem sText hRoot iItemData iImage iSelImage To hItem
32581>>>>>>>>>>>>>//        End_Procedure
32581>>>>>>>>>>>>>//
32581>>>>>>>>>>>>>//    End_Object
32581>>>>>>>>>>>>>//    Function BrowseFolder String sCaption String sStartFolder Returns String 
32581>>>>>>>>>>>>>//    End_Function
32581>>>>>>>>>>>>>//End_Object
32581>>>>>>>>>>>>>//#ENDIF              
32581>>>>>>>>>>>>>
32581>>>>>>>>>>>>>//Enum_List
32581>>>>>>>>>>>>>//    Define cfoCopy
32581>>>>>>>>>>>>>//    Define cfoRename
32581>>>>>>>>>>>>>//    Define cfoDelete
32581>>>>>>>>>>>>>//    Define cfoMove
32581>>>>>>>>>>>>>//End_Enum_List
32581>>>>>>>>>>>>>//
32581>>>>>>>>>>>>>//Struct tFileOperation
32581>>>>>>>>>>>>>//    Integer eOperation
32581>>>>>>>>>>>>>//    Boolean bFolder // File or folder?
32581>>>>>>>>>>>>>//    String sSource
32581>>>>>>>>>>>>>//    String sTarget
32581>>>>>>>>>>>>>//End_Struct
32581>>>>>>>>>>>>>
32581>>>>>>>>>>>>>//Function CopyFile String sPath1 String sPath2 Returns Integer
32581>>>>>>>>>>>>>//Function DeleteFile String sPath Boolean bToBin Returns Integer
32581>>>>>>>>>>>>>//Function RenameFile String sFileName1 String sFileName2 Returns Integer
32581>>>>>>>>>>>>>//Function MoveFile String sPath1 String sPath2 Returns Integer
32581>>>>>>>>>>>>>//// Returns False on success. If sNewFolder already exists the function will return True (failure)
32581>>>>>>>>>>>>>//Function CreateFolder String sNewFolder Returns Boolean
32581>>>>>>>>>>>>>////> Returns True on success
32581>>>>>>>>>>>>>//Function CreateFolderIfNotExist String sFolder Returns Boolean
32581>>>>>>>>>>>>>//// sRootFolder must already exist. Returns True if the sRootFolder\sSubFolderPath can be accessed after calling the function
32581>>>>>>>>>>>>>//Function CreateFolderMultiLevel String sRootFolder String sSubFolderPath Returns Boolean
32581>>>>>>>>>>>>>//Function DeleteFolder String sPath Returns Integer
32581>>>>>>>>>>>>>//Function DeleteAllFilesInFolder String sPath Returns Integer
32581>>>>>>>>>>>>>//Function DeleteFolderRecursive String sPath Returns Integer
32581>>>>>>>>>>>>>//    
32581>>>>>>>>>>>
32581>>>>>>>>>>>
32581>>>>>>>>>>>Global_Variable Integer oDataDictionaryFunctions
32581>>>>>>>>>>>
32581>>>>>>>>>>>Procedure _RegisterAllMainDDObjects for cObject
32583>>>>>>>>>>>    Integer iDM iMainDD
32583>>>>>>>>>>>    Get Delegation_Mode to iDM
32584>>>>>>>>>>>    Set Delegation_Mode to No_Delegate_Or_Error
32585>>>>>>>>>>>    Get Main_DD to iMainDD
32586>>>>>>>>>>>    Set Delegation_Mode to iDM
32587>>>>>>>>>>>    If (iMainDD<>0) Begin
32589>>>>>>>>>>>        Send _AllDataDictionaryContainersRegister of oDataDictionaryFunctions Self    
32590>>>>>>>>>>>    End
32590>>>>>>>>>>>>
32590>>>>>>>>>>>End_Procedure
32591>>>>>>>>>>>
32591>>>>>>>>>>>Struct tDDORelation
32591>>>>>>>>>>>    Integer hFromDDO
32591>>>>>>>>>>>    Integer hToDDO
32591>>>>>>>>>>>    Boolean bConstrained // Constrain_File is set
32591>>>>>>>>>>>End_Struct
32591>>>>>>>>>>>
32591>>>>>>>>>>>Object _oDataDictionaryFunctions is a cObject
32593>>>>>>>>>>>    Move Self to oDataDictionaryFunctions
32594>>>>>>>>>>>
32594>>>>>>>>>>>    Global_Variable Integer[] _gaDdoClasses
32594>>>>>>>>>>>    Global_Variable Integer[] _gaDdoObjects
32594>>>>>>>>>>>
32594>>>>>>>>>>>    // This method lets you decide the class of object to be queried when reading DatabaseBuilder settings.
32594>>>>>>>>>>>    Procedure Set DDO_Class Integer iTable Integer iClass
32597>>>>>>>>>>>        Move iClass to _gaDdoClasses[iTable]
32598>>>>>>>>>>>    End_Procedure
32599>>>>>>>>>>>
32599>>>>>>>>>>>    Function DDO_Class Integer iTable Returns Integer
32602>>>>>>>>>>>        If (SizeOfArray(_gaDdoClasses)>iTable) Begin
32604>>>>>>>>>>>            Function_Return _gaDdoClasses[iTable]
32605>>>>>>>>>>>        End
32605>>>>>>>>>>>>
32605>>>>>>>>>>>        Function_Return 0
32606>>>>>>>>>>>    End_Function
32607>>>>>>>>>>>    
32607>>>>>>>>>>>    // DDO's created by this function are only meant for
32607>>>>>>>>>>>    // querying properties, not for updating tables.
32607>>>>>>>>>>>    // Table must be Open prior to calling this Function!
32607>>>>>>>>>>>    Function DDO_Object Integer iTable Returns Integer
32610>>>>>>>>>>>        Integer hDDO iClass
32610>>>>>>>>>>>
32610>>>>>>>>>>>        Move 0 to hDDO
32611>>>>>>>>>>>        If (SizeOfArray(_gaDdoObjects)>iTable) Begin
32613>>>>>>>>>>>            Move _gaDdoObjects[iTable] to hDDO
32614>>>>>>>>>>>        End
32614>>>>>>>>>>>>
32614>>>>>>>>>>>        
32614>>>>>>>>>>>        If (hDDO=0) Begin // If the object isn't there we'll try to create it
32616>>>>>>>>>>>            Get DDO_Class iTable to iClass // Get registered class for the table
32617>>>>>>>>>>>            If (iClass<>0) Begin // If there was one:
32619>>>>>>>>>>>                Get Create iClass to hDDO // create new DDO
32620>>>>>>>>>>>                Move hDDO to _gaDdoObjects[iTable]
32621>>>>>>>>>>>            End
32621>>>>>>>>>>>>
32621>>>>>>>>>>>        End
32621>>>>>>>>>>>>
32621>>>>>>>>>>>        Function_Return hDDO
32622>>>>>>>>>>>    End_Function
32623>>>>>>>>>>>    
32623>>>>>>>>>>>    //> Returns an array of connected child DDOs of hDDO
32623>>>>>>>>>>>    Function ChildDdoArray Integer hDDO Returns Integer[]
32626>>>>>>>>>>>        Integer iMax iIndex
32626>>>>>>>>>>>        Integer[] aDDOs
32627>>>>>>>>>>>        Get Data_Set_Client_Count of hDDO to iMax
32628>>>>>>>>>>>        Decrement iMax
32629>>>>>>>>>>>        For iIndex from 0 to iMax
32635>>>>>>>>>>>>
32635>>>>>>>>>>>            Get Data_Set_Client of hDDO iIndex to aDDOs[iIndex]
32636>>>>>>>>>>>        Loop
32637>>>>>>>>>>>>
32637>>>>>>>>>>>        Function_Return aDDOs
32638>>>>>>>>>>>    End_Function
32639>>>>>>>>>>>
32639>>>>>>>>>>>    //> Returns an array of connected parent DDOs of hDDO
32639>>>>>>>>>>>    Function ParentDdoArray Integer hDDO Returns Integer[]
32642>>>>>>>>>>>        Integer iMax iIndex
32642>>>>>>>>>>>        Integer[] aDDOs
32643>>>>>>>>>>>        Get Data_Set_Server_Count of hDDO to iMax
32644>>>>>>>>>>>        Decrement iMax
32645>>>>>>>>>>>        For iIndex from 0 to iMax
32651>>>>>>>>>>>>
32651>>>>>>>>>>>            Get Data_Set_Server of hDDO iIndex to aDDOs[iIndex]
32652>>>>>>>>>>>        Loop
32653>>>>>>>>>>>>
32653>>>>>>>>>>>        Function_Return aDDOs
32654>>>>>>>>>>>    End_Function
32655>>>>>>>>>>>    
32655>>>>>>>>>>>    //> Returns an array of required child tables of hDDO. These are the tables
32655>>>>>>>>>>>    //> that should be represented by connecting DDOs (if a delete operation is to
32655>>>>>>>>>>>    //> succeed)
32655>>>>>>>>>>>    Function RequiredChildTableArray Integer hDDO Returns Integer[]
32658>>>>>>>>>>>        Integer iMax iIndex
32658>>>>>>>>>>>        Integer[] aTables
32659>>>>>>>>>>>        Get Client_File_Count of hDDO to iMax
32660>>>>>>>>>>>        Decrement iMax
32661>>>>>>>>>>>        For iIndex from 0 to iMax
32667>>>>>>>>>>>>
32667>>>>>>>>>>>            Get Client_File of hDDO iIndex to aTables[iIndex]
32668>>>>>>>>>>>        Loop
32669>>>>>>>>>>>>
32669>>>>>>>>>>>        Function_Return aTables
32670>>>>>>>>>>>    End_Function
32671>>>>>>>>>>>
32671>>>>>>>>>>>    //> Returns an array of required parent tables of hDDO. These are the tables
32671>>>>>>>>>>>    //> that should be represented by connected DDOs (if a save operation is to
32671>>>>>>>>>>>    //> succeed)
32671>>>>>>>>>>>    Function RequiredParentTableArray Integer hDDO Returns Integer[]
32674>>>>>>>>>>>        Integer iMax iIndex
32674>>>>>>>>>>>        Integer[] aTables
32675>>>>>>>>>>>        Get Server_File_Count of hDDO to iMax
32676>>>>>>>>>>>        Decrement iMax
32677>>>>>>>>>>>        For iIndex from 0 to iMax
32683>>>>>>>>>>>>
32683>>>>>>>>>>>            Get Server_File of hDDO iIndex to aTables[iIndex]
32684>>>>>>>>>>>        Loop
32685>>>>>>>>>>>>
32685>>>>>>>>>>>        Function_Return aTables
32686>>>>>>>>>>>    End_Function
32687>>>>>>>>>>>
32687>>>>>>>>>>>        Function _SearchDdoArrayForTable Integer[] aDDO Integer iTable Returns Integer
32690>>>>>>>>>>>            Integer iMax iIndex
32690>>>>>>>>>>>            Move (SizeOfArray(aDDO)-1) to iMax
32691>>>>>>>>>>>            For iIndex from 0 to iMax
32697>>>>>>>>>>>>
32697>>>>>>>>>>>                If (iTable=main_file(aDDO[iIndex])) Begin
32699>>>>>>>>>>>                    Function_Return iIndex
32700>>>>>>>>>>>                End
32700>>>>>>>>>>>>
32700>>>>>>>>>>>            Loop
32701>>>>>>>>>>>>
32701>>>>>>>>>>>            Function_Return -1
32702>>>>>>>>>>>        End_Function
32703>>>>>>>>>>>    
32703>>>>>>>>>>>    Function MissingChildTableArray Integer hDDO Returns Integer[]
32706>>>>>>>>>>>        Integer iMax iIndex iMissingIndex
32706>>>>>>>>>>>        Integer[] aRequiredChildTables aChildDDOs aMissingTables
32709>>>>>>>>>>>        Get ChildDdoArray hDDO to aChildDDOs
32710>>>>>>>>>>>        Get RequiredChildTableArray hDDO to aRequiredChildTables
32711>>>>>>>>>>>        Move 0 to iMissingIndex
32712>>>>>>>>>>>        Move (SizeOfArray(aRequiredChildTables)-1) to iMax
32713>>>>>>>>>>>        For iIndex from 0 to iMax
32719>>>>>>>>>>>>
32719>>>>>>>>>>>            If (_SearchDdoArrayForTable(Self,aChildDDOs,aRequiredChildTables[iIndex])=-1) Begin
32721>>>>>>>>>>>                Move aRequiredChildTables[iIndex] to aMissingTables[iMissingIndex]
32722>>>>>>>>>>>                Increment iMissingIndex
32723>>>>>>>>>>>            End
32723>>>>>>>>>>>>
32723>>>>>>>>>>>        Loop
32724>>>>>>>>>>>>
32724>>>>>>>>>>>        Function_Return aMissingTables
32725>>>>>>>>>>>    End_Function
32726>>>>>>>>>>>    
32726>>>>>>>>>>>    Function MissingParentTableArray Integer hDDO Returns Integer[]
32729>>>>>>>>>>>        Integer iMax iIndex iMissingIndex
32729>>>>>>>>>>>        Integer[] aRequiredParentTables aParentDDOs aMissingTables
32732>>>>>>>>>>>        Get ParentDdoArray hDDO to aParentDDOs
32733>>>>>>>>>>>        Get RequiredParentTableArray hDDO to aRequiredParentTables
32734>>>>>>>>>>>        Move 0 to iMissingIndex
32735>>>>>>>>>>>        Move (SizeOfArray(aRequiredParentTables)-1) to iMax
32736>>>>>>>>>>>        For iIndex from 0 to iMax
32742>>>>>>>>>>>>
32742>>>>>>>>>>>            If (_SearchDdoArrayForTable(Self,aParentDDOs,aRequiredParentTables[iIndex])=-1) Begin
32744>>>>>>>>>>>                Move aRequiredParentTables[iIndex] to aMissingTables[iMissingIndex]
32745>>>>>>>>>>>                Increment iMissingIndex
32746>>>>>>>>>>>            End
32746>>>>>>>>>>>>
32746>>>>>>>>>>>        Loop
32747>>>>>>>>>>>>
32747>>>>>>>>>>>        Function_Return aMissingTables
32748>>>>>>>>>>>    End_Function
32749>>>>>>>>>>>    
32749>>>>>>>>>>>        Function _IsMember Integer iValue Integer[] aValues Returns Boolean
32752>>>>>>>>>>>            Integer iIndex
32752>>>>>>>>>>>            Move (SearchArray(iValue,aValues)) to iIndex
32753>>>>>>>>>>>            Function_Return (iIndex<>-1)
32754>>>>>>>>>>>        End_Function
32755>>>>>>>>>>>        
32755>>>>>>>>>>>        Procedure _BuildParentStructure Integer hDDO Boolean bParentFirst Integer[] ByRef aDDOs Integer[] ByRef aBeingHandled 
32758>>>>>>>>>>>            Integer iMax iItem hParentDD
32758>>>>>>>>>>>            
32758>>>>>>>>>>>            Get Data_Set_Server_Count of hDDO to iMax
32759>>>>>>>>>>>            Decrement iMax
32760>>>>>>>>>>>            For iItem from 0 to iMax
32766>>>>>>>>>>>>
32766>>>>>>>>>>>                Get Data_Set_Server of hDDO iItem to hParentDD
32767>>>>>>>>>>>                
32767>>>>>>>>>>>                If (not(_IsMember(Self,hParentDD,aBeingHandled))) Begin
32769>>>>>>>>>>>                    Move hParentDD to aBeingHandled[SizeOfArray(aBeingHandled)]
32770>>>>>>>>>>>                     
32770>>>>>>>>>>>                    If (bParentFirst) Begin
32772>>>>>>>>>>>                        Send _BuildParentStructure hParentDD bParentFirst (&aDDOs) (&aBeingHandled)
32773>>>>>>>>>>>                        Send _BuildChildStructure hParentDD bParentFirst (&aDDOs) (&aBeingHandled)
32774>>>>>>>>>>>                    End
32774>>>>>>>>>>>>
32774>>>>>>>>>>>    
32774>>>>>>>>>>>                    Move hParentDD to aDDOs[SizeOfArray(aDDOs)]
32775>>>>>>>>>>>    
32775>>>>>>>>>>>                    If (not(bParentFirst)) Begin
32777>>>>>>>>>>>                        Send _BuildChildStructure hParentDD bParentFirst (&aDDOs) (&aBeingHandled)
32778>>>>>>>>>>>                        Send _BuildParentStructure hParentDD bParentFirst (&aDDOs) (&aBeingHandled)
32779>>>>>>>>>>>                    End
32779>>>>>>>>>>>>
32779>>>>>>>>>>>                End
32779>>>>>>>>>>>>
32779>>>>>>>>>>>            Loop
32780>>>>>>>>>>>>
32780>>>>>>>>>>>        End_Procedure
32781>>>>>>>>>>>    
32781>>>>>>>>>>>        Procedure _BuildChildStructure Integer hDDO Boolean bParentFirst Integer[] ByRef aDDOs Integer[] ByRef aBeingHandled 
32784>>>>>>>>>>>            Integer iMax iItem hChildDD
32784>>>>>>>>>>>            
32784>>>>>>>>>>>            Get Data_Set_Client_Count of hDDO to iMax
32785>>>>>>>>>>>            Decrement iMax
32786>>>>>>>>>>>            For iItem from 0 to iMax
32792>>>>>>>>>>>>
32792>>>>>>>>>>>                Get Data_Set_Client of hDDO iItem to hChildDD
32793>>>>>>>>>>>                
32793>>>>>>>>>>>                If (not(_IsMember(Self,hChildDD,aBeingHandled))) Begin
32795>>>>>>>>>>>                    Move hChildDD to aBeingHandled[SizeOfArray(aBeingHandled)]
32796>>>>>>>>>>>
32796>>>>>>>>>>>                    If (bParentFirst) Begin
32798>>>>>>>>>>>                        Send _BuildParentStructure hChildDD bParentFirst (&aDDOs) (&aBeingHandled)
32799>>>>>>>>>>>                        Send _BuildChildStructure hChildDD bParentFirst (&aDDOs) (&aBeingHandled)
32800>>>>>>>>>>>                    End
32800>>>>>>>>>>>>
32800>>>>>>>>>>>
32800>>>>>>>>>>>                    Move hChildDD to aDDOs[SizeOfArray(aDDOs)]
32801>>>>>>>>>>>    
32801>>>>>>>>>>>                    If (not(bParentFirst)) Begin
32803>>>>>>>>>>>                        Send _BuildChildStructure hChildDD bParentFirst (&aDDOs) (&aBeingHandled)
32804>>>>>>>>>>>                        Send _BuildParentStructure hChildDD bParentFirst (&aDDOs) (&aBeingHandled)
32805>>>>>>>>>>>                    End
32805>>>>>>>>>>>>
32805>>>>>>>>>>>                End
32805>>>>>>>>>>>>
32805>>>>>>>>>>>            Loop
32806>>>>>>>>>>>>
32806>>>>>>>>>>>        End_Procedure
32807>>>>>>>>>>>
32807>>>>>>>>>>>    // Returns an array of DDO handles.
32807>>>>>>>>>>>    Function ParentStructure Integer hRootDD Boolean bParentFirst Returns Integer[]
32810>>>>>>>>>>>        Integer[] aRval aBeingHandled
32812>>>>>>>>>>>        Move hRootDD to aBeingHandled[0]
32813>>>>>>>>>>>        Send _BuildParentStructure hRootDD bParentFirst (&aRval) (&aBeingHandled)
32814>>>>>>>>>>>        Function_Return aRval
32815>>>>>>>>>>>    End_Function
32816>>>>>>>>>>>    
32816>>>>>>>>>>>    // Returns an array of DDO handles.
32816>>>>>>>>>>>    Function ChildStructure Integer hRootDD Boolean bParentFirst Returns Integer[]
32819>>>>>>>>>>>        Integer[] aRval aBeingHandled
32821>>>>>>>>>>>        Move hRootDD to aBeingHandled[0]
32822>>>>>>>>>>>        Send _BuildChildStructure hRootDD bParentFirst (&aRval) (&aBeingHandled)
32823>>>>>>>>>>>        Function_Return aRval
32824>>>>>>>>>>>    End_Function
32825>>>>>>>>>>>    
32825>>>>>>>>>>>    //> Returns an array of DDO objects
32825>>>>>>>>>>>    Function CompleteStructure Integer hRootDD Boolean bParentFirst Returns Integer[]
32828>>>>>>>>>>>        Integer[] aRval aBeingHandled
32830>>>>>>>>>>>        If (bParentFirst) Begin
32832>>>>>>>>>>>            Send _BuildParentStructure hRootDD bParentFirst (&aRval) (&aBeingHandled)
32833>>>>>>>>>>>            If (SizeOfArray(aRval)=0) Begin
32835>>>>>>>>>>>                Send _BuildChildStructure hRootDD bParentFirst (&aRval) (&aBeingHandled)
32836>>>>>>>>>>>            End
32836>>>>>>>>>>>>
32836>>>>>>>>>>>        End 
32836>>>>>>>>>>>>
32836>>>>>>>>>>>        Else Begin
32837>>>>>>>>>>>            Send _BuildChildStructure hRootDD bParentFirst (&aRval) (&aBeingHandled)
32838>>>>>>>>>>>            If (SizeOfArray(aRval)=0) Begin
32840>>>>>>>>>>>                Send _BuildParentStructure hRootDD bParentFirst (&aRval) (&aBeingHandled)
32841>>>>>>>>>>>            End
32841>>>>>>>>>>>>
32841>>>>>>>>>>>        End
32841>>>>>>>>>>>>
32841>>>>>>>>>>>        If (not(_IsMember(Self,hRootDD,aRval))) Begin
32843>>>>>>>>>>>            Move hRootDD to aRval[SizeOfArray(aRval)]
32844>>>>>>>>>>>        End
32844>>>>>>>>>>>>
32844>>>>>>>>>>>        Function_Return aRval
32845>>>>>>>>>>>    End_Function
32846>>>>>>>>>>>
32846>>>>>>>>>>>        Procedure _RequiredTablesSave Integer hDD Integer[] ByRef aTables
32849>>>>>>>>>>>            Integer iMax iIndex iTable
32849>>>>>>>>>>>            Integer hParentDD
32849>>>>>>>>>>>            Get Server_File_Count of hDD to iMax
32850>>>>>>>>>>>            Decrement iMax
32851>>>>>>>>>>>            For iIndex from 0 to iMax
32857>>>>>>>>>>>>
32857>>>>>>>>>>>                Get Server_File of hDD iIndex to iTable
32858>>>>>>>>>>>                If (not(_IsMember(Self,iTable,aTables))) Begin
32860>>>>>>>>>>>                    Move iTable to aTables[SizeOfArray(aTables)]
32861>>>>>>>>>>>                    Get Data_Set of hDD iTable to hParentDD
32862>>>>>>>>>>>                    If (hParentDD>0) Begin
32864>>>>>>>>>>>                        Send _RequiredTablesSave hParentDD (&aTables)
32865>>>>>>>>>>>                    End
32865>>>>>>>>>>>>
32865>>>>>>>>>>>                End
32865>>>>>>>>>>>>
32865>>>>>>>>>>>            Loop
32866>>>>>>>>>>>>
32866>>>>>>>>>>>        End_Procedure
32867>>>>>>>>>>>    
32867>>>>>>>>>>>    //> Returns a list of required tables
32867>>>>>>>>>>>    Function RequiredTablesSave Integer hRootDD Returns Integer[]
32870>>>>>>>>>>>        Integer[] aTables
32871>>>>>>>>>>>        Send _RequiredTablesSave hRootDD (&aTables)
32872>>>>>>>>>>>        Function_Return aTables
32873>>>>>>>>>>>    End_Function
32874>>>>>>>>>>>    
32874>>>>>>>>>>>    Function CheckRequiredTables Integer hRootDD Integer[] aTables Returns Integer[]
32877>>>>>>>>>>>        Integer iMax iIndex iTable
32877>>>>>>>>>>>        Integer hDD
32877>>>>>>>>>>>        Integer[] aMissingTables
32878>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
32879>>>>>>>>>>>        For iIndex from 0 to iMax
32885>>>>>>>>>>>>
32885>>>>>>>>>>>            Move aTables[iIndex] to iTable
32886>>>>>>>>>>>            Get Data_Set of hRootDD iTable to hDD
32887>>>>>>>>>>>            If (hDD<=0) Begin
32889>>>>>>>>>>>                Move iTable to aMissingTables[SizeOfArray(aMissingTables)]  
32890>>>>>>>>>>>            End
32890>>>>>>>>>>>>
32890>>>>>>>>>>>        Loop
32891>>>>>>>>>>>>
32891>>>>>>>>>>>        Function_Return aMissingTables
32892>>>>>>>>>>>    End_Function
32893>>>>>>>>>>>    
32893>>>>>>>>>>>    Function TableArrayIntegerToName Integer[] aTables Integer iAttr Returns String[]
32896>>>>>>>>>>>        Integer iMax iIndex
32896>>>>>>>>>>>        String[] aValues
32897>>>>>>>>>>>        If (iAttr=DF_FILE_LOGICAL_NAME or iAttr=DF_FILE_ROOT_NAME or iAttr=DF_FILE_DISPLAY_NAME) Begin
32899>>>>>>>>>>>            Move (SizeOfArray(aTables)-1) to iMax
32900>>>>>>>>>>>            For iIndex from 0 to iMax
32906>>>>>>>>>>>>
32906>>>>>>>>>>>                Get_Attribute iAttr of aTables[iIndex] to aValues[iIndex]
32909>>>>>>>>>>>            Loop
32910>>>>>>>>>>>>
32910>>>>>>>>>>>        End
32910>>>>>>>>>>>>
32910>>>>>>>>>>>        Function_Return aValues
32911>>>>>>>>>>>    End_Function
32912>>>>>>>>>>>
32912>>>>>>>>>>>    // This is not sofisticated enough. The tOIDeoInfo variable cannot hold
32912>>>>>>>>>>>    // the definition of a dbGrid type object and can therefore not extract
32912>>>>>>>>>>>    // the correct label name.
32912>>>>>>>>>>>    Function ControlLabel Integer hDDO Integer iTable Integer iField Returns String
32915>>>>>>>>>>>    End_Function
32916>>>>>>>>>>>
32916>>>>>>>>>>>    Procedure ShowDebugPanel
32919>>>>>>>>>>>    End_Procedure
32920>>>>>>>>>>>
32920>>>>>>>>>>>    // Call function hFunc in object hObject without creating an error
32920>>>>>>>>>>>    // if the object does not understand the call
32920>>>>>>>>>>>    Function _PaddedValue Integer hObject Integer hFunc Returns Integer
32923>>>>>>>>>>>        Integer iDm
32923>>>>>>>>>>>        String sValue
32923>>>>>>>>>>>        Get Delegation_Mode of hObject to iDm        
32924>>>>>>>>>>>        Set Delegation_Mode of hObject to NO_DELEGATE_OR_ERROR
32925>>>>>>>>>>>        Get hFunc of hObject to sValue
32926>>>>>>>>>>>        Set Delegation_Mode of hObject to iDm
32927>>>>>>>>>>>        Function_Return sValue
32928>>>>>>>>>>>    End_Function
32929>>>>>>>>>>>    
32929>>>>>>>>>>>    // Call function hFunc in object hObject with aurgunent iItem without
32929>>>>>>>>>>>    // creating an Error if the object does not understand the call
32929>>>>>>>>>>>    Function _PaddedItemValue Integer hObject Integer hFunc Integer iItem Returns Integer
32932>>>>>>>>>>>        Integer iDm
32932>>>>>>>>>>>        String sValue
32932>>>>>>>>>>>        Get Delegation_Mode of hObject to iDm        
32933>>>>>>>>>>>        Set Delegation_Mode of hObject to NO_DELEGATE_OR_ERROR
32934>>>>>>>>>>>        Get hFunc of hObject iItem to sValue
32935>>>>>>>>>>>        Set Delegation_Mode of hObject to iDm
32936>>>>>>>>>>>        Function_Return sValue
32937>>>>>>>>>>>    End_Function
32938>>>>>>>>>>>    
32938>>>>>>>>>>>    Function _PaddedDataFile Integer hObject Returns Integer
32941>>>>>>>>>>>        Integer iItem iTable
32941>>>>>>>>>>>        Get _PaddedValue hObject GET_Current_Item to iItem
32942>>>>>>>>>>>        Get _PaddedItemValue hObject GET_Data_File iItem to iTable
32943>>>>>>>>>>>        Function_Return iTable
32944>>>>>>>>>>>    End_Function
32945>>>>>>>>>>>    
32945>>>>>>>>>>>    Function DdoArrayToTableArray Integer[] aDDOs Returns Integer[]
32948>>>>>>>>>>>        Integer iMax iIndex iTable
32948>>>>>>>>>>>        Integer[] aTables
32949>>>>>>>>>>>        Move (SizeOfArray(aDDOs)-1) to iMax
32950>>>>>>>>>>>        For iIndex from 0 to iMax
32956>>>>>>>>>>>>
32956>>>>>>>>>>>            Get main_file of aDDOs[iIndex] to iTable
32957>>>>>>>>>>>            Move iTable to aTables[iIndex]
32958>>>>>>>>>>>        Loop
32959>>>>>>>>>>>>
32959>>>>>>>>>>>        Function_Return aTables
32960>>>>>>>>>>>    End_Function
32961>>>>>>>>>>>
32961>>>>>>>>>>>        Procedure _TrimParentDdoStructure Integer hDDO
32964>>>>>>>>>>>            Integer iMax iIndex
32964>>>>>>>>>>>            Integer[] aRequiredTables aParentDDOs aParentTables
32967>>>>>>>>>>>            Get RequiredParentTableArray hDDO to aRequiredTables
32968>>>>>>>>>>>            Get ParentDdoArray hDDO to aParentDDOs
32969>>>>>>>>>>>            Get DdoArrayToTableArray aParentDDOs to aParentTables
32970>>>>>>>>>>>            Move (SizeOfArray(aRequiredTables)-1) to iMax
32971>>>>>>>>>>>            For iIndex from 0 to iMax
32977>>>>>>>>>>>>
32977>>>>>>>>>>>                If (not(IntegerIsMember(oStackFunctions,aParentTables,aRequiredTables[iIndex]))) Begin
32979>>>>>>>>>>>                    // Remove required parent file
32979>>>>>>>>>>>                    Send Remove_Server_File of hDDO aRequiredTables[iIndex]
32980>>>>>>>>>>>                End
32980>>>>>>>>>>>>
32980>>>>>>>>>>>            Loop
32981>>>>>>>>>>>>
32981>>>>>>>>>>>        End_Procedure
32982>>>>>>>>>>>
32982>>>>>>>>>>>    Procedure TrimGrandParentDdoStructure Integer hDDO
32985>>>>>>>>>>>        Integer iMax iIndex
32985>>>>>>>>>>>        Integer[] aParentDDOs
32986>>>>>>>>>>>        Get ParentDdoArray hDDO to aParentDDOs
32987>>>>>>>>>>>        Move (SizeOfArray(aParentDDOs)-1) to iMax
32988>>>>>>>>>>>        For iIndex from 0 to iMax
32994>>>>>>>>>>>>
32994>>>>>>>>>>>            Send _TrimParentDdoStructure aParentDDOs[iIndex]
32995>>>>>>>>>>>        Loop
32996>>>>>>>>>>>>
32996>>>>>>>>>>>    End_Procedure
32997>>>>>>>>>>>
32997>>>>>>>>>>>    Procedure TrimParentDdoStructure integer hDDO
33000>>>>>>>>>>>        // NOTE! Not safeguarded against cyclic DDO_Server's
33000>>>>>>>>>>>        Integer iMax iIndex
33000>>>>>>>>>>>        Integer[] aParentDDOs
33001>>>>>>>>>>>        Send _TrimParentDdoStructure hDDO
33002>>>>>>>>>>>        Get ParentDdoArray hDDO to aParentDDOs
33003>>>>>>>>>>>        Move (SizeOfArray(aParentDDOs)-1) to iMax
33004>>>>>>>>>>>        For iIndex from 0 to iMax
33010>>>>>>>>>>>>
33010>>>>>>>>>>>            Send TrimParentDdoStructure aParentDDOs[iIndex]
33011>>>>>>>>>>>        Loop
33012>>>>>>>>>>>>
33012>>>>>>>>>>>    End_Procedure
33013>>>>>>>>>>>
33013>>>>>>>>>>>        Procedure _CreateMissingParentDDOs Integer hDDO Boolean bRecursive
33016>>>>>>>>>>>            Integer iMax iIndex iDDClass hNewDDO
33016>>>>>>>>>>>            Integer[] aRequiredTables aParentDDOs aParentTables
33019>>>>>>>>>>>            Get RequiredParentTableArray hDDO to aRequiredTables
33020>>>>>>>>>>>            Get ParentDdoArray hDDO to aParentDDOs
33021>>>>>>>>>>>            Get DdoArrayToTableArray aParentDDOs to aParentTables
33022>>>>>>>>>>>            Move (SizeOfArray(aRequiredTables)-1) to iMax
33023>>>>>>>>>>>            For iIndex from 0 to iMax
33029>>>>>>>>>>>>
33029>>>>>>>>>>>                If (not(IntegerIsMember(oStackFunctions,aParentTables,aRequiredTables[iIndex]))) Begin
33031>>>>>>>>>>>                    // Attempt to create the missing DDO:
33031>>>>>>>>>>>                    Get DDO_Class aRequiredTables[iIndex] to iDDClass
33032>>>>>>>>>>>                    If (iDDClass<>0) Begin
33034>>>>>>>>>>>                        Get Create of (Parent(hDDO)) iDDClass to hNewDDO
33035>>>>>>>>>>>                        Set DDO_Server of hDDO to hNewDDO
33036>>>>>>>>>>>                        If (bRecursive) Begin
33038>>>>>>>>>>>                            Send _CreateMissingParentDDOs hNewDDO bRecursive
33039>>>>>>>>>>>                        End
33039>>>>>>>>>>>>
33039>>>>>>>>>>>                    End
33039>>>>>>>>>>>>
33039>>>>>>>>>>>                    Else Begin
33040>>>>>>>>>>>                        Error 232 ("Can't create DDO for table "+String(aRequiredTables[iIndex])+" (missing class)")
33041>>>>>>>>>>>>
33041>>>>>>>>>>>                    End
33041>>>>>>>>>>>>
33041>>>>>>>>>>>                End
33041>>>>>>>>>>>>
33041>>>>>>>>>>>            Loop
33042>>>>>>>>>>>>
33042>>>>>>>>>>>        End_Procedure
33043>>>>>>>>>>>
33043>>>>>>>>>>>    Procedure CreateMissingParentDDOs Integer hDDO Boolean bRecursive
33046>>>>>>>>>>>        Send _CreateMissingParentDDOs hDDO bRecursive
33047>>>>>>>>>>>    End_Procedure
33048>>>>>>>>>>>    
33048>>>>>>>>>>>    //> This function adds missing child DDOs to hDDO passed as parameter.
33048>>>>>>>>>>>    Procedure CreateMissingImmediateChildDDOs Integer hDDO 
33051>>>>>>>>>>>        Integer iMax iIndex hChildDDO
33051>>>>>>>>>>>        Integer[] aChildTables
33052>>>>>>>>>>>        
33052>>>>>>>>>>>        If (Cascade_Delete_State(hDDO)) Begin
33054>>>>>>>>>>>            Error 231 "Cascade_Delete_State state must be set to false in order to use the CreateMissingParentDDOs method"
33055>>>>>>>>>>>>
33055>>>>>>>>>>>        End
33055>>>>>>>>>>>>
33055>>>>>>>>>>>        Else Begin
33056>>>>>>>>>>>            Get MissingChildTableArray hDDO to aChildTables
33057>>>>>>>>>>>            Move (SizeOfArray(aChildTables)-1) to iMax
33058>>>>>>>>>>>            For iIndex from 0 to iMax
33064>>>>>>>>>>>>
33064>>>>>>>>>>>                Get Create of (Parent(hDDO)) U_DataDictionary to hChildDDO // Create as siblings of hDDO
33065>>>>>>>>>>>                Set main_file of hChildDDO to aChildTables[iIndex]
33066>>>>>>>>>>>                Set DDO_Server of hChildDDO to hDDO
33067>>>>>>>>>>>            Loop
33068>>>>>>>>>>>>
33068>>>>>>>>>>>        End
33068>>>>>>>>>>>>
33068>>>>>>>>>>>    End_Procedure
33069>>>>>>>>>>>    
33069>>>>>>>>>>>    Procedure CreateMissingImmediateChildDDOsNoWarning Integer hDDO
33072>>>>>>>>>>>        Integer iMax iIndex hChildDDO
33072>>>>>>>>>>>        Integer[] aChildTables
33073>>>>>>>>>>>
33073>>>>>>>>>>>        Get MissingChildTableArray hDDO to aChildTables
33074>>>>>>>>>>>        Move (SizeOfArray(aChildTables)-1) to iMax
33075>>>>>>>>>>>        For iIndex from 0 to iMax
33081>>>>>>>>>>>>
33081>>>>>>>>>>>            Get Create of (Parent(hDDO)) U_DataDictionary to hChildDDO // Create as siblings of hDDO
33082>>>>>>>>>>>            Set Main_File of hChildDDO to aChildTables[iIndex]
33083>>>>>>>>>>>            Set DDO_Server of hChildDDO to hDDO
33084>>>>>>>>>>>        Loop
33085>>>>>>>>>>>>
33085>>>>>>>>>>>    End_Procedure
33086>>>>>>>>>>>
33086>>>>>>>>>>>    //Function ParentPath Returns Integer[]
33086>>>>>>>>>>>    //End_Function
33086>>>>>>>>>>>
33086>>>>>>>>>>>// -------------- Build "graphical" representation of DDO relationships -----------------
33086>>>>>>>>>>>
33086>>>>>>>>>>>                Function _AlreadyMappedAtRow Integer hDDO tRelationsDrawingMapItem[] aMap Returns Integer
33089>>>>>>>>>>>                    Integer iMax iIndex
33089>>>>>>>>>>>                    Move (SizeOfArray(aMap)-1) to iMax
33090>>>>>>>>>>>                    For iIndex from 0 to iMax
33096>>>>>>>>>>>>
33096>>>>>>>>>>>                        If (hDDO=aMap[iIndex].iItemId) Begin
33098>>>>>>>>>>>                            Function_Return iIndex // hDDO already mapped at row iIndex
33099>>>>>>>>>>>                        End
33099>>>>>>>>>>>>
33099>>>>>>>>>>>                    Loop
33100>>>>>>>>>>>>
33100>>>>>>>>>>>                    Function_Return -1 // not mapped
33101>>>>>>>>>>>                End_Function
33102>>>>>>>>>>>                
33102>>>>>>>>>>>                Function _RemoveValueFromArray Integer hValue Integer[] aValues Returns Integer[]
33105>>>>>>>>>>>                    Integer iMax iIndex
33105>>>>>>>>>>>                    Integer[] aRval
33106>>>>>>>>>>>                    Move (SizeOfArray(aValues)-1) to iMax
33107>>>>>>>>>>>                    For iIndex from 0 to iMax
33113>>>>>>>>>>>>
33113>>>>>>>>>>>                        If (hValue<>aValues[iIndex]) Begin
33115>>>>>>>>>>>                            Move aValues[iIndex] to aRval[SizeOfArray(aRval)]
33116>>>>>>>>>>>                        End
33116>>>>>>>>>>>>
33116>>>>>>>>>>>                    Loop
33117>>>>>>>>>>>>
33117>>>>>>>>>>>                    Function_Return aRval
33118>>>>>>>>>>>                End_Function
33119>>>>>>>>>>>                
33119>>>>>>>>>>>                Global_Variable Integer[] _gaDDFVisited
33119>>>>>>>>>>>               
33119>>>>>>>>>>>                Procedure _DmrAddToVisited Integer hDD
33122>>>>>>>>>>>                    Move hDD to _gaDDFVisited[SizeOfArray(_gaDDFVisited)]
33123>>>>>>>>>>>                End_Procedure
33124>>>>>>>>>>>               
33124>>>>>>>>>>>                Function _DmrAlreadyVisited Integer hDD Returns Boolean
33127>>>>>>>>>>>                    Integer iMax iIndex
33127>>>>>>>>>>>                    Move (SizeOfArray(_gaDDFVisited)-1) to iMax
33128>>>>>>>>>>>                    For iIndex from 0 to iMax
33134>>>>>>>>>>>>
33134>>>>>>>>>>>                        If (hDD=_gaDDFVisited[iIndex]) Begin
33136>>>>>>>>>>>                            Function_Return True
33137>>>>>>>>>>>                        End
33137>>>>>>>>>>>>
33137>>>>>>>>>>>                    Loop
33138>>>>>>>>>>>>
33138>>>>>>>>>>>                    Function_Return False
33139>>>>>>>>>>>                End_Function
33140>>>>>>>>>>>                
33140>>>>>>>>>>>        Global_Variable Boolean[] __gaDDFVerticalLines
33140>>>>>>>>>>>        
33140>>>>>>>>>>>        Procedure __doRelationsMapAddDdoRelation tDDORelation[] ByRef aDdoRelations Integer hChildTableDDO Integer hParentTableDDO
33143>>>>>>>>>>>            Integer iIndex iMax
33143>>>>>>>>>>>            Move (SizeOfArray(aDdoRelations)-1) to iMax
33144>>>>>>>>>>>            For iIndex from 0 to iMax
33150>>>>>>>>>>>>
33150>>>>>>>>>>>                If (aDdoRelations[iIndex].hFromDDO=hChildTableDDO and aDdoRelations[iIndex].hToDDO=hParentTableDDO) Begin
33152>>>>>>>>>>>                    Procedure_Return
33153>>>>>>>>>>>                End
33153>>>>>>>>>>>>
33153>>>>>>>>>>>            Loop
33154>>>>>>>>>>>>
33154>>>>>>>>>>>            
33154>>>>>>>>>>>            Move (SizeOfArray(aDdoRelations)) to iIndex
33155>>>>>>>>>>>            Move hChildTableDDO to aDdoRelations[iIndex].hFromDDO
33156>>>>>>>>>>>            Move hParentTableDDO to aDdoRelations[iIndex].hToDDO
33157>>>>>>>>>>>            Move (Constrain_File(hChildTableDDO)<>0 and Constrain_File(hChildTableDDO)=Main_File(hParentTableDDO)) to aDdoRelations[iIndex].bConstrained
33158>>>>>>>>>>>        End_Procedure
33159>>>>>>>>>>>                                                                                                                    
33159>>>>>>>>>>>        Procedure _doRelationsMap Integer hDDO Integer hIgnoreDD Integer iLevel tRelationsDrawingMapItem[] ByRef aMap Boolean bFirst Boolean bLast Boolean bParent Boolean bChild tDDORelation[] ByRef aDdoRelations
33162>>>>>>>>>>>            Integer iMax iIndex
33162>>>>>>>>>>>            Integer iAlreadyMappedAtRow
33162>>>>>>>>>>>            Boolean bUp bDown bLeft bRight     
33162>>>>>>>>>>>            Integer[] aParentDDOs aChildDDOs
33164>>>>>>>>>>>            String sValue
33164>>>>>>>>>>>            Boolean bAlreadyVisited
33164>>>>>>>>>>>            Integer hChildTableDDO hParentTableDDO
33164>>>>>>>>>>>
33164>>>>>>>>>>>            //Has the DDO already been mapped?
33164>>>>>>>>>>>            
33164>>>>>>>>>>>            Get _AlreadyMappedAtRow hDDO aMap to iAlreadyMappedAtRow
33165>>>>>>>>>>>            
33165>>>>>>>>>>>            Get _DmrAlreadyVisited hDDO to bAlreadyVisited
33166>>>>>>>>>>>            If (not(bAlreadyVisited)) Begin
33168>>>>>>>>>>>                Send _DmrAddToVisited hDDO
33169>>>>>>>>>>>            End
33169>>>>>>>>>>>>
33169>>>>>>>>>>> 
33169>>>>>>>>>>>            If (not(bAlreadyVisited)) Begin
33171>>>>>>>>>>>                Get ParentDdoArray hDDO to aParentDDOs
33172>>>>>>>>>>>                Get ChildDdoArray hDDO to aChildDDOs
33173>>>>>>>>>>>                Get _RemoveValueFromArray hIgnoreDD aParentDDOs to aParentDDOs
33174>>>>>>>>>>>                Get _RemoveValueFromArray hIgnoreDD aChildDDOs to aChildDDOs
33175>>>>>>>>>>>            End
33175>>>>>>>>>>>>
33175>>>>>>>>>>>
33175>>>>>>>>>>>            Move (SizeOfArray(aMap)-1) to iIndex
33176>>>>>>>>>>>            
33176>>>>>>>>>>>            Move False to __gaDDFVerticalLines[iLevel]
33177>>>>>>>>>>>            
33177>>>>>>>>>>>            If (not(bAlreadyVisited)) Begin
33179>>>>>>>>>>>                Move (SizeOfArray(aParentDDOs)-1) to iMax
33180>>>>>>>>>>>                For iIndex from 0 to iMax
33186>>>>>>>>>>>>
33186>>>>>>>>>>>                    Send __doRelationsMapAddDdoRelation (&aDdoRelations) hDDO aParentDDOs[iIndex]
33187>>>>>>>>>>>                    Send _doRelationsMap aParentDDOs[iIndex] hDDO (iLevel+1) (&aMap) (iIndex=0) (iIndex=iMax) True False (&aDdoRelations)
33188>>>>>>>>>>>                Loop
33189>>>>>>>>>>>>
33189>>>>>>>>>>>            End
33189>>>>>>>>>>>>
33189>>>>>>>>>>>            If (bParent and bFirst and iLevel>0) Begin
33191>>>>>>>>>>>                Move True to __gaDDFVerticalLines[iLevel-1] // Turn on parent vertical line
33192>>>>>>>>>>>            End
33192>>>>>>>>>>>>
33192>>>>>>>>>>>
33192>>>>>>>>>>>            Send BooleanDrop of oStackFunctions (&__gaDDFVerticalLines) 
33193>>>>>>>>>>>
33193>>>>>>>>>>>            Move (SizeOfArray(aMap)) to iIndex
33194>>>>>>>>>>>            Move hDDO to aMap[iIndex].iItemId
33195>>>>>>>>>>>            Move iLevel to aMap[iIndex].iLevel
33196>>>>>>>>>>>            Move __gaDDFVerticalLines to aMap[iIndex].aVerticalLines
33197>>>>>>>>>>>
33197>>>>>>>>>>>            If (iAlreadyMappedAtRow=-1 and bAlreadyVisited) Begin
33199>>>>>>>>>>>                Move -2 to iAlreadyMappedAtRow // Means that we don't yet know in what row the it "was" mapped in (may be fixed in a second pass)
33200>>>>>>>>>>>            End
33200>>>>>>>>>>>>
33200>>>>>>>>>>>            
33200>>>>>>>>>>>            Move iAlreadyMappedAtRow to aMap[iIndex].iAlreadyMappedAtRow
33201>>>>>>>>>>>            Move bFirst  to aMap[iIndex].bFirst
33202>>>>>>>>>>>            Move bLast   to aMap[iIndex].bLast  
33203>>>>>>>>>>>            Move bParent to aMap[iIndex].bParent
33204>>>>>>>>>>>            Move bChild  to aMap[iIndex].bChild
33205>>>>>>>>>>>
33205>>>>>>>>>>>            If (bChild and bLast and iLevel>0) Begin
33207>>>>>>>>>>>                Move False to __gaDDFVerticalLines[iLevel-1]
33208>>>>>>>>>>>            End
33208>>>>>>>>>>>>
33208>>>>>>>>>>>            
33208>>>>>>>>>>>            If (not(bAlreadyVisited)) Begin
33210>>>>>>>>>>>                Move True to __gaDDFVerticalLines[iLevel]
33211>>>>>>>>>>>                Move (SizeOfArray(aChildDDOs)-1) to iMax
33212>>>>>>>>>>>                For iIndex from 0 to iMax
33218>>>>>>>>>>>>
33218>>>>>>>>>>>                    Send __doRelationsMapAddDdoRelation (&aDdoRelations) aChildDDOs[iIndex] hDDO 
33219>>>>>>>>>>>                    Send _doRelationsMap aChildDDOs[iIndex] hDDO (iLevel+1) (&aMap) (iIndex=0) (iIndex=iMax) False True (&aDdoRelations)
33220>>>>>>>>>>>                Loop
33221>>>>>>>>>>>>
33221>>>>>>>>>>>                Send BooleanDrop of oStackFunctions (&__gaDDFVerticalLines)
33222>>>>>>>>>>>            End
33222>>>>>>>>>>>>
33222>>>>>>>>>>>
33222>>>>>>>>>>>       End_Procedure
33223>>>>>>>>>>>    
33223>>>>>>>>>>>    Function DDO_RelationsDrawingMap Integer hRootDD Returns tRelationsDrawingMapItem[]
33226>>>>>>>>>>>        tRelationsDrawingMapItem[] aMap
33226>>>>>>>>>>>        tRelationsDrawingMapItem[] aMap
33227>>>>>>>>>>>        tDDORelation[] aDdoRelations
33227>>>>>>>>>>>        tDDORelation[] aDdoRelations
33228>>>>>>>>>>>        Boolean[] aVerticalLines
33229>>>>>>>>>>>        Move (ResizeArray(_gaDDFVisited,0)) to _gaDDFVisited
33230>>>>>>>>>>>        Move (ResizeArray(__gaDDFVerticalLines,0)) to __gaDDFVerticalLines
33231>>>>>>>>>>>        If (hRootDD<>0) Begin
33233>>>>>>>>>>>            Send _doRelationsMap hRootDD 0 0 (&aMap) False False False False (&aDdoRelations)
33234>>>>>>>>>>>        End
33234>>>>>>>>>>>>
33234>>>>>>>>>>>        Function_Return aMap
33235>>>>>>>>>>>    End_Function
33236>>>>>>>>>>>    
33236>>>>>>>>>>>    Function DDO_Relations Integer hRootDD Returns tDDORelation[]
33239>>>>>>>>>>>        tRelationsDrawingMapItem[] aMap
33239>>>>>>>>>>>        tRelationsDrawingMapItem[] aMap
33240>>>>>>>>>>>        tDDORelation[] aDdoRelations
33240>>>>>>>>>>>        tDDORelation[] aDdoRelations
33241>>>>>>>>>>>        Boolean[] aVerticalLines
33242>>>>>>>>>>>        Move (ResizeArray(_gaDDFVisited,0)) to _gaDDFVisited
33243>>>>>>>>>>>        Move (ResizeArray(__gaDDFVerticalLines,0)) to __gaDDFVerticalLines
33244>>>>>>>>>>>        If (hRootDD<>0) Begin
33246>>>>>>>>>>>            Send _doRelationsMap hRootDD 0 0 (&aMap) False False False False (&aDdoRelations)
33247>>>>>>>>>>>        End
33247>>>>>>>>>>>>
33247>>>>>>>>>>>        Function_Return aDdoRelations
33248>>>>>>>>>>>    End_Function
33249>>>>>>>>>>>    
33249>>>>>>>>>>>                
33249>>>>>>>>>>>//          +--Zip
33249>>>>>>>>>>>//      +--Customer
33249>>>>>>>>>>>//      |--SalesP
33249>>>>>>>>>>>//     Order
33249>>>>>>>>>>>//      |       +--Country
33249>>>>>>>>>>>//      |   +--Vendor
33249>>>>>>>>>>>//      |   |--Product
33249>>>>>>>>>>>//      |   |   +--Stock
33249>>>>>>>>>>>//      +--Line
33249>>>>>>>>>>>//          |           +--Locations
33249>>>>>>>>>>>//          |       +--Pallets
33249>>>>>>>>>>>//          |   +--Packids
33249>>>>>>>>>>>//          +--Reservations
33249>>>>>>>>>>>//              +--Labels
33249>>>>>>>>>>>//
33249>>>>>>>>>>>//        +--Zip
33249>>>>>>>>>>>//     +--Customer
33249>>>>>>>>>>>//     |--SalesP
33249>>>>>>>>>>>//     Order
33249>>>>>>>>>>>//     |     +--Country
33249>>>>>>>>>>>//     |  +--Vendor
33249>>>>>>>>>>>//     |  |--Product
33249>>>>>>>>>>>//     |  |  +--Stock
33249>>>>>>>>>>>//     +--Line
33249>>>>>>>>>>>//        |        +--Locations
33249>>>>>>>>>>>//        |     +--Pallets
33249>>>>>>>>>>>//        |  +--Packids
33249>>>>>>>>>>>//        +--Reservations
33249>>>>>>>>>>>//           +--Labels
33249>>>>>>>>>>>//
33249>>>>>>>>>>>//       +-Zip
33249>>>>>>>>>>>//     +-Customer
33249>>>>>>>>>>>//     |-SalesP
33249>>>>>>>>>>>//     Order
33249>>>>>>>>>>>//     |   +-Country
33249>>>>>>>>>>>//     | +-Vendor
33249>>>>>>>>>>>//     | |-Product
33249>>>>>>>>>>>//     | | +-Stock
33249>>>>>>>>>>>//     +-Line
33249>>>>>>>>>>>//       |     +-Locations
33249>>>>>>>>>>>//       |   +-Pallets
33249>>>>>>>>>>>//       | +-Packids
33249>>>>>>>>>>>//       +-Reservations
33249>>>>>>>>>>>//         +-Labels
33249>>>>>>>>>>>
33249>>>>>>>>>>>// --------------------------------------------------------------------------------------
33249>>>>>>>>>>>    Function IsExtendedFieldDefinitionMissing Integer hDD Integer iField Returns Boolean
33252>>>>>>>>>>>        Integer iType
33252>>>>>>>>>>>        Integer hFieldObjects hFieldObject
33252>>>>>>>>>>>
33252>>>>>>>>>>>        Get_Attribute DF_FIELD_TYPE of (Main_File(hDD)) iField to iType
33255>>>>>>>>>>>
33255>>>>>>>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin
33257>>>>>>>>>>>            Get Field_Objects of hDD to hFieldObjects
33258>>>>>>>>>>>            If (hFieldObject<>0) Begin
33260>>>>>>>>>>>                Get Field_Object of hDD iField to hFieldObject
33261>>>>>>>>>>>                Function_Return (hFieldObject<>0)
33262>>>>>>>>>>>            End
33262>>>>>>>>>>>>
33262>>>>>>>>>>>            Function_Return True
33263>>>>>>>>>>>        End
33263>>>>>>>>>>>>
33263>>>>>>>>>>>        Function_Return False
33264>>>>>>>>>>>    End_Function
33265>>>>>>>>>>>
33265>>>>>>>>>>>// --------------------------------------------------------------------------------------
33265>>>>>>>>>>>    Function CreateCompleteDDO Integer iTable Returns Handle
33268>>>>>>>>>>>        Integer hDDO hDDC
33268>>>>>>>>>>>
33268>>>>>>>>>>>        // First create the root ddo:
33268>>>>>>>>>>>        Get DDO_Class iTable to hDDC
33269>>>>>>>>>>>        If (hDDC=0) Begin
33271>>>>>>>>>>>            Error 233 ("DD class not spedified for table "+String(iTable))
33272>>>>>>>>>>>>
33272>>>>>>>>>>>        End
33272>>>>>>>>>>>>
33272>>>>>>>>>>>        Else Begin
33273>>>>>>>>>>>            Get Create hDDC to hDDO
33274>>>>>>>>>>>            Send CreateMissingImmediateChildDDOsNoWarning hDDO
33275>>>>>>>>>>>            Send CreateMissingParentDDOs hDDO True
33276>>>>>>>>>>>        End
33276>>>>>>>>>>>>
33276>>>>>>>>>>>
33276>>>>>>>>>>>        Function_Return hDDO
33277>>>>>>>>>>>    End_Function
33278>>>>>>>>>>>
33278>>>>>>>>>>>    Struct tAutoIncrementColumn
33278>>>>>>>>>>>        Integer iTable
33278>>>>>>>>>>>        Integer iColumn
33278>>>>>>>>>>>        Integer iSourceTable
33278>>>>>>>>>>>        Integer iSourceColumn
33278>>>>>>>>>>>        Number  nMaxValue
33278>>>>>>>>>>>        Number  nCounterValue
33278>>>>>>>>>>>    End_Struct
33278>>>>>>>>>>>    
33278>>>>>>>>>>>        Procedure _AutoIncrementStatus tAutoIncrementColumn stAutoIncrementColumn Number ByRef nColumnHighestValue Number ByRef nCounter Boolean bUpdateSource
33281>>>>>>>>>>>            Integer iIndex iSourceRecords
33281>>>>>>>>>>>
33281>>>>>>>>>>>            Get_Attribute DF_FIELD_INDEX of stAutoIncrementColumn.iTable stAutoIncrementColumn.iColumn to iIndex
33284>>>>>>>>>>>            Clear stAutoIncrementColumn.iTable
33285>>>>>>>>>>>            Vfind stAutoIncrementColumn.iTable iIndex LT // Finds the last record according to index
33287>>>>>>>>>>>            Get_Field_Value stAutoIncrementColumn.iTable stAutoIncrementColumn.iColumn to nColumnHighestValue
33290>>>>>>>>>>>            
33290>>>>>>>>>>>            Get_Attribute DF_FILE_MAX_RECORDS of stAutoIncrementColumn.iSourceTable to iSourceRecords
33293>>>>>>>>>>>            
33293>>>>>>>>>>>            If (iSourceRecords=1) Begin
33295>>>>>>>>>>>                Reread stAutoIncrementColumn.iSourceTable    
33299>>>>>>>>>>>            End
33299>>>>>>>>>>>>
33299>>>>>>>>>>>            Else Begin
33300>>>>>>>>>>>                Lock
33301>>>>>>>>>>>>
33301>>>>>>>>>>>                Relate stAutoIncrementColumn.iTable
33302>>>>>>>>>>>            End
33302>>>>>>>>>>>>
33302>>>>>>>>>>>            Get_Field_Value stAutoIncrementColumn.iSourceTable stAutoIncrementColumn.iSourceColumn to nCounter
33305>>>>>>>>>>>            
33305>>>>>>>>>>>            If (bUpdateSource) Begin
33307>>>>>>>>>>>                If (nColumnHighestValue<>nCounter) Begin
33309>>>>>>>>>>>                    Set_Field_Value stAutoIncrementColumn.iSourceTable stAutoIncrementColumn.iSourceColumn to nColumnHighestValue
33312>>>>>>>>>>>                    SaveRecord stAutoIncrementColumn.iSourceTable
33313>>>>>>>>>>>                End
33313>>>>>>>>>>>>
33313>>>>>>>>>>>            End
33313>>>>>>>>>>>>
33313>>>>>>>>>>>            
33313>>>>>>>>>>>            Unlock
33314>>>>>>>>>>>>
33314>>>>>>>>>>>        End_Procedure
33315>>>>>>>>>>>        
33315>>>>>>>>>>>    Function AutoIncrementColumns Integer iTable Returns tAutoIncrementColumn[]
33318>>>>>>>>>>>        Integer hDDO iIndex iMax
33318>>>>>>>>>>>        Integer[] aAutoIncFields
33319>>>>>>>>>>>        tDDFileField[] aSysFileFields
33319>>>>>>>>>>>        tDDFileField[] aSysFileFields
33320>>>>>>>>>>>        tAutoIncrementColumn[] aColumns
33320>>>>>>>>>>>        tAutoIncrementColumn[] aColumns
33321>>>>>>>>>>>        Get DDO_Object iTable to hDDO
33322>>>>>>>>>>>        If (hDDO<>0) Begin
33324>>>>>>>>>>>            Get pAutoIncrementFields of hDDO to aAutoIncFields
33325>>>>>>>>>>>            Get pAutoIncrementSysFileFields of hDDO to aSysFileFields
33326>>>>>>>>>>>            Move (SizeOfArray(aAutoIncFields)-1) to iMax
33327>>>>>>>>>>>            For iIndex from 0 to iMax
33333>>>>>>>>>>>>
33333>>>>>>>>>>>                Move iTable to aColumns[iIndex].iTable
33334>>>>>>>>>>>                Move aAutoIncFields[iIndex] to aColumns[iIndex].iColumn
33335>>>>>>>>>>>                Move aSysFileFields[iIndex].iFile to aColumns[iIndex].iSourceTable
33336>>>>>>>>>>>                Move aSysFileFields[iIndex].iField to aColumns[iIndex].iSourceColumn
33337>>>>>>>>>>>                Send _AutoIncrementStatus aColumns[iIndex] (&aColumns[iIndex].nMaxValue) (&aColumns[iIndex].nCounterValue) False
33338>>>>>>>>>>>            Loop
33339>>>>>>>>>>>>
33339>>>>>>>>>>>        End
33339>>>>>>>>>>>>
33339>>>>>>>>>>>        Function_Return aColumns
33340>>>>>>>>>>>    End_Function
33341>>>>>>>>>>>    
33341>>>>>>>>>>>    Procedure AutoIncrementColumnsRepair Integer iTable
33344>>>>>>>>>>>        Integer iIndex iMax
33344>>>>>>>>>>>        Number nHigh nCount
33344>>>>>>>>>>>        tAutoIncrementColumn[] aColumns
33344>>>>>>>>>>>        tAutoIncrementColumn[] aColumns
33345>>>>>>>>>>>        Get AutoIncrementColumns iTable to aColumns
33346>>>>>>>>>>>        Move (SizeOfArray(aColumns)-1) to iMax
33347>>>>>>>>>>>        For iIndex from 0 to iMax
33353>>>>>>>>>>>>
33353>>>>>>>>>>>            Send _AutoIncrementStatus aColumns[iIndex] (&nHigh) (&nCount) True
33354>>>>>>>>>>>        Loop
33355>>>>>>>>>>>>
33355>>>>>>>>>>>    End_Procedure
33356>>>>>>>>>>>
33356>>>>>>>>>>>    Procedure AutoIncrementColumnsRepairAll
33359>>>>>>>>>>>        Integer iTable iMax 
33359>>>>>>>>>>>        Move (SizeOfArray(_gaDdoClasses)-1) to iMax
33360>>>>>>>>>>>        
33360>>>>>>>>>>>        For iTable from 1 to iMax
33366>>>>>>>>>>>>
33366>>>>>>>>>>>            If (_gaDdoClasses[iTable]<>0) Begin
33368>>>>>>>>>>>                Send AutoIncrementColumnsRepair iTable //_gaDdoClasses[iTable]
33369>>>>>>>>>>>            End
33369>>>>>>>>>>>>
33369>>>>>>>>>>>        Loop
33370>>>>>>>>>>>>
33370>>>>>>>>>>>    End_Procedure
33371>>>>>>>>>>>    
33371>>>>>>>>>>>    Function AutoIncrementStatusTable Integer iTable Returns tAutoIncrementColumn[]
33374>>>>>>>>>>>        tAutoIncrementColumn[] aAutoIncrementColumn
33374>>>>>>>>>>>        tAutoIncrementColumn[] aAutoIncrementColumn
33375>>>>>>>>>>>        Get AutoIncrementColumns iTable to aAutoIncrementColumn
33376>>>>>>>>>>>        Function_Return aAutoIncrementColumn
33377>>>>>>>>>>>    End_Function
33378>>>>>>>>>>>    
33378>>>>>>>>>>>        Function _AppendtAutoIncrementColumnArrays tAutoIncrementColumn[] aColumns1 tAutoIncrementColumn[] aColumns2 Returns tAutoIncrementColumn[]
33381>>>>>>>>>>>            Integer iIndex iMax iCount
33381>>>>>>>>>>>            Move (SizeOfArray(aColumns2)-1) to iMax
33382>>>>>>>>>>>            Move (SizeOfArray(aColumns1)) to iCount
33383>>>>>>>>>>>            For iIndex from 0 to iMax
33389>>>>>>>>>>>>
33389>>>>>>>>>>>                Move aColumns2[iIndex] to aColumns1[iCount]
33390>>>>>>>>>>>                Increment iCount
33391>>>>>>>>>>>            Loop
33392>>>>>>>>>>>>
33392>>>>>>>>>>>            Function_Return aColumns1
33393>>>>>>>>>>>        End_Function
33394>>>>>>>>>>>    
33394>>>>>>>>>>>    Function AutoIncrementStatusAll Returns tAutoIncrementColumn[]
33397>>>>>>>>>>>        Integer iTable iMax 
33397>>>>>>>>>>>        Move (SizeOfArray(_gaDdoClasses)-1) to iMax
33398>>>>>>>>>>>        tAutoIncrementColumn[] aAutoIncrementColumn aRval
33398>>>>>>>>>>>        tAutoIncrementColumn[] aAutoIncrementColumn aRval
33400>>>>>>>>>>>
33400>>>>>>>>>>>        For iTable from 1 to iMax
33406>>>>>>>>>>>>
33406>>>>>>>>>>>            If (_gaDdoClasses[iTable]<>0) Begin
33408>>>>>>>>>>>                Get AutoIncrementStatusTable iTable to aAutoIncrementColumn
33409>>>>>>>>>>>                Get _AppendtAutoIncrementColumnArrays aRval aAutoIncrementColumn to aRval
33410>>>>>>>>>>>//                Get AutoIncrementColumns iTable to aAutoIncrementColumn
33410>>>>>>>>>>>            End
33410>>>>>>>>>>>>
33410>>>>>>>>>>>        Loop
33411>>>>>>>>>>>>
33411>>>>>>>>>>>
33411>>>>>>>>>>>        Function_Return aRval
33412>>>>>>>>>>>    End_Function 
33413>>>>>>>>>>>        
33413>>>>>>>>>>>        Property Integer[] _paDdContainers
33415>>>>>>>>>>>        
33415>>>>>>>>>>>        Procedure _AllDataDictionaryContainersRegister Integer hDDContainer
33418>>>>>>>>>>>            Integer[] aContainers
33419>>>>>>>>>>>            Get _paDdContainers to aContainers
33420>>>>>>>>>>>            Move hDDContainer to aContainers[SizeOfArray(aContainers)]
33421>>>>>>>>>>>            Set _paDdContainers to aContainers
33422>>>>>>>>>>>        End_Procedure
33423>>>>>>>>>>>    
33423>>>>>>>>>>>    Function AllDataDictionaryContainers Integer hRoot Returns Integer[]
33426>>>>>>>>>>>        Integer[] aContainers
33427>>>>>>>>>>>        Set _paDdContainers to aContainers
33428>>>>>>>>>>>        If (hRoot=0) Begin
33430>>>>>>>>>>>            Move Desktop to hRoot
33431>>>>>>>>>>>        End
33431>>>>>>>>>>>>
33431>>>>>>>>>>>        Broadcast Recursive Send _RegisterAllMainDDObjects of hRoot
33433>>>>>>>>>>>        Get _paDdContainers to aContainers
33434>>>>>>>>>>>        Function_Return aContainers
33435>>>>>>>>>>>    End_Function
33436>>>>>>>>>>>    
33436>>>>>>>>>>>        Function _DDStateIndicator Integer hDD Returns String
33439>>>>>>>>>>>            Boolean bState
33439>>>>>>>>>>>            String sValue
33439>>>>>>>>>>>            Get HasRecord of hDD to bState
33440>>>>>>>>>>>            If (bState) Move (sValue+"R") to sValue
33443>>>>>>>>>>>            Get Changed_State of hDD to bState
33444>>>>>>>>>>>            If (bState) Move (sValue+"C") to sValue
33447>>>>>>>>>>>            Get Should_Save of hDD to bState
33448>>>>>>>>>>>            If (bState) Move (sValue+"S") to sValue
33451>>>>>>>>>>>            If (sValue<>"") Begin
33453>>>>>>>>>>>                Move ("("+sValue+")") to sValue
33454>>>>>>>>>>>            End
33454>>>>>>>>>>>>
33454>>>>>>>>>>>            Else Begin
33455>>>>>>>>>>>                Move "(at ease)" to sValue
33456>>>>>>>>>>>            End
33456>>>>>>>>>>>>
33456>>>>>>>>>>>            Function_Return sValue
33457>>>>>>>>>>>        End_Function
33458>>>>>>>>>>>    
33458>>>>>>>>>>>    Function yUML_DDODiagram Integer hCont Boolean bIncludeCurrentState Returns tYumlClassDiagram
33461>>>>>>>>>>>        Integer iMax iIndex hMainDD 
33461>>>>>>>>>>>        String sFromLabel sToLabel sContainerName
33461>>>>>>>>>>>        String sProject sStateIndicator
33461>>>>>>>>>>>        tYumlClassDiagram strDiagram
33461>>>>>>>>>>>        tYumlClassDiagram strDiagram
33461>>>>>>>>>>>        tDDORelation[] aDdoRelations
33461>>>>>>>>>>>        tDDORelation[] aDdoRelations
33462>>>>>>>>>>>    
33462>>>>>>>>>>>        Get Module_Name to sProject
33463>>>>>>>>>>>        Move (Lowercase(Name(hCont))) to sContainerName
33464>>>>>>>>>>>    
33464>>>>>>>>>>>        Get NewDiagram of oYumlFunctions to strDiagram
33465>>>>>>>>>>>        Move ("DDO relations project '"+sProject+"' object path '"+sContainerName+"'") to strDiagram.sNote
33466>>>>>>>>>>>        If (bIncludeCurrentState) Begin
33468>>>>>>>>>>>            Move (strDiagram.sNote+" (R=HasRecord C=Changed_State S=Should_Save)") to strDiagram.sNote
33469>>>>>>>>>>>        End
33469>>>>>>>>>>>>
33469>>>>>>>>>>>        Get Main_DD of hCont to hMainDD
33470>>>>>>>>>>>        Get DDO_Relations of oDataDictionaryFunctions hMainDD to aDdoRelations
33471>>>>>>>>>>>    
33471>>>>>>>>>>>        Move (SizeOfArray(aDdoRelations)-1) to iMax
33472>>>>>>>>>>>        For iIndex from 0 to iMax
33478>>>>>>>>>>>>
33478>>>>>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of (Main_File(aDdoRelations[iIndex].hFromDDO)) to sFromLabel
33481>>>>>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of (Main_File(aDdoRelations[iIndex].hToDDO)) to sToLabel
33484>>>>>>>>>>>            If (bIncludeCurrentState) Begin
33486>>>>>>>>>>>                Get _DDStateIndicator aDdoRelations[iIndex].hFromDDO to sStateIndicator 
33487>>>>>>>>>>>                Move (sFromLabel+" "+sStateIndicator) to sFromLabel
33488>>>>>>>>>>>                Get _DDStateIndicator aDdoRelations[iIndex].hToDDO to sStateIndicator 
33489>>>>>>>>>>>                Move (sToLabel+" "+sStateIndicator) to sToLabel
33490>>>>>>>>>>>            End
33490>>>>>>>>>>>>
33490>>>>>>>>>>>            Send AddRelation of oYumlFunctions (&strDiagram) sFromLabel sToLabel aDdoRelations[iIndex].bConstrained
33491>>>>>>>>>>>        Loop
33492>>>>>>>>>>>>
33492>>>>>>>>>>>    
33492>>>>>>>>>>>        Function_Return strDiagram
33493>>>>>>>>>>>    End_Function
33494>>>>>>>>>>>
33494>>>>>>>>>>>    Procedure _yUML_GenerateOneDiagram Integer hCont Integer iChannel
33497>>>>>>>>>>>        Integer iMax iIndex hMainDD
33497>>>>>>>>>>>        String sUrl sFromLabel sToLabel sContainerName
33497>>>>>>>>>>>        tYumlClassDiagram strDiagram
33497>>>>>>>>>>>        tYumlClassDiagram strDiagram
33497>>>>>>>>>>>        tDDORelation[] aDdoRelations
33497>>>>>>>>>>>        tDDORelation[] aDdoRelations
33498>>>>>>>>>>>    
33498>>>>>>>>>>>        Move (Lowercase(Name(hCont))) to sContainerName
33499>>>>>>>>>>>        Writeln channel iChannel sContainerName
33502>>>>>>>>>>>        
33502>>>>>>>>>>>        Get yUML_DDODiagram hCont False to strDiagram
33503>>>>>>>>>>>        
33503>>>>>>>>>>>        Get DiagramUrl of oYumlFunctions strDiagram to sUrl
33504>>>>>>>>>>>        Writeln channel iChannel sUrl
33507>>>>>>>>>>>    End_Procedure
33508>>>>>>>>>>>    
33508>>>>>>>>>>>    Procedure yUML_GenerateAllDdoDiagrams
33511>>>>>>>>>>>        Integer iChannel iIndex iMax
33511>>>>>>>>>>>        String sFolder sFileName
33511>>>>>>>>>>>        Integer[] aDdoContainers
33512>>>>>>>>>>>    
33512>>>>>>>>>>>        // Get all objects that has a main_dd property set to a non-zero value.
33512>>>>>>>>>>>        Get AllDataDictionaryContainers of oDataDictionaryFunctions Desktop to aDdoContainers
33513>>>>>>>>>>>    
33513>>>>>>>>>>>        Get VdfFolderPath of oFileFunctions VDF_PROGRAM to sFolder
33514>>>>>>>>>>>        Get Module_Name to sFileName
33515>>>>>>>>>>>        Get AppendPath of oFileFunctions sFolder sFileName to sFileName
33516>>>>>>>>>>>        Move (sFileName+".yuml") to sFileName
33517>>>>>>>>>>>        Get DirectOutput of oFileFunctions sFileName to iChannel
33518>>>>>>>>>>>        If (iChannel>=0) Begin
33520>>>>>>>>>>>            Move (SizeOfArray(aDdoContainers)-1) to iMax
33521>>>>>>>>>>>            For iIndex from 0 to iMax
33527>>>>>>>>>>>>
33527>>>>>>>>>>>                Send _yUML_GenerateOneDiagram aDdoContainers[iIndex] iChannel 
33528>>>>>>>>>>>            Loop
33529>>>>>>>>>>>>
33529>>>>>>>>>>>            Send CloseOutput of oFileFunctions iChannel
33530>>>>>>>>>>>        End
33530>>>>>>>>>>>>
33530>>>>>>>>>>>    End_Procedure
33531>>>>>>>>>>>    
33531>>>>>>>>>>>    Procedure VDFXRay_ExtractAllProjectInfoAndSave
33534>>>>>>>>>>>    End_Procedure
33535>>>>>>>>>>>    
33535>>>>>>>>>>>    Function ReadFirstRow Integer hDD Integer iTable Integer iIndex Returns Boolean
33538>>>>>>>>>>>        Send Request_Read of hDD FIRST_RECORD iTable iIndex
33539>>>>>>>>>>>        Function_Return (Found)
33540>>>>>>>>>>>    End_Function
33541>>>>>>>>>>>
33541>>>>>>>>>>>    Function ReadNextRow Integer hDD Integer iTable Integer iIndex Returns Boolean
33544>>>>>>>>>>>        Send Request_Read of hDD GT iTable iIndex
33545>>>>>>>>>>>        Function_Return (Found)
33546>>>>>>>>>>>    End_Function
33547>>>>>>>>>>>        
33547>>>>>>>>>>>End_Object // oDataDictionaryFunctions
33548>>>>>>>>>>>
33548>>>>>>>>>>>Global_Variable Integer _goDdoDebugView // _giDDCallLevel 
33548>>>>>>>>>>>//Move 0 to _giDDCallLevel
33548>>>>>>>>>>>Move 0 to _goDdoDebugView
33549>>>>>>>>>>>
33549>>>>>>>>>>>
33549>>>>>>>>>>>// No need at all for this from 17.1 and on
33549>>>>>>>>>>>
33549>>>>>>>>>>>Class cfreeDataDictionary is a DataDictionary
33550>>>>>>>>>>>    Procedure Construct_Object
33552>>>>>>>>>>>        Forward Send Construct_Object
33554>>>>>>>>>>>        Property Boolean pbConditionalParent False
33555>>>>>>>>>>>        Property Boolean _pbPartofOperation True
33556>>>>>>>>>>>    End_Procedure
33557>>>>>>>>>>>    
33557>>>>>>>>>>>    Procedure Set DDO_Server Handle ObjId
33559>>>>>>>>>>>        If (ObjId<>0) Begin
33561>>>>>>>>>>>            Forward Set DDO_Server to ObjId
33563>>>>>>>>>>>        End
33563>>>>>>>>>>>>
33563>>>>>>>>>>>        Else Begin
33564>>>>>>>>>>>            Error 201 ("Unknown object in "+Name(Self)+" DDO_Server setting")
33565>>>>>>>>>>>>
33565>>>>>>>>>>>        End
33565>>>>>>>>>>>>
33565>>>>>>>>>>>    End_Procedure
33566>>>>>>>>>>>    
33566>>>>>>>>>>>//    Procedure LogTransaction String sMethod // sMethod = Save, Edit or Delete
33566>>>>>>>>>>>//    End_Procedure
33566>>>>>>>>>>>//    
33566>>>>>>>>>>>//    Procedure LogTableAccess String sMethod // sMethod = Save, Edit or Delete
33566>>>>>>>>>>>//    End_Procedure
33566>>>>>>>>>>>//    
33566>>>>>>>>>>>//    Procedure Request_Clear
33566>>>>>>>>>>>//        Forward Send Request_Clear
33566>>>>>>>>>>>//    End_Procedure
33566>>>>>>>>>>>//    
33566>>>>>>>>>>>//    Procedure Request_Delete
33566>>>>>>>>>>>//        Send LogTransaction "Delete"
33566>>>>>>>>>>>//        Forward Send Request_Delete
33566>>>>>>>>>>>//    End_Procedure
33566>>>>>>>>>>>//
33566>>>>>>>>>>>//    Procedure Request_Save
33566>>>>>>>>>>>//        Boolean bEdit
33566>>>>>>>>>>>//        Get HasRecord to bEdit
33566>>>>>>>>>>>//        Send LogTransaction (If(bEdit,"Edit","Create"))
33566>>>>>>>>>>>//        Forward Send Request_Save
33566>>>>>>>>>>>//    End_Procedure
33566>>>>>>>>>>>    
33566>>>>>>>>>>>    Function Is_cfreeDataDictionary Returns Boolean
33568>>>>>>>>>>>        Function_Return True
33569>>>>>>>>>>>    End_Function
33570>>>>>>>>>>>    
33570>>>>>>>>>>>    
33570>>>>>>>>>>>    
33570>>>>>>>>>>>    //> If pbConditionalParent is true we may have to redirect message clear
33570>>>>>>>>>>>    //> to another DDO. The reason is that if we allow for cleared parent records
33570>>>>>>>>>>>    //> pressing F5 while in a parent table should clear the parent table rather
33570>>>>>>>>>>>    //> than clearing the whole view.
33570>>>>>>>>>>>    
33570>>>>>>>>>>>    //> Unfortunately message clear is sent during object initialization in which
33570>>>>>>>>>>>    //> case there is no meaningful Focus to check for.
33570>>>>>>>>>>>    
33570>>>>>>>>>>>        Procedure _SetChangedStateChildren Integer hParent
33572>>>>>>>>>>>            Integer iMax iIndex
33572>>>>>>>>>>>            Integer[] aChildDDOs
33573>>>>>>>>>>>            Get ChildDdoArray of oDataDictionaryFunctions hParent to aChildDDOs
33574>>>>>>>>>>>            Move (SizeOfArray(aChildDDOs)-1) to iMax
33575>>>>>>>>>>>            For iIndex from 0 to iMax
33581>>>>>>>>>>>>
33581>>>>>>>>>>>                Set Changed_State of aChildDDOs[iIndex] to True
33582>>>>>>>>>>>            Loop
33583>>>>>>>>>>>>
33583>>>>>>>>>>>        End_Procedure
33584>>>>>>>>>>>
33584>>>>>>>>>>>    Procedure Clear // Augmentation
33586>>>>>>>>>>>        Integer hFoc iTable hDD
33586>>>>>>>>>>>        Boolean bConditionalParent
33586>>>>>>>>>>>        Move 0 to hDD
33587>>>>>>>>>>>        
33587>>>>>>>>>>>        Get Focus of desktop to hFoc
33588>>>>>>>>>>>        
33588>>>>>>>>>>>        If (hFoc>Desktop) Begin // If any object at hall has the focus
33590>>>>>>>>>>>            Get _PaddedDataFile of oDataDictionaryFunctions hFoc to iTable // Very carefully: Do you have a datafile?
33591>>>>>>>>>>>            
33591>>>>>>>>>>>            If (iTable<>0 and iTable<>Main_File(Self)) Begin // It is not the same as our own main_file
33593>>>>>>>>>>>                Get Data_Set iTable to hDD
33594>>>>>>>>>>>                
33594>>>>>>>>>>>                If (hDD<>0) Begin // DDO object for that table does exist!
33596>>>>>>>>>>>                                                                    
33596>>>>>>>>>>>                    Get _PaddedValue of oDataDictionaryFunctions hDD GET_pbConditionalParent to bConditionalParent
33597>>>>>>>>>>>                    
33597>>>>>>>>>>>                    If (bConditionalParent) Begin
33599>>>>>>>>>>>                    
33599>>>>>>>>>>>                        // A test is needed here to determine whether we are at the tail of a save operation
33599>>>>>>>>>>>                    
33599>>>>>>>>>>>                        If (HasRecord(hDD)) Begin
33601>>>>>>>>>>>                            // At this point we need to se the changed_state of the parent of hDD
33601>>>>>>>>>>>                            // the same way it is set if a new parent record is found.
33601>>>>>>>>>>>//                            Set Changed_State of hDD to True
33601>>>>>>>>>>>                        End
33601>>>>>>>>>>>>
33601>>>>>>>>>>>                        Else Begin
33602>>>>>>>>>>>                            // If it does not currently have a record we cancel
33602>>>>>>>>>>>                            // the clever clear behavior
33602>>>>>>>>>>>                            Move 0 to hDD
33603>>>>>>>>>>>                        End
33603>>>>>>>>>>>>
33603>>>>>>>>>>>                    End
33603>>>>>>>>>>>>
33603>>>>>>>>>>>                    Else Begin
33604>>>>>>>>>>>                        Move 0 to hDD
33605>>>>>>>>>>>                    End
33605>>>>>>>>>>>>
33605>>>>>>>>>>>                End
33605>>>>>>>>>>>>
33605>>>>>>>>>>>            End
33605>>>>>>>>>>>>
33605>>>>>>>>>>>        End
33605>>>>>>>>>>>>
33605>>>>>>>>>>>
33605>>>>>>>>>>>        If (hDD>0) Begin
33607>>>>>>>>>>>            Send Clear of hDD
33608>>>>>>>>>>>            // When a parent is changed (even if it's cleared) we must set changed_state of all children:
33608>>>>>>>>>>>            Send _SetChangedStateChildren hDD
33609>>>>>>>>>>>        End
33609>>>>>>>>>>>>
33609>>>>>>>>>>>        Else Begin
33610>>>>>>>>>>>            Forward Send Clear
33612>>>>>>>>>>>        End
33612>>>>>>>>>>>>
33612>>>>>>>>>>>    End_Procedure
33613>>>>>>>>>>>    
33613>>>>>>>>>>>    Function _IsForeign Returns Boolean
33615>>>>>>>>>>>        Boolean bForeign
33615>>>>>>>>>>>        Move (Self<>OPERATION_ORIGIN) to bForeign
33616>>>>>>>>>>>        Function_Return bForeign
33617>>>>>>>>>>>    End_Function
33618>>>>>>>>>>>    
33618>>>>>>>>>>>    Function _IgnoreSaveMainFile Returns Boolean
33620>>>>>>>>>>>        Function_Return (pbConditionalParent(Self) and _IsForeign(Self) and not(HasRecord(Self)))
33621>>>>>>>>>>>    End_Function
33622>>>>>>>>>>>    
33622>>>>>>>>>>>    // Procedure Save_Main_File should be cancelled if we are representing a conditional parent
33622>>>>>>>>>>>    // that does not have a record.
33622>>>>>>>>>>>    Procedure Save_Main_File
33624>>>>>>>>>>>//        Integer iTable
33624>>>>>>>>>>>//        Boolean bActiveRecord
33624>>>>>>>>>>>        If (_IgnoreSaveMainFile(Self)) Begin
33626>>>>>>>>>>>        End
33626>>>>>>>>>>>>
33626>>>>>>>>>>>        Else Begin
33627>>>>>>>>>>>//            Get main_file to iTable
33627>>>>>>>>>>>//            Move (not(IsNullRowID(GetRowID(iTable)))) to bActiveRecord
33627>>>>>>>>>>>//            Send LogTableAccess (If(bActiveRecord,"Edit","Save"))
33627>>>>>>>>>>>            Forward Send Save_Main_File
33629>>>>>>>>>>>        End
33629>>>>>>>>>>>>
33629>>>>>>>>>>>    End_Procedure
33630>>>>>>>>>>>    
33630>>>>>>>>>>>    Procedure Delete_Main_File
33632>>>>>>>>>>>//        Send LogTableAccess "Delete"
33632>>>>>>>>>>>        Forward Send Delete_Main_File
33634>>>>>>>>>>>    End_Procedure
33635>>>>>>>>>>>
33635>>>>>>>>>>>    // Function Validate_Field should not validate if we are representing a conditional parent
33635>>>>>>>>>>>    // that does not have a record.
33635>>>>>>>>>>>    Function Validate_Field Integer iField Returns Integer
33637>>>>>>>>>>>        Integer iResult
33637>>>>>>>>>>>        If (pbConditionalParent(Self) and _IsForeign(Self) and not(HasRecord(Self))) Begin
33639>>>>>>>>>>>            Move 0 to iResult // no validation
33640>>>>>>>>>>>        End
33640>>>>>>>>>>>>
33640>>>>>>>>>>>        Else Begin
33641>>>>>>>>>>>            Forward Get Validate_Field iField to iResult
33643>>>>>>>>>>>        End
33643>>>>>>>>>>>>
33643>>>>>>>>>>>        Function_Return iResult
33644>>>>>>>>>>>    End_Function
33645>>>>>>>>>>>End_Class // cfreeDataDictionary
33646>>>>>>>>>>>
33646>>>>>>>>>Use VdfRuntime.pkg
Including file: VdfRuntime.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\VdfRuntime.pkg)
33646>>>>>>>>>>>Use VdfBase.pkg
33646>>>>>>>>>>>// VDFRuntime
33646>>>>>>>>>>>Use Winkern.pkg
33646>>>>>>>>>>>Use RegistryFunctions.pkg
Including file: RegistryFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\RegistryFunctions.pkg)
33646>>>>>>>>>>>>>//  Use RegistryFunctions.pkg //
33646>>>>>>>>>>>>>
33646>>>>>>>>>>>>>Use NamedValueFunctions.pkg
Including file: NamedValueFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\NamedValueFunctions.pkg)
33646>>>>>>>>>>>>>>>//  Use NamedValueFunctions.pkg // oNamedValueFunctions object
33646>>>>>>>>>>>>>>>
33646>>>>>>>>>>>>>>>Struct tNamedValue
33646>>>>>>>>>>>>>>>    String  sName
33646>>>>>>>>>>>>>>>    String  sValue
33646>>>>>>>>>>>>>>>End_Struct
33646>>>>>>>>>>>>>>>
33646>>>>>>>>>>>>>>>Struct tNamedValueList
33646>>>>>>>>>>>>>>>    Boolean bCaseSensitive
33646>>>>>>>>>>>>>>>    tNamedValue[] aNamedValues
33646>>>>>>>>>>>>>>>    tNamedValue[] aNamedValues
33646>>>>>>>>>>>>>>>End_Struct
33646>>>>>>>>>>>>>>>
33646>>>>>>>>>>>>>>>Global_Variable Integer oNamedValueFunctions
33646>>>>>>>>>>>>>>>
33646>>>>>>>>>>>>>>>Object _oNamedValueFunctions is a cObject
33648>>>>>>>>>>>>>>>    
33648>>>>>>>>>>>>>>>    Move Self to oNamedValueFunctions
33649>>>>>>>>>>>>>>>    
33649>>>>>>>>>>>>>>>    Function NewNamedValueList Boolean bCaseSensitive Returns tNamedValueList
33652>>>>>>>>>>>>>>>        tNamedValueList strEmptyList
33652>>>>>>>>>>>>>>>        tNamedValueList strEmptyList
33652>>>>>>>>>>>>>>>        Move bCaseSensitive to strEmptyList.bCaseSensitive
33653>>>>>>>>>>>>>>>        Function_Return strEmptyList
33654>>>>>>>>>>>>>>>    End_Function
33655>>>>>>>>>>>>>>>    
33655>>>>>>>>>>>>>>>        Function _FindName Boolean bCaseSense tNamedValue[] aValues String sName Returns Integer
33658>>>>>>>>>>>>>>>            Integer iIndex iMax
33658>>>>>>>>>>>>>>>            Move (SizeOfArray(aValues)-1) to iMax
33659>>>>>>>>>>>>>>>            For iIndex from 0 to iMax
33665>>>>>>>>>>>>>>>>
33665>>>>>>>>>>>>>>>                If (sName=aValues[iIndex].sName) Begin
33667>>>>>>>>>>>>>>>                    Function_Return iIndex
33668>>>>>>>>>>>>>>>                End
33668>>>>>>>>>>>>>>>>
33668>>>>>>>>>>>>>>>            Loop
33669>>>>>>>>>>>>>>>>
33669>>>>>>>>>>>>>>>            Function_Return -1
33670>>>>>>>>>>>>>>>        End_Function
33671>>>>>>>>>>>>>>>        
33671>>>>>>>>>>>>>>>    Function NameHasValue tNamedValueList strList String sName Returns Boolean
33674>>>>>>>>>>>>>>>        Function_Return (_FindName(Self,strList.bCaseSensitive,strList.aNamedValues,sName)>=0)
33675>>>>>>>>>>>>>>>    End_Function
33676>>>>>>>>>>>>>>>        
33676>>>>>>>>>>>>>>>    Procedure Set NamedValue tNamedValueList ByRef strList String sName String sValue
33679>>>>>>>>>>>>>>>        Integer iIndex
33679>>>>>>>>>>>>>>>        Get _FindName strList.bCaseSensitive strList.aNamedValues sName to iIndex
33680>>>>>>>>>>>>>>>        If (iIndex=-1) Begin
33682>>>>>>>>>>>>>>>            Move (SizeOfArray(strList.aNamedValues)) to iIndex
33683>>>>>>>>>>>>>>>            Move sName to strList.aNamedValues[iIndex].sName
33684>>>>>>>>>>>>>>>        End
33684>>>>>>>>>>>>>>>>
33684>>>>>>>>>>>>>>>        Move sValue to strList.aNamedValues[iIndex].sValue
33685>>>>>>>>>>>>>>>    End_Procedure
33686>>>>>>>>>>>>>>>    
33686>>>>>>>>>>>>>>>    Function NamedValue tNamedValueList strList String sName Returns String
33689>>>>>>>>>>>>>>>        Integer iIndex
33689>>>>>>>>>>>>>>>        Get _FindName True strList.aNamedValues sName to iIndex
33690>>>>>>>>>>>>>>>        If (iIndex<>-1) Begin
33692>>>>>>>>>>>>>>>            Function_Return strList.aNamedValues[iIndex].sValue
33693>>>>>>>>>>>>>>>        End
33693>>>>>>>>>>>>>>>>
33693>>>>>>>>>>>>>>>        Function_Return ""
33694>>>>>>>>>>>>>>>    End_Function
33695>>>>>>>>>>>>>>>    
33695>>>>>>>>>>>>>>>End_Object
33696>>>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
33696>>>>>>>>>>>>>Use cRegistry.pkg
33696>>>>>>>>>>>>>
33696>>>>>>>>>>>>>Struct tRegKeyData
33696>>>>>>>>>>>>>    Integer hRoot
33696>>>>>>>>>>>>>    String sKey
33696>>>>>>>>>>>>>    String[] aSubKeys
33696>>>>>>>>>>>>>    tNamedValue[] aValues
33696>>>>>>>>>>>>>    tNamedValue[] aValues
33696>>>>>>>>>>>>>End_Struct
33696>>>>>>>>>>>>>
33696>>>>>>>>>>>>>Global_Variable Integer oRegistryFunctions
33696>>>>>>>>>>>>>
33696>>>>>>>>>>>>>Object _oRegistryFunctions is a cObject
33698>>>>>>>>>>>>>    
33698>>>>>>>>>>>>>    Move Self to oRegistryFunctions
33699>>>>>>>>>>>>>        
33699>>>>>>>>>>>>>    Object _oRegistry is a cRegistry // Private
33701>>>>>>>>>>>>>        Set pbLazyWrite to False
33702>>>>>>>>>>>>>        Set pfAccessRights to KEY_READ
33703>>>>>>>>>>>>>//        Set pfAccessRights to KEY_ALL_ACCESS
33703>>>>>>>>>>>>>        Function _ReadKeyData Handle hRoot String sKey tRegKeyData ByRef stKeyData Boolean bReadBinaries Returns Boolean
33706>>>>>>>>>>>>>            Boolean bOpen
33706>>>>>>>>>>>>>            Integer iKey iMaxKey iValueType
33706>>>>>>>>>>>>>            Handle hoArray
33706>>>>>>>>>>>>>            String sName
33706>>>>>>>>>>>>>            String[] aValues
33707>>>>>>>>>>>>>            tRegKeyData stEmptyKeyData
33707>>>>>>>>>>>>>            tRegKeyData stEmptyKeyData
33707>>>>>>>>>>>>>            
33707>>>>>>>>>>>>>            Move stEmptyKeyData to stKeyData
33708>>>>>>>>>>>>>            Move hRoot to stKeyData.hRoot
33709>>>>>>>>>>>>>            Move sKey to stKeyData.sKey
33710>>>>>>>>>>>>>
33710>>>>>>>>>>>>>            Set pfAccessRights to KEY_READ
33711>>>>>>>>>>>>>            
33711>>>>>>>>>>>>>            Set phRootKey to hRoot
33712>>>>>>>>>>>>>            Get OpenKey sKey to bOpen
33713>>>>>>>>>>>>>            If (bOpen) Begin
33715>>>>>>>>>>>>>            
33715>>>>>>>>>>>>>                Get Create U_Array to hoArray // Create an array object
33716>>>>>>>>>>>>>                Get GetSubkeys hoArray to iMaxKey
33717>>>>>>>>>>>>>                Decrement iMaxKey
33718>>>>>>>>>>>>>              
33718>>>>>>>>>>>>>                For iKey from 0 to iMaxKey
33724>>>>>>>>>>>>>>
33724>>>>>>>>>>>>>                    Get Value of hoArray iKey to stKeyData.aSubKeys[iKey]
33725>>>>>>>>>>>>>                Loop
33726>>>>>>>>>>>>>>
33726>>>>>>>>>>>>>                
33726>>>>>>>>>>>>>                Send Delete_Data of hoArray
33727>>>>>>>>>>>>>                Get GetValues hoArray to iMaxKey
33728>>>>>>>>>>>>>                Decrement iMaxKey
33729>>>>>>>>>>>>>                
33729>>>>>>>>>>>>>                For iKey from 0 to iMaxKey
33735>>>>>>>>>>>>>>
33735>>>>>>>>>>>>>                    Get Value of hoArray iKey to sName
33736>>>>>>>>>>>>>                    Move sName to stKeyData.aValues[iKey].sName 
33737>>>>>>>>>>>>>                    
33737>>>>>>>>>>>>>                    Get ValueType sName to iValueType
33738>>>>>>>>>>>>>                    
33738>>>>>>>>>>>>>                    If (iValueType=rdString) Begin
33740>>>>>>>>>>>>>                        Get ReadString sName to stKeyData.aValues[iKey].sValue
33741>>>>>>>>>>>>>                    End
33741>>>>>>>>>>>>>>
33741>>>>>>>>>>>>>                    Else If (iValueType=rdDword) Begin
33744>>>>>>>>>>>>>                        Get ReadDword sName to stKeyData.aValues[iKey].sValue
33745>>>>>>>>>>>>>                    End
33745>>>>>>>>>>>>>>
33745>>>>>>>>>>>>>    //                        If (iValueType=rdBinary) Begin // Not that simple
33745>>>>>>>>>>>>>    //                            //Get ReadBinary sName to stKeyData.aValues[iKey].sValue
33745>>>>>>>>>>>>>    //                        End
33745>>>>>>>>>>>>>    //                        If (iValueType=rdUnknown) Begin
33745>>>>>>>>>>>>>    //                        End
33745>>>>>>>>>>>>>                Loop
33746>>>>>>>>>>>>>>
33746>>>>>>>>>>>>>                
33746>>>>>>>>>>>>>                Send CloseKey // must close all open Keys
33747>>>>>>>>>>>>>                
33747>>>>>>>>>>>>>                Send Destroy of hoArray // Remove the array object from memory.
33748>>>>>>>>>>>>>                Function_Return True
33749>>>>>>>>>>>>>            End
33749>>>>>>>>>>>>>>
33749>>>>>>>>>>>>>            Function_Return False
33750>>>>>>>>>>>>>        End_Function
33751>>>>>>>>>>>>>
33751>>>>>>>>>>>>>        // Types: rdString rdDword rdBinary 
33751>>>>>>>>>>>>>        Procedure _WriteRegValue Handle hRoot String sKey String sName String sValue Integer iValueType
33754>>>>>>>>>>>>>            Boolean bExists bOpened 
33754>>>>>>>>>>>>>            Integer iType
33754>>>>>>>>>>>>>            Set phRootKey to hRoot
33755>>>>>>>>>>>>>            
33755>>>>>>>>>>>>>            Set pfAccessRights to KEY_ALL_ACCESS
33756>>>>>>>>>>>>>            Get KeyExistsCreateIfNot hRoot sKey to bExists
33757>>>>>>>>>>>>>            If (bExists) Begin
33759>>>>>>>>>>>>>                Get OpenKey sKey to bOpened
33760>>>>>>>>>>>>>                If (bOpened) Begin
33762>>>>>>>>>>>>>                    If (ValueExists(Self,sName)) Begin
33764>>>>>>>>>>>>>                        Get ValueType sName to iType
33765>>>>>>>>>>>>>                    End
33765>>>>>>>>>>>>>>
33765>>>>>>>>>>>>>                    Else Begin
33766>>>>>>>>>>>>>                        Move iValueType to iType
33767>>>>>>>>>>>>>                    End
33767>>>>>>>>>>>>>>
33767>>>>>>>>>>>>>                    
33767>>>>>>>>>>>>>                    If (iType=rdString) Begin
33769>>>>>>>>>>>>>                        Send WriteString sName sValue
33770>>>>>>>>>>>>>                    End
33770>>>>>>>>>>>>>>
33770>>>>>>>>>>>>>                    Else If (iType=rdDword) Begin
33773>>>>>>>>>>>>>                        Send WriteDword sName sValue
33774>>>>>>>>>>>>>                    End
33774>>>>>>>>>>>>>>
33774>>>>>>>>>>>>>                    Else If (iType=rdBinary) Begin
33777>>>>>>>>>>>>>                        Send WriteBinary sName (AddressOf(sValue)) (Length(sValue))
33778>>>>>>>>>>>>>                    End
33778>>>>>>>>>>>>>>
33778>>>>>>>>>>>>>                    Else Begin
33779>>>>>>>>>>>>>                        Error 803 "Illegal value type"
33780>>>>>>>>>>>>>>
33780>>>>>>>>>>>>>                    End
33780>>>>>>>>>>>>>>
33780>>>>>>>>>>>>>                    
33780>>>>>>>>>>>>>                    Send CloseKey
33781>>>>>>>>>>>>>                End
33781>>>>>>>>>>>>>>
33781>>>>>>>>>>>>>                Else Begin
33782>>>>>>>>>>>>>                    Error 802 "Insufficient rights to change value of registry key"
33783>>>>>>>>>>>>>>
33783>>>>>>>>>>>>>                End
33783>>>>>>>>>>>>>>
33783>>>>>>>>>>>>>                Set pfAccessRights to KEY_READ
33784>>>>>>>>>>>>>            End
33784>>>>>>>>>>>>>>
33784>>>>>>>>>>>>>            Else Begin
33785>>>>>>>>>>>>>                Error 802 "Registry key does not exist"
33786>>>>>>>>>>>>>>
33786>>>>>>>>>>>>>            End
33786>>>>>>>>>>>>>>
33786>>>>>>>>>>>>>        End_Procedure
33787>>>>>>>>>>>>>        
33787>>>>>>>>>>>>>        Function _DeleteRegValue Handle hRoot String sKey String sName Returns Boolean
33790>>>>>>>>>>>>>            Boolean bExists bOpened bSucces 
33790>>>>>>>>>>>>>            Integer iType
33790>>>>>>>>>>>>>            Set phRootKey to hRoot
33791>>>>>>>>>>>>>            
33791>>>>>>>>>>>>>            Set pfAccessRights to KEY_ALL_ACCESS
33792>>>>>>>>>>>>>            Get KeyExistsCreateIfNot hRoot sKey to bExists
33793>>>>>>>>>>>>>            If (bExists) Begin
33795>>>>>>>>>>>>>                Get OpenKey sKey to bOpened
33796>>>>>>>>>>>>>                If (bOpened) Begin
33798>>>>>>>>>>>>>                    If (ValueExists(Self,sName)) Begin                          
33800>>>>>>>>>>>>>                        Get DeleteValue sName to bSucces
33801>>>>>>>>>>>>>                    End
33801>>>>>>>>>>>>>>
33801>>>>>>>>>>>>>                    
33801>>>>>>>>>>>>>                    Send CloseKey
33802>>>>>>>>>>>>>                End
33802>>>>>>>>>>>>>>
33802>>>>>>>>>>>>>                Else Begin
33803>>>>>>>>>>>>>                    Error 802 "Insufficient rights to change value of registry key"
33804>>>>>>>>>>>>>>
33804>>>>>>>>>>>>>                End
33804>>>>>>>>>>>>>>
33804>>>>>>>>>>>>>                Set pfAccessRights to KEY_READ
33805>>>>>>>>>>>>>            End
33805>>>>>>>>>>>>>>
33805>>>>>>>>>>>>>//            Else Begin
33805>>>>>>>>>>>>>//                Error 802 "Registry key does not exist"
33805>>>>>>>>>>>>>//            End
33805>>>>>>>>>>>>>            Function_Return bSucces
33806>>>>>>>>>>>>>        End_Function
33807>>>>>>>>>>>>>        
33807>>>>>>>>>>>>>        Function _DeleteRegKey Handle hRoot String sKey String sSubKey Returns Boolean
33810>>>>>>>>>>>>>            Boolean bExists bOpened bSucces 
33810>>>>>>>>>>>>>            Integer iType
33810>>>>>>>>>>>>>            Set phRootKey to hRoot
33811>>>>>>>>>>>>>            
33811>>>>>>>>>>>>>            Set pfAccessRights to KEY_ALL_ACCESS
33812>>>>>>>>>>>>>            Get KeyExists sKey to bExists
33813>>>>>>>>>>>>>            If (bExists) Begin
33815>>>>>>>>>>>>>                Get OpenKey sKey to bOpened
33816>>>>>>>>>>>>>                If (bOpened) Begin
33818>>>>>>>>>>>>>                    If (KeyExists(Self,sSubKey)) Begin
33820>>>>>>>>>>>>>                        Get DeleteKey (sKey+"\"+sSubKey) to bSucces
33821>>>>>>>>>>>>>                    End
33821>>>>>>>>>>>>>>
33821>>>>>>>>>>>>>                    
33821>>>>>>>>>>>>>                    Send CloseKey
33822>>>>>>>>>>>>>                End
33822>>>>>>>>>>>>>>
33822>>>>>>>>>>>>>                Else Begin
33823>>>>>>>>>>>>>                    Error 802 "Insufficient rights to delete sub-registry-key"
33824>>>>>>>>>>>>>>
33824>>>>>>>>>>>>>                End
33824>>>>>>>>>>>>>>
33824>>>>>>>>>>>>>                Set pfAccessRights to KEY_READ
33825>>>>>>>>>>>>>            End
33825>>>>>>>>>>>>>>
33825>>>>>>>>>>>>>//            Else Begin
33825>>>>>>>>>>>>>//                Error 802 "Registry key does not exist"
33825>>>>>>>>>>>>>//            End
33825>>>>>>>>>>>>>            Function_Return bSucces
33826>>>>>>>>>>>>>        End_Function
33827>>>>>>>>>>>>>            
33827>>>>>>>>>>>>>    End_Object // _oRegistry
33828>>>>>>>>>>>>>
33828>>>>>>>>>>>>>    Enum_List // Standard Registry Keys
33828>>>>>>>>>>>>>        Define SRK_VDF_ROOT
33828>>>>>>>>>>>>>        Define SRK_VDF_ROOT_CURRENT_VERSION
33828>>>>>>>>>>>>>    End_Enum_List
33828>>>>>>>>>>>>>
33828>>>>>>>>>>>>>    Function _CurrentVdfVer Returns String
33831>>>>>>>>>>>>>        String sMajor sMinor
33831>>>>>>>>>>>>>        Move (String(FMAC_VERSION)) to sMajor
33832>>>>>>>>>>>>>        Move (String(FMAC_REVISION)) to sMinor
33833>>>>>>>>>>>>>        Function_Return (sMajor+"."+sMinor)
33834>>>>>>>>>>>>>    End_Function
33835>>>>>>>>>>>>>    
33835>>>>>>>>>>>>>    Procedure GetStandardKey Integer iKey Handle ByRef hRoot String ByRef sKey
33838>>>>>>>>>>>>>        String sVdfVer
33838>>>>>>>>>>>>>        If (iKey=SRK_VDF_ROOT) Begin
33840>>>>>>>>>>>>>            Move HKEY_LOCAL_MACHINE to hRoot
33841>>>>>>>>>>>>>            Move "SOFTWARE\Data Access Worldwide\Visual DataFlex" to sKey
33842>>>>>>>>>>>>>        End
33842>>>>>>>>>>>>>>
33842>>>>>>>>>>>>>        If (iKey=SRK_VDF_ROOT_CURRENT_VERSION) Begin
33844>>>>>>>>>>>>>            Move HKEY_LOCAL_MACHINE to hRoot
33845>>>>>>>>>>>>>            Get _CurrentVdfVer to sVdfVer
33846>>>>>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\Visual DataFlex\"+sVdfVer) to sKey
33847>>>>>>>>>>>>>        End
33847>>>>>>>>>>>>>>
33847>>>>>>>>>>>>>    End_Procedure
33848>>>>>>>>>>>>>    
33848>>>>>>>>>>>>>    Function ReadKeyData Handle hRoot String sKey tRegKeyData ByRef stKeyData Boolean bReadBinaries Returns Boolean
33851>>>>>>>>>>>>>        Function_Return (_ReadKeyData(_oRegistry,hRoot,sKey,&stKeyData,bReadBinaries))
33852>>>>>>>>>>>>>    End_Function
33853>>>>>>>>>>>>>    
33853>>>>>>>>>>>>>    Function NamedRegValue tRegKeyData stKeyData String sName Returns String
33856>>>>>>>>>>>>>        tNamedValueList strList
33856>>>>>>>>>>>>>        tNamedValueList strList
33856>>>>>>>>>>>>>        String sValue
33856>>>>>>>>>>>>>        Get NewNamedValueList of oNamedValueFunctions True to strList
33857>>>>>>>>>>>>>        Move stKeyData.aValues to strList.aNamedValues
33858>>>>>>>>>>>>>        Get NamedValue of oNamedValueFunctions strList sName to sValue
33859>>>>>>>>>>>>>        Function_Return sValue
33860>>>>>>>>>>>>>    End_Function
33861>>>>>>>>>>>>>    
33861>>>>>>>>>>>>>    Function KeyExists Handle hRoot String sKey Returns Boolean
33864>>>>>>>>>>>>>        Set phRootKey of _oRegistry to hRoot
33865>>>>>>>>>>>>>        Function_Return (KeyExists(_oRegistry,sKey))
33866>>>>>>>>>>>>>    End_Function
33867>>>>>>>>>>>>>    
33867>>>>>>>>>>>>>    Function CreateKey Handle hRoot String sKey Returns Boolean
33870>>>>>>>>>>>>>        Integer iError
33870>>>>>>>>>>>>>        Set phRootKey of _oRegistry to hRoot
33871>>>>>>>>>>>>>        Get CreateKey of _oRegistry sKey to iError
33872>>>>>>>>>>>>>        If (iError<>0) Begin
33874>>>>>>>>>>>>>            Send Info_Box ("CreateKey returned the following error from Windows: "+String(iError))
33875>>>>>>>>>>>>>        End
33875>>>>>>>>>>>>>>
33875>>>>>>>>>>>>>        Function_Return (iError=0)
33876>>>>>>>>>>>>>//        Function_Return (CreateKey(_oRegistry,sKey))
33876>>>>>>>>>>>>>    End_Function
33877>>>>>>>>>>>>>    
33877>>>>>>>>>>>>>    Function KeyExistsCreateIfNot Handle hRoot String sKey Returns Boolean
33880>>>>>>>>>>>>>        Boolean bCreated
33880>>>>>>>>>>>>>        String sParentKey 
33880>>>>>>>>>>>>>        If (sKey="") Begin
33882>>>>>>>>>>>>>            Function_Return False
33883>>>>>>>>>>>>>        End
33883>>>>>>>>>>>>>>
33883>>>>>>>>>>>>>        If (not(KeyExists(Self,hRoot,sKey))) Begin
33885>>>>>>>>>>>>>            Get PathToFolder of oFileFunctions sKey to sParentKey
33886>>>>>>>>>>>>>            Get KeyExistsCreateIfNot hRoot sParentKey to bCreated
33887>>>>>>>>>>>>>            If (bCreated) Begin
33889>>>>>>>>>>>>>                Get CreateKey hRoot sKey to bCreated
33890>>>>>>>>>>>>>                If (bCreated) Begin
33892>>>>>>>>>>>>>                    Send CloseKey of _oRegistry 
33893>>>>>>>>>>>>>                End
33893>>>>>>>>>>>>>>
33893>>>>>>>>>>>>>                Function_Return bCreated
33894>>>>>>>>>>>>>            End
33894>>>>>>>>>>>>>>
33894>>>>>>>>>>>>>        End
33894>>>>>>>>>>>>>>
33894>>>>>>>>>>>>>        Function_Return (KeyExists(Self,hRoot,sKey))
33895>>>>>>>>>>>>>    End_Function
33896>>>>>>>>>>>>>
33896>>>>>>>>>>>>>    // iValueType is rdString rdDword or rdBinary
33896>>>>>>>>>>>>>    Procedure WriteRegValue Handle hRoot String sKey String sName String sValue Integer iValueType
33899>>>>>>>>>>>>>        Send _WriteRegValue of _oRegistry hRoot sKey sName sValue iValueType
33900>>>>>>>>>>>>>    End_Procedure
33901>>>>>>>>>>>>>    
33901>>>>>>>>>>>>>    Function DeleteRegValue Handle hRoot String sKey String sName Returns Boolean
33904>>>>>>>>>>>>>        Boolean bSucces
33904>>>>>>>>>>>>>        Get _DeleteRegValue of _oRegistry hRoot sKey sName to bSucces
33905>>>>>>>>>>>>>        Function_Return bSucces
33906>>>>>>>>>>>>>    End_Function
33907>>>>>>>>>>>>>    
33907>>>>>>>>>>>>>    Function DeleteRegKey Handle hRoot String sKey String sSubKey Returns Boolean
33910>>>>>>>>>>>>>        Boolean bSucces
33910>>>>>>>>>>>>>        Get _DeleteRegKey of _oRegistry hRoot sKey sSubKey to bSucces
33911>>>>>>>>>>>>>        Function_Return bSucces
33912>>>>>>>>>>>>>    End_Function
33913>>>>>>>>>>>>>    
33913>>>>>>>>>>>>>End_Object
33914>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
33914>>>>>>>>>>>
33914>>>>>>>>>>>Struct tVdfRuntime
33914>>>>>>>>>>>    String  sRegistryKey
33914>>>>>>>>>>>    String  sVdfVersion
33914>>>>>>>>>>>    String  sRootFolder
33914>>>>>>>>>>>    String  sDfPath
33914>>>>>>>>>>>    String  sCollateLanguage
33914>>>>>>>>>>>    Boolean WAS_bEnableSlaveNode
33914>>>>>>>>>>>    Integer WAS_iGracefulTerminate
33914>>>>>>>>>>>    Integer WAS_iListen
33914>>>>>>>>>>>    Integer WAS_iMaxSessions
33914>>>>>>>>>>>    Integer WAS_iMessageTimeout
33914>>>>>>>>>>>    String  WAS_sProductClass
33914>>>>>>>>>>>    Integer WAS_iRefreshInterval
33914>>>>>>>>>>>    String  WAS_sRegCode
33914>>>>>>>>>>>    String  WAS_sRegName
33914>>>>>>>>>>>    String  WAS_sRegNumber
33914>>>>>>>>>>>    String  WAS_sUsers
33914>>>>>>>>>>>    Integer WAS_iTransactionTimeout
33914>>>>>>>>>>>End_Struct
33914>>>>>>>>>>>
33914>>>>>>>>>>>Struct tVdfWebApplication
33914>>>>>>>>>>>    String  sVdfVersion // Pointer to runtime array
33914>>>>>>>>>>>    String  sName
33914>>>>>>>>>>>    Integer iRuntimeIndex // Obsoleted by sVdfVersion
33914>>>>>>>>>>>    String  sRegistryKey
33914>>>>>>>>>>>    Boolean bDisable
33914>>>>>>>>>>>    Boolean bLogAccess
33914>>>>>>>>>>>    String  sLogFile
33914>>>>>>>>>>>    Integer iMaxLogEntries
33914>>>>>>>>>>>    Integer iMinPool
33914>>>>>>>>>>>    Integer iMaxPool
33914>>>>>>>>>>>    String  sOperationMode
33914>>>>>>>>>>>    String  sProgramParameters
33914>>>>>>>>>>>    String  sProgramPath
33914>>>>>>>>>>>    Integer iPurgePoolInterval
33914>>>>>>>>>>>    Boolean bUseConnectorPool
33914>>>>>>>>>>>    String  sDataPath
33914>>>>>>>>>>>End_Struct
33914>>>>>>>>>>>
33914>>>>>>>>>>>Global_Variable tVdfRuntime[] gaRuntimes // Filled in automatically at program start
33914>>>>>>>>>>>Global_Variable tVdfWebApplication[] gaWebApplications // This too
33914>>>>>>>>>>>
33914>>>>>>>>>>>Global_Variable Integer oVdfRuntimeFunctions
33914>>>>>>>>>>>
33914>>>>>>>>>>>
33914>>>>>>>>>>>Struct tCollateLanguage
33914>>>>>>>>>>>    String sName
33914>>>>>>>>>>>    String sCollateString
33914>>>>>>>>>>>End_Struct
33914>>>>>>>>>>>
33914>>>>>>>>>>>Global_Variable tCollateLanguage[] gaCollateStrings
33914>>>>>>>>>>>
33914>>>>>>>>>>>//External_Function VDFR_IsDebuggerPresent "IsDebuggerPresent" Kernel32.dll Returns Integer
33914>>>>>>>>>>>
33914>>>>>>>>>>>Object _oVdfRuntimeFunctions is a cObject
33916>>>>>>>>>>>    Move Self to oVdfRuntimeFunctions
33917>>>>>>>>>>>
33917>>>>>>>>>>>    Property String _psCurrentCollateString ""
33919>>>>>>>>>>>
33919>>>>>>>>>>>    Function CurrentCollateString Returns String
33922>>>>>>>>>>>        Integer iChar iItem iMax hArr
33922>>>>>>>>>>>        String sValue
33922>>>>>>>>>>>        If (_psCurrentCollateString(Self)="") Begin
33924>>>>>>>>>>>            Get Create U_Array to hArr
33925>>>>>>>>>>>            Send Delete_Data of hArr
33926>>>>>>>>>>>            For iChar from 32 to 255
33932>>>>>>>>>>>>
33932>>>>>>>>>>>                Set Value of hArr (iChar-32) to (Character(iChar))
33933>>>>>>>>>>>            Loop
33934>>>>>>>>>>>>
33934>>>>>>>>>>>            Send Sort_Items of hArr Ascending // This reveals the true sorting of the current runtime.
33935>>>>>>>>>>>            Get Item_Count of hArr to iMax
33936>>>>>>>>>>>            Decrement iMax
33937>>>>>>>>>>>            Move "" to sValue
33938>>>>>>>>>>>            For iItem from 0 to iMax
33944>>>>>>>>>>>>
33944>>>>>>>>>>>                Move (sValue+Value(hArr,iItem)) to sValue
33945>>>>>>>>>>>            Loop
33946>>>>>>>>>>>>
33946>>>>>>>>>>>            Set _psCurrentCollateString to sValue
33947>>>>>>>>>>>            Send Destroy of hArr
33948>>>>>>>>>>>        End
33948>>>>>>>>>>>>
33948>>>>>>>>>>>        Function_Return (_psCurrentCollateString(Self))
33949>>>>>>>>>>>    End_Function
33950>>>>>>>>>>>    
33950>>>>>>>>>>>    Function MinimumCollateCharacter Returns String
33953>>>>>>>>>>>        String sCurrentCollateString 
33953>>>>>>>>>>>//        Get _psCurrentCollateString to sCurrentCollateString
33953>>>>>>>>>>>        Get CurrentCollateString to sCurrentCollateString
33954>>>>>>>>>>>        Function_Return (Left(sCurrentCollateString,1))
33955>>>>>>>>>>>    End_Function
33956>>>>>>>>>>>    
33956>>>>>>>>>>>    Function MaximumCollateCharacter Returns String
33959>>>>>>>>>>>        String sCurrentCollateString 
33959>>>>>>>>>>>//        Get _psCurrentCollateString to sCurrentCollateString
33959>>>>>>>>>>>        Get CurrentCollateString to sCurrentCollateString
33960>>>>>>>>>>>        Function_Return (Right(sCurrentCollateString,1))
33961>>>>>>>>>>>    End_Function
33962>>>>>>>>>>>
33962>>>>>>>>>>>             Function _MakeString String sValue Returns String
33965>>>>>>>>>>>                Integer iMax iIndex iChar
33965>>>>>>>>>>>                String sRval
33965>>>>>>>>>>>                String[] aValues
33966>>>>>>>>>>>
33966>>>>>>>>>>>                Move "" to sRval
33967>>>>>>>>>>>                Send SplitString of oStringFunctions sValue " " True False (&aValues)
33968>>>>>>>>>>>                Move (SizeOfArray(aValues)-1) to iMax
33969>>>>>>>>>>>                For iIndex from 0 to iMax
33975>>>>>>>>>>>>
33975>>>>>>>>>>>                    Move aValues[iIndex] to iChar
33976>>>>>>>>>>>                    Move (sRval+Character(iChar)) to sRval
33977>>>>>>>>>>>                Loop
33978>>>>>>>>>>>>
33978>>>>>>>>>>>                Function_Return sRval
33979>>>>>>>>>>>             End_Function
33980>>>>>>>>>>>
33980>>>>>>>>>>>            Function _DanishCollateString Returns String
33983>>>>>>>>>>>                String sValue
33983>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 95 127 48 49 50 51 52 53 54 55 56 57 65 97 66 98 67 99 68 100 69 64 144 158 201 101 96 130 174 233 172 70 102 71 103 72 104 73 105 74 106" to sValue
33984>>>>>>>>>>>                Move (sValue+" 75 107 76 108 77 109 78 110 79 111 80 112 81 113 82 114 83 115 84 116 85 117 86 118 87 119 88 120 89 121 94 154 220 219 160 126 129 232 252 161 90 122 91 123 92 124 93 125 146 152 198 211 162 145 168 230 215") to sValue
33985>>>>>>>>>>>                Move (sValue+" 163 157 191 216 210 155 207 248 214 143 150 197 208 134 166 167 170 229 212 171 128 131 132 133 135 136 137 138 139 140 141 142 147 148 149 151 153 156 159 164 165 169 173 175 176 177 178 179 180 181 182 183") to sValue
33986>>>>>>>>>>>                Move (sValue+" 184 185 186 187 188 189 190 192 193 194 195 196 199 200 202 203 204 205 206 209 213 217 218 221 222 223 224 225 226 227 228 231 234 235 236 237 238 239 240 241 242 243 244 245 246 247 249 250 251 253 254 255") to sValue
33987>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
33988>>>>>>>>>>>            End_Function
33989>>>>>>>>>>>        
33989>>>>>>>>>>>            Function _SwedishCollateString Returns String
33992>>>>>>>>>>>                String sValue
33992>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 95 127 48 49 50 51 52 53 54 55 56 57 65 97 66 98 67 99 68 100 69 64 144 158 201 168 101 96 130 174 233 169 70 102 71 103 72 104 73 105 74" to sValue
33993>>>>>>>>>>>                Move (sValue+" 106 75 107 76 108 77 109 78 110 79 111 80 112 81 113 82 114 83 115 84 116 85 117 86 118 87 119 88 120 89 121 94 154 216 220 219 126 129 232 252 207 167 90 122 93 125 91 123 92 124 143 150 197 208 161 134 166") to sValue
33994>>>>>>>>>>>                Move (sValue+" 229 212 142 147 196 132 164 162 165 163 228 153 188 214 148 204 218 246 206 128 131 133 135 136 137 138 139 140 141 145 146 149 151 152 155 156 157 159 160 170 171 172 173 175 176 177 178 179 180 181 182 183") to sValue
33995>>>>>>>>>>>                Move (sValue+" 184 185 186 187 189 190 191 192 193 194 195 198 199 200 202 203 205 209 210 211 213 215 217 221 222 223 224 225 226 227 230 231 234 235 236 237 238 239 240 241 242 243 244 245 247 248 249 250 251 253 254 255") to sValue
33996>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
33997>>>>>>>>>>>            End_Function
33998>>>>>>>>>>>        
33998>>>>>>>>>>>            Function _NorwegianCollateString Returns String
34001>>>>>>>>>>>                String sValue
34001>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 95 127 48 49 50 51 52 53 54 55 56 57 65 97 66 98 67 99 68 100 69 64 144 158 201 101 96 130 174 233 172 70 102 71 103 72 104 73 105 74 106" to sValue
34002>>>>>>>>>>>                Move (sValue+" 75 107 76 108 77 109 78 110 79 111 80 112 81 113 82 114 83 115 84 116 85 117 86 118 87 119 88 120 89 121 94 154 220 219 160 126 129 232 252 161 90 122 91 123 92 124 93 125 146 152 198 211 162 145 168 230 215") to sValue
34003>>>>>>>>>>>                Move (sValue+" 163 157 191 216 210 155 207 248 214 143 150 197 208 134 166 167 170 229 212 171 128 131 132 133 135 136 137 138 139 140 141 142 147 148 149 151 153 156 159 164 165 169 173 175 176 177 178 179 180 181 182 183") to sValue
34004>>>>>>>>>>>                Move (sValue+" 184 185 186 187 188 189 190 192 193 194 195 196 199 200 202 203 204 205 206 209 213 217 218 221 222 223 224 225 226 227 228 231 234 235 236 237 238 239 240 241 242 243 244 245 246 247 249 250 251 253 254 255") to sValue
34005>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34006>>>>>>>>>>>            End_Function
34007>>>>>>>>>>>        
34007>>>>>>>>>>>            Function _GermanCollateString Returns String
34010>>>>>>>>>>>                String sValue
34010>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 64 94 95 96 127 48 49 50 51 52 53 54 55 56 57 65 91 142 147 196 97 123 132 163 228 66 98 67 99 68 100 69 101 70 102 71 103 72 104 73 105" to sValue
34011>>>>>>>>>>>                Move (sValue+" 74 106 75 107 76 108 77 109 78 110 79 92 153 188 218 214 111 124 148 204 206 246 80 112 81 113 82 114 83 115 126 225 238 222 223 84 116 85 93 154 216 219 220 117 125 129 232 207 252 86 118 87 119 88 120 89 121") to sValue
34012>>>>>>>>>>>                Move (sValue+" 90 122 128 130 131 133 134 135 136 137 138 139 140 141 143 144 145 146 149 150 151 152 155 156 157 158 159 160 161 162 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185") to sValue
34013>>>>>>>>>>>                Move (sValue+" 186 187 189 190 191 192 193 194 195 197 198 199 200 201 202 203 205 208 209 210 211 212 213 215 217 221 224 226 227 229 230 231 233 234 235 236 237 239 240 241 242 243 244 245 247 248 249 250 251 253 254 255") to sValue
34014>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34015>>>>>>>>>>>            End_Function
34016>>>>>>>>>>>        
34016>>>>>>>>>>>            Function _SpanishCollateString Returns String
34019>>>>>>>>>>>                String sValue
34019>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 91 92 93 94 95 96 123 124 125 126 127 128 131 132 133 134 135 136 137 138 139 140 141 142 143 145 146 147 148 149 150 151 152 153 155 156" to sValue
34020>>>>>>>>>>>                Move (sValue+" 157 158 159 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 215 216") to sValue
34021>>>>>>>>>>>                Move (sValue+" 217 218 219 220 221 222 223 225 226 227 228 229 230 231 232 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 48 49 50 51 52 53 54 55 56 57 64 65 97 181 160 66 98 67 99") to sValue
34022>>>>>>>>>>>                Move (sValue+" 68 100 69 101 144 130 70 102 71 103 72 104 73 105 214 161 74 106 75 107 76 108 77 109 78 110 165 164 79 111 224 162 80 112 81 113 82 114 83 115 84 116 85 117 233 163 154 129 86 118 87 119 88 120 89 121 90 122") to sValue
34023>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34024>>>>>>>>>>>            End_Function
34025>>>>>>>>>>>        
34025>>>>>>>>>>>            Function _PortugueseCollateString Returns String
34028>>>>>>>>>>>                String sValue
34028>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 91 92 93 94 95 96 123 124 125 126 127 145 146 155 156 157 158 159 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 184" to sValue
34029>>>>>>>>>>>                Move (sValue+" 185 186 187 188 189 190 191 192 193 194 195 196 197 200 201 202 203 204 205 206 207 208 209 217 218 219 220 221 230 231 232 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 134") to sValue
34030>>>>>>>>>>>                Move (sValue+" 143 152 213 223 225 48 49 50 51 52 53 54 55 56 57 64 65 97 181 160 183 133 182 131 142 132 199 198 66 98 67 99 128 135 68 100 69 101 144 130 212 138 210 136 211 137 70 102 71 103 72 104 73 105 214 161 222 141") to sValue
34031>>>>>>>>>>>                Move (sValue+" 215 140 216 139 74 106 75 107 76 108 77 109 78 110 79 111 224 162 227 149 226 147 153 148 229 228 80 112 81 113 82 114 83 115 84 116 85 117 233 163 235 151 234 150 154 129 86 118 87 119 88 120 89 121 90 122") to sValue
34032>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34033>>>>>>>>>>>            End_Function
34034>>>>>>>>>>>        
34034>>>>>>>>>>>            Function _DutchCollateString Returns String
34037>>>>>>>>>>>                String sValue
34037>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 91 92 93 94 95 96 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152" to sValue
34038>>>>>>>>>>>                Move (sValue+" 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204") to sValue
34039>>>>>>>>>>>                Move (sValue+" 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 48") to sValue
34040>>>>>>>>>>>                Move (sValue+" 49 50 51 52 53 54 55 56 57 64 65 97 66 98 67 99 68 100 69 101 70 102 71 103 72 104 73 105 74 106 75 107 76 108 77 109 78 110 79 111 80 112 81 113 82 114 83 115 84 116 85 117 86 118 87 119 88 120 89 121 90 122") to sValue
34041>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34042>>>>>>>>>>>            End_Function
34043>>>>>>>>>>>        
34043>>>>>>>>>>>            Function _RussianCollateString Returns String
34046>>>>>>>>>>>                String sValue
34046>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 91 92 93 94 95 96 123 124 125 126 127 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200" to sValue
34047>>>>>>>>>>>                Move (sValue+" 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 242 243 244 245 246 247 248 249 250 251 252 253 254 255 48 49 50 51 52 53 54 55 56 57 64 65 97 66 98 67 99 68 100 69") to sValue
34048>>>>>>>>>>>                Move (sValue+" 101 70 102 71 103 72 104 73 105 74 106 75 107 76 108 77 109 78 110 79 111 80 112 81 113 82 114 83 115 84 116 85 117 86 118 87 119 88 120 89 121 90 122 128 160 129 161 130 162 131 163 132 164 133 165 240 241") to sValue
34049>>>>>>>>>>>                Move (sValue+" 134 166 135 167 136 168 137 169 138 170 139 171 140 172 141 173 142 174 143 175 144 224 145 225 146 226 147 227 148 228 149 229 150 230 151 231 152 232 153 233 154 234 155 235 156 236 157 237 158 238 159 239") to sValue
34050>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34051>>>>>>>>>>>            End_Function
34052>>>>>>>>>>>        
34052>>>>>>>>>>>            Function _FrenchCollateString Returns String
34055>>>>>>>>>>>                String sValue
34055>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 91 92 93 94 95 96 123 124 125 126 127 145 146 155 156 157 158 159 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 184" to sValue
34056>>>>>>>>>>>                Move (sValue+" 185 186 187 188 189 190 191 192 193 194 195 196 197 200 201 202 203 204 205 206 207 208 209 217 218 219 220 221 230 231 232 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 134") to sValue
34057>>>>>>>>>>>                Move (sValue+" 143 152 213 223 225 48 49 50 51 52 53 54 55 56 57 64 65 97 181 160 183 133 182 131 142 132 199 198 66 98 67 99 128 135 68 100 69 101 144 130 212 138 210 136 211 137 70 102 71 103 72 104 73 105 214 161 222 141") to sValue
34058>>>>>>>>>>>                Move (sValue+" 215 140 216 139 74 106 75 107 76 108 77 109 78 110 79 111 224 162 227 149 226 147 153 148 229 228 80 112 81 113 82 114 83 115 84 116 85 117 233 163 235 151 234 150 154 129 86 118 87 119 88 120 89 121 90 122") to sValue
34059>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34060>>>>>>>>>>>            End_Function
34061>>>>>>>>>>>        
34061>>>>>>>>>>>            Function _EnglishCollateString Returns String
34064>>>>>>>>>>>                String sValue
34064>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 91 92 93 94 95 96 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152" to sValue
34065>>>>>>>>>>>                Move (sValue+" 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204") to sValue
34066>>>>>>>>>>>                Move (sValue+" 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 48") to sValue
34067>>>>>>>>>>>                Move (sValue+" 49 50 51 52 53 54 55 56 57 64 65 97 66 98 67 99 68 100 69 101 70 102 71 103 72 104 73 105 74 106 75 107 76 108 77 109 78 110 79 111 80 112 81 113 82 114 83 115 84 116 85 117 86 118 87 119 88 120 89 121 90 122") to sValue
34068>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34069>>>>>>>>>>>            End_Function
34070>>>>>>>>>>>        
34070>>>>>>>>>>>            Procedure _AddCollate String sName String sCollateString
34073>>>>>>>>>>>                Integer iIndex
34073>>>>>>>>>>>                Move (SizeOfArray(gaCollateStrings)) to iIndex
34074>>>>>>>>>>>                Move sName to gaCollateStrings[iIndex].sName
34075>>>>>>>>>>>                Move sCollateString to gaCollateStrings[iIndex].sCollateString
34076>>>>>>>>>>>            End_Procedure
34077>>>>>>>>>>>            
34077>>>>>>>>>>>            Function _CollateLanguage String sCollate Returns String
34080>>>>>>>>>>>                Integer iMax iIndex
34080>>>>>>>>>>>                String sRval
34080>>>>>>>>>>>                If (SizeOfArray(gaCollateStrings)=0) Begin
34082>>>>>>>>>>>                    Send _AddCollate "English"    (_EnglishCollateString(Self))
34083>>>>>>>>>>>                    Send _AddCollate "Dutch"      (_DutchCollateString(Self))
34084>>>>>>>>>>>                    Send _AddCollate "Danish"     (_DanishCollateString(Self))
34085>>>>>>>>>>>                    Send _AddCollate "Norwegian"  (_NorwegianCollateString(Self))
34086>>>>>>>>>>>                    Send _AddCollate "Swedish"    (_SwedishCollateString(Self))
34087>>>>>>>>>>>                    Send _AddCollate "German"     (_GermanCollateString(Self))
34088>>>>>>>>>>>                    Send _AddCollate "Spanish"    (_SpanishCollateString(Self))
34089>>>>>>>>>>>                    Send _AddCollate "Portuguese" (_PortugueseCollateString(Self))
34090>>>>>>>>>>>                    Send _AddCollate "Russian"    (_RussianCollateString(Self))
34091>>>>>>>>>>>                    Send _AddCollate "French"     (_FrenchCollateString(Self))
34092>>>>>>>>>>>                End
34092>>>>>>>>>>>>
34092>>>>>>>>>>>                Move "" to sRval
34093>>>>>>>>>>>                Move (SizeOfArray(gaCollateStrings)-1) to iMax
34094>>>>>>>>>>>                For iIndex from 0 to iMax
34100>>>>>>>>>>>>
34100>>>>>>>>>>>                    If (sCollate=gaCollateStrings[iIndex].sCollateString) Begin
34102>>>>>>>>>>>                        If (sRval<>"") Move (sRval+", ") to sRval
34105>>>>>>>>>>>                        Move (sRval+gaCollateStrings[iIndex].sName) to sRval
34106>>>>>>>>>>>                    End
34106>>>>>>>>>>>>
34106>>>>>>>>>>>                Loop
34107>>>>>>>>>>>>
34107>>>>>>>>>>>                If (sRval="") Move "Unknown" to sRval
34110>>>>>>>>>>>                Function_Return sRval
34111>>>>>>>>>>>            End_Function
34112>>>>>>>>>>>
34112>>>>>>>>>>>    Function CurrentCollateLanguage Returns String
34115>>>>>>>>>>>        String sCurrentCollate 
34115>>>>>>>>>>>        Get CurrentCollateString to sCurrentCollate
34116>>>>>>>>>>>        Function_Return (_CollateLanguage(Self,sCurrentCollate))
34117>>>>>>>>>>>    End_Function
34118>>>>>>>>>>>    
34118>>>>>>>>>>>    Function RuntimeIndex String sVdfVer Returns Integer
34121>>>>>>>>>>>        Integer iMax iItem
34121>>>>>>>>>>>        Move (SizeOfArray(gaRuntimes)-1) to iMax
34122>>>>>>>>>>>        For iItem from 0 to iMax
34128>>>>>>>>>>>>
34128>>>>>>>>>>>            If (sVdfVer=gaRuntimes[iItem].sVdfVersion) Begin
34130>>>>>>>>>>>                Function_Return iItem
34131>>>>>>>>>>>            End
34131>>>>>>>>>>>>
34131>>>>>>>>>>>        Loop
34132>>>>>>>>>>>>
34132>>>>>>>>>>>        Function_Return -1
34133>>>>>>>>>>>    End_Function
34134>>>>>>>>>>>    
34134>>>>>>>>>>>    Function RuntimeStruct String sVdfVer Returns tVdfRuntime
34137>>>>>>>>>>>        Integer iItem
34137>>>>>>>>>>>        tVdfRuntime strRuntime
34137>>>>>>>>>>>        tVdfRuntime strRuntime
34137>>>>>>>>>>>        Get RuntimeIndex sVdfVer to iItem
34138>>>>>>>>>>>        If (iItem>=0) Begin
34140>>>>>>>>>>>            Move gaRuntimes[iItem] to strRuntime
34141>>>>>>>>>>>        End
34141>>>>>>>>>>>>
34141>>>>>>>>>>>        Function_Return strRuntime
34142>>>>>>>>>>>    End_Function
34143>>>>>>>>>>>    
34143>>>>>>>>>>>    Property String _psOriginalProgramPath
34145>>>>>>>>>>>    
34145>>>>>>>>>>>            Function _ReadFileDfCollateCfg String sPath Returns String
34148>>>>>>>>>>>                Integer iChannel iPos iRangeStart iRangeStop iChar iLen
34148>>>>>>>>>>>                Boolean bSeqEof
34148>>>>>>>>>>>                String sValue sLine sText
34148>>>>>>>>>>>                String[] aItems
34149>>>>>>>>>>>                
34149>>>>>>>>>>>                Get DirectInput of oFileFunctions sPath to iChannel
34150>>>>>>>>>>>                If (iChannel>=0) Begin
34152>>>>>>>>>>>                    Move 1 to iPos
34153>>>>>>>>>>>                    Repeat
34153>>>>>>>>>>>>
34153>>>>>>>>>>>                        Readln channel iChannel sLine
34155>>>>>>>>>>>                        Move (SeqEof) to bSeqEof
34156>>>>>>>>>>>                        If (not(bSeqEof)) Begin
34158>>>>>>>>>>>                            Send SplitString of oStringFunctions sLine " " True False (&aItems)
34159>>>>>>>>>>>                            If (Left(sLine,5)="RANGE") Begin
34161>>>>>>>>>>>                                Move aItems[1] to iRangeStart
34162>>>>>>>>>>>                                Move aItems[2] to iRangeStop
34163>>>>>>>>>>>                                For iChar from iRangeStart to iRangeStop
34169>>>>>>>>>>>>
34169>>>>>>>>>>>                                    Move (Overstrike(Character(iChar),sValue,iPos)) to sValue
34170>>>>>>>>>>>                                    Increment iPos
34171>>>>>>>>>>>                                Loop
34172>>>>>>>>>>>>
34172>>>>>>>>>>>                            End
34172>>>>>>>>>>>>
34172>>>>>>>>>>>                            If (Left(sLine,6)="SINGLE") Begin
34174>>>>>>>>>>>                                Move aItems[1] to iChar
34175>>>>>>>>>>>                                Move (Overstrike(Character(iChar),sValue,iPos)) to sValue
34176>>>>>>>>>>>                                Increment iPos                               
34177>>>>>>>>>>>                            End
34177>>>>>>>>>>>>
34177>>>>>>>>>>>                            If (Left(sLine,4)="TEXT") Begin
34179>>>>>>>>>>>                                Move aItems[1] to sText
34180>>>>>>>>>>>                                Move (Replace('"',sText,"")) to sText
34181>>>>>>>>>>>                                Move (Length(sText)-1) to iLen
34182>>>>>>>>>>>                                Move (Left(sText,iLen)) to sText
34183>>>>>>>>>>>                                Move (Overstrike(sText,sValue,iPos)) to sValue
34184>>>>>>>>>>>                                Move (iPos+iLen) to iPos
34185>>>>>>>>>>>                            End
34185>>>>>>>>>>>>
34185>>>>>>>>>>>                        End
34185>>>>>>>>>>>>
34185>>>>>>>>>>>                    Until (bSeqEof)
34187>>>>>>>>>>>                    Send CloseInput of oFileFunctions iChannel
34188>>>>>>>>>>>                End
34188>>>>>>>>>>>>
34188>>>>>>>>>>>                Function_Return (Remove(sValue,1,32))
34189>>>>>>>>>>>            End_Function
34190>>>>>>>>>>>
34190>>>>>>>>>>>            // Updates global array gaRuntimes
34190>>>>>>>>>>>            Procedure _EnumerateRuntimes
34193>>>>>>>>>>>                Boolean bContinue
34193>>>>>>>>>>>                Integer iVersionIndex iVersionMax
34193>>>>>>>>>>>                String sRoot sVdfVersion sCollate
34193>>>>>>>>>>>                tRegKeyData stVdfVersions stKeyData
34193>>>>>>>>>>>                tRegKeyData stVdfVersions stKeyData
34193>>>>>>>>>>>
34193>>>>>>>>>>>                Move (ResizeArray(gaRuntimes,0)) to gaRuntimes
34194>>>>>>>>>>>
34194>>>>>>>>>>>                Move "SOFTWARE\Data Access Worldwide\Visual DataFlex" to sRoot
34195>>>>>>>>>>>                Get ReadKeyData of oRegistryFunctions HKEY_LOCAL_MACHINE sRoot (&stVdfVersions) False to bContinue
34196>>>>>>>>>>>//                If (not(bContinue)) Begin
34196>>>>>>>>>>>//                    Move "SOFTWARE\Wow6432Node\Data Access Worldwide\Visual DataFlex" to sRoot
34196>>>>>>>>>>>//                    Get ReadKeyData of oRegistryFunctions HKEY_LOCAL_MACHINE sRoot (&stVdfVersions) False to bContinue
34196>>>>>>>>>>>//                End
34196>>>>>>>>>>>                If (bContinue) Begin
34198>>>>>>>>>>>                    Move (SizeOfArray(stVdfVersions.aSubKeys)-1) to iVersionMax
34199>>>>>>>>>>>                    For iVersionIndex from 0 to iVersionMax
34205>>>>>>>>>>>>
34205>>>>>>>>>>>                        Move stVdfVersions.aSubKeys[iVersionIndex] to sVdfVersion
34206>>>>>>>>>>>                        Move sVdfVersion to gaRuntimes[iVersionIndex].sVdfVersion
34207>>>>>>>>>>>                        Move (sRoot+"\"+sVdfVersion) to gaRuntimes[iVersionIndex].sRegistryKey
34208>>>>>>>>>>>                        If (ReadKeyData(oRegistryFunctions,HKEY_LOCAL_MACHINE,sRoot+"\"+sVdfVersion+"\Defaults",&stKeyData,False)) Begin
34210>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "DFPath"     to gaRuntimes[iVersionIndex].sDfPath
34211>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "VDFRootDir" to gaRuntimes[iVersionIndex].sRootFolder
34212>>>>>>>>>>>                            
34212>>>>>>>>>>>                            Get _ReadFileDfCollateCfg (AppendPath(oFileFunctions,gaRuntimes[iVersionIndex].sRootFolder,"Bin\df_collate.cfg")) to sCollate
34213>>>>>>>>>>>                            Get _CollateLanguage sCollate to gaRuntimes[iVersionIndex].sCollateLanguage
34214>>>>>>>>>>>                            
34214>>>>>>>>>>>                        End
34214>>>>>>>>>>>>
34214>>>>>>>>>>>                        If (ReadKeyData(oRegistryFunctions,HKEY_LOCAL_MACHINE,sRoot+"\"+sVdfVersion+"\WebApp Server",&stKeyData,False)) Begin
34216>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "EnableSlaveNode"    to gaRuntimes[iVersionIndex].WAS_bEnableSlaveNode
34217>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "GracefulTerminate"  to gaRuntimes[iVersionIndex].WAS_iGracefulTerminate
34218>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "Listen"             to gaRuntimes[iVersionIndex].WAS_iListen
34219>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "MaxSessions"        to gaRuntimes[iVersionIndex].WAS_iMaxSessions
34220>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "MessageTimeout"     to gaRuntimes[iVersionIndex].WAS_iMessageTimeout
34221>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "Product Class"      to gaRuntimes[iVersionIndex].WAS_sProductClass
34222>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "RefreshInterval"    to gaRuntimes[iVersionIndex].WAS_iRefreshInterval
34223>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "Registration Code"  to gaRuntimes[iVersionIndex].WAS_sRegCode
34224>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "Registration Name"  to gaRuntimes[iVersionIndex].WAS_sRegName
34225>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "Serial Number"      to gaRuntimes[iVersionIndex].WAS_sRegNumber
34226>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "Users"              to gaRuntimes[iVersionIndex].WAS_sUsers
34227>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "TransactionTimeout" to gaRuntimes[iVersionIndex].WAS_iTransactionTimeout
34228>>>>>>>>>>>                        End
34228>>>>>>>>>>>>
34228>>>>>>>>>>>                    Loop
34229>>>>>>>>>>>>
34229>>>>>>>>>>>                End
34229>>>>>>>>>>>>
34229>>>>>>>>>>>            End_Procedure
34230>>>>>>>>>>>
34230>>>>>>>>>>>            // Updates index iRuntimeIndex of global array gaWebApplications with the webapplications belonging
34230>>>>>>>>>>>            // to the runtime specified in parameter stRuntime
34230>>>>>>>>>>>            Procedure _EnumerateWebApplications Integer iRuntimeIndex tVdfRuntime stRuntime
34233>>>>>>>>>>>                Integer iAppIndex iAppMax
34233>>>>>>>>>>>                String sWebAppsRootKey sWebAppRootKey sAppName sPath
34233>>>>>>>>>>>                tRegKeyData stWebAppsRootKeyData stWebAppKeyData
34233>>>>>>>>>>>                tRegKeyData stWebAppsRootKeyData stWebAppKeyData
34233>>>>>>>>>>>                tVdfWebApplication stWebApplication
34233>>>>>>>>>>>                tVdfWebApplication stWebApplication
34233>>>>>>>>>>>
34233>>>>>>>>>>>                Move (stRuntime.sRegistryKey+"\WebApp Server\Web Applications") to sWebAppsRootKey
34234>>>>>>>>>>>
34234>>>>>>>>>>>                If (ReadKeyData(oRegistryFunctions,HKEY_LOCAL_MACHINE,sWebAppsRootKey,&stWebAppsRootKeyData,False)) Begin
34236>>>>>>>>>>>                    Move (SizeOfArray(stWebAppsRootKeyData.aSubKeys)-1) to iAppMax
34237>>>>>>>>>>>                    For iAppIndex from 0 to iAppMax
34243>>>>>>>>>>>>
34243>>>>>>>>>>>                        Move stWebAppsRootKeyData.aSubKeys[iAppIndex] to sAppName
34244>>>>>>>>>>>                        Move sAppName to stWebApplication.sName
34245>>>>>>>>>>>                        Move (sWebAppsRootKey+"\"+sAppName) to sWebAppRootKey
34246>>>>>>>>>>>                        Move sWebAppRootKey to stWebApplication.sRegistryKey
34247>>>>>>>>>>>                        Move iRuntimeIndex to stWebApplication.iRuntimeIndex
34248>>>>>>>>>>>                        Move gaRuntimes[iRuntimeIndex].sVdfVersion to stWebApplication.sVdfVersion
34249>>>>>>>>>>>                        
34249>>>>>>>>>>>                        If (ReadKeyData(oRegistryFunctions,HKEY_LOCAL_MACHINE,sWebAppRootKey,&stWebAppKeyData,False)) Begin
34251>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "Disable"            to stWebApplication.bDisable
34252>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "LogAccess"          to stWebApplication.bLogAccess
34253>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "LogFile"            to stWebApplication.sLogFile
34254>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "MaxLogEntries"      to stWebApplication.iMaxLogEntries
34255>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "MinPool"            to stWebApplication.iMinPool
34256>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "MaxPool"            to stWebApplication.iMaxPool
34257>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "OperationMode"      to stWebApplication.sOperationMode
34258>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "ProgramParameters"  to stWebApplication.sProgramParameters
34259>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "ProgramPath"        to sPath
34260>>>>>>>>>>>                            Move sPath to stWebApplication.sProgramPath
34261>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "PurgePoolInterval"  to stWebApplication.iPurgePoolInterval
34262>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "UseConnectorPool"   to stWebApplication.bUseConnectorPool
34263>>>>>>>>>>>
34263>>>>>>>>>>>                            Get PathToFolder of oFileFunctions sPath to sPath // C:\Samples\AJAX Order Entry\Programs\webapp.exe -> C:\VDF12\Samples\AJAX Order Entry\Programs
34264>>>>>>>>>>>                            Get PathToFolder of oFileFunctions sPath to sPath // C:\Samples\AJAX Order Entry\Programs -> C:\VDF12\Samples\AJAX Order Entry
34265>>>>>>>>>>>                            Get AppendPath of oFileFunctions sPath "Data" to sPath
34266>>>>>>>>>>>                            Move sPath to stWebApplication.sDataPath
34267>>>>>>>>>>>
34267>>>>>>>>>>>                        End
34267>>>>>>>>>>>>
34267>>>>>>>>>>>                        Move stWebApplication to gaWebApplications[SizeOfArray(gaWebApplications)]
34268>>>>>>>>>>>                    Loop
34269>>>>>>>>>>>>
34269>>>>>>>>>>>                End
34269>>>>>>>>>>>>
34269>>>>>>>>>>>            End_Procedure
34270>>>>>>>>>>>
34270>>>>>>>>>>>    Procedure RereadWebApplications
34273>>>>>>>>>>>        Integer iRuntimeIndex iRunTimeMax
34273>>>>>>>>>>>        String sWebAppRoot
34273>>>>>>>>>>>
34273>>>>>>>>>>>        Send _EnumerateRuntimes
34274>>>>>>>>>>>
34274>>>>>>>>>>>        Move (ResizeArray(gaWebApplications,0)) to gaWebApplications
34275>>>>>>>>>>>
34275>>>>>>>>>>>        Move (SizeOfArray(gaRuntimes)-1) to iRunTimeMax
34276>>>>>>>>>>>        For iRuntimeIndex from 0 to iRunTimeMax
34282>>>>>>>>>>>>
34282>>>>>>>>>>>            Send _EnumerateWebApplications iRuntimeIndex gaRuntimes[iRuntimeIndex]
34283>>>>>>>>>>>        Loop
34284>>>>>>>>>>>>
34284>>>>>>>>>>>        Move 0 to WindowIndex
34285>>>>>>>>>>>    End_Procedure
34286>>>>>>>>>>>
34286>>>>>>>>>>>    Function WebApplication Integer iWebAppIndex Returns tVdfWebApplication
34289>>>>>>>>>>>        String sWebAppRootKey sPath
34289>>>>>>>>>>>        tVdfWebApplication stWebApp
34289>>>>>>>>>>>        tVdfWebApplication stWebApp
34289>>>>>>>>>>>        tRegKeyData stWebAppKeyData
34289>>>>>>>>>>>        tRegKeyData stWebAppKeyData
34289>>>>>>>>>>>
34289>>>>>>>>>>>        Move gaWebApplications[iWebAppIndex].sRegistryKey to sWebAppRootKey
34290>>>>>>>>>>>        Move gaWebApplications[iWebAppIndex] to stWebApp
34291>>>>>>>>>>>
34291>>>>>>>>>>>        If (ReadKeyData(oRegistryFunctions,HKEY_LOCAL_MACHINE,sWebAppRootKey,&stWebAppKeyData,False)) Begin
34293>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "Disable"            to stWebApp.bDisable
34294>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "LogAccess"          to stWebApp.bLogAccess
34295>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "LogFile"            to stWebApp.sLogFile
34296>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "MaxLogEntries"      to stWebApp.iMaxLogEntries
34297>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "MinPool"            to stWebApp.iMinPool
34298>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "MaxPool"            to stWebApp.iMaxPool
34299>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "OperationMode"      to stWebApp.sOperationMode
34300>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "ProgramParameters"  to stWebApp.sProgramParameters
34301>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "ProgramPath"        to sPath
34302>>>>>>>>>>>            Move sPath to stWebApp.sProgramPath
34303>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "PurgePoolInterval"  to stWebApp.iPurgePoolInterval
34304>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "UseConnectorPool"   to stWebApp.bUseConnectorPool
34305>>>>>>>>>>>
34305>>>>>>>>>>>            Get PathToFolder of oFileFunctions sPath to sPath // C:\Samples\AJAX Order Entry\Programs\webapp.exe -> C:\VDF12\Samples\AJAX Order Entry\Programs
34306>>>>>>>>>>>            Get PathToFolder of oFileFunctions sPath to sPath // C:\Samples\AJAX Order Entry\Programs -> C:\VDF12\Samples\AJAX Order Entry
34307>>>>>>>>>>>            Get AppendPath of oFileFunctions sPath "Data" to sPath
34308>>>>>>>>>>>            Move sPath to stWebApp.sDataPath
34309>>>>>>>>>>>
34309>>>>>>>>>>>        End
34309>>>>>>>>>>>>
34309>>>>>>>>>>>        Else Begin
34310>>>>>>>>>>>            Error 832 "Could not read WebApp registry"
34311>>>>>>>>>>>>
34311>>>>>>>>>>>        End
34311>>>>>>>>>>>>
34311>>>>>>>>>>>        Function_Return stWebApp
34312>>>>>>>>>>>    End_Function
34313>>>>>>>>>>>
34313>>>>>>>>>>>    Procedure RereadWebApplication Integer iWebAppIndex
34316>>>>>>>>>>>        get WebApplication iWebAppIndex to gaWebApplications[iWebAppIndex]
34317>>>>>>>>>>>    End_Procedure
34318>>>>>>>>>>>
34318>>>>>>>>>>>    Procedure Set WebAppRunState Integer iWebAppIndex Boolean bRunState
34321>>>>>>>>>>>        Integer iRuntimeIndex
34321>>>>>>>>>>>        String sRegKey
34321>>>>>>>>>>>        If (iWebAppIndex<SizeOfArray(gaWebApplications)) Begin
34323>>>>>>>>>>>            Move gaWebApplications[iWebAppIndex].iRuntimeIndex to iRuntimeIndex
34324>>>>>>>>>>>            Move gaWebApplications[iWebAppIndex].sRegistryKey to sRegKey
34325>>>>>>>>>>>            Send WriteRegValue of oRegistryFunctions HKEY_LOCAL_MACHINE sRegKey "Disable" (If(bRunState,0,1)) rdDword
34326>>>>>>>>>>>        End
34326>>>>>>>>>>>>
34326>>>>>>>>>>>        Else Begin
34327>>>>>>>>>>>            Error 801 "Webapp index out of range"
34328>>>>>>>>>>>>
34328>>>>>>>>>>>        End
34328>>>>>>>>>>>>
34328>>>>>>>>>>>    End_Procedure
34329>>>>>>>>>>>    
34329>>>>>>>>>>>    Function WebAppRunState Integer iWebAppIndex Returns Boolean
34332>>>>>>>>>>>        tVdfWebApplication stWebApp
34332>>>>>>>>>>>        tVdfWebApplication stWebApp
34332>>>>>>>>>>>        Get WebApplication iWebAppIndex to stWebApp
34333>>>>>>>>>>>        Function_Return (not(stWebApp.bDisable))
34334>>>>>>>>>>>    End_Function
34335>>>>>>>>>>>    
34335>>>>>>>>>>>    //> Locate a webapplication in the global array gaWebApplications by the name (incl.
34335>>>>>>>>>>>    //> the full path of the applcation (F.x. "c:\apps\wasp2\programs\webapp.exe")
34335>>>>>>>>>>>    Function WebApplicationIndex String sProgramPath Returns Integer
34338>>>>>>>>>>>        Integer iIndex iMax
34338>>>>>>>>>>>
34338>>>>>>>>>>>        Move (Lowercase(sProgramPath)) to sProgramPath
34339>>>>>>>>>>>        If (Right(sProgramPath,4)<>".exe") Begin
34341>>>>>>>>>>>            Move (sProgramPath+".exe.") to sProgramPath
34342>>>>>>>>>>>        End
34342>>>>>>>>>>>>
34342>>>>>>>>>>>        Move (SizeOfArray(gaWebApplications)-1) to iMax
34343>>>>>>>>>>>        For iIndex from 0 to iMax
34349>>>>>>>>>>>>
34349>>>>>>>>>>>            If (sProgramPath=Lowercase(gaWebApplications[iIndex].sProgramPath)) Begin
34351>>>>>>>>>>>                Function_Return iIndex
34352>>>>>>>>>>>            End
34352>>>>>>>>>>>>
34352>>>>>>>>>>>        Loop
34353>>>>>>>>>>>>
34353>>>>>>>>>>>        Function_Return -1 // not found
34354>>>>>>>>>>>    End_Function
34355>>>>>>>>>>>    
34355>>>>>>>>>>>    // Index of the webapplication that we are (if we are a webapplication)
34355>>>>>>>>>>>    Function CurrentWebApplicationIndex Returns Integer
34358>>>>>>>>>>>        String sProgramPath
34358>>>>>>>>>>>        Get _psOriginalProgramPath to sProgramPath
34359>>>>>>>>>>>        Function_Return (WebApplicationIndex(Self,sProgramPath))
34360>>>>>>>>>>>    End_Function
34361>>>>>>>>>>>    
34361>>>>>>>>>>>    Function WebApplicationNameAndVersionToIndex String sName String sVdfVer Returns Integer
34364>>>>>>>>>>>        Integer iIndex iMax
34364>>>>>>>>>>>        Move (Lowercase(Trim(sName))) to sName
34365>>>>>>>>>>>        Move (Lowercase(Trim(sVdfVer))) to sVdfVer
34366>>>>>>>>>>>        Move (SizeOfArray(gaWebApplications)-1) to iMax
34367>>>>>>>>>>>        For iIndex from 0 to iMax
34373>>>>>>>>>>>>
34373>>>>>>>>>>>            If (sName=Lowercase(gaWebApplications[iIndex].sName) and sVdfVer=Lowercase(gaWebApplications[iIndex].sVdfVersion)) Begin
34375>>>>>>>>>>>                Function_Return iIndex
34376>>>>>>>>>>>            End
34376>>>>>>>>>>>>
34376>>>>>>>>>>>        Loop
34377>>>>>>>>>>>>
34377>>>>>>>>>>>        Function_Return -1
34378>>>>>>>>>>>    End_Function
34379>>>>>>>>>>>    
34379>>>>>>>>>>>    Function CurrentVdfVer Returns String
34382>>>>>>>>>>>        String sMajor sMinor
34382>>>>>>>>>>>        Move (String(FMAC_VERSION)) to sMajor
34383>>>>>>>>>>>        Move (String(FMAC_REVISION)) to sMinor
34384>>>>>>>>>>>        Function_Return (sMajor+"."+sMinor)
34385>>>>>>>>>>>    End_Function
34386>>>>>>>>>>>    
34386>>>>>>>>>>>    Function VdfVerStringToNumber String sVdfVer Returns Number
34389>>>>>>>>>>>        Integer iPos iMajor iMinor
34389>>>>>>>>>>>        Move (Pos(".",sVdfVer)) to iPos
34390>>>>>>>>>>>        Move (Left(sVdfVer,iPos-1)) to iMajor
34391>>>>>>>>>>>        Move (Right(sVdfVer,1)) to iMinor
34392>>>>>>>>>>>        Function_Return (Number(iMinor/10.0+iMajor))
34393>>>>>>>>>>>    End_Function
34394>>>>>>>>>>>    
34394>>>>>>>>>>>    Procedure _Initialize
34397>>>>>>>>>>>        String sFolder sModule sProgramPath
34397>>>>>>>>>>>        
34397>>>>>>>>>>>        Send RereadWebApplications // (and enumerate runtime)
34398>>>>>>>>>>>        Get VdfFolderPath of oFileFunctions VDF_PROGRAM to sFolder
34399>>>>>>>>>>>        Get Module_Name to sModule
34400>>>>>>>>>>>        Get AppendPath of oFileFunctions sFolder sModule to sProgramPath
34401>>>>>>>>>>>        Set _psOriginalProgramPath to sProgramPath
34402>>>>>>>>>>>    End_Procedure
34403>>>>>>>>>>>    
34403>>>>>>>>>>>    Send _Initialize
34404>>>>>>>>>>>
34404>>>>>>>>>>>// VDF License functions
34404>>>>>>>>>>>    
34404>>>>>>>>>>>    Function LicenseName Returns String
34407>>>>>>>>>>>        Integer iNumber
34407>>>>>>>>>>>        String sName
34407>>>>>>>>>>>        Registration sName iNumber
34408>>>>>>>>>>>>
34408>>>>>>>>>>>        Function_Return sName
34409>>>>>>>>>>>    End_Function
34410>>>>>>>>>>>    Function LicenseNumber Returns Integer
34413>>>>>>>>>>>        Integer iLicenseNumber
34413>>>>>>>>>>>        String sName
34413>>>>>>>>>>>        Registration sName iLicenseNumber
34414>>>>>>>>>>>>
34414>>>>>>>>>>>        Function_Return iLicenseNumber
34415>>>>>>>>>>>    End_Function
34416>>>>>>>>>>>    Function LicenseMaxUsers Returns Integer
34419>>>>>>>>>>>        Integer iMaxUsers
34419>>>>>>>>>>>        Get_Licensed_Max_Users to iMaxUsers
34420>>>>>>>>>>>        Function_Return iMaxUsers
34421>>>>>>>>>>>    End_Function
34422>>>>>>>>>>>    Function LicenseCurrentUsers Returns Integer
34425>>>>>>>>>>>        Integer iUserCount
34425>>>>>>>>>>>        Get_Current_User_Count to iUserCount
34426>>>>>>>>>>>        Function_Return iUserCount
34427>>>>>>>>>>>    End_Function
34428>>>>>>>>>>>    Function IsDebuggerActive Returns Boolean
34431>>>>>>>>>>>        Function_Return (IsDebuggerPresent())
34432>>>>>>>>>>>    End_Function
34433>>>>>>>>>>>End_Object // oVdfRuntimeFunctions
34434>>>>>>>>>
34434>>>>>>>>>Global_Variable Integer oIndexFunctions
34434>>>>>>>>>Object _oIndexFunctions is a cObject
34436>>>>>>>>>    Move Self to oIndexFunctions
34437>>>>>>>>>    
34437>>>>>>>>>    Property Integer _DeadlySecretSwitch False
34439>>>>>>>>>    Property Integer _piPrimKeyTable
34441>>>>>>>>>    
34441>>>>>>>>>    Procedure FlushReadCache
34444>>>>>>>>>        Send Reset of oOverlapColumnFunctions
34445>>>>>>>>>    End_Procedure
34446>>>>>>>>>    
34446>>>>>>>>>    Function IsIndexUnique Integer iTable Integer iIndex Returns Boolean
34449>>>>>>>>>        Boolean bIsUnique
34449>>>>>>>>>        Integer iMax
34449>>>>>>>>>        tocIndex strIndex
34449>>>>>>>>>        tocIndex strIndex
34449>>>>>>>>>        Get IndexDefinition of oOverlapColumnFunctions iTable iIndex to strIndex
34450>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iMax
34451>>>>>>>>>        If (iMax>=0) Begin
34453>>>>>>>>>            Move (strIndex.aSegments[iMax].iColumn<>0) to bIsUnique
34454>>>>>>>>>        End
34454>>>>>>>>>>
34454>>>>>>>>>        Else Begin
34455>>>>>>>>>            Move False to bIsUnique
34456>>>>>>>>>        End
34456>>>>>>>>>>
34456>>>>>>>>>        Function_Return bIsUnique 
34457>>>>>>>>>    End_Function
34458>>>>>>>>>    
34458>>>>>>>>>    Function IndexDefinition Integer iTable Integer iIndex Returns tOCIndex
34461>>>>>>>>>        Function_Return (IndexDefinition(oOverlapColumnFunctions,iTable,iIndex))
34462>>>>>>>>>    End_Function
34463>>>>>>>>>    
34463>>>>>>>>>    Function IndexDefinitionColumnNumbers Integer iTable Integer iIndex Returns Integer[]
34466>>>>>>>>>        Function_Return (IndexDefinitionColumnNumbers(oOverlapColumnFunctions,iTable,iIndex))
34467>>>>>>>>>    End_Function
34468>>>>>>>>>    
34468>>>>>>>>>    Function IsIndexOnline Integer iTable Integer iIndex Returns Boolean
34471>>>>>>>>>        tocIndex strIndex
34471>>>>>>>>>        tocIndex strIndex
34471>>>>>>>>>        Get IndexDefinition of oOverlapColumnFunctions iTable iIndex to strIndex
34472>>>>>>>>>        Function_Return strIndex.bOnline
34473>>>>>>>>>    End_Function
34474>>>>>>>>>
34474>>>>>>>>>    //> iSelectCode: 0=All 1:Unique 2:Off-line 3:On-line
34474>>>>>>>>>    Function IndexSet Integer iTable Integer iSelectCode Returns Integer[]
34477>>>>>>>>>        Boolean bOnline
34477>>>>>>>>>        Integer iIndex 
34477>>>>>>>>>        Integer[] aIndices
34478>>>>>>>>>        tocIndex strIndex
34478>>>>>>>>>        tocIndex strIndex
34478>>>>>>>>>        For iIndex from 1 to 15
34484>>>>>>>>>>
34484>>>>>>>>>            Get IndexDefinition iTable iIndex to strIndex
34485>>>>>>>>>            If (SizeOfArray(strIndex.aSegments)>0) Begin
34487>>>>>>>>>                If (iSelectCode=0) Begin // All
34489>>>>>>>>>                    Move iIndex to aIndices[SizeOfArray(aIndices)]
34490>>>>>>>>>                End
34490>>>>>>>>>>
34490>>>>>>>>>                If (iSelectCode=1) Begin // Unique
34492>>>>>>>>>                    If (IsIndexUnique(Self,iTable,iIndex)) Begin
34494>>>>>>>>>                        Move iIndex to aIndices[SizeOfArray(aIndices)]
34495>>>>>>>>>                    End
34495>>>>>>>>>>
34495>>>>>>>>>                End
34495>>>>>>>>>>
34495>>>>>>>>>                If (iSelectCode=2) Begin // Off-line
34497>>>>>>>>>                    Get IsIndexOnline iTable iIndex to bOnline
34498>>>>>>>>>                    If (not(bOnline)) Begin
34500>>>>>>>>>                        Move iIndex to aIndices[SizeOfArray(aIndices)]
34501>>>>>>>>>                    End
34501>>>>>>>>>>
34501>>>>>>>>>                End
34501>>>>>>>>>>
34501>>>>>>>>>                If (iSelectCode=3) Begin // On-line
34503>>>>>>>>>                    Get IsIndexOnline iTable iIndex to bOnline
34504>>>>>>>>>                    If (bOnline) Begin
34506>>>>>>>>>                        Move iIndex to aIndices[SizeOfArray(aIndices)]
34507>>>>>>>>>                    End
34507>>>>>>>>>>
34507>>>>>>>>>                End
34507>>>>>>>>>>
34507>>>>>>>>>            End
34507>>>>>>>>>>
34507>>>>>>>>>        Loop
34508>>>>>>>>>>
34508>>>>>>>>>        Function_Return aIndices
34509>>>>>>>>>    End_Function
34510>>>>>>>>>    
34510>>>>>>>>>    Function FirstUniqueIndex Integer iTable Returns Integer
34513>>>>>>>>>        Integer iIndex iRecnumTable
34513>>>>>>>>>        tocIndex strIndex
34513>>>>>>>>>        tocIndex strIndex
34513>>>>>>>>>        For iIndex from 1 to 15
34519>>>>>>>>>>
34519>>>>>>>>>            Get IndexDefinition iTable iIndex to strIndex
34520>>>>>>>>>            If (SizeOfArray(strIndex.aSegments)>0) Begin
34522>>>>>>>>>                If (IsIndexUnique(Self,iTable,iIndex)) Begin
34524>>>>>>>>>                    Function_Return iIndex
34525>>>>>>>>>                End
34525>>>>>>>>>>
34525>>>>>>>>>            End
34525>>>>>>>>>>
34525>>>>>>>>>        Loop
34526>>>>>>>>>>
34526>>>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of iTable to iRecnumTable
34529>>>>>>>>>        If (iRecnumTable<>0) Begin
34531>>>>>>>>>            Function_Return 0 // Use Recnum for gods sake.
34532>>>>>>>>>        End
34532>>>>>>>>>>
34532>>>>>>>>>        Function_Return -1 // Sorry, no luck
34533>>>>>>>>>    End_Function
34534>>>>>>>>>    
34534>>>>>>>>>    Function ShortestUniqueIndex Integer iTable Returns Integer
34537>>>>>>>>>        tocTable strTable
34537>>>>>>>>>        tocTable strTable
34537>>>>>>>>>        Get TableDefinition of _oOverlapColumnFunctions iTable to strTable
34538>>>>>>>>>        Function_Return strTable.iShortestUniqueIndex
34539>>>>>>>>>    End_Function
34540>>>>>>>>>
34540>>>>>>>>>    Function KeyStateColumns Integer iTable Returns Integer[]
34543>>>>>>>>>        Integer hDDO iColumn
34543>>>>>>>>>        String sKeyStates
34543>>>>>>>>>        Integer[] aColumns
34544>>>>>>>>>        Get DDO_Object of oDataDictionaryFunctions iTable to hDDO
34545>>>>>>>>>        If (hDDO>0) Begin
34547>>>>>>>>>            Get Key_Fields of hDDO to sKeyStates
34548>>>>>>>>>            Repeat
34548>>>>>>>>>>
34548>>>>>>>>>                Move (Pos("X",sKeyStates)) to iColumn
34549>>>>>>>>>                If (iColumn>0) Begin
34551>>>>>>>>>                    Move iColumn to aColumns[SizeOfArray(aColumns)]
34552>>>>>>>>>                    Move (Overstrike(" ", sKeyStates, iColumn)) to sKeyStates
34553>>>>>>>>>                End
34553>>>>>>>>>>
34553>>>>>>>>>            Until (iColumn=0)
34555>>>>>>>>>
34555>>>>>>>>>        End
34555>>>>>>>>>>
34555>>>>>>>>>        Function_Return aColumns
34556>>>>>>>>>    End_Function
34557>>>>>>>>>    
34557>>>>>>>>>    // Calling this function only has meaning if all iTable members of
34557>>>>>>>>>    // aSegments AND aFields are identical. The function just assumes
34557>>>>>>>>>    // this is the case, but does not check for it.
34557>>>>>>>>>//  Function IndexSegmentsMatch tTableField[] aSegments tTableField[] aFields Returns Integer
34557>>>>>>>>>    Function _IndexSegmentMatchLength Integer iTable Integer iIndex Integer[] aColumns Returns Integer // returns the number of most-significant index-segments that may be seeded if we have aColumns at our disposal.
34560>>>>>>>>>        Integer iSegmentIndex iSegmentMax
34560>>>>>>>>>        Integer iColumnIndex iColumnMax
34560>>>>>>>>>        Integer iMatchLength
34560>>>>>>>>>        Integer[] aSegments
34561>>>>>>>>>        
34561>>>>>>>>>        Get IndexDefinitionColumnNumbers iTable iIndex to aSegments
34562>>>>>>>>>        Move (SizeOfArray(aSegments)-1) to iSegmentMax
34563>>>>>>>>>        Move (SizeOfArray(aColumns)-1) to iColumnMax
34564>>>>>>>>>
34564>>>>>>>>>        For iSegmentIndex from 0 to iSegmentMax
34570>>>>>>>>>>
34570>>>>>>>>>            For iColumnIndex from 0 to iColumnMax
34576>>>>>>>>>>
34576>>>>>>>>>                If (aSegments[iSegmentIndex]=aColumns[iColumnIndex]) Begin
34578>>>>>>>>>                    Move -1 to aSegments[iSegmentIndex] // Mark as matched
34579>>>>>>>>>                    Move iColumnMax to iColumnIndex // Break the loop.
34580>>>>>>>>>                End
34580>>>>>>>>>>
34580>>>>>>>>>            Loop
34581>>>>>>>>>>
34581>>>>>>>>>        Loop
34582>>>>>>>>>>
34582>>>>>>>>>
34582>>>>>>>>>        Move 0 to iMatchLength
34583>>>>>>>>>
34583>>>>>>>>>        For iSegmentIndex from 0 to iSegmentMax
34589>>>>>>>>>>
34589>>>>>>>>>            If (aSegments[iSegmentIndex]>-1) Begin
34591>>>>>>>>>                Function_Return iMatchLength
34592>>>>>>>>>            End
34592>>>>>>>>>>
34592>>>>>>>>>            Increment iMatchLength
34593>>>>>>>>>        Loop
34594>>>>>>>>>>
34594>>>>>>>>>
34594>>>>>>>>>        Function_Return iMatchLength // All segments matched
34595>>>>>>>>>    End_Function
34596>>>>>>>>>    
34596>>>>>>>>>    Function IndexFullySpecified Integer iTable Integer iIndex Integer[] aColumns Returns Boolean
34599>>>>>>>>>        Integer iMatchLength
34599>>>>>>>>>        Integer[] aSegments
34600>>>>>>>>>        Get IndexDefinitionColumnNumbers iTable iIndex to aSegments
34601>>>>>>>>>        Get _IndexSegmentMatchLength iTable iIndex aColumns to iMatchLength
34602>>>>>>>>>        Function_Return (SizeOfArray(aSegments)=iMatchLength)
34603>>>>>>>>>    End_Function
34604>>>>>>>>>    
34604>>>>>>>>>//    Function IndexSegmentMatchLengthX Integer iTable Integer iIndex tocIndexSegment[] aAvailableSegments Returns Integer 
34604>>>>>>>>>//        Integer iItem iItemMax
34604>>>>>>>>>//        tocIndexSegment[] aIndexSegments
34604>>>>>>>>>//        Get IndexDefinition iTable iIndex to aIndexSegments
34604>>>>>>>>>//        Move (SizeOfArray(aIndexSegments)-1) to iItemMax
34604>>>>>>>>>//        For iItem from 0 to iItemMax
34604>>>>>>>>>//        Loop
34604>>>>>>>>>//    End_Function
34604>>>>>>>>>
34604>>>>>>>>>    Function _CompareIndicesByLength Integer iIndex1 Integer iIndex2 Returns Integer
34607>>>>>>>>>        Integer iTable iLen1 iLen2
34607>>>>>>>>>        Get _piPrimKeyTable to iTable
34608>>>>>>>>>        Get_Attribute DF_INDEX_KEY_LENGTH of iTable iIndex1 to iLen1
34611>>>>>>>>>        Get_Attribute DF_INDEX_KEY_LENGTH of iTable iIndex2 to iLen2
34614>>>>>>>>>        If (iLen1<iLen2) Function_Return (LT)
34617>>>>>>>>>        If (iLen1>iLen2) Function_Return (GT)
34620>>>>>>>>>        // If two indices have the length, we prefer the one with the lowest number
34620>>>>>>>>>        If (iIndex1<iIndex2) Function_Return (LT)
34623>>>>>>>>>        If (iIndex1>iIndex2) Function_Return (GT)
34626>>>>>>>>>        Function_Return (EQ)
34627>>>>>>>>>    End_Function
34628>>>>>>>>>    
34628>>>>>>>>>    Function PrimaryKey Integer iTable Returns Integer
34631>>>>>>>>>        Integer iIndex hDDO iMatchLength iItem iMax
34631>>>>>>>>>        Integer[] aKeyColumns aUniqueIndices aIndexCandidates
34634>>>>>>>>>        Get_Attribute DF_FILE_PRIMARY_INDEX of iTable to iIndex
34637>>>>>>>>>        If (iIndex<=0) Begin // If DF_FILE_PRIMARY_INDEX wasn't set we'll try to see what can be deduced from Key_Field_State settings
34639>>>>>>>>>            // OK Primary key wasn't set. Therefore we see if we can get hold of a DD object.
34639>>>>>>>>>            Get KeyStateColumns iTable to aKeyColumns
34640>>>>>>>>>            Get IndexSet iTable 1 to aUniqueIndices
34641>>>>>>>>>            Move (SizeOfArray(aUniqueIndices)-1) to iMax
34642>>>>>>>>>            For iItem from 0 to iMax
34648>>>>>>>>>>
34648>>>>>>>>>                If (IndexFullySpecified(Self,iTable,aUniqueIndices[iItem],aKeyColumns)) Begin
34650>>>>>>>>>                    Function_Return aUniqueIndices[iItem]
34651>>>>>>>>>                End
34651>>>>>>>>>>
34651>>>>>>>>>            Loop
34652>>>>>>>>>>
34652>>>>>>>>>            // If we still haven't found an index we'll just use the unique index with whe shortest key:
34652>>>>>>>>>            If (iMax>=0) Begin
34654>>>>>>>>>                Set _piPrimKeyTable to iTable
34655>>>>>>>>>                Move (SortArray(aUniqueIndices,Self,GET__CompareIndicesByLength)) to aUniqueIndices
34656>>>>>>>>>                Function_Return aUniqueIndices[0]
34657>>>>>>>>>            End
34657>>>>>>>>>>
34657>>>>>>>>>        End
34657>>>>>>>>>>
34657>>>>>>>>>        Function_Return iIndex
34658>>>>>>>>>    End_Function
34659>>>>>>>>>    
34659>>>>>>>>>    //> Given that I have the value of the columns listed in aColumns, give me an index
34659>>>>>>>>>    //> to find EQ by in table iTable.
34659>>>>>>>>>    Function FindEQIndex Integer iTable Integer[] aColumns Returns Integer
34662>>>>>>>>>        Integer iIndex
34662>>>>>>>>>        Integer iIndexItem iIndexMax
34662>>>>>>>>>        Integer[] aIndices
34663>>>>>>>>>        Get IndexSet iTable 1 to aIndices
34664>>>>>>>>>        Move (SizeOfArray(aIndices)-1) to iIndexMax
34665>>>>>>>>>        For iIndexItem from 0 to iIndexMax
34671>>>>>>>>>>
34671>>>>>>>>>            Move aIndices[iIndexItem] to iIndex
34672>>>>>>>>>            If (IndexFullySpecified(Self,iTable,iIndex,aColumns)) Begin
34674>>>>>>>>>                Function_Return iIndex
34675>>>>>>>>>            End
34675>>>>>>>>>>
34675>>>>>>>>>        Loop
34676>>>>>>>>>>
34676>>>>>>>>>        Function_Return -1 // No index found
34677>>>>>>>>>    End_Function
34678>>>>>>>>>    
34678>>>>>>>>>    //> iTable must be open.
34678>>>>>>>>>    Function RecordIdentifierColumns Integer iTable Returns Integer[]
34681>>>>>>>>>        Integer iColumn iIndex
34681>>>>>>>>>        Integer[] aColumns
34682>>>>>>>>>
34682>>>>>>>>>        // First check if table has a DF_FILE_RECORD_IDENTITY column set for it.
34682>>>>>>>>>        Get_Attribute DF_FILE_RECORD_IDENTITY of iTable to iColumn
34685>>>>>>>>>        If (iColumn<>0) Begin // If it does, we'll go with that
34687>>>>>>>>>            Move iColumn to aColumns[0]
34688>>>>>>>>>        End
34688>>>>>>>>>>
34688>>>>>>>>>        Else Begin
34689>>>>>>>>>            // Then see if the table has a primary index.
34689>>>>>>>>>            Get_Attribute DF_FILE_PRIMARY_INDEX of iTable to iIndex
34692>>>>>>>>>            If (iIndex<>0) Begin // If it does, we'll go with that
34694>>>>>>>>>                Get IndexDefinitionColumnNumbers iTable iIndex to aColumns
34695>>>>>>>>>            End
34695>>>>>>>>>>
34695>>>>>>>>>            Else Begin
34696>>>>>>>>>                // Finally see if we can find an index ourselves.
34696>>>>>>>>>                Get ShortestUniqueIndex iTable to iIndex
34697>>>>>>>>>                If (iIndex>=0) Begin
34699>>>>>>>>>                    Get IndexDefinitionColumnNumbers iTable iIndex to aColumns
34700>>>>>>>>>                End
34700>>>>>>>>>>
34700>>>>>>>>>            End
34700>>>>>>>>>>
34700>>>>>>>>>        End
34700>>>>>>>>>>
34700>>>>>>>>>        Function_Return aColumns
34701>>>>>>>>>    End_Function
34702>>>>>>>>>    
34702>>>>>>>>>    Function ColumnSortValueFormat Integer iTable Integer iColumn String sValue Returns String
34705>>>>>>>>>        Integer iType iLen iPrecision 
34705>>>>>>>>>        Number nValue
34705>>>>>>>>>        Date dValue
34705>>>>>>>>>        Get_Attribute DF_FIELD_TYPE of iTable iColumn to iType
34708>>>>>>>>>        If (iType=DF_DATE) Begin
34710>>>>>>>>>            Move sValue to dValue
34711>>>>>>>>>            If (Integer(dValue)<>0) Begin
34713>>>>>>>>>                Get DateToString of oDateFunctions dValue DF_DATE_MILITARY True "" to sValue
34714>>>>>>>>>            End
34714>>>>>>>>>>
34714>>>>>>>>>            Else Begin
34715>>>>>>>>>                If (_DeadlySecretSwitch(Self)) Begin // Switched is used by 5-levels-out function IndexSortValueFileNameFormat. Makes sense?
34717>>>>>>>>>                    Move "00000000" to sValue // Null date
34718>>>>>>>>>                End
34718>>>>>>>>>>
34718>>>>>>>>>            End
34718>>>>>>>>>>
34718>>>>>>>>>        End 
34718>>>>>>>>>>
34718>>>>>>>>>        Else If (iType=DF_BCD) Begin
34721>>>>>>>>>            Get_Attribute DF_FIELD_LENGTH of iTable iColumn to iLen
34724>>>>>>>>>            Get_Attribute DF_FIELD_PRECISION of iTable iColumn to iPrecision
34727>>>>>>>>>            Move sValue to nValue
34728>>>>>>>>>            If (iPrecision<>0) Begin
34730>>>>>>>>>                Increment iLen // Make room for comma
34731>>>>>>>>>            End
34731>>>>>>>>>>
34731>>>>>>>>>            get NumberToStringR of oStringFunctions nValue iPrecision iLen to sValue
34732>>>>>>>>>            Move (Replaces(" ",sValue,"0")) to sValue // Zerofill
34733>>>>>>>>>        End
34733>>>>>>>>>>
34733>>>>>>>>>        Else If (iType=DF_DATETIME) Begin
34736>>>>>>>>>            // This will bite someday, it should be converted to millitary format (or maybe it is?)
34736>>>>>>>>>        End
34736>>>>>>>>>>
34736>>>>>>>>>        Else Begin
34737>>>>>>>>>            If (_DeadlySecretSwitch(Self)) Begin // Switched is used by 5-levels-out function IndexSortValueFileNameFormat. Makes sense?
34739>>>>>>>>>                Get StringToHex of oStringFunctions sValue to sValue
34740>>>>>>>>>            End
34740>>>>>>>>>>
34740>>>>>>>>>        End
34740>>>>>>>>>>
34740>>>>>>>>>        Function_Return sValue
34741>>>>>>>>>    End_Function
34742>>>>>>>>>    
34742>>>>>>>>>    //> The function returns a column value formattet according to its definition (i.e. a 8.4
34742>>>>>>>>>    //> numeric field is returned right aligned in a string 13 characters long while the value
34742>>>>>>>>>    //> of an ASCII field is returned as is.
34742>>>>>>>>>    Function ColumnSortValue Integer iTable Integer iColumn Returns String
34745>>>>>>>>>        String sValue
34745>>>>>>>>>        Get_Field_Value iTable iColumn to sValue
34748>>>>>>>>>        Function_Return (ColumnSortValueFormat(Self,iTable,iColumn,sValue))
34749>>>>>>>>>    End_Function
34750>>>>>>>>>    
34750>>>>>>>>>    //> The function returns the 
34750>>>>>>>>>    Function IndexSegmentSortValue Integer iTable tocIndexSegment stSegment Returns String 
34753>>>>>>>>>        String sValue
34753>>>>>>>>>        Get ColumnSortValue iTable stSegment.iColumn to sValue
34754>>>>>>>>>        If (stSegment.bUppercase) Begin
34756>>>>>>>>>            Move (Uppercase(sValue)) to sValue
34757>>>>>>>>>        End
34757>>>>>>>>>>
34757>>>>>>>>>        If (stSegment.bDescending) Begin
34759>>>>>>>>>            Get NegateString of oStringFunctions sValue to sValue
34760>>>>>>>>>        End
34760>>>>>>>>>>
34760>>>>>>>>>        Function_Return sValue
34761>>>>>>>>>    End_Function
34762>>>>>>>>>    
34762>>>>>>>>>    Function IndexSortValue Integer iTable Integer iIndex Returns String
34765>>>>>>>>>        Integer iSegment iSegments
34765>>>>>>>>>        String sValue
34765>>>>>>>>>        tocIndex strIndex
34765>>>>>>>>>        tocIndex strIndex
34765>>>>>>>>>        Get IndexDefinition iTable iIndex to strIndex
34766>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
34767>>>>>>>>>        For iSegment from 0 to iSegments
34773>>>>>>>>>>
34773>>>>>>>>>            Move (sValue+IndexSegmentSortValue(Self,iTable,strIndex.aSegments[iSegment])) to sValue
34774>>>>>>>>>        Loop
34775>>>>>>>>>>
34775>>>>>>>>>        Function_Return sValue
34776>>>>>>>>>    End_Function
34777>>>>>>>>>
34777>>>>>>>>>    //> This functions performs the same as function IndexSortValue above, except that the
34777>>>>>>>>>    //> return value will be accepted by the OS as a valid component of a file name.
34777>>>>>>>>>    Function IndexSortValueFileNameFormat Integer iTable Integer iIndex Returns String
34780>>>>>>>>>        String sValue
34780>>>>>>>>>        Set _DeadlySecretSwitch to True
34781>>>>>>>>>        Get IndexSortValue iTable iIndex to sValue
34782>>>>>>>>>        Set _DeadlySecretSwitch to False
34783>>>>>>>>>        Function_Return sValue
34784>>>>>>>>>    End_Function
34785>>>>>>>>>    
34785>>>>>>>>>    
34785>>>>>>>>>    Function IndexValue Integer iTable Integer iIndex String sSep Returns String
34788>>>>>>>>>        Integer iSegment iSegments
34788>>>>>>>>>        String sValue sSegmentValue
34788>>>>>>>>>        tocIndex strIndex
34788>>>>>>>>>        tocIndex strIndex
34788>>>>>>>>>        Get IndexDefinition iTable iIndex to strIndex
34789>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
34790>>>>>>>>>        For iSegment from 0 to iSegments
34796>>>>>>>>>>
34796>>>>>>>>>            Get ColumnSortValue iTable strIndex.aSegments[iSegment].iColumn to sSegmentValue
34797>>>>>>>>>            If (iSegment<>0) Begin
34799>>>>>>>>>                Move (sValue+sSep) to sValue
34800>>>>>>>>>            End
34800>>>>>>>>>>
34800>>>>>>>>>            Move (sValue+sSegmentValue) to sValue
34801>>>>>>>>>        Loop
34802>>>>>>>>>>
34802>>>>>>>>>        Function_Return sValue
34803>>>>>>>>>    End_Function
34804>>>>>>>>>    
34804>>>>>>>>>    Function IndexSegmentValueArray Integer iTable Integer iIndex Returns String[]
34807>>>>>>>>>        Integer iSegment iSegments
34807>>>>>>>>>        String sSegmentValue sValue
34807>>>>>>>>>        String[] aValues
34808>>>>>>>>>        tocIndex strIndex
34808>>>>>>>>>        tocIndex strIndex
34808>>>>>>>>>        Get IndexDefinition iTable iIndex to strIndex
34809>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
34810>>>>>>>>>        For iSegment from 0 to iSegments
34816>>>>>>>>>>
34816>>>>>>>>>            Get_Field_Value iTable strIndex.aSegments[iSegment].iColumn to sValue
34819>>>>>>>>>            Move sValue to aValues[SizeOfArray(aValues)]
34820>>>>>>>>>        Loop
34821>>>>>>>>>>
34821>>>>>>>>>        Function_Return aValues
34822>>>>>>>>>    End_Function
34823>>>>>>>>>    
34823>>>>>>>>>    Function FindRecordByValueArray Integer iTable Integer iIndex String[] aValues Returns Boolean
34826>>>>>>>>>        Integer iSegment iSegments
34826>>>>>>>>>        String sSegmentValue sValue
34826>>>>>>>>>        tocIndex strIndex
34826>>>>>>>>>        tocIndex strIndex
34826>>>>>>>>>        Clear iTable
34827>>>>>>>>>        Get IndexDefinition iTable iIndex to strIndex
34828>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
34829>>>>>>>>>        For iSegment from 0 to iSegments
34835>>>>>>>>>>
34835>>>>>>>>>            Set_Field_Value iTable strIndex.aSegments[iSegment].iColumn to aValues[iSegment]
34838>>>>>>>>>        Loop
34839>>>>>>>>>>
34839>>>>>>>>>        Vfind iTable iIndex EQ
34841>>>>>>>>>        Function_Return (Found)
34842>>>>>>>>>    End_Function
34843>>>>>>>>>    
34843>>>>>>>>>    // This function does the same as function IndexSortValue above, except that it gets it's
34843>>>>>>>>>    // column value from the array passed instead of the record buffer.
34843>>>>>>>>>    Function IndexSortValueFromArray Integer iTable Integer iIndex String[] aColumnValues Returns String
34846>>>>>>>>>        Integer iSegment iSegments iColumn
34846>>>>>>>>>        String sValue sSegmentValue
34846>>>>>>>>>        tocIndex strIndex
34846>>>>>>>>>        tocIndex strIndex
34846>>>>>>>>>        Get IndexDefinition iTable iIndex to strIndex
34847>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
34848>>>>>>>>>        For iSegment from 0 to iSegments
34854>>>>>>>>>>
34854>>>>>>>>>            Move strIndex.aSegments[iSegment].iColumn to iColumn
34855>>>>>>>>>            Move aColumnValues[iColumn] to sSegmentValue
34856>>>>>>>>>            Get ColumnSortValueFormat iTable iColumn sSegmentValue to sSegmentValue
34857>>>>>>>>>            Move (sValue+sSegmentValue) to sValue
34858>>>>>>>>>        Loop
34859>>>>>>>>>>
34859>>>>>>>>>        Function_Return sValue
34860>>>>>>>>>    End_Function
34861>>>>>>>>>    
34861>>>>>>>>>    Function IndexValueFromArray Integer iTable Integer iIndex String sSep String[] aColumnValues Returns String
34864>>>>>>>>>        Integer iSegment iSegments iColumn
34864>>>>>>>>>        String sValue sSegmentValue
34864>>>>>>>>>        tocIndex strIndex
34864>>>>>>>>>        tocIndex strIndex
34864>>>>>>>>>        Get IndexDefinition iTable iIndex to strIndex
34865>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
34866>>>>>>>>>        For iSegment from 0 to iSegments
34872>>>>>>>>>>
34872>>>>>>>>>            Move strIndex.aSegments[iSegment].iColumn to iColumn
34873>>>>>>>>>            Move aColumnValues[iColumn] to sSegmentValue
34874>>>>>>>>>            Get ColumnSortValueFormat iTable iColumn sSegmentValue to sSegmentValue
34875>>>>>>>>>            Move (sValue+sSegmentValue) to sValue
34876>>>>>>>>>            If (iSegment<>0) Begin
34878>>>>>>>>>                Move (sValue+sSep) to sValue
34879>>>>>>>>>            End
34879>>>>>>>>>>
34879>>>>>>>>>        Loop
34880>>>>>>>>>>
34880>>>>>>>>>        Function_Return sValue
34881>>>>>>>>>    End_Function
34882>>>>>>>>>    
34882>>>>>>>>>    Function RecordIDAsHumanReadableString Integer iTable Returns String
34885>>>>>>>>>        Integer iMax iItem
34885>>>>>>>>>        Integer[] aColumns
34886>>>>>>>>>        String sReturnValue sName sValue
34886>>>>>>>>>        Get RecordIdentifierColumns iTable to aColumns
34887>>>>>>>>>        Move (SizeOfArray(aColumns)-1) to iMax
34888>>>>>>>>>        For iItem from 0 to iMax
34894>>>>>>>>>>
34894>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iTable aColumns[iItem] to sName
34897>>>>>>>>>            Get_Field_Value iTable aColumns[iItem] to sValue
34900>>>>>>>>>            Move (sReturnValue+sName+": "+Trim(sValue)) to sReturnValue
34901>>>>>>>>>            If (iItem<>iMax) Begin
34903>>>>>>>>>                Move (sReturnValue+";") to sReturnValue
34904>>>>>>>>>            End
34904>>>>>>>>>>
34904>>>>>>>>>        Loop
34905>>>>>>>>>>
34905>>>>>>>>>        Function_Return sReturnValue
34906>>>>>>>>>    End_Function
34907>>>>>>>>>    
34907>>>>>>>>>    Function SwitchIndicesOffline Integer iTable String sOpenAsName Returns Integer[]
34910>>>>>>>>>        Integer iItem iMax iIndex iOrgTableHandle
34910>>>>>>>>>        Integer[] aIndices
34911>>>>>>>>>        String sDriver
34911>>>>>>>>>        
34911>>>>>>>>>        Get_Attribute DF_FILE_DRIVER of iTable to sDriver
34914>>>>>>>>>
34914>>>>>>>>>        If (sDriver="DATAFLEX") Begin
34916>>>>>>>>>            Get IndexSet iTable 3 to aIndices // 3 means on-line indices
34917>>>>>>>>>            Move (SizeOfArray(aIndices)-1) to iMax
34918>>>>>>>>>            If (iMax>=0) Begin
34920>>>>>>>>>                Move iTable to iOrgTableHandle
34921>>>>>>>>>                Structure_Start iTable
34922>>>>>>>>>                    For iItem from 0 to iMax
34928>>>>>>>>>>
34928>>>>>>>>>                        Move aIndices[iItem] to iIndex
34929>>>>>>>>>                        Set_Attribute DF_INDEX_TYPE of iTable iIndex to DF_INDEX_TYPE_BATCH
34932>>>>>>>>>                    Loop
34933>>>>>>>>>>
34933>>>>>>>>>                Structure_End iTable DF_STRUCTEND_OPT_NONE "."
34935>>>>>>>>>                Move iOrgTableHandle to iTable
34936>>>>>>>>>                Close iTable // Close and re-open
34937>>>>>>>>>                If (sOpenAsName<>"") Begin
34939>>>>>>>>>                    Open sOpenAsName as iTable
34941>>>>>>>>>                End
34941>>>>>>>>>>
34941>>>>>>>>>                Else Begin
34942>>>>>>>>>                    Open iTable
34944>>>>>>>>>                End
34944>>>>>>>>>>
34944>>>>>>>>>            End
34944>>>>>>>>>>
34944>>>>>>>>>        End
34944>>>>>>>>>>
34944>>>>>>>>>        Function_Return aIndices
34945>>>>>>>>>    End_Function
34946>>>>>>>>>    
34946>>>>>>>>>    Procedure SwitchIndicesOnLine Integer iTable String sOpenAsName Integer[] aIndices
34949>>>>>>>>>        Integer iItem iMax iIndex iOrgTableHandle
34949>>>>>>>>>        String sDriver
34949>>>>>>>>>        
34949>>>>>>>>>        Get_Attribute DF_FILE_DRIVER of iTable to sDriver
34952>>>>>>>>>
34952>>>>>>>>>        If (sDriver="DATAFLEX") Begin
34954>>>>>>>>>            Move (SizeOfArray(aIndices)-1) to iMax
34955>>>>>>>>>            If (iMax>=0) Begin
34957>>>>>>>>>                Move iTable to iOrgTableHandle
34958>>>>>>>>>                Structure_Start iTable
34959>>>>>>>>>                    For iItem from 0 to iMax
34965>>>>>>>>>>
34965>>>>>>>>>                        Move aIndices[iItem] to iIndex
34966>>>>>>>>>                        Set_Attribute DF_INDEX_TYPE of iTable iIndex to DF_INDEX_TYPE_ONLINE
34969>>>>>>>>>                    Loop
34970>>>>>>>>>>
34970>>>>>>>>>                Structure_End iTable DF_STRUCTEND_OPT_NONE "." // This forces a re-index
34972>>>>>>>>>                Move iOrgTableHandle to iTable
34973>>>>>>>>>                Close iTable // Close and re-open
34974>>>>>>>>>                If (sOpenAsName<>"") Begin
34976>>>>>>>>>                    Open sOpenAsName as iTable
34978>>>>>>>>>                End
34978>>>>>>>>>>
34978>>>>>>>>>                Else Begin
34979>>>>>>>>>                    Open iTable
34981>>>>>>>>>                End
34981>>>>>>>>>>
34981>>>>>>>>>            End
34981>>>>>>>>>>
34981>>>>>>>>>        End
34981>>>>>>>>>>
34981>>>>>>>>>    End_Procedure
34982>>>>>>>>>    
34982>>>>>>>>>    Procedure SeedMinValue Integer iTable Integer iColumn Boolean bMax
34985>>>>>>>>>        Integer iType iLength iDecimals iCount
34985>>>>>>>>>        Number nValueInt nValueFrac
34985>>>>>>>>>        String sChar
34985>>>>>>>>>        Time tiNull
34985>>>>>>>>>        DateTime dtValue
34985>>>>>>>>>        
34985>>>>>>>>>        Get_Attribute DF_FIELD_TYPE of iTable iColumn to iType
34988>>>>>>>>>        If (iType=DF_BCD) Begin
34990>>>>>>>>>            Get_Attribute DF_FIELD_LENGTH of iTable iColumn to iLength
34993>>>>>>>>>            Get_Attribute DF_FIELD_PRECISION of iTable iColumn to iDecimals
34996>>>>>>>>>            // Calculate fraction part
34996>>>>>>>>>            Move 0 to nValueFrac
34997>>>>>>>>>            For iCount from 1 to iDecimals 
35003>>>>>>>>>>
35003>>>>>>>>>                Move (nValueFrac/10+0.9) to nValueFrac 
35004>>>>>>>>>            Loop
35005>>>>>>>>>>
35005>>>>>>>>>            // Calculate integer part
35005>>>>>>>>>            Move (iLength-iDecimals) to iLength 
35006>>>>>>>>>            Move 0 to nValueInt
35007>>>>>>>>>            If (bMax) Begin
35009>>>>>>>>>                For iCount from 1 to iLength
35015>>>>>>>>>>
35015>>>>>>>>>                    Move (nValueInt*10+9) to nValueInt
35016>>>>>>>>>                Loop
35017>>>>>>>>>>
35017>>>>>>>>>            End
35017>>>>>>>>>>
35017>>>>>>>>>            Else Begin
35018>>>>>>>>>                For iCount from 2 to iLength
35024>>>>>>>>>>
35024>>>>>>>>>                    Move (nValueInt*10+9) to nValueInt
35025>>>>>>>>>                Loop
35026>>>>>>>>>>
35026>>>>>>>>>                Move (-nValueInt) to nValueInt
35027>>>>>>>>>            End
35027>>>>>>>>>>
35027>>>>>>>>>            Set_Field_Value iTable iColumn to (nValueInt+nValueFrac)
35030>>>>>>>>>        End
35030>>>>>>>>>>
35030>>>>>>>>>        If (iType=DF_DATE) Begin
35032>>>>>>>>>            If (bMax) Begin
35034>>>>>>>>>                Set_Field_Value iTable iColumn to LargestPossibleDate
35037>>>>>>>>>            End
35037>>>>>>>>>>
35037>>>>>>>>>            Else Begin
35038>>>>>>>>>                Set_Field_Value iTable iColumn to 0
35041>>>>>>>>>            End
35041>>>>>>>>>>
35041>>>>>>>>>        End
35041>>>>>>>>>>
35041>>>>>>>>>        If (iType=DF_DATETIME) Begin
35043>>>>>>>>>            If (bMax) Begin
35045>>>>>>>>>                Get ComposeDateTime of oDateFunctions LargestPossibleDate tiNull to dtValue
35046>>>>>>>>>            End
35046>>>>>>>>>>
35046>>>>>>>>>            Else Begin
35047>>>>>>>>>                Get ComposeDateTime of oDateFunctions (Date(0)) tiNull to dtValue
35048>>>>>>>>>            End
35048>>>>>>>>>>
35048>>>>>>>>>            Set_Field_Value iTable iColumn to dtValue
35051>>>>>>>>>        End
35051>>>>>>>>>>
35051>>>>>>>>>        If (iType=DF_ASCII) Begin
35053>>>>>>>>>            Get_Attribute DF_FIELD_LENGTH of iTable iColumn to iLength
35056>>>>>>>>>            If (bMax) Begin
35058>>>>>>>>>                Get MaximumCollateCharacter of oVdfRuntimeFunctions to sChar
35059>>>>>>>>>            End
35059>>>>>>>>>>
35059>>>>>>>>>            Else Begin
35060>>>>>>>>>                Get MinimumCollateCharacter of oVdfRuntimeFunctions to sChar
35061>>>>>>>>>            End
35061>>>>>>>>>>
35061>>>>>>>>>            Set_Field_Value iTable iColumn to (Repeat(sChar,iLength))
35064>>>>>>>>>        End
35064>>>>>>>>>>
35064>>>>>>>>>        
35064>>>>>>>>>    End_Procedure
35065>>>>>>>>>    
35065>>>>>>>>>    Function MinimalIncrement Integer iTable Integer iColumn Boolean bDecrement Returns Boolean
35068>>>>>>>>>        Integer iType
35068>>>>>>>>>        Get_Attribute DF_FIELD_TYPE of iTable iColumn to iType
35071>>>>>>>>>        Send Info_Box "nao implementado" "Scusi"
35072>>>>>>>>>        If (iType=DF_BCD) Begin
35074>>>>>>>>>            
35074>>>>>>>>>        End
35074>>>>>>>>>>
35074>>>>>>>>>    End_Function
35075>>>>>>>>>
35075>>>>>>>>>End_Object
35076>>>>>>>Use StackFunctions.pkg  // oStackFunctions object
35076>>>>>>>Use FileFunctions.pkg   // oFileFunctions object
35076>>>>>>>Use TemporaryTables.pkg
Including file: TemporaryTables.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\TemporaryTables.pkg)
35076>>>>>>>>>// Temporary tables are embedded tables!
35076>>>>>>>>>
35076>>>>>>>>>Use AttributeFunctions.pkg
Including file: AttributeFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\AttributeFunctions.pkg)
35076>>>>>>>>>>>// Use AttributeFunctions.pkg // Database and global API attributes
35076>>>>>>>>>>>
35076>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
35076>>>>>>>>>>>Use TableAccessFunctions.pkg
Including file: TableAccessFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\TableAccessFunctions.pkg)
35076>>>>>>>>>>>>>// Use TableAccess.pkg // Define oTableAccessFunctions object
35076>>>>>>>>>>>>>
35076>>>>>>>>>>>>>//> This package defines the tBasicFieldType type that is used throughout many of the other packages. It also
35076>>>>>>>>>>>>>//> contains methods for extracting meta data from a DD object.
35076>>>>>>>>>>>>>//> pkg.doc.end
35076>>>>>>>>>>>>>
35076>>>>>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
35076>>>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
35076>>>>>>>>>>>>>Use TableDriverFunctions.pkg
Including file: TableDriverFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\TableDriverFunctions.pkg)
35076>>>>>>>>>>>>>>>Use VdfBase.pkg
35076>>>>>>>>>>>>>>>
35076>>>>>>>>>>>>>>>Use cli.pkg // DAW package
35076>>>>>>>>>>>>>>>
35076>>>>>>>>>>>>>>>Enumeration_List // Driver ID's
35076>>>>>>>>>>>>>>>    Define TD_DRIVER_ERROR
35076>>>>>>>>>>>>>>>    Define TD_DRIVER_UNKNOWN
35076>>>>>>>>>>>>>>>    Define TD_DRIVER_DATAFLEX
35076>>>>>>>>>>>>>>>    Define TD_DRIVER_PERVASIVE
35076>>>>>>>>>>>>>>>    Define TD_DRIVER_ORACLE
35076>>>>>>>>>>>>>>>    Define TD_DRIVER_MS_SQL
35076>>>>>>>>>>>>>>>    Define TD_DRIVER_DB2
35076>>>>>>>>>>>>>>>    Define TD_DRIVER_ODBC
35076>>>>>>>>>>>>>>>    Define TD_DRIVER_MS_SQL_DAW
35076>>>>>>>>>>>>>>>    Define TD_DRIVER_MAX // Points to the highest known driver ID (as does (SizeOfArray(gaConnectivityDrivers))  )
35076>>>>>>>>>>>>>>>End_Enumeration_List
35076>>>>>>>>>>>>>>>
35076>>>>>>>>>>>>>>>Struct tConnectivityServer
35076>>>>>>>>>>>>>>>End_Struct
35076>>>>>>>>>>>>>>>
35076>>>>>>>>>>>>>>>Struct tConnectivityDriver
35076>>>>>>>>>>>>>>>    String sName
35076>>>>>>>>>>>>>>>    String sNameAbr
35076>>>>>>>>>>>>>>>    String sManufacturer
35076>>>>>>>>>>>>>>>    String sDll
35076>>>>>>>>>>>>>>>    Boolean bLoaded
35076>>>>>>>>>>>>>>>    tConnectivityServer[] aServers
35076>>>>>>>>>>>>>>>    tConnectivityServer[] aServers
35076>>>>>>>>>>>>>>>End_Struct
35076>>>>>>>>>>>>>>>
35076>>>>>>>>>>>>>>>Global_Variable tConnectivityDriver[] gaConnectivityDrivers
35076>>>>>>>>>>>>>>>
35076>>>>>>>>>>>>>>>Global_Variable Integer oTableDriverFunctions
35076>>>>>>>>>>>>>>>
35076>>>>>>>>>>>>>>>Object _oTableDriverFunctions is a cObject
35078>>>>>>>>>>>>>>>    Move Self to oTableDriverFunctions
35079>>>>>>>>>>>>>>>
35079>>>>>>>>>>>>>>>            Procedure _AddDriver tConnectivityDriver[] ByRef aDrivers Integer iDriver String sName String sDll String sManufacturer
35082>>>>>>>>>>>>>>>                Move sName to aDrivers[iDriver].sName
35083>>>>>>>>>>>>>>>                Move sDll to aDrivers[iDriver].sDll
35084>>>>>>>>>>>>>>>                Move sManufacturer to aDrivers[iDriver].sManufacturer
35085>>>>>>>>>>>>>>>            End_Procedure
35086>>>>>>>>>>>>>>>
35086>>>>>>>>>>>>>>>            Procedure _register_known_drivers
35089>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_ERROR      "(Error)"           ""         ""            ""
35090>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_UNKNOWN    "Unknown"           ""         ""            ""
35091>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_DATAFLEX   "Embedded"          "DATAFLEX" "Data Access" ""
35092>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_PERVASIVE  "Pervasive"         "DFBTRDRV" "Data Access" ""
35093>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_ORACLE     "Oracle"            "ORA_DRV"  "Mertech"     ""
35094>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_MS_SQL     "MS-SQL (MT)"       "SQL_DRV"  "Mertech"     ""
35095>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_DB2        "DB/2"              "DB2_DRV"  "Data Access" ""
35096>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_ODBC       "ODBC"              "ODBC_DRV" "Data Access" ""
35097>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_MS_SQL_DAW "MS-SQL (DAW)"      "MSSQLDRV" "Data Access" ""
35098>>>>>>>>>>>>>>>                // If any drivers are missing, let me know @ sture@stureaps.dk
35098>>>>>>>>>>>>>>>            End_Procedure
35099>>>>>>>>>>>>>>>            Send _register_known_drivers    
35100>>>>>>>>>>>>>>>    
35100>>>>>>>>>>>>>>>    Procedure CallBackDrivers Integer hMsg Integer hObj
35103>>>>>>>>>>>>>>>        Integer iMax iIndex
35103>>>>>>>>>>>>>>>        For iIndex from TD_DRIVER_DATAFLEX to (TD_DRIVER_MAX-1)
35109>>>>>>>>>>>>>>>>
35109>>>>>>>>>>>>>>>            Send hMsg of hObj gaConnectivityDrivers[iIndex]
35110>>>>>>>>>>>>>>>        Loop
35111>>>>>>>>>>>>>>>>
35111>>>>>>>>>>>>>>>    End_Procedure
35112>>>>>>>>>>>>>>>    
35112>>>>>>>>>>>>>>>    //> All known drivers except the embedded driver.
35112>>>>>>>>>>>>>>>    Function ForeignDriverArray Returns String[]
35115>>>>>>>>>>>>>>>        Integer iMax iIndex
35115>>>>>>>>>>>>>>>        String[] aDrivers
35116>>>>>>>>>>>>>>>        For iIndex from (TD_DRIVER_DATAFLEX+1) to (TD_DRIVER_MAX-1)
35122>>>>>>>>>>>>>>>>
35122>>>>>>>>>>>>>>>            Move gaConnectivityDrivers[iIndex].sDll to aDrivers[SizeOfArray(aDrivers)]
35123>>>>>>>>>>>>>>>        Loop
35124>>>>>>>>>>>>>>>>
35124>>>>>>>>>>>>>>>        Function_Return aDrivers
35125>>>>>>>>>>>>>>>    End_Function
35126>>>>>>>>>>>>>>>
35126>>>>>>>>>>>>>>>    Function DriverDllToId String sDll Returns Integer
35129>>>>>>>>>>>>>>>        Integer iSize iDriver
35129>>>>>>>>>>>>>>>        Move (trim(Uppercase(sDll))) to sDll
35130>>>>>>>>>>>>>>>        If (sDll<>"") Begin
35132>>>>>>>>>>>>>>>            Move (SizeOfArray(gaConnectivityDrivers)) to iSize
35133>>>>>>>>>>>>>>>            Decrement iSize
35134>>>>>>>>>>>>>>>            For iDriver from TD_DRIVER_DATAFLEX to iSize
35140>>>>>>>>>>>>>>>>
35140>>>>>>>>>>>>>>>                If (gaConnectivityDrivers[iDriver].sDll=sDll) Begin
35142>>>>>>>>>>>>>>>                    Function_Return iDriver
35143>>>>>>>>>>>>>>>                End
35143>>>>>>>>>>>>>>>>
35143>>>>>>>>>>>>>>>            Loop
35144>>>>>>>>>>>>>>>>
35144>>>>>>>>>>>>>>>        End
35144>>>>>>>>>>>>>>>>
35144>>>>>>>>>>>>>>>        Function_Return TD_DRIVER_UNKNOWN // Is not zero
35145>>>>>>>>>>>>>>>    End_Function
35146>>>>>>>>>>>>>>>
35146>>>>>>>>>>>>>>>    Function DriverIdToName Integer iDriver Returns String
35149>>>>>>>>>>>>>>>        Function_Return gaConnectivityDrivers[iDriver].sName
35150>>>>>>>>>>>>>>>    End_Function
35151>>>>>>>>>>>>>>>
35151>>>>>>>>>>>>>>>    Function DriverIdToDll Integer iDriver Returns String
35154>>>>>>>>>>>>>>>        Function_Return gaConnectivityDrivers[iDriver].sDll
35155>>>>>>>>>>>>>>>    End_Function
35156>>>>>>>>>>>>>>>
35156>>>>>>>>>>>>>>>    //> Retrieve driver index as used by driver atrributes setting's and getting's
35156>>>>>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
35159>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iDriverIndex
35159>>>>>>>>>>>>>>>        String sTest 
35159>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
35162>>>>>>>>>>>>>>>        Move (Uppercase(sDriver)) to sDriver
35163>>>>>>>>>>>>>>>        For iDriverIndex from 1 to iNumberOfDrivers
35169>>>>>>>>>>>>>>>>
35169>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriverIndex to sTest
35172>>>>>>>>>>>>>>>            If (Uppercase(sTest)=sDriver) Begin
35174>>>>>>>>>>>>>>>                Function_Return iDriverIndex
35175>>>>>>>>>>>>>>>            End
35175>>>>>>>>>>>>>>>>
35175>>>>>>>>>>>>>>>        Loop
35176>>>>>>>>>>>>>>>>
35176>>>>>>>>>>>>>>>        Function_Return 0 // Driver not loaded
35177>>>>>>>>>>>>>>>    End_Function
35178>>>>>>>>>>>>>>>    
35178>>>>>>>>>>>>>>>    Function DriverRevision String sDriver Returns String
35181>>>>>>>>>>>>>>>        Handle hoCLIHandler
35181>>>>>>>>>>>>>>>        String sVersion
35181>>>>>>>>>>>>>>>        Get Create U_cCLIHandler to hoCLIHandler
35182>>>>>>>>>>>>>>>        Set psDriverID of hoCLIHandler to sDriver
35183>>>>>>>>>>>>>>>        Get CKRevision of hoCLIHandler to sVersion
35184>>>>>>>>>>>>>>>        Send Destroy of hoCLIHandler
35185>>>>>>>>>>>>>>>        Function_Return sVersion
35186>>>>>>>>>>>>>>>    End_Function
35187>>>>>>>>>>>>>>>
35187>>>>>>>>>>>>>>>    Function TableDatabaseHandle Integer iTable Integer ByRef iDriverIndex Integer ByRef iServerIndex Returns Integer
35190>>>>>>>>>>>>>>>        String sDriver sServer sLogin
35190>>>>>>>>>>>>>>>        Integer hDatabase iNumServers
35190>>>>>>>>>>>>>>>        Integer iDriverIndexX iServerIndexX
35190>>>>>>>>>>>>>>>        Get_Attribute DF_FILE_DRIVER of iTable to sDriver
35193>>>>>>>>>>>>>>>        Get_Attribute DF_FILE_LOGIN of iTable to sLogin
35196>>>>>>>>>>>>>>>        Get DriverIndex sDriver to iDriverIndexX
35197>>>>>>>>>>>>>>>        If (iDriverIndexX>0) Begin
35199>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriverIndexX to iNumServers
35202>>>>>>>>>>>>>>>            For iServerIndexX from 1 to iNumServers
35208>>>>>>>>>>>>>>>>
35208>>>>>>>>>>>>>>>                Get_Attribute DF_DRIVER_SERVER_NAME of iDriverIndexX iServerIndexX to sServer
35211>>>>>>>>>>>>>>>                If (sServer=sLogin) Begin
35213>>>>>>>>>>>>>>>                    Get_Attribute DF_DATABASE_ID of iDriverIndexX iServerIndexX to hDatabase
35216>>>>>>>>>>>>>>>                    Move iDriverIndexX to iDriverIndex
35217>>>>>>>>>>>>>>>                    Move iServerIndexX to iServerIndex
35218>>>>>>>>>>>>>>>                    Function_Return hDatabase
35219>>>>>>>>>>>>>>>                End
35219>>>>>>>>>>>>>>>>
35219>>>>>>>>>>>>>>>            Loop
35220>>>>>>>>>>>>>>>>
35220>>>>>>>>>>>>>>>        End
35220>>>>>>>>>>>>>>>>
35220>>>>>>>>>>>>>>>        Function_Return 0
35221>>>>>>>>>>>>>>>    End_Function
35222>>>>>>>>>>>>>>>    
35222>>>>>>>>>>>>>>>    Function TableCacheTimeout Integer iTable Returns Integer
35225>>>>>>>>>>>>>>>        Integer hDatabaseHandle iDriverIndex iServerIndex iTimeOutMS
35225>>>>>>>>>>>>>>>        Get TableDatabaseHandle iTable (&iDriverIndex) (&iServerIndex) to hDatabaseHandle
35226>>>>>>>>>>>>>>>        If (hDatabaseHandle>0) Begin
35228>>>>>>>>>>>>>>>            Get_Attribute DF_DATABASE_FIND_CACHE_TIMEOUT of iDriverIndex hDatabaseHandle to iTimeOutMS
35231>>>>>>>>>>>>>>>        End
35231>>>>>>>>>>>>>>>>
35231>>>>>>>>>>>>>>>        Else Begin
35232>>>>>>>>>>>>>>>            Error 232 ("Could not get cache timeout for table "+String(iTable))
35233>>>>>>>>>>>>>>>>
35233>>>>>>>>>>>>>>>        End
35233>>>>>>>>>>>>>>>>
35233>>>>>>>>>>>>>>>        Function_Return iTimeOutMS
35234>>>>>>>>>>>>>>>    End_Function
35235>>>>>>>>>>>>>>>    
35235>>>>>>>>>>>>>>>    //> It actually influences all tables opened on the
35235>>>>>>>>>>>>>>>    Procedure Set TableCacheTimeout Integer iTable Integer iTimeOutMS
35238>>>>>>>>>>>>>>>        Integer hDatabaseHandle iDriverIndex iServerIndex
35238>>>>>>>>>>>>>>>        Get TableDatabaseHandle iTable (&iDriverIndex) (&iServerIndex) to hDatabaseHandle
35239>>>>>>>>>>>>>>>        If (hDatabaseHandle>0) Begin
35241>>>>>>>>>>>>>>>            Set_Attribute DF_DATABASE_FIND_CACHE_TIMEOUT of iDriverIndex hDatabaseHandle to iTimeOutMS
35244>>>>>>>>>>>>>>>        End
35244>>>>>>>>>>>>>>>>
35244>>>>>>>>>>>>>>>        Else Begin
35245>>>>>>>>>>>>>>>            Error 231 ("Could not set cache timeout for table "+String(iTable))
35246>>>>>>>>>>>>>>>>
35246>>>>>>>>>>>>>>>        End
35246>>>>>>>>>>>>>>>>
35246>>>>>>>>>>>>>>>    End_Procedure
35247>>>>>>>>>>>>>>>End_Object
35248>>>>>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
35248>>>>>>>>>>>>>Use WorkSpaceFunctions.pkg
Including file: WorkSpaceFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\WorkSpaceFunctions.pkg)
35248>>>>>>>>>>>>>>>// Use WorkSpaceFunctions.pkg // Workspace functions encapsulated in WsFunctions object (StureApsPublicLib)
35248>>>>>>>>>>>>>>>
35248>>>>>>>>>>>>>>>Use VdfBase.pkg // DAW package, provides low level support expected of all VDF applications (windows and webapp)
35248>>>>>>>>>>>>>>>Use cRegistry.pkg // DAW package, provides access to the Windows system Registry
35248>>>>>>>>>>>>>>>Use Windows.pkg
35248>>>>>>>>>>>>>>>
35248>>>>>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
35248>>>>>>>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
35248>>>>>>>>>>>>>>>Use VdfRuntime.pkg
35248>>>>>>>>>>>>>>>Use RegistryFunctions.pkg
35248>>>>>>>>>>>>>>>
35248>>>>>>>>>>>>>>>Use cApplication.pkg
35248>>>>>>>>>>>>>>>Use cWorkspace.pkg
35248>>>>>>>>>>>>>>>
35248>>>>>>>>>>>>>>>Use cIniFile.pkg
35248>>>>>>>>>>>>>>>
35248>>>>>>>>>>>>>>>Global_Variable Integer oWsSelector
35248>>>>>>>>>>>>>>>Global_Variable Integer oWorkSpaceFunctions
35248>>>>>>>>>>>>>>>
35248>>>>>>>>>>>>>>>Struct tWorkSpaceFile // (.ws file)
35248>>>>>>>>>>>>>>>    String sAppSrcPath     
35248>>>>>>>>>>>>>>>    String sBitmapPath     
35248>>>>>>>>>>>>>>>    String sDataPath       
35248>>>>>>>>>>>>>>>    String sDdSrcPath      
35248>>>>>>>>>>>>>>>    String sDescription    
35248>>>>>>>>>>>>>>>    String sFileList       
35248>>>>>>>>>>>>>>>    String sHelpPath       
35248>>>>>>>>>>>>>>>    String sHome           
35248>>>>>>>>>>>>>>>    String sIdeSrcPath     
35248>>>>>>>>>>>>>>>    String sProgramPath    
35248>>>>>>>>>>>>>>>    String sAppHtmlPath    
35248>>>>>>>>>>>>>>>    String sWorkspaceName  
35248>>>>>>>>>>>>>>>    String sWorkspaceWSFile
35248>>>>>>>>>>>>>>>                           
35248>>>>>>>>>>>>>>>    String sSystemDfPath
35248>>>>>>>>>>>>>>>    String sSystemMakePath 
35248>>>>>>>>>>>>>>>    String sDfPath
35248>>>>>>>>>>>>>>>End_Struct
35248>>>>>>>>>>>>>>>
35248>>>>>>>>>>>>>>>Struct tStudioWorkSpaceFile // (.sws file)
35248>>>>>>>>>>>>>>>    String   sSwsFilePath
35248>>>>>>>>>>>>>>>    String   sVdfVersion
35248>>>>>>>>>>>>>>>    String   sConfigFile
35248>>>>>>>>>>>>>>>    String[] aProjects
35248>>>>>>>>>>>>>>>    String   sDataDictClass
35248>>>>>>>>>>>>>>>    String   sDataDictPkg
35248>>>>>>>>>>>>>>>    tWorkSpaceFile strWorkSpaceFile
35248>>>>>>>>>>>>>>>    tWorkSpaceFile strWorkSpaceFile
35248>>>>>>>>>>>>>>>    tStudioWorkSpaceFile[] aLibraries
35248>>>>>>>>>>>>>>>    tStudioWorkSpaceFile[] aLibraries
35248>>>>>>>>>>>>>>>End_Struct
35248>>>>>>>>>>>>>>>
35248>>>>>>>>>>>>>>>
35248>>>>>>>>>>>>>>>Object _oWorkSpaceFunctions is a cObject
35250>>>>>>>>>>>>>>>    Move Self to oWorkSpaceFunctions
35251>>>>>>>>>>>>>>>    
35251>>>>>>>>>>>>>>>    Object _oRecentWs is a cRegistry // Private
35253>>>>>>>>>>>>>>>//            Set pfAccessRights to (KEY_READ+KEY_ENUMERATE_SUB_KEYS)
35253>>>>>>>>>>>>>>>        Set phRootKey to HKEY_CURRENT_USER
35254>>>>>>>>>>>>>>>    End_Object
35255>>>>>>>>>>>>>>>    
35255>>>>>>>>>>>>>>>    // Reads data out of the .ws file and all of the included libraries recursively
35255>>>>>>>>>>>>>>>    Function WorkspaceStruct String sWorkspaceFile Returns tWorkSpaceFile
35258>>>>>>>>>>>>>>>        // Content of this function is largely stolen from function OpenWorkspaceFile in DAW
35258>>>>>>>>>>>>>>>        // package cWorkspace.pkg:
35258>>>>>>>>>>>>>>>        Handle hoIniFile
35258>>>>>>>>>>>>>>>        Pointer lpsApplicationStartPath
35258>>>>>>>>>>>>>>>        tWorkSpaceFile strWS
35258>>>>>>>>>>>>>>>        tWorkSpaceFile strWS
35258>>>>>>>>>>>>>>>        String sApplicationStartPath sWsName sOldDirectory
35258>>>>>>>>>>>>>>>        String sHome sAppSrcPath sBitmapPath sDataPath sDdSrcPath sDescription sAppHtmlPath
35258>>>>>>>>>>>>>>>        String sFileList sHelpPath sIdeSrcPath sProgramPath sWorkspaceName
35258>>>>>>>>>>>>>>>        String sPath
35258>>>>>>>>>>>>>>>
35258>>>>>>>>>>>>>>>        
35258>>>>>>>>>>>>>>>        If (FileExists(oFileFunctions,sWorkspaceFile)=1) Begin
35260>>>>>>>>>>>>>>>            
35260>>>>>>>>>>>>>>>            Get PathToFolder of oFileFunctions sWorkspaceFile to sPath
35261>>>>>>>>>>>>>>>        
35261>>>>>>>>>>>>>>>            Get Create U_cIniFile to hoIniFile
35262>>>>>>>>>>>>>>>            Set psFilename of hoIniFile to sWorkspaceFile
35263>>>>>>>>>>>>>>>    
35263>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "Home" ""          to sHome
35264>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "AppSrcPath" ""    to sAppSrcPath
35265>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "AppHtmlPath" ""   to sAppHtmlPath
35266>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "BitmapPath" ""    to sBitmapPath
35267>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "DataPath" ""      to sDataPath
35268>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "DdSrcPath" ""     to sDdSrcPath
35269>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "FileList" ""      to sFileList
35270>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "HelpPath" ""      to sHelpPath
35271>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "IdeSrcPath" ""    to sIdeSrcPath
35272>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "ProgramPath" ""   to sProgramPath
35273>>>>>>>>>>>>>>>            Move (Left(sWsName, Length(sWsName) -3))                   to sWorkspaceName
35274>>>>>>>>>>>>>>>    
35274>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions sPath sHome to strWS.sHome
35275>>>>>>>>>>>>>>>    
35275>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sAppSrcPath    to strWS.sAppSrcPath 
35276>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sAppHtmlPath   to strWS.sAppHtmlPath
35277>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sBitmapPath    to strWS.sBitmapPath 
35278>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sDataPath      to strWS.sDataPath   
35279>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sDdSrcPath     to strWS.sDdSrcPath  
35280>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sFileList      to strWS.sFileList   
35281>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sHelpPath      to strWS.sHelpPath   
35282>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sIdeSrcPath    to strWS.sIdeSrcPath 
35283>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sWorkspaceName to strWS.sWorkspaceName 
35284>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sProgramPath   to strWS.sProgramPath
35285>>>>>>>>>>>>>>>    
35285>>>>>>>>>>>>>>>            Send Destroy of hoIniFile // destroy dynaically created inifile object
35286>>>>>>>>>>>>>>>    
35286>>>>>>>>>>>>>>>        End
35286>>>>>>>>>>>>>>>>
35286>>>>>>>>>>>>>>>
35286>>>>>>>>>>>>>>>        Function_Return strWS
35287>>>>>>>>>>>>>>>    End_Function
35288>>>>>>>>>>>>>>>    
35288>>>>>>>>>>>>>>>    // Reads data out of the .sws file and all of the included libraries recursively
35288>>>>>>>>>>>>>>>    Function StudioWorkspaceStruct String sSwsPath Returns tStudioWorkSpaceFile
35291>>>>>>>>>>>>>>>        Integer hIniFile
35291>>>>>>>>>>>>>>>        Integer hArray iMax iIndex
35291>>>>>>>>>>>>>>>        tStudioWorkSpaceFile strWSfile
35291>>>>>>>>>>>>>>>        tStudioWorkSpaceFile strWSfile
35291>>>>>>>>>>>>>>>        String sValueName sFolder sValue sPath
35291>>>>>>>>>>>>>>>        
35291>>>>>>>>>>>>>>>        Get Create U_cIniFile to hIniFile
35292>>>>>>>>>>>>>>>        Get Create U_Array to hArray
35293>>>>>>>>>>>>>>>        
35293>>>>>>>>>>>>>>>        Set psFileName of hIniFile to sSwsPath
35294>>>>>>>>>>>>>>>        Move sSwsPath to strWSfile.sSwsFilePath
35295>>>>>>>>>>>>>>>        
35295>>>>>>>>>>>>>>>        Get ReadString of hIniFile "Properties" "Version" "" to strWSfile.sVdfVersion
35296>>>>>>>>>>>>>>>        Get ReadString of hIniFile "WorkspacePaths" "ConfigFile" "" to strWSfile.sConfigFile
35297>>>>>>>>>>>>>>>        
35297>>>>>>>>>>>>>>>        If (strWSfile.sConfigFile<>"") Begin // If a ws file is specified, we will read it
35299>>>>>>>>>>>>>>>            If (Left(strWSfile.sConfigFile,2)=".\") Begin
35301>>>>>>>>>>>>>>>                Get PathToFolder of oFileFunctions sSwsPath to sPath
35302>>>>>>>>>>>>>>>                Move (Replace(".",strWSfile.sConfigFile,sPath)) to strWSfile.sConfigFile
35303>>>>>>>>>>>>>>>            End
35303>>>>>>>>>>>>>>>>
35303>>>>>>>>>>>>>>>            Get WorkspaceStruct strWSfile.sConfigFile to strWSfile.strWorkSpaceFile
35304>>>>>>>>>>>>>>>        End
35304>>>>>>>>>>>>>>>>
35304>>>>>>>>>>>>>>>        
35304>>>>>>>>>>>>>>>        Send Delete_Data of hArray
35305>>>>>>>>>>>>>>>        Send ReadSection of hIniFile "Projects" hArray
35306>>>>>>>>>>>>>>>        Get Item_Count of hArray to iMax
35307>>>>>>>>>>>>>>>        Decrement iMax
35308>>>>>>>>>>>>>>>        For iIndex from 0 to iMax
35314>>>>>>>>>>>>>>>>
35314>>>>>>>>>>>>>>>            Get Value of hArray iIndex to sValueName 
35315>>>>>>>>>>>>>>>            Get ReadString of hIniFile "Projects" sValueName "" to strWSfile.aProjects[iIndex]
35316>>>>>>>>>>>>>>>        Loop
35317>>>>>>>>>>>>>>>>
35317>>>>>>>>>>>>>>>        
35317>>>>>>>>>>>>>>>        Get ReadString of hIniFile "DataDictionary" "class" "" to strWSfile.sDataDictClass
35318>>>>>>>>>>>>>>>        Get ReadString of hIniFile "DataDictionary" "file" "" to strWSfile.sDataDictPkg
35319>>>>>>>>>>>>>>>        
35319>>>>>>>>>>>>>>>        Get PathToFolder of oFileFunctions sSwsPath to sFolder
35320>>>>>>>>>>>>>>>        Send Delete_Data of hArray
35321>>>>>>>>>>>>>>>        Send ReadSection of hIniFile "Libraries" hArray
35322>>>>>>>>>>>>>>>        Get Item_Count of hArray to iMax
35323>>>>>>>>>>>>>>>        Decrement iMax
35324>>>>>>>>>>>>>>>        For iIndex from 0 to iMax
35330>>>>>>>>>>>>>>>>
35330>>>>>>>>>>>>>>>            Get Value of hArray iIndex to sValueName 
35331>>>>>>>>>>>>>>>            Get ReadString of hIniFile "Libraries" sValueName "" to sSwsPath
35332>>>>>>>>>>>>>>>
35332>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions sFolder sSwsPath to sSwsPath
35333>>>>>>>>>>>>>>>            Get StudioWorkspaceStruct sSwsPath to strWSfile.aLibraries[iIndex]
35334>>>>>>>>>>>>>>>        Loop
35335>>>>>>>>>>>>>>>>
35335>>>>>>>>>>>>>>>
35335>>>>>>>>>>>>>>>        Send Destroy of hArray
35336>>>>>>>>>>>>>>>        Send Destroy of hIniFile
35337>>>>>>>>>>>>>>>        Function_Return strWSfile
35338>>>>>>>>>>>>>>>    End_Function
35339>>>>>>>>>>>>>>>    
35339>>>>>>>>>>>>>>>    Function VdfRootFolder tStudioWorkSpaceFile strWorkspace Returns String
35342>>>>>>>>>>>>>>>        tVdfRuntime strRuntime
35342>>>>>>>>>>>>>>>        tVdfRuntime strRuntime
35342>>>>>>>>>>>>>>>        If (strWorkspace.sVdfVersion<>"") Begin
35344>>>>>>>>>>>>>>>            Get RuntimeStruct of oVdfRuntimeFunctions strWorkspace.sVdfVersion to strRuntime
35345>>>>>>>>>>>>>>>            Function_Return strRuntime.sRootFolder
35346>>>>>>>>>>>>>>>        End
35346>>>>>>>>>>>>>>>>
35346>>>>>>>>>>>>>>>        Function_Return "" 
35347>>>>>>>>>>>>>>>    End_Function
35348>>>>>>>>>>>>>>>    
35348>>>>>>>>>>>>>>>//        Function _AddWorkspace tStudioWorkSpaceFile strWS tStudioWorkSpaceFile[] ByRef aWS Returns Boolean
35348>>>>>>>>>>>>>>>//            Integer iItem iMax
35348>>>>>>>>>>>>>>>//            Move (SizeOfArray(aWS)-1) to iMax
35348>>>>>>>>>>>>>>>//            For iItem from 0 to iMax
35348>>>>>>>>>>>>>>>//                If (Lowercase(strWS.sSwsFilePath)=Lowercase(aWS[iItem].sSwsFilePath)) Begin
35348>>>>>>>>>>>>>>>//                    Function_Return False
35348>>>>>>>>>>>>>>>//                End
35348>>>>>>>>>>>>>>>//            Loop
35348>>>>>>>>>>>>>>>//            Move (ResizeArray(strWS.aLibraries,0)) to strWS.aLibraries
35348>>>>>>>>>>>>>>>//            Move strWS to aWS[iMax+1]
35348>>>>>>>>>>>>>>>//            Function_Return True
35348>>>>>>>>>>>>>>>//        End_Function
35348>>>>>>>>>>>>>>>//        
35348>>>>>>>>>>>>>>>//        Procedure _WorkspaceList tStudioWorkSpaceFile strWS tStudioWorkSpaceFile[] ByRef aWS 
35348>>>>>>>>>>>>>>>//            Integer iMax iItem
35348>>>>>>>>>>>>>>>//            If (_AddWorkspace(Self,strWS,&aWS)) Begin
35348>>>>>>>>>>>>>>>//                Move (SizeOfArray(strWS.aLibraries)-1) to iMax
35348>>>>>>>>>>>>>>>//                For iItem from 0 to iMax
35348>>>>>>>>>>>>>>>//                    Send _WorkspaceList strWS.aLibraries[iItem] (&aWS)
35348>>>>>>>>>>>>>>>//                Loop
35348>>>>>>>>>>>>>>>//            End
35348>>>>>>>>>>>>>>>//        End_Procedure
35348>>>>>>>>>>>>>>>//    
35348>>>>>>>>>>>>>>>//    Function WorkspaceLibraryList String sSwsPath Returns tStudioWorkSpaceFile[]
35348>>>>>>>>>>>>>>>//        tStudioWorkSpaceFile[] strWS
35348>>>>>>>>>>>>>>>//        tStudioWorkSpaceFile[] aWS
35348>>>>>>>>>>>>>>>//        Get StudioWorkspaceStruct sSwsPath to strWS
35348>>>>>>>>>>>>>>>//        Send _WorkspaceList strWS (&aWS)
35348>>>>>>>>>>>>>>>//        Function_Return aWS
35348>>>>>>>>>>>>>>>//    End_Function
35348>>>>>>>>>>>>>>>    
35348>>>>>>>>>>>>>>>        Procedure _AddFolder String sFolder String[] ByRef aFolders
35351>>>>>>>>>>>>>>>            Integer iMax iItem
35351>>>>>>>>>>>>>>>            Move (SizeOfArray(aFolders)-1) to iMax
35352>>>>>>>>>>>>>>>            For iItem from 0 to iMax
35358>>>>>>>>>>>>>>>>
35358>>>>>>>>>>>>>>>                If (Lowercase(sFolder)=Lowercase(aFolders[iItem])) Begin
35360>>>>>>>>>>>>>>>                    Procedure_Return
35361>>>>>>>>>>>>>>>                End
35361>>>>>>>>>>>>>>>>
35361>>>>>>>>>>>>>>>            Loop
35362>>>>>>>>>>>>>>>>
35362>>>>>>>>>>>>>>>            Move sFolder to aFolders[iMax+1]
35363>>>>>>>>>>>>>>>        End_Procedure
35364>>>>>>>>>>>>>>>        
35364>>>>>>>>>>>>>>>        Procedure _AddLibraryAppSrcFolder tStudioWorkSpaceFile strLibrary String[] ByRef aFolders
35367>>>>>>>>>>>>>>>            Integer iMax iItem
35367>>>>>>>>>>>>>>>            Send _AddFolder strLibrary.strWorkSpaceFile.sAppSrcPath (&aFolders)
35368>>>>>>>>>>>>>>>            Move (SizeOfArray(strLibrary.aLibraries)-1) to iMax
35369>>>>>>>>>>>>>>>            For iItem from 0 to iMax
35375>>>>>>>>>>>>>>>>
35375>>>>>>>>>>>>>>>                Send _AddLibraryAppSrcFolder strLibrary.aLibraries[iItem] (&aFolders)
35376>>>>>>>>>>>>>>>            Loop 
35377>>>>>>>>>>>>>>>>
35377>>>>>>>>>>>>>>>        End_Procedure
35378>>>>>>>>>>>>>>>    
35378>>>>>>>>>>>>>>>    Function WorkspaceSourceFolders String sSwsPath Boolean bIncludeVdfPkgFolder Returns String[]
35381>>>>>>>>>>>>>>>        Integer iMax iItem
35381>>>>>>>>>>>>>>>        String sFolder
35381>>>>>>>>>>>>>>>        String[] aFolders
35382>>>>>>>>>>>>>>>        tStudioWorkSpaceFile strCurrentWorkSpace
35382>>>>>>>>>>>>>>>        tStudioWorkSpaceFile strCurrentWorkSpace
35382>>>>>>>>>>>>>>>        tVdfRuntime strRuntime
35382>>>>>>>>>>>>>>>        tVdfRuntime strRuntime
35382>>>>>>>>>>>>>>>        
35382>>>>>>>>>>>>>>>        Get StudioWorkspaceStruct sSwsPath to strCurrentWorkSpace
35383>>>>>>>>>>>>>>>        Send _AddFolder strCurrentWorkSpace.strWorkSpaceFile.sAppSrcPath (&aFolders)
35384>>>>>>>>>>>>>>>        Send _AddFolder strCurrentWorkSpace.strWorkSpaceFile.sDdSrcPath (&aFolders)
35385>>>>>>>>>>>>>>>        
35385>>>>>>>>>>>>>>>        Move (SizeOfArray(strCurrentWorkSpace.aLibraries)-1) to iMax
35386>>>>>>>>>>>>>>>        For iItem from 0 to iMax
35392>>>>>>>>>>>>>>>>
35392>>>>>>>>>>>>>>>            Send _AddLibraryAppSrcFolder strCurrentWorkSpace.aLibraries[iItem] (&aFolders)
35393>>>>>>>>>>>>>>>        Loop
35394>>>>>>>>>>>>>>>>
35394>>>>>>>>>>>>>>>            
35394>>>>>>>>>>>>>>>        If (bIncludeVdfPkgFolder) Begin
35396>>>>>>>>>>>>>>>            Get RuntimeStruct of oVdfRuntimeFunctions strCurrentWorkSpace.sVdfVersion to strRuntime
35397>>>>>>>>>>>>>>>            
35397>>>>>>>>>>>>>>>            If (strRuntime.sRootFolder<>"") Begin
35399>>>>>>>>>>>>>>>                Get AppendPath of oFileFunctions strRuntime.sRootFolder "Pkg" to sFolder
35400>>>>>>>>>>>>>>>                Send _AddFolder sFolder (&aFolders)
35401>>>>>>>>>>>>>>>            End 
35401>>>>>>>>>>>>>>>>
35401>>>>>>>>>>>>>>>        End
35401>>>>>>>>>>>>>>>>
35401>>>>>>>>>>>>>>>        Function_Return aFolders
35402>>>>>>>>>>>>>>>    End_Function
35403>>>>>>>>>>>>>>>    
35403>>>>>>>>>>>>>>>    Procedure _ReadRegistryRecentWorkSpacesOfVdfVersion String sVdfVerDotRev String[] ByRef aValues
35406>>>>>>>>>>>>>>>        Boolean bOpen
35406>>>>>>>>>>>>>>>        Handle hoArray
35406>>>>>>>>>>>>>>>        Integer iMaxKey iKey iCount
35406>>>>>>>>>>>>>>>        String sKey sVdfKey sKeyValue
35406>>>>>>>>>>>>>>>        
35406>>>>>>>>>>>>>>>        Get OpenKey of _oRecentWs ("Software\Data Access Worldwide\Visual DataFlex Tools\"+sVdfVerDotRev+"\Studio\RecentWorkspaces") to bOpen
35407>>>>>>>>>>>>>>>        If (bOpen) Begin
35409>>>>>>>>>>>>>>>            Get Create U_Array to hoArray // Create an array object
35410>>>>>>>>>>>>>>>            Get GetValues of _oRecentWs hoArray to iMaxKey
35411>>>>>>>>>>>>>>>            Decrement iMaxKey
35412>>>>>>>>>>>>>>>            Move (SizeOfArray(aValues)) to iCount
35413>>>>>>>>>>>>>>>            For iKey from 0 to iMaxKey
35419>>>>>>>>>>>>>>>>
35419>>>>>>>>>>>>>>>                Get value of hoArray iKey to sKey
35420>>>>>>>>>>>>>>>                Get ReadString of _oRecentWs sKey to sKeyValue
35421>>>>>>>>>>>>>>>                If (sKeyValue<>"") Begin // Empty values may occur
35423>>>>>>>>>>>>>>>                    Move sKeyValue to aValues[iCount]
35424>>>>>>>>>>>>>>>                    Increment iCount
35425>>>>>>>>>>>>>>>                End
35425>>>>>>>>>>>>>>>>
35425>>>>>>>>>>>>>>>            Loop
35426>>>>>>>>>>>>>>>>
35426>>>>>>>>>>>>>>>            Send Destroy of hoArray // Remove the array object from memory.
35427>>>>>>>>>>>>>>>            Send CloseKey of _oRecentWs
35428>>>>>>>>>>>>>>>        End
35428>>>>>>>>>>>>>>>>
35428>>>>>>>>>>>>>>>    End_Procedure
35429>>>>>>>>>>>>>>>
35429>>>>>>>>>>>>>>>    Procedure ReadRegistryRecentWorkSpacesOfVdfVersion String sVdfVerDotRev String[] ByRef aValues
35432>>>>>>>>>>>>>>>        Move (ResizeArray(aValues,0)) to aValues
35433>>>>>>>>>>>>>>>        Send _ReadRegistryRecentWorkSpacesOfVdfVersion sVdfVerDotRev (&aValues)
35434>>>>>>>>>>>>>>>    End_Procedure
35435>>>>>>>>>>>>>>>
35435>>>>>>>>>>>>>>>    //> The VDF studio stores its "Recent Workspaces" list in the Windows registry. Use the ReadRegistryRecentWorkSpaces
35435>>>>>>>>>>>>>>>    //> procedure to dig them out.
35435>>>>>>>>>>>>>>>    Procedure ReadRegistryRecentWorkSpaces String[] ByRef aValues
35438>>>>>>>>>>>>>>>        String sVdfVer sVdfRev sVdfBuild sVdfVerDotRev
35438>>>>>>>>>>>>>>>        Version_Information sVdfVer sVdfRev sVdfBuild
35440>>>>>>>>>>>>>>>        Move (sVdfVer+"."+sVdfRev) to sVdfVerDotRev
35441>>>>>>>>>>>>>>>        Send ReadRegistryRecentWorkSpacesOfVdfVersion sVdfVerDotRev (&aValues)
35442>>>>>>>>>>>>>>>    End_Procedure
35443>>>>>>>>>>>>>>>    
35443>>>>>>>>>>>>>>>    Procedure ReadRegistryRecentWorkspacesAllVersions String[] ByRef aValues
35446>>>>>>>>>>>>>>>        Integer iMax iIndex
35446>>>>>>>>>>>>>>>        Move (ResizeArray(aValues,0)) to aValues
35447>>>>>>>>>>>>>>>        Move (SizeOfArray(gaRuntimes)-1) to iMax
35448>>>>>>>>>>>>>>>        For iIndex from 0 to iMax
35454>>>>>>>>>>>>>>>>
35454>>>>>>>>>>>>>>>            Send _ReadRegistryRecentWorkSpacesOfVdfVersion gaRuntimes[iIndex].sVdfVersion (&aValues)
35455>>>>>>>>>>>>>>>        Loop
35456>>>>>>>>>>>>>>>>
35456>>>>>>>>>>>>>>>    End_Procedure
35457>>>>>>>>>>>>>>>
35457>>>>>>>>>>>>>>>    //> Returns a handle to cWorkSpace object currently in action.
35457>>>>>>>>>>>>>>>    Function WorkSpaceObject Returns Handle
35460>>>>>>>>>>>>>>>        Handle hRval
35460>>>>>>>>>>>>>>>        Move 0 to hRval
35461>>>>>>>>>>>>>>>        If (ghoApplication>=0) Begin
35463>>>>>>>>>>>>>>>            Get phoWorkspace of ghoApplication to hRval
35464>>>>>>>>>>>>>>>        End
35464>>>>>>>>>>>>>>>>
35464>>>>>>>>>>>>>>>        Function_Return hRval
35465>>>>>>>>>>>>>>>    End_Function
35466>>>>>>>>>>>>>>>
35466>>>>>>>>>>>>>>>    //> Returns the name (incl. full path) of the .ws file currently used.
35466>>>>>>>>>>>>>>>    Function WorkSpaceFile Returns String
35469>>>>>>>>>>>>>>>        Handle hoWs
35469>>>>>>>>>>>>>>>        String sFile
35469>>>>>>>>>>>>>>>        Get WorkSpaceObject to hoWs
35470>>>>>>>>>>>>>>>        If (hoWs>0) Begin
35472>>>>>>>>>>>>>>>            Get psWorkspaceWSFile of hoWs to sFile
35473>>>>>>>>>>>>>>>        End
35473>>>>>>>>>>>>>>>>
35473>>>>>>>>>>>>>>>        Else Begin
35474>>>>>>>>>>>>>>>            Move "" to sFile
35475>>>>>>>>>>>>>>>        End
35475>>>>>>>>>>>>>>>>
35475>>>>>>>>>>>>>>>        Function_Return sFile
35476>>>>>>>>>>>>>>>    End_Function
35477>>>>>>>>>>>>>>>    
35477>>>>>>>>>>>>>>>    Function SwsFileVersion String sSws String ByRef sVdfVer Returns Boolean
35480>>>>>>>>>>>>>>>        Boolean bSeqEof
35480>>>>>>>>>>>>>>>        Integer iChannel
35480>>>>>>>>>>>>>>>        String sLine
35480>>>>>>>>>>>>>>>        Move "" to sVdfVer
35481>>>>>>>>>>>>>>>        Get DirectInput of oFileFunctions sSws to iChannel
35482>>>>>>>>>>>>>>>        If (iChannel>=0) Begin
35484>>>>>>>>>>>>>>>            Repeat
35484>>>>>>>>>>>>>>>>
35484>>>>>>>>>>>>>>>                Readln channel iChannel sLine
35486>>>>>>>>>>>>>>>                Move (SeqEof) to bSeqEof
35487>>>>>>>>>>>>>>>                If (not(bSeqEof)) Begin
35489>>>>>>>>>>>>>>>                    If (Left(sLine,8)="Version=") Begin
35491>>>>>>>>>>>>>>>                        Send CloseInput of oFileFunctions iChannel
35492>>>>>>>>>>>>>>>                        Move (Replace("Version=",sLine,"")) to sVdfVer
35493>>>>>>>>>>>>>>>                        Function_Return True
35494>>>>>>>>>>>>>>>                    End
35494>>>>>>>>>>>>>>>>
35494>>>>>>>>>>>>>>>                End
35494>>>>>>>>>>>>>>>>
35494>>>>>>>>>>>>>>>            Until (bSeqEof)
35496>>>>>>>>>>>>>>>            Send CloseInput of oFileFunctions iChannel
35497>>>>>>>>>>>>>>>        End
35497>>>>>>>>>>>>>>>>
35497>>>>>>>>>>>>>>>        Function_Return False
35498>>>>>>>>>>>>>>>    End_Function
35499>>>>>>>>>>>>>>>    
35499>>>>>>>>>>>>>>>    //> Use this function to calculate the absolute path of the .ws file corresponding to the abslute path of a .sws file given as parameter.
35499>>>>>>>>>>>>>>>    Function SwsFileToWsFile String sSwsFile Returns String
35502>>>>>>>>>>>>>>>        Boolean bStop
35502>>>>>>>>>>>>>>>        //Integer iChannel
35502>>>>>>>>>>>>>>>        Handle hoIniFile
35502>>>>>>>>>>>>>>>        String sWsFile sLine
35502>>>>>>>>>>>>>>>
35502>>>>>>>>>>>>>>>        Get Create U_cIniFile To hoIniFile
35503>>>>>>>>>>>>>>>
35503>>>>>>>>>>>>>>>        Set psFilename of hoIniFile To sSwsFile
35504>>>>>>>>>>>>>>>        Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" To sWsFile
35505>>>>>>>>>>>>>>>        Send Destroy of hoIniFile // destroy dynaically created inifile object
35506>>>>>>>>>>>>>>>
35506>>>>>>>>>>>>>>>        If (left(sWsFile,2)=".\") Begin // If that's not the case we assume that the path is absolute. (Maybe someday it is necessary to take "..\" into account also).
35508>>>>>>>>>>>>>>>            Move (Remove(swsFile,1,2)) to sWsFile // Remove the first two characters
35509>>>>>>>>>>>>>>>            Get PathToFolder of oFileFunctions sSwsFile to sSwsFile // "C:\Apps\FreeLib\FreeLib.sws" -> "C:\Apps\FreeLib"
35510>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions sSwsFile sWsFile to sWsFile
35511>>>>>>>>>>>>>>>        End
35511>>>>>>>>>>>>>>>>
35511>>>>>>>>>>>>>>>        Function_Return sWsFile
35512>>>>>>>>>>>>>>>    End_Function
35513>>>>>>>>>>>>>>>
35513>>>>>>>>>>>>>>>    //> Function OpenWorkspace takes a .sws or .ws file and calls the "OpenWorkSpaceFile" method of the current cWorkSpace object. The return
35513>>>>>>>>>>>>>>>    //> value is one of the following:
35513>>>>>>>>>>>>>>>    //>     -1                      : cWorkSpace object not found
35513>>>>>>>>>>>>>>>    //>     wsWorkspaceOpened       : WS opened ok
35513>>>>>>>>>>>>>>>    //>     wsWorkspaceNotFound     : the named WS was not found in the global list
35513>>>>>>>>>>>>>>>    //>     wsWorkspaceFileNotFound : the WS file was not found
35513>>>>>>>>>>>>>>>    //>     wsDataPathEmpty         : the DataPath entry was empty
35513>>>>>>>>>>>>>>>    //>     wsFileListEmpty         : The FileList entry was empty
35513>>>>>>>>>>>>>>>    //>     wsFileListNotExist      : The FileList.cfg file could not be found
35513>>>>>>>>>>>>>>>    //>
35513>>>>>>>>>>>>>>>    //> Most likely, you want to close all tables before calling this function.
35513>>>>>>>>>>>>>>>    //>
35513>>>>>>>>>>>>>>>    Function OpenWorkspace String sFile Returns Integer
35516>>>>>>>>>>>>>>>        Handle hoWs
35516>>>>>>>>>>>>>>>        Integer iRval
35516>>>>>>>>>>>>>>>        Get WorkSpaceObject to hoWs
35517>>>>>>>>>>>>>>>        If (hoWs>=0) Begin
35519>>>>>>>>>>>>>>>            If (Lowercase(PathToFileName(oFileFunctions,sFile))="filelist.cfg") Begin
35521>>>>>>>>>>>>>>>                // If this function is passed a filelist.cfg we have to give
35521>>>>>>>>>>>>>>>                // special treatment to the workspace object:
35521>>>>>>>>>>>>>>>                Send DoClearPaths of hoWs
35522>>>>>>>>>>>>>>>                Set psHome            of hoWs to (PathToFolder(oFileFunctions,sFile))
35523>>>>>>>>>>>>>>>                Set psWorkspaceName   of hoWs to ""
35524>>>>>>>>>>>>>>>                Set psAppSrcPath      of hoWs to ""
35525>>>>>>>>>>>>>>>                Set psAppHtmlPath     of hoWs to ""
35526>>>>>>>>>>>>>>>                Set psBitmapPath      of hoWs to ""
35527>>>>>>>>>>>>>>>                Set psDataPath        of hoWs to (PathToFolder(oFileFunctions,sFile))
35528>>>>>>>>>>>>>>>                Set psDdSrcPath       of hoWs to ""
35529>>>>>>>>>>>>>>>                Set psDescription     of hoWs to ""
35530>>>>>>>>>>>>>>>                Set psFileList        of hoWs to sFile
35531>>>>>>>>>>>>>>>                Set psHelpPath        of hoWs to ""
35532>>>>>>>>>>>>>>>                Set psIdeSrcPath      of hoWs to ""
35533>>>>>>>>>>>>>>>                Set psProgramPath     of hoWs to ""
35534>>>>>>>>>>>>>>>                Set psSystemDfPath    of hoWs to (VdfSystemDfPath(hoWs))
35535>>>>>>>>>>>>>>>                Set psSystemMakePath  of hoWs to (VdfSystemMakePath(hoWs))
35536>>>>>>>>>>>>>>>                Set psWorkspaceWSFile of hoWs to ""
35537>>>>>>>>>>>>>>>
35537>>>>>>>>>>>>>>>                Set psDfPath           of hoWS to (PathToFolder(oFileFunctions,sFile))
35538>>>>>>>>>>>>>>>                Set_Attribute DF_FILELIST_NAME to sFile
35541>>>>>>>>>>>>>>>                Set_Attribute DF_OPEN_PATH     to (PathToFolder(oFileFunctions,sFile))
35544>>>>>>>>>>>>>>>                Move wsWorkspaceOpened to iRval
35545>>>>>>>>>>>>>>>            End
35545>>>>>>>>>>>>>>>>
35545>>>>>>>>>>>>>>>            Else Begin
35546>>>>>>>>>>>>>>>                If (Lowercase(Right(sFile,4))=".sws") Begin
35548>>>>>>>>>>>>>>>                    Get SwsFileToWsFile sFile to sFile
35549>>>>>>>>>>>>>>>                End
35549>>>>>>>>>>>>>>>>
35549>>>>>>>>>>>>>>>                Send DoClearPaths of hoWs
35550>>>>>>>>>>>>>>>                Get OpenWorkspaceFile of hoWs sFile to iRval
35551>>>>>>>>>>>>>>>            End
35551>>>>>>>>>>>>>>>>
35551>>>>>>>>>>>>>>>        End
35551>>>>>>>>>>>>>>>>
35551>>>>>>>>>>>>>>>        Else Begin
35552>>>>>>>>>>>>>>>            Error 232 "Workspace object not found (WorkSpaceFunctions.pkg)"
35553>>>>>>>>>>>>>>>>
35553>>>>>>>>>>>>>>>        End
35553>>>>>>>>>>>>>>>>
35553>>>>>>>>>>>>>>>        Function_Return iRval
35554>>>>>>>>>>>>>>>    End_Function
35555>>>>>>>>>>>>>>>
35555>>>>>>>>>>>>>>>    Function OpenWorkspaceErrorText integer iReturnValue returns string
35558>>>>>>>>>>>>>>>        if (iReturnValue=-1)                      function_return "cWorkSpace object not found"
35561>>>>>>>>>>>>>>>        if (iReturnValue=wsWorkspaceOpened)       function_return "WS opened ok"
35564>>>>>>>>>>>>>>>        if (iReturnValue=wsWorkspaceNotFound)     function_return "The named WS was not found in the global list"
35567>>>>>>>>>>>>>>>        if (iReturnValue=wsWorkspaceFileNotFound) function_return "The WS file was not found"
35570>>>>>>>>>>>>>>>        if (iReturnValue=wsDataPathEmpty)         function_return "The DataPath entry was empty"
35573>>>>>>>>>>>>>>>        if (iReturnValue=wsFileListEmpty)         function_return "The FileList entry was empty"
35576>>>>>>>>>>>>>>>        if (iReturnValue=wsFileListNotExist)      function_return "'FileList.cfg' file could not be found"
35579>>>>>>>>>>>>>>>        function_return ""
35580>>>>>>>>>>>>>>>    End_Function
35581>>>>>>>>>>>>>>>
35581>>>>>>>>>>>>>>>    
35581>>>>>>>>>>>>>>>End_Object
35582>>>>>>>>>>>>>Use IntFileFunctions.pkg
Including file: IntFileFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\IntFileFunctions.pkg)
35582>>>>>>>>>>>>>>>Use VdfBase.pkg
35582>>>>>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
35582>>>>>>>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
35582>>>>>>>>>>>>>>>
35582>>>>>>>>>>>>>>>Struct cIntFile
35582>>>>>>>>>>>>>>>    String  sDriverName
35582>>>>>>>>>>>>>>>    String  sDatabaseName
35582>>>>>>>>>>>>>>>    String  sSchemaName
35582>>>>>>>>>>>>>>>    Integer iNumberOfDfFields
35582>>>>>>>>>>>>>>>    Integer iPrimaryIndex
35582>>>>>>>>>>>>>>>    String  sOptimize
35582>>>>>>>>>>>>>>>    Integer iMaxRowsToQuery
35582>>>>>>>>>>>>>>>    String  sLocalCache    
35582>>>>>>>>>>>>>>>End_Struct
35582>>>>>>>>>>>>>>>
35582>>>>>>>>>>>>>>>Object oIntFileFunctions is a cObject
35584>>>>>>>>>>>>>>>        Function _ReadItem String sLine String sLead Returns String
35587>>>>>>>>>>>>>>>        End_Function
35588>>>>>>>>>>>>>>>        
35588>>>>>>>>>>>>>>>        Procedure _ReadItemString String sLine String sLead String ByRef sValue
35591>>>>>>>>>>>>>>>            If (BeginsWith(oStringFunctions,sLine,sLead)) Begin
35593>>>>>>>>>>>>>>>                Move (Trim(Replace(sLead,sLine,""))) to sValue
35594>>>>>>>>>>>>>>>            End
35594>>>>>>>>>>>>>>>>
35594>>>>>>>>>>>>>>>        End_Procedure
35595>>>>>>>>>>>>>>>
35595>>>>>>>>>>>>>>>        Procedure _ReadItemInteger String sLine String sLead Integer ByRef iValue
35598>>>>>>>>>>>>>>>            If (BeginsWith(oStringFunctions,sLine,sLead)) Begin
35600>>>>>>>>>>>>>>>                Move (Trim(Replace(sLead,sLine,""))) to iValue
35601>>>>>>>>>>>>>>>            End
35601>>>>>>>>>>>>>>>>
35601>>>>>>>>>>>>>>>        End_Procedure
35602>>>>>>>>>>>>>>>    
35602>>>>>>>>>>>>>>>    Function ReadIntFile String sFileName Returns cIntFile
35605>>>>>>>>>>>>>>>        Boolean bSeqEof
35605>>>>>>>>>>>>>>>        Integer iChannel
35605>>>>>>>>>>>>>>>        String sLine sValue
35605>>>>>>>>>>>>>>>        cIntFile stIntFile
35605>>>>>>>>>>>>>>>        cIntFile stIntFile
35605>>>>>>>>>>>>>>>        Get DirectInput of oFileFunctions sFileName to iChannel
35606>>>>>>>>>>>>>>>        If (iChannel>=0) Begin
35608>>>>>>>>>>>>>>>            Repeat
35608>>>>>>>>>>>>>>>>
35608>>>>>>>>>>>>>>>                Readln channel iChannel sLine
35610>>>>>>>>>>>>>>>                Move (SeqEof) to bSeqeof
35611>>>>>>>>>>>>>>>                If (not(bSeqEof)) Begin
35613>>>>>>>>>>>>>>>                    Send _ReadItemString  sLine "DRIVER_NAME "       (&stIntFile.sDriverName)
35614>>>>>>>>>>>>>>>                    Send _ReadItemString  sLine "DATABASE_NAME "     (&stIntFile.sDatabaseName)
35615>>>>>>>>>>>>>>>                    Send _ReadItemString  sLine "SCHEMA_NAME "       (&stIntFile.sSchemaName)
35616>>>>>>>>>>>>>>>                    Send _ReadItemInteger sLine "NUMBER_DF_FIELDS "  (&stIntFile.iNumberOfDfFields)
35617>>>>>>>>>>>>>>>                    Send _ReadItemInteger sLine "PRIMARY_INDEX "     (&stIntFile.iPrimaryIndex)
35618>>>>>>>>>>>>>>>                    Send _ReadItemString  sLine "OPTIMIZE "          (&stIntFile.sOptimize)
35619>>>>>>>>>>>>>>>                    Send _ReadItemInteger sLine "MAX_ROWS_TO_QUERY " (&stIntFile.iMaxRowsToQuery)
35620>>>>>>>>>>>>>>>                    Send _ReadItemString  sLine "LOCAL_CACHE "       (&stIntFile.sLocalCache)
35621>>>>>>>>>>>>>>>                End
35621>>>>>>>>>>>>>>>>
35621>>>>>>>>>>>>>>>            Until (SeqEof)
35623>>>>>>>>>>>>>>>            Send CloseInput of oFileFunctions iChannel
35624>>>>>>>>>>>>>>>        End
35624>>>>>>>>>>>>>>>>
35624>>>>>>>>>>>>>>>        Function_Return stIntFile    
35625>>>>>>>>>>>>>>>    End_Function
35626>>>>>>>>>>>>>>>End_Object
35627>>>>>>>>>>>>>Use StackFunctions.pkg // Define oStackFunctions object
35627>>>>>>>>>>>>>
35627>>>>>>>>>>>>>// Define the maximum number of records defined in an embedded table for other packages to utilize:
35627>>>>>>>>>>>>>Define C_MaxNumberOfRecordsInEmbeddedTable for 16711679
35627>>>>>>>>>>>>>Define C_MaxRecordSizeEmbeddedTable for 16384
35627>>>>>>>>>>>>>
35627>>>>>>>>>>>>>Struct tTableOpenState
35627>>>>>>>>>>>>>    Integer iTable
35627>>>>>>>>>>>>>    Boolean bOpen
35627>>>>>>>>>>>>>    Integer iDriver    // Rest of the members only hold meaningful values if this member is not TA_DRIVER_ERROR
35627>>>>>>>>>>>>>    Integer iShareMode // DF_SHARE, DF_EXCLUSIVE
35627>>>>>>>>>>>>>
35627>>>>>>>>>>>>>       // DF_FILEMODE_ORIGINAL    -1 // only valid for smart_filemode in data sets
35627>>>>>>>>>>>>>       // DF_FILEMODE_DEFAULT     0
35627>>>>>>>>>>>>>       // DF_FILEMODE_NO_REREAD   1
35627>>>>>>>>>>>>>       // DF_FILEMODE_NO_LOCKS    2
35627>>>>>>>>>>>>>       // DF_FILEMODE_NO_EDITS    8
35627>>>>>>>>>>>>>       // DF_FILEMODE_NO_DELETES  16
35627>>>>>>>>>>>>>       // DF_FILEMODE_NO_FINDS    32
35627>>>>>>>>>>>>>       // DF_FILEMODE_NO_CREATES  64
35627>>>>>>>>>>>>>       // DF_FILEMODE_READONLY    91
35627>>>>>>>>>>>>>       // DF_FILEMODE_SINGLE_USER 3
35627>>>>>>>>>>>>>
35627>>>>>>>>>>>>>    Integer iFileMode  // DF_FILEMODE_DEFAULT, DF_FILEMODE_NO_REREAD etc etc etc
35627>>>>>>>>>>>>>    Integer iAliasMode // DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER, DF_FILE_IS_ALIAS
35627>>>>>>>>>>>>>    String  sPhysName  // Runtimes idea of the root name of the table
35627>>>>>>>>>>>>>End_Struct
35627>>>>>>>>>>>>>
35627>>>>>>>>>>>>>If (False) Begin
35629>>>>>>>>>>>>>    TableAccessOpenError: Move 0 to windowindex
35630>>>>>>>>>>>>>    return
35631>>>>>>>>>>>>>End
35631>>>>>>>>>>>>>>
35631>>>>>>>>>>>>>
35631>>>>>>>>>>>>>
35631>>>>>>>>>>>>>Global_Variable integer oTableAccessFunctions
35631>>>>>>>>>>>>>
35631>>>>>>>>>>>>>Object _oTableAccessFunctions is a cObject
35633>>>>>>>>>>>>>
35633>>>>>>>>>>>>>    Move Self to oTableAccessFunctions
35634>>>>>>>>>>>>>
35634>>>>>>>>>>>>>    //> This function is used to find out if a table is currently open. If not
35634>>>>>>>>>>>>>    //> it will return 0 (TA_DRIVER_ERROR)  and if it is opened a driver ID like
35634>>>>>>>>>>>>>    //> TA_DRIVER_DATAFLEX or TA_DRIVER_ORACLE will be returned.
35634>>>>>>>>>>>>>    Function TableDriver Integer iTable Returns Integer
35637>>>>>>>>>>>>>        Integer iRval iHandleType iPos iItem iItemMax
35637>>>>>>>>>>>>>        cIntFile stIntFile
35637>>>>>>>>>>>>>        cIntFile stIntFile
35637>>>>>>>>>>>>>        String[] aDrivers
35638>>>>>>>>>>>>>        String sDll
35638>>>>>>>>>>>>>        String sRootName
35638>>>>>>>>>>>>>
35638>>>>>>>>>>>>>        Move TD_DRIVER_UNKNOWN to iRval
35639>>>>>>>>>>>>>        
35639>>>>>>>>>>>>>        // If table is currently being restructured we stop here and return 'unknown driver'
35639>>>>>>>>>>>>>        Get_Attribute DF_FILE_HANDLE_TYPE of iTable to iHandleType
35642>>>>>>>>>>>>>        If (iHandleType=DF_FILE_HANDLE_EXISTING_RESTRUCTURE or iHandleType=DF_FILE_HANDLE_NEW_RESTRUCTURE) Function_Return TD_DRIVER_UNKNOWN
35645>>>>>>>>>>>>>        
35645>>>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iTable to iRval
35648>>>>>>>>>>>>>        If (iRval<>0) Begin // If open
35650>>>>>>>>>>>>>            Get_Attribute DF_FILE_DRIVER of iTable to sDll
35653>>>>>>>>>>>>>            Get DriverDllToId of oTableDriverFunctions sDll to iRval
35654>>>>>>>>>>>>>        End
35654>>>>>>>>>>>>>>
35654>>>>>>>>>>>>>        Else Begin // If not open
35655>>>>>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of iTable to sRootName
35658>>>>>>>>>>>>>            Move (Trim(sRootName)) to sRootName
35659>>>>>>>>>>>>>            Move "" to sDll
35660>>>>>>>>>>>>>            If (Right(Lowercase(sRootName),4)=".int") Begin
35662>>>>>>>>>>>>>                Get ReadIntFile of oIntFileFunctions sRootName to stIntFile
35663>>>>>>>>>>>>>                Move stIntFile.sDriverName to sDll
35664>>>>>>>>>>>>>                Get DriverDllToId of oTableDriverFunctions sDll to iRval
35665>>>>>>>>>>>>>            End
35665>>>>>>>>>>>>>>
35665>>>>>>>>>>>>>            Else Begin
35666>>>>>>>>>>>>>                // Check if there's a driver prefix
35666>>>>>>>>>>>>>                Move (Uppercase(sRootName)) to sRootName
35667>>>>>>>>>>>>>                Move (Pos(":",sRootName)) to iPos
35668>>>>>>>>>>>>>                If (iPos>0) Begin
35670>>>>>>>>>>>>>                    Move (Left(sRootName,iPos-1)) to sDll
35671>>>>>>>>>>>>>                    Get ForeignDriverArray of oTableDriverFunctions to aDrivers 
35672>>>>>>>>>>>>>                    Move (SizeOfArray(aDrivers)-1) to iItemMax
35673>>>>>>>>>>>>>                    For iItem from 0 to iItemMax
35679>>>>>>>>>>>>>>
35679>>>>>>>>>>>>>                        If (sDll=aDrivers[iItem]) Begin
35681>>>>>>>>>>>>>                            Get DriverDllToId of oTableDriverFunctions sDll to iRval
35682>>>>>>>>>>>>>                        End
35682>>>>>>>>>>>>>>
35682>>>>>>>>>>>>>                    Loop
35683>>>>>>>>>>>>>>
35683>>>>>>>>>>>>>                End
35683>>>>>>>>>>>>>>
35683>>>>>>>>>>>>>            End
35683>>>>>>>>>>>>>>
35683>>>>>>>>>>>>>        End
35683>>>>>>>>>>>>>>
35683>>>>>>>>>>>>>        Function_Return iRval
35684>>>>>>>>>>>>>    End_Function
35685>>>>>>>>>>>>>
35685>>>>>>>>>>>>>    Function IsOpen Integer iTable Returns Boolean
35688>>>>>>>>>>>>>        Integer iHandleType
35688>>>>>>>>>>>>>        Boolean bOpen
35688>>>>>>>>>>>>>        Get_Attribute DF_FILE_HANDLE_TYPE of iTable to iHandleType
35691>>>>>>>>>>>>>        Move (iHandleType=DF_FILE_HANDLE_EXISTING_RESTRUCTURE or iHandleType=DF_FILE_HANDLE_NEW_RESTRUCTURE) to bOpen
35692>>>>>>>>>>>>>        If (not(bOpen)) Begin
35694>>>>>>>>>>>>>            Get_Attribute DF_FILE_OPENED of iTable to bOpen
35697>>>>>>>>>>>>>        End
35697>>>>>>>>>>>>>>
35697>>>>>>>>>>>>>        Function_Return bOpen
35698>>>>>>>>>>>>>    End_Function
35699>>>>>>>>>>>>>
35699>>>>>>>>>>>>>    Function IsOpenAs Integer iTable Returns Boolean
35702>>>>>>>>>>>>>        Boolean bOpen
35702>>>>>>>>>>>>>        String sPhysName sRootName
35702>>>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iTable to bOpen
35705>>>>>>>>>>>>>        If (bOpen) Begin
35707>>>>>>>>>>>>>            Get_Attribute DF_FILE_PHYSICAL_NAME of iTable to sPhysName
35710>>>>>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of iTable to sRootName
35713>>>>>>>>>>>>>            If (uppercase(sPhysName)<>uppercase(sRootName)) Function_Return True
35716>>>>>>>>>>>>>        End
35716>>>>>>>>>>>>>>
35716>>>>>>>>>>>>>        Function_Return False
35717>>>>>>>>>>>>>    End_Function
35718>>>>>>>>>>>>>    
35718>>>>>>>>>>>>>    Property Boolean _pbRecursionStopper False
35720>>>>>>>>>>>>>    
35720>>>>>>>>>>>>>    //> The function returns True if the table could be opened. False otherwise.
35720>>>>>>>>>>>>>    Function OpenTable Integer iTable Integer iMode Integer iBufIndex Returns Boolean
35723>>>>>>>>>>>>>        Integer iWindowIndex   // *** VOODOO WARNING ***
35723>>>>>>>>>>>>>        Integer iDriverID
35723>>>>>>>>>>>>>        String sDll sRootName sRoot sDriver
35723>>>>>>>>>>>>>        String sFolder
35723>>>>>>>>>>>>>        Boolean bRval
35723>>>>>>>>>>>>>        Move WindowIndex to iWindowIndex // Preserve this obsolete global variable for old times sake.
35724>>>>>>>>>>>>>        Move |VI31 to |VI32 //copy ON ERROR label
35725>>>>>>>>>>>>>        On Error Gosub TableAccessOpenError
35726>>>>>>>>>>>>>        Indicate Err False
35727>>>>>>>>>>>>>        Move 1 to WindowIndex
35728>>>>>>>>>>>>>        If (iBufIndex<>0) Begin
35730>>>>>>>>>>>>>            Open iTable Mode iMode iBufIndex
35732>>>>>>>>>>>>>        End
35732>>>>>>>>>>>>>>
35732>>>>>>>>>>>>>        Else Begin
35733>>>>>>>>>>>>>            Open iTable Mode iMode
35735>>>>>>>>>>>>>        End
35735>>>>>>>>>>>>>>
35735>>>>>>>>>>>>>        Move |VI32 to |VI31 //restore original ON ERROR label
35736>>>>>>>>>>>>>        Move (WindowIndex<>0) to bRval // If an error was triggered the
35737>>>>>>>>>>>>>        Indicate Err False        // subroutine will have changed windowindex
35738>>>>>>>>>>>>>        Move iWindowIndex to WindowIndex
35739>>>>>>>>>>>>>        If (not(_pbRecursionStopper(Self)) and not(bRval)) Begin
35741>>>>>>>>>>>>>            Get TableDriver iTable to iDriverID
35742>>>>>>>>>>>>>            If (iDriverID<>TD_DRIVER_UNKNOWN and iDriverID<>TD_DRIVER_ERROR and iDriverID<>TD_DRIVER_DATAFLEX) Begin
35744>>>>>>>>>>>>>                Get DriverIdToDll of oTableDriverFunctions iDriverID to sDriver
35745>>>>>>>>>>>>>                Load_Driver sDriver
35746>>>>>>>>>>>>>                Set _pbRecursionStopper to True
35747>>>>>>>>>>>>>                Get OpenTable iTable iMode to bRval
35748>>>>>>>>>>>>>                Set _pbRecursionStopper to False
35749>>>>>>>>>>>>>            End
35749>>>>>>>>>>>>>>
35749>>>>>>>>>>>>>        End
35749>>>>>>>>>>>>>>
35749>>>>>>>>>>>>>        Function_Return bRval
35750>>>>>>>>>>>>>    End_Function
35751>>>>>>>>>>>>>    
35751>>>>>>>>>>>>>    Function OpenTables Integer[] aTables Integer iMode Returns Boolean
35754>>>>>>>>>>>>>        Boolean bOpen
35754>>>>>>>>>>>>>        Integer iTable iMax iItem
35754>>>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
35755>>>>>>>>>>>>>        For iItem from 0 to iMax
35761>>>>>>>>>>>>>>
35761>>>>>>>>>>>>>            Get OpenTable aTables[iItem] iMode 0 to bOpen
35762>>>>>>>>>>>>>            If (not(bOpen)) Begin
35764>>>>>>>>>>>>>                Function_Return False
35765>>>>>>>>>>>>>            End
35765>>>>>>>>>>>>>>
35765>>>>>>>>>>>>>        Loop
35766>>>>>>>>>>>>>>
35766>>>>>>>>>>>>>        Function_Return True
35767>>>>>>>>>>>>>    End_Function
35768>>>>>>>>>>>>>
35768>>>>>>>>>>>>>    Function OpenTableAs String sFileName Integer iTable Integer iMode Integer iBufIndex Returns Boolean
35771>>>>>>>>>>>>>        Integer iWindowIndex  // *** ALSO VOODOO WARNING ***
35771>>>>>>>>>>>>>        String sDll
35771>>>>>>>>>>>>>        Boolean bRval
35771>>>>>>>>>>>>>        If (IsOpen(Self,iTable)) Close iTable
35774>>>>>>>>>>>>>        Move (ToAnsi(sFileName)) to sFileName
35775>>>>>>>>>>>>>        If (sFileName="") Function_Return TD_DRIVER_ERROR
35778>>>>>>>>>>>>>        Move WindowIndex to iWindowIndex
35779>>>>>>>>>>>>>        Move |VI31 to |VI32 //copy ON ERROR label
35780>>>>>>>>>>>>>        On Error Gosub TableAccessOpenError
35781>>>>>>>>>>>>>        Indicate Err False
35782>>>>>>>>>>>>>        Move 1 to WindowIndex
35783>>>>>>>>>>>>>        If (iBufIndex<>0) Open sFileName as iTable Mode iMode iBufIndex
35787>>>>>>>>>>>>>        Else Open sFileName as iTable Mode iMode
35790>>>>>>>>>>>>>        Move |VI32 to |VI31 //restore original ON ERROR label
35791>>>>>>>>>>>>>        Move (WindowIndex<>0) to bRval // If an error was triggered the
35792>>>>>>>>>>>>>        Indicate Err False // subroutine will have changed windowindex
35793>>>>>>>>>>>>>        Move iWindowIndex to WindowIndex
35794>>>>>>>>>>>>>        Function_Return bRval
35795>>>>>>>>>>>>>    End_Function
35796>>>>>>>>>>>>>
35796>>>>>>>>>>>>>    Function OpenTableAsAutoHandle String sFileName Integer iMode Integer iBufIndex Returns Integer
35799>>>>>>>>>>>>>        Boolean bOpen
35799>>>>>>>>>>>>>        Integer iTable
35799>>>>>>>>>>>>>        Get TempFilelistEntry 500 to iTable // Start looking from 500
35800>>>>>>>>>>>>>        If (iTable<>0) Begin
35802>>>>>>>>>>>>>            Get OpenTableAs sFileName iTable iMode iBufIndex to bOpen
35803>>>>>>>>>>>>>            If (not(bOpen)) Begin
35805>>>>>>>>>>>>>                Move 0 to iTable // Failure
35806>>>>>>>>>>>>>            End
35806>>>>>>>>>>>>>>
35806>>>>>>>>>>>>>        End
35806>>>>>>>>>>>>>>
35806>>>>>>>>>>>>>        Else Begin
35807>>>>>>>>>>>>>            // The reason that the upper code failed may be that we're dealing
35807>>>>>>>>>>>>>            // with an old filelist.cfg with a maximum of 256 entries. We therefore
35807>>>>>>>>>>>>>            // try again starting from entry 1:
35807>>>>>>>>>>>>>            Get TempFilelistEntry 1 to iTable // Start looking from 1
35808>>>>>>>>>>>>>            If (iTable<>0) Begin
35810>>>>>>>>>>>>>                Get OpenTableAs sFileName iTable iMode iBufIndex to bOpen
35811>>>>>>>>>>>>>                If (not(bOpen)) Begin
35813>>>>>>>>>>>>>                    Move 0 to iTable // Failure
35814>>>>>>>>>>>>>                End
35814>>>>>>>>>>>>>>
35814>>>>>>>>>>>>>            End
35814>>>>>>>>>>>>>>
35814>>>>>>>>>>>>>        End
35814>>>>>>>>>>>>>>
35814>>>>>>>>>>>>>        Function_Return iTable
35815>>>>>>>>>>>>>    End_Function
35816>>>>>>>>>>>>>    
35816>>>>>>>>>>>>>    Function OpenShadowTable Integer iTable Boolean bReadOnly Returns Integer
35819>>>>>>>>>>>>>        Integer iShadowTable
35819>>>>>>>>>>>>>        String sTable
35819>>>>>>>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of iTable to sTable
35822>>>>>>>>>>>>>        Get OpenTableAsAutoHandle sTable DF_SHARE 0 to iShadowTable
35823>>>>>>>>>>>>>        If (bReadOnly) Begin
35825>>>>>>>>>>>>>            Send FlagTableReadOnly iShadowTable
35826>>>>>>>>>>>>>        End
35826>>>>>>>>>>>>>>
35826>>>>>>>>>>>>>        Function_Return iShadowTable
35827>>>>>>>>>>>>>    End_Function
35828>>>>>>>>>>>>>
35828>>>>>>>>>>>>>    Procedure CloseTable Integer iTable
35831>>>>>>>>>>>>>        Boolean bOpen
35831>>>>>>>>>>>>>        If iTable Begin
35833>>>>>>>>>>>>>            Get_Attribute DF_FILE_OPENED of iTable to bOpen
35836>>>>>>>>>>>>>            If bOpen Close iTable
35839>>>>>>>>>>>>>        End
35839>>>>>>>>>>>>>>
35839>>>>>>>>>>>>>    End_Procedure
35840>>>>>>>>>>>>>
35840>>>>>>>>>>>>>    Procedure CloseAll
35843>>>>>>>>>>>>>        Close DF_ALL DF_PERMANENT
35844>>>>>>>>>>>>>    End_Procedure
35845>>>>>>>>>>>>>    
35845>>>>>>>>>>>>>    Function ZeroFileTable Integer iTable Returns Boolean
35848>>>>>>>>>>>>>        Integer iIndex
35848>>>>>>>>>>>>>        Boolean bFound bConnectionRestored
35848>>>>>>>>>>>>>        
35848>>>>>>>>>>>>>        tTableOpenState strState
35848>>>>>>>>>>>>>        tTableOpenState strState
35848>>>>>>>>>>>>>        Get TableOpenState iTable to strState
35849>>>>>>>>>>>>>        Close iTable
35850>>>>>>>>>>>>>        If (OpenTable(Self,iTable,DF_EXCLUSIVE,0)) Begin
35852>>>>>>>>>>>>>            ZeroFile iTable
35853>>>>>>>>>>>>>        End
35853>>>>>>>>>>>>>>
35853>>>>>>>>>>>>>        Else Begin
35854>>>>>>>>>>>>>            Open iTable
35856>>>>>>>>>>>>>            Clear iTable
35857>>>>>>>>>>>>>            Get PrimaryIndex iTable to iIndex
35858>>>>>>>>>>>>>            Repeat
35858>>>>>>>>>>>>>>
35858>>>>>>>>>>>>>                Vfind iTable iIndex (GT)
35860>>>>>>>>>>>>>                Move (Found) to bFound
35861>>>>>>>>>>>>>                If (bFound) Begin
35863>>>>>>>>>>>>>                    Delete iTable
35864>>>>>>>>>>>>>                End
35864>>>>>>>>>>>>>>
35864>>>>>>>>>>>>>            Until (not(bFound))
35866>>>>>>>>>>>>>        End
35866>>>>>>>>>>>>>>
35866>>>>>>>>>>>>>        
35866>>>>>>>>>>>>>        Get SetTableOpenState strState True False to bConnectionRestored
35867>>>>>>>>>>>>>        Function_Return bConnectionRestored
35868>>>>>>>>>>>>>    End_Function
35869>>>>>>>>>>>>>
35869>>>>>>>>>>>>>    Function TableIntegerArray Integer iFileListNavAttr Returns Integer[]
35872>>>>>>>>>>>>>        Integer iTable iIndex
35872>>>>>>>>>>>>>        Integer[] aTables
35873>>>>>>>>>>>>>        If (iFileListNavAttr=DF_FILE_NEXT_OPENED or iFileListNavAttr=DF_FILE_NEXT_USED or iFileListNavAttr=DF_FILE_NEXT_EMPTY) Begin
35875>>>>>>>>>>>>>            Move 0 to iTable
35876>>>>>>>>>>>>>            Move 0 to iIndex
35877>>>>>>>>>>>>>            Repeat
35877>>>>>>>>>>>>>>
35877>>>>>>>>>>>>>                Get_Attribute iFileListNavAttr of iTable to iTable
35880>>>>>>>>>>>>>                If (iTable<>0) Begin
35882>>>>>>>>>>>>>                    Move iTable to aTables[iIndex]
35883>>>>>>>>>>>>>                    Increment iIndex
35884>>>>>>>>>>>>>                End
35884>>>>>>>>>>>>>>
35884>>>>>>>>>>>>>            Until (iTable=0)
35886>>>>>>>>>>>>>        End
35886>>>>>>>>>>>>>>
35886>>>>>>>>>>>>>        Else Error 810 "Illegal attribute passed to TableIntegerArray function"
35888>>>>>>>>>>>>>        Function_Return aTables
35889>>>>>>>>>>>>>    End_Function
35890>>>>>>>>>>>>>    
35890>>>>>>>>>>>>>    Function TableArrayNameToNumber String[] aTableNames Returns Integer[]
35893>>>>>>>>>>>>>        Integer[] aTables
35894>>>>>>>>>>>>>        Integer iMax iItem
35894>>>>>>>>>>>>>        Move (SizeOfArray(aTableNames)-1) to iMax
35895>>>>>>>>>>>>>        For iItem from 0 to iMax
35901>>>>>>>>>>>>>>
35901>>>>>>>>>>>>>            Get TableNameToNumber aTableNames[iItem] to aTables[iItem]
35902>>>>>>>>>>>>>        Loop     
35903>>>>>>>>>>>>>>
35903>>>>>>>>>>>>>        Function_Return aTables
35904>>>>>>>>>>>>>    End_Function
35905>>>>>>>>>>>>>    
35905>>>>>>>>>>>>>    //> Function TempFilelistEntry returns the first table number larger than iTable that may be used to temporarily open a table.
35905>>>>>>>>>>>>>    Function TempFilelistEntry Integer iTable Returns Integer
35908>>>>>>>>>>>>>        Boolean bOpen
35908>>>>>>>>>>>>>        Repeat
35908>>>>>>>>>>>>>>
35908>>>>>>>>>>>>>            Get_Attribute DF_FILE_NEXT_EMPTY of iTable to iTable
35911>>>>>>>>>>>>>            If (iTable>0) Begin
35913>>>>>>>>>>>>>                Get_Attribute DF_FILE_OPENED of iTable to bOpen
35916>>>>>>>>>>>>>            End
35916>>>>>>>>>>>>>>
35916>>>>>>>>>>>>>        Until (iTable=0 or not(bOpen))
35918>>>>>>>>>>>>>        Function_Return iTable
35919>>>>>>>>>>>>>    End_Function
35920>>>>>>>>>>>>>
35920>>>>>>>>>>>>>    Function TableOpenState Integer iTable Returns tTableOpenState
35923>>>>>>>>>>>>>        Boolean bIsOpen
35923>>>>>>>>>>>>>        tTableOpenState stRval
35923>>>>>>>>>>>>>        tTableOpenState stRval
35923>>>>>>>>>>>>>        Move iTable to stRval.iTable
35924>>>>>>>>>>>>>        Get TableDriver iTable to stRval.iDriver
35925>>>>>>>>>>>>>        If (stRval.iDriver<>TD_DRIVER_ERROR) Begin
35927>>>>>>>>>>>>>            Move True to stRval.bOpen
35928>>>>>>>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE     of iTable to stRval.iShareMode // DF_SHARE, DF_EXCLUSIVE
35931>>>>>>>>>>>>>            Get_Attribute DF_FILE_MODE          of iTable to stRval.iFileMode  // DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER, DF_FILE_IS_ALIAS
35934>>>>>>>>>>>>>            Get_Attribute DF_FILE_ALIAS         of iTable to stRval.iAliasMode // DF_FILEMODE_DEFAULT, DF_FILEMODE_NO_REREAD etc etc etc
35937>>>>>>>>>>>>>            Get_Attribute DF_FILE_PHYSICAL_NAME of iTable to stRval.sPhysName  // Runtimes idea of the root name of the file
35940>>>>>>>>>>>>>        End
35940>>>>>>>>>>>>>>
35940>>>>>>>>>>>>>        Else Begin
35941>>>>>>>>>>>>>            Move False to stRval
35942>>>>>>>>>>>>>        End
35942>>>>>>>>>>>>>>
35942>>>>>>>>>>>>>        Function_Return stRval
35943>>>>>>>>>>>>>    End_Function
35944>>>>>>>>>>>>>
35944>>>>>>>>>>>>>    Function TableOpenStates Returns tTableOpenState[]
35947>>>>>>>>>>>>>        Integer iTable iItem
35947>>>>>>>>>>>>>        tTableOpenState[] aTables
35947>>>>>>>>>>>>>        tTableOpenState[] aTables
35948>>>>>>>>>>>>>        Move 0 to iTable
35949>>>>>>>>>>>>>        Move 0 to iItem
35950>>>>>>>>>>>>>        Repeat
35950>>>>>>>>>>>>>>
35950>>>>>>>>>>>>>            Get_Attribute DF_FILE_NEXT_OPENED of iTable to iTable
35953>>>>>>>>>>>>>            If (iTable<>0) Begin
35955>>>>>>>>>>>>>                Get TableOpenState iTable to aTables[iItem]
35956>>>>>>>>>>>>>                Increment iItem
35957>>>>>>>>>>>>>            End
35957>>>>>>>>>>>>>>
35957>>>>>>>>>>>>>        Until (iTable=0)
35959>>>>>>>>>>>>>        Function_Return aTables
35960>>>>>>>>>>>>>    End_Function
35961>>>>>>>>>>>>>
35961>>>>>>>>>>>>>//    Function IsTableEntryAvailable Integer iTable Returns Boolean
35961>>>>>>>>>>>>>//        Boolean bOpen bIsAvailable
35961>>>>>>>>>>>>>//        String sRoot
35961>>>>>>>>>>>>>//        Get_Attribute DF_FILE_OPENED of iTable to bOpen
35961>>>>>>>>>>>>>//        If (bOpen) Begin
35961>>>>>>>>>>>>>//            Move False to bIsAvailable
35961>>>>>>>>>>>>>//        End
35961>>>>>>>>>>>>>//        Else Begin
35961>>>>>>>>>>>>>//            Get_Attribute DF_FILE_ROOT_NAME of iTable to sRoot
35961>>>>>>>>>>>>>//            Move (sRoot="") to bIsAvailable
35961>>>>>>>>>>>>>//        End
35961>>>>>>>>>>>>>//        Function_Return bIsAvailable
35961>>>>>>>>>>>>>//    End_Function
35961>>>>>>>>>>>>>//
35961>>>>>>>>>>>>>
35961>>>>>>>>>>>>>    Function SetTableOpenState tTableOpenState stOpenState Boolean bQuiet Boolean bIgnorePhysicalName Returns Boolean
35964>>>>>>>>>>>>>        Boolean bOpen
35964>>>>>>>>>>>>>        Close stOpenState.iTable // Apparantly doesn't fail if table isn't open
35965>>>>>>>>>>>>>        If (stOpenState.bOpen) Begin
35967>>>>>>>>>>>>>            Get OpenTable of oTableAccessFunctions stOpenState.iTable stOpenState.iShareMode 0 to bOpen
35968>>>>>>>>>>>>>            If (bOpen) Begin
35970>>>>>>>>>>>>>                Set_Attribute DF_FILE_ALIAS of stOpenState.iTable to stOpenState.iAliasMode // DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER, DF_FILE_IS_ALIAS
35973>>>>>>>>>>>>>                Set_Attribute DF_FILE_MODE  of stOpenState.iTable to stOpenState.iFileMode  // DF_FILEMODE_DEFAULT, DF_FILEMODE_NO_REREAD etc etc etc
35976>>>>>>>>>>>>>            End
35976>>>>>>>>>>>>>>
35976>>>>>>>>>>>>>            Function_Return bOpen
35977>>>>>>>>>>>>>        End
35977>>>>>>>>>>>>>>
35977>>>>>>>>>>>>>        Function_Return True
35978>>>>>>>>>>>>>    End_Function
35979>>>>>>>>>>>>>    
35979>>>>>>>>>>>>>    Function SetTableOpenStates tTableOpenState[] aOpenStates Boolean bQuiet Boolean bIgnorePhysicalName Returns Boolean
35982>>>>>>>>>>>>>        Integer iIndex iMax
35982>>>>>>>>>>>>>        Boolean bOpen bRval
35982>>>>>>>>>>>>>        Move True to bRval
35983>>>>>>>>>>>>>        Move (SizeOfArray(aOpenStates)-1) to iMax
35984>>>>>>>>>>>>>        For iIndex from 0 to iMax
35990>>>>>>>>>>>>>>
35990>>>>>>>>>>>>>            Get SetTableOpenState aOpenStates[iIndex] bQuiet bIgnorePhysicalName to bOpen
35991>>>>>>>>>>>>>            If (not(bOpen)) Begin
35993>>>>>>>>>>>>>                Move False to bRval
35994>>>>>>>>>>>>>            End
35994>>>>>>>>>>>>>>
35994>>>>>>>>>>>>>        Loop
35995>>>>>>>>>>>>>>
35995>>>>>>>>>>>>>        Function_Return bRval
35996>>>>>>>>>>>>>    End_Function
35997>>>>>>>>>>>>>
35997>>>>>>>>>>>>>    // FileModeSjov
35997>>>>>>>>>>>>>
35997>>>>>>>>>>>>>    Struct tTAFileMode
35997>>>>>>>>>>>>>        Integer iTable
35997>>>>>>>>>>>>>        Integer iFileMode
35997>>>>>>>>>>>>>    End_Struct
35997>>>>>>>>>>>>>
35997>>>>>>>>>>>>>    Function TableFileModesSetAll Integer iFileMode Integer[] aExceptTables Returns tTAFileMode[]
36000>>>>>>>>>>>>>        Integer iItem iMax iTable
36000>>>>>>>>>>>>>        Integer[] aOpenTables
36001>>>>>>>>>>>>>        Integer iCount
36001>>>>>>>>>>>>>        tTAFileMode[] aOriginalFileModes
36001>>>>>>>>>>>>>        tTAFileMode[] aOriginalFileModes
36002>>>>>>>>>>>>>        
36002>>>>>>>>>>>>>        Get TableIntegerArray DF_FILE_NEXT_OPENED to aOpenTables
36003>>>>>>>>>>>>>        Move 0 to iCount
36004>>>>>>>>>>>>>        Move (SizeOfArray(aOpenTables)-1) to iMax
36005>>>>>>>>>>>>>        For iItem from 0 to iMax
36011>>>>>>>>>>>>>>
36011>>>>>>>>>>>>>            Move aOpenTables[iItem] to iTable
36012>>>>>>>>>>>>>            If (not(IntegerIsOnStack(oStackFunctions,iTable,aExceptTables))) Begin
36014>>>>>>>>>>>>>                Move iTable to aOriginalFileModes[iCount].iTable
36015>>>>>>>>>>>>>                Get_Attribute DF_FILE_MODE of iTable to aOriginalFileModes[iCount].iFileMode
36018>>>>>>>>>>>>>                Increment iCount
36019>>>>>>>>>>>>>                Set_Attribute DF_FILE_MODE of iTable to iFileMode
36022>>>>>>>>>>>>>            End
36022>>>>>>>>>>>>>>
36022>>>>>>>>>>>>>        Loop
36023>>>>>>>>>>>>>>
36023>>>>>>>>>>>>>        
36023>>>>>>>>>>>>>        Function_Return aOriginalFileModes
36024>>>>>>>>>>>>>    End_Function
36025>>>>>>>>>>>>>    
36025>>>>>>>>>>>>>    Function TableFileModesSetAll2 Integer iFileMode Integer iExceptTable1 Integer iExceptTable2 Integer iExceptTable3 Integer iExceptTable4 Integer iExceptTable5 Returns tTAFileMode[]
36028>>>>>>>>>>>>>        Integer[] aExceptTables
36029>>>>>>>>>>>>>        
36029>>>>>>>>>>>>>        If (num_arguments>1) Move iExceptTable1 to aExceptTables[0]
36032>>>>>>>>>>>>>        If (num_arguments>2) Move iExceptTable2 to aExceptTables[1]
36035>>>>>>>>>>>>>        If (num_arguments>3) Move iExceptTable3 to aExceptTables[2]
36038>>>>>>>>>>>>>        If (num_arguments>4) Move iExceptTable4 to aExceptTables[3]
36041>>>>>>>>>>>>>        If (num_arguments>5) Move iExceptTable5 to aExceptTables[4]
36044>>>>>>>>>>>>>        
36044>>>>>>>>>>>>>        Function_Return (TableFileModesSetAll2(Self))
36045>>>>>>>>>>>>>    End_Function
36046>>>>>>>>>>>>>    
36046>>>>>>>>>>>>>    Procedure TableFileModesRestore tTAFileMode[] aOriginalFileModes
36049>>>>>>>>>>>>>        Integer iItem iMax iTable iFileMode
36049>>>>>>>>>>>>>        Move (SizeOfArray(aOriginalFileModes)-1) to iMax
36050>>>>>>>>>>>>>        for iItem from 0 to iMax
36056>>>>>>>>>>>>>>
36056>>>>>>>>>>>>>            Move aOriginalFileModes[iItem].iTable to iTable
36057>>>>>>>>>>>>>            Move aOriginalFileModes[iItem].iFileMode to iFileMode
36058>>>>>>>>>>>>>            Set_Attribute DF_FILE_MODE of iTable to iFileMode
36061>>>>>>>>>>>>>        Loop
36062>>>>>>>>>>>>>>
36062>>>>>>>>>>>>>    End_Procedure
36063>>>>>>>>>>>>>    
36063>>>>>>>>>>>>>    // End FileModeSjov
36063>>>>>>>>>>>>>    
36063>>>>>>>>>>>>>    //> The function returns true if the file passed in sFilelistPath is a valid filelist.cfg
36063>>>>>>>>>>>>>    Function FilelistOk String sFilelistPath Returns Boolean
36066>>>>>>>>>>>>>        Integer iChannel
36066>>>>>>>>>>>>>        Boolean bSuccess
36066>>>>>>>>>>>>>        String sTest
36066>>>>>>>>>>>>>        Move False to bSuccess
36067>>>>>>>>>>>>>        If (FileExists(oFileFunctions,sFilelistPath)=1) Begin // Must be a file!
36069>>>>>>>>>>>>>            Get DirectInput of oFileFunctions sFilelistPath to iChannel
36070>>>>>>>>>>>>>            If (iChannel>=0) Begin
36072>>>>>>>>>>>>>                Read_Block channel iChannel sTest 12
36074>>>>>>>>>>>>>                Send CloseInput of oFileFunctions iChannel
36075>>>>>>>>>>>>>                If (sTest="filelist.cfg") Begin // This has to be the first 12 characters
36077>>>>>>>>>>>>>                    Move True to bSuccess
36078>>>>>>>>>>>>>                End
36078>>>>>>>>>>>>>>
36078>>>>>>>>>>>>>            End
36078>>>>>>>>>>>>>>
36078>>>>>>>>>>>>>        End
36078>>>>>>>>>>>>>>
36078>>>>>>>>>>>>>        Function_Return bSuccess
36079>>>>>>>>>>>>>    End_Function
36080>>>>>>>>>>>>>
36080>>>>>>>>>>>>>    Function ChangeFilelist String sFilelistPath Returns Boolean
36083>>>>>>>>>>>>>        Boolean bSuccess
36083>>>>>>>>>>>>>        If (FilelistOk(Self,sFilelistPath)) Begin
36085>>>>>>>>>>>>>            Send CloseAll
36086>>>>>>>>>>>>>            Set_Attribute DF_FILELIST_NAME to sFilelistPath
36089>>>>>>>>>>>>>            Set_Attribute DF_OPEN_PATH to (PathToFolder(oFileFunctions,sFilelistPath))
36092>>>>>>>>>>>>>            Move True to bSuccess
36093>>>>>>>>>>>>>        End
36093>>>>>>>>>>>>>>
36093>>>>>>>>>>>>>        Else Begin
36094>>>>>>>>>>>>>            Move False to bSuccess
36095>>>>>>>>>>>>>        End
36095>>>>>>>>>>>>>>
36095>>>>>>>>>>>>>        Function_Return bSuccess
36096>>>>>>>>>>>>>    End_Function
36097>>>>>>>>>>>>>
36097>>>>>>>>>>>>>    Function ChangeDatabase String sNewDataFolder Returns Boolean
36100>>>>>>>>>>>>>        Integer hWS
36100>>>>>>>>>>>>>        Boolean bSuccess
36100>>>>>>>>>>>>>        tTableOpenState[] aOpenStates
36100>>>>>>>>>>>>>        tTableOpenState[] aOpenStates
36101>>>>>>>>>>>>>        Get TableOpenStates of oTableAccessFunctions to aOpenStates
36102>>>>>>>>>>>>>        Get WorkSpaceObject of oWorkSpaceFunctions to hWS
36103>>>>>>>>>>>>>        Close DF_ALL DF_PERMANENT
36104>>>>>>>>>>>>>        If (hWS<>"") Begin
36106>>>>>>>>>>>>>            Set psDataPath of hWS to sNewDataFolder
36107>>>>>>>>>>>>>            Set psFileList of hWS to sNewDataFolder
36108>>>>>>>>>>>>>            Send DoSetPaths of hWS
36109>>>>>>>>>>>>>        End
36109>>>>>>>>>>>>>>
36109>>>>>>>>>>>>>        Else Begin
36110>>>>>>>>>>>>>            Set_Attribute DF_FILELIST_NAME to sNewDataFolder
36113>>>>>>>>>>>>>            Set_Attribute DF_OPEN_PATH     to sNewDataFolder
36116>>>>>>>>>>>>>        End
36116>>>>>>>>>>>>>>
36116>>>>>>>>>>>>>        Get SetTableOpenStates of oTableAccessFunctions aOpenStates False True to bSuccess
36117>>>>>>>>>>>>>        Function_Return bSuccess
36118>>>>>>>>>>>>>    End_Function
36119>>>>>>>>>>>>>
36119>>>>>>>>>>>>>    Procedure FlagTableReadOnly Integer iTable
36122>>>>>>>>>>>>>        Move iTable to FileNumber
36123>>>>>>>>>>>>>        File_Mode Indirect_File READ_ONLY
36127>>>>>>>>>>>>>    End_Procedure
36128>>>>>>>>>>>>>
36128>>>>>>>>>>>>>    Procedure RunDbExplorer String sTableFilePath
36131>>>>>>>>>>>>>        String sDbExplorPath
36131>>>>>>>>>>>>>        Get VdfFolderPath of oFileFunctions VDF_ROOT to sDbExplorPath
36132>>>>>>>>>>>>>        Get AppendPath of oFileFunctions sDbExplorPath "Bin" to sDbExplorPath
36133>>>>>>>>>>>>>        Get AppendPath of oFileFunctions sDbExplorPath "DBExplor.exe" to sDbExplorPath
36134>>>>>>>>>>>>>        Runprogram Background (sDbExplorPath+' -t"'+sTableFilePath+'"')
36135>>>>>>>>>>>>>    End_Procedure
36136>>>>>>>>>>>>>
36136>>>>>>>>>>>>>    Procedure RunVDFXray String sTablePath Integer iTable Integer iColumn
36139>>>>>>>>>>>>>        Runprogram Background ("vdfxray -filelist "+sTablePath+" "+String(iTable)+" "+String(iColumn))
36140>>>>>>>>>>>>>    End_Procedure
36141>>>>>>>>>>>>>
36141>>>>>>>>>>>>>    Procedure RunVDFXrayCurrentFileList Integer iTable Integer iColumn
36144>>>>>>>>>>>>>        String sTablePath
36144>>>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sTablePath
36147>>>>>>>>>>>>>        Send RunVDFXray sTablePath iTable iColumn
36148>>>>>>>>>>>>>    End_Procedure
36149>>>>>>>>>>>>>    
36149>>>>>>>>>>>>>    Procedure RunNewVDFXRay
36152>>>>>>>>>>>>>        RunProgram Background "vdfxray"
36153>>>>>>>>>>>>>    End_Procedure
36154>>>>>>>>>>>>>    
36154>>>>>>>>>>>>>    //> Get "open as" path of filelist entry iTable
36154>>>>>>>>>>>>>    Function TableOpenAsPath Integer iTable Returns String
36157>>>>>>>>>>>>>        Boolean bResolved
36157>>>>>>>>>>>>>        Integer iPos
36157>>>>>>>>>>>>>        String sOpenPath sRootName sOpenAsPath sExt sFolder sDriver
36157>>>>>>>>>>>>>        String sTemp sDriverArray
36157>>>>>>>>>>>>>
36157>>>>>>>>>>>>>        If (iTable>0) Begin
36159>>>>>>>>>>>>>            Move False to bResolved
36160>>>>>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of iTable to sRootName
36163>>>>>>>>>>>>>
36163>>>>>>>>>>>>>            // Is root name prefixed by a driver id? (MSSQLDRV:Customer)
36163>>>>>>>>>>>>>            Move (Pos(":",sRootName)) to iPos
36164>>>>>>>>>>>>>            If (iPos>0) Begin
36166>>>>>>>>>>>>>                Move (Uppercase(Left(sRootName,iPos))) to sTemp
36167>>>>>>>>>>>>>                Get JoinString of oStringFunctions (ForeignDriverArray(oTableDriverFunctions)) ":" 0 0 to sDriver
36168>>>>>>>>>>>>>                Move (sDriver+":") to sDriver
36169>>>>>>>>>>>>>                If (Uppercase(sDriver) contains sTemp) Begin
36171>>>>>>>>>>>>>                    // There definately was a driver prefix
36171>>>>>>>>>>>>>                    Move (Left(sRootName,iPos-1)) to sDriver
36172>>>>>>>>>>>>>                    
36172>>>>>>>>>>>>>                    Move (Remove(sRootName,1,iPos)) to sRootName
36173>>>>>>>>>>>>>                    
36173>>>>>>>>>>>>>                    Get PathToType of oFileFunctions sRootName to sExt
36174>>>>>>>>>>>>>                    If (sExt="") Begin
36176>>>>>>>>>>>>>                        Move (sRootName+".int") to sRootName
36177>>>>>>>>>>>>>                    End
36177>>>>>>>>>>>>>>
36177>>>>>>>>>>>>>                    Move True to bResolved
36178>>>>>>>>>>>>>                End
36178>>>>>>>>>>>>>>
36178>>>>>>>>>>>>>            End
36178>>>>>>>>>>>>>>
36178>>>>>>>>>>>>>            
36178>>>>>>>>>>>>>            If (not(bResolved)) Begin
36180>>>>>>>>>>>>>                Get PathToType of oFileFunctions sRootName to sExt
36181>>>>>>>>>>>>>                If (sExt="") begin
36183>>>>>>>>>>>>>                    Move (sRootName+".dat") to sRootName
36184>>>>>>>>>>>>>                End
36184>>>>>>>>>>>>>>
36184>>>>>>>>>>>>>            End
36184>>>>>>>>>>>>>>
36184>>>>>>>>>>>>>
36184>>>>>>>>>>>>>            // Is absolute path included?
36184>>>>>>>>>>>>>            If (sRootName contains ":" or sRootName contains "\") Begin
36186>>>>>>>>>>>>>                // Yes! Don't do a thing. Other than:
36186>>>>>>>>>>>>>                Move sRootName to sOpenAsPath
36187>>>>>>>>>>>>>            End
36187>>>>>>>>>>>>>>
36187>>>>>>>>>>>>>            Else Begin
36188>>>>>>>>>>>>>                Get_Attribute DF_OPEN_PATH to sOpenPath
36191>>>>>>>>>>>>>                Get FindFile of oFileFunctions sRootName sOpenPath to sFolder
36192>>>>>>>>>>>>>                If (sFolder<>"") Begin
36194>>>>>>>>>>>>>                    Get AppendPath of oFileFunctions sFolder sRootName to sOpenAsPath
36195>>>>>>>>>>>>>                End
36195>>>>>>>>>>>>>>
36195>>>>>>>>>>>>>                Else Begin
36196>>>>>>>>>>>>>                    Move sRootName to sOpenAsPath
36197>>>>>>>>>>>>>                End
36197>>>>>>>>>>>>>>
36197>>>>>>>>>>>>>            End
36197>>>>>>>>>>>>>>
36197>>>>>>>>>>>>>        End
36197>>>>>>>>>>>>>>
36197>>>>>>>>>>>>>        Function_Return sOpenAsPath
36198>>>>>>>>>>>>>    End_Function
36199>>>>>>>>>>>>>
36199>>>>>>>>>>>>>    Function FieldNameToNumber Integer iTable String sName Returns Integer
36202>>>>>>>>>>>>>        Integer iMax iField
36202>>>>>>>>>>>>>        String sFieldName
36202>>>>>>>>>>>>>        Move (Lowercase(sName)) to sName
36203>>>>>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iMax
36206>>>>>>>>>>>>>        For iField from 1 to iMax
36212>>>>>>>>>>>>>>
36212>>>>>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iTable iField to sFieldName
36215>>>>>>>>>>>>>            If (sName=Lowercase(sFieldName)) Begin
36217>>>>>>>>>>>>>                Function_Return iField
36218>>>>>>>>>>>>>            End
36218>>>>>>>>>>>>>>
36218>>>>>>>>>>>>>        Loop
36219>>>>>>>>>>>>>>
36219>>>>>>>>>>>>>        If (sName="recnum") Begin
36221>>>>>>>>>>>>>            Function_Return 0
36222>>>>>>>>>>>>>        End
36222>>>>>>>>>>>>>>
36222>>>>>>>>>>>>>        Function_Return -1 // not found
36223>>>>>>>>>>>>>    End_Function
36224>>>>>>>>>>>>>
36224>>>>>>>>>>>>>    Function TableNameToNumber String sLogicalName Returns Integer
36227>>>>>>>>>>>>>        Integer iTable
36227>>>>>>>>>>>>>        String sValue
36227>>>>>>>>>>>>>        Move (Uppercase(sLogicalName)) to sLogicalName
36228>>>>>>>>>>>>>        Move 0 to iTable
36229>>>>>>>>>>>>>        Repeat
36229>>>>>>>>>>>>>>
36229>>>>>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of iTable to iTable
36232>>>>>>>>>>>>>            If (iTable<>0) Begin
36234>>>>>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sValue
36237>>>>>>>>>>>>>                If (sLogicalName=Uppercase(sValue)) Begin
36239>>>>>>>>>>>>>                    Function_Return iTable
36240>>>>>>>>>>>>>                End
36240>>>>>>>>>>>>>>
36240>>>>>>>>>>>>>            End
36240>>>>>>>>>>>>>>
36240>>>>>>>>>>>>>        Until (iTable=0)
36242>>>>>>>>>>>>>
36242>>>>>>>>>>>>>        Function_Return -1
36243>>>>>>>>>>>>>    End_Function
36244>>>>>>>>>>>>>    
36244>>>>>>>>>>>>>    Function FieldNumberMirror Integer iColumn Returns Integer // Get FieldNumberMirror of oTableAccessFunctions field Customer.Name to iFieldName
36247>>>>>>>>>>>>>        Function_Return iColumn
36248>>>>>>>>>>>>>    End_Function
36249>>>>>>>>>>>>>
36249>>>>>>>>>>>>>    Function FieldName Integer iTable Integer iField Boolean bInclTableName Returns String
36252>>>>>>>>>>>>>        String sColumnName sTableName
36252>>>>>>>>>>>>>        If (iField<0) Begin
36254>>>>>>>>>>>>>            Function_Return ""
36255>>>>>>>>>>>>>        End
36255>>>>>>>>>>>>>>
36255>>>>>>>>>>>>>        Get_Attribute DF_FIELD_NAME of iTable iField to sColumnName
36258>>>>>>>>>>>>>        If (iField=0 and sColumnName="") Begin
36260>>>>>>>>>>>>>            Move "Recnum" to sColumnName
36261>>>>>>>>>>>>>        End
36261>>>>>>>>>>>>>>
36261>>>>>>>>>>>>>        If (bInclTableName and sColumnName<>"") Begin
36263>>>>>>>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sTableName
36266>>>>>>>>>>>>>            Move (sTableName+"."+sColumnName) to sColumnName
36267>>>>>>>>>>>>>        End
36267>>>>>>>>>>>>>>
36267>>>>>>>>>>>>>        Function_Return sColumnName
36268>>>>>>>>>>>>>    End_Function
36269>>>>>>>>>>>>>
36269>>>>>>>>>>>>>    Function FieldValue Integer iTable Integer iField Returns String
36272>>>>>>>>>>>>>        String sValue
36272>>>>>>>>>>>>>        If (iField>=1) Begin
36274>>>>>>>>>>>>>            Get_Field_Value iTable iField to sValue
36277>>>>>>>>>>>>>        End
36277>>>>>>>>>>>>>>
36277>>>>>>>>>>>>>        Else Begin
36278>>>>>>>>>>>>>            Move "Error" to sValue
36279>>>>>>>>>>>>>            Error 251 "Field index out of range"
36280>>>>>>>>>>>>>>
36280>>>>>>>>>>>>>        End
36280>>>>>>>>>>>>>>
36280>>>>>>>>>>>>>        Function_Return sValue
36281>>>>>>>>>>>>>    End_Function
36282>>>>>>>>>>>>>    
36282>>>>>>>>>>>>>    Function FieldNameValue Integer iTable String sName Returns String
36285>>>>>>>>>>>>>        Integer iField
36285>>>>>>>>>>>>>        Get FieldNameToNumber iTable sName to iField
36286>>>>>>>>>>>>>        Function_Return (FieldValue(Self,iTable,iField))
36287>>>>>>>>>>>>>    End_Function
36288>>>>>>>>>>>>>    
36288>>>>>>>>>>>>>    Procedure Set FieldNameValue Integer iTable String sName String sValue
36291>>>>>>>>>>>>>        Integer iField
36291>>>>>>>>>>>>>        Get FieldNameToNumber iTable sName to iField
36292>>>>>>>>>>>>>        Set_Field_Value iTable iField to sValue
36295>>>>>>>>>>>>>    End_Procedure
36296>>>>>>>>>>>>>
36296>>>>>>>>>>>>>    Function StripPathAndDriverFromTableRootName String sRoot Returns String
36299>>>>>>>>>>>>>        Integer iPos
36299>>>>>>>>>>>>>        Get rPos of oStringFunctions "\" sRoot to iPos
36300>>>>>>>>>>>>>        If (iPos>0) Begin
36302>>>>>>>>>>>>>            Move (Remove(sRoot,1,iPos)) to sRoot
36303>>>>>>>>>>>>>        End
36303>>>>>>>>>>>>>>
36303>>>>>>>>>>>>>        Get rPos of oStringFunctions ":" sRoot to iPos
36304>>>>>>>>>>>>>        If (iPos>0) Begin
36306>>>>>>>>>>>>>            Move (Remove(sRoot,1,iPos)) to sRoot
36307>>>>>>>>>>>>>        End
36307>>>>>>>>>>>>>>
36307>>>>>>>>>>>>>        Get PathStripType of oFileFunctions sRoot to sRoot
36308>>>>>>>>>>>>>        Function_Return sRoot
36309>>>>>>>>>>>>>    End_Function
36310>>>>>>>>>>>>>    
36310>>>>>>>>>>>>>//    Function TableDriver Integer iTable Returns String
36310>>>>>>>>>>>>>//        
36310>>>>>>>>>>>>>//    End_Function
36310>>>>>>>>>>>>>
36310>>>>>>>>>>>>>    Function FieldTypeText Integer iType Integer iTextType Returns String
36313>>>>>>>>>>>>>        If (iTextType=0) Begin
36315>>>>>>>>>>>>>            If (iType=DF_ASCII   ) Function_Return "ASCII"
36318>>>>>>>>>>>>>            If (iType=DF_BCD     ) Function_Return "Number"
36321>>>>>>>>>>>>>            If (iType=DF_DATE    ) Function_Return "Date"
36324>>>>>>>>>>>>>            If (iType=DF_DATETIME) Function_Return "DateTime"
36327>>>>>>>>>>>>>            If (iType=DF_OVERLAP ) Function_Return "Overlap"
36330>>>>>>>>>>>>>            If (iType=DF_TEXT    ) Function_Return "Text"
36333>>>>>>>>>>>>>            If (iType=DF_BINARY  ) Function_Return "Binary"
36336>>>>>>>>>>>>>            Function_Return "Type Unknown"
36337>>>>>>>>>>>>>        End
36337>>>>>>>>>>>>>>
36337>>>>>>>>>>>>>        If (iTextType=1) Begin
36339>>>>>>>>>>>>>            If (iType=DF_ASCII   ) Function_Return "ASC"
36342>>>>>>>>>>>>>            If (iType=DF_BCD     ) Function_Return "NUM"
36345>>>>>>>>>>>>>            If (iType=DF_DATE    ) Function_Return "DAT"
36348>>>>>>>>>>>>>            If (iType=DF_DATETIME) Function_Return "DT"
36351>>>>>>>>>>>>>            If (iType=DF_OVERLAP ) Function_Return "OVE"
36354>>>>>>>>>>>>>            If (iType=DF_TEXT    ) Function_Return "TXT"
36357>>>>>>>>>>>>>            If (iType=DF_BINARY  ) Function_Return "BIN"
36360>>>>>>>>>>>>>            Function_Return "???"
36361>>>>>>>>>>>>>        End
36361>>>>>>>>>>>>>>
36361>>>>>>>>>>>>>        If (iTextType=2) Begin
36363>>>>>>>>>>>>>            If (iType=DF_ASCII   ) Function_Return "DF_ASCII"
36366>>>>>>>>>>>>>            If (iType=DF_BCD     ) Function_Return "DF_BCD"
36369>>>>>>>>>>>>>            If (iType=DF_DATE    ) Function_Return "DF_DATE"
36372>>>>>>>>>>>>>            If (iType=DF_DATETIME) Function_Return "DF_DATETIME"
36375>>>>>>>>>>>>>            If (iType=DF_OVERLAP ) Function_Return "DF_OVERLAP"
36378>>>>>>>>>>>>>            If (iType=DF_TEXT    ) Function_Return "DF_TEXT"
36381>>>>>>>>>>>>>            If (iType=DF_BINARY  ) Function_Return "DF_BINARY"
36384>>>>>>>>>>>>>            Function_Return "Type Unknown"
36385>>>>>>>>>>>>>        End
36385>>>>>>>>>>>>>>
36385>>>>>>>>>>>>>    End_Function
36386>>>>>>>>>>>>>
36386>>>>>>>>>>>>>    Function FieldLengthText Integer iType Integer iLen Integer iPrec Returns String
36389>>>>>>>>>>>>>        String sRval
36389>>>>>>>>>>>>>        Move iLen to sRval
36390>>>>>>>>>>>>>        If (iType=DF_BCD) Begin
36392>>>>>>>>>>>>>            Move "#.#" to sRval
36393>>>>>>>>>>>>>            Move (Replace("#",sRval,iLen-iPrec)) to sRval
36394>>>>>>>>>>>>>            Move (Replace("#",sRval,iPrec)) to sRval
36395>>>>>>>>>>>>>        End
36395>>>>>>>>>>>>>>
36395>>>>>>>>>>>>>        Function_Return sRval
36396>>>>>>>>>>>>>    End_Function
36397>>>>>>>>>>>>>
36397>>>>>>>>>>>>>
36397>>>>>>>>>>>>>    Define C_LegalColumnNameFirstLetters      for "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
36397>>>>>>>>>>>>>    Define C_LegalColumnNameSucceedingLetters for "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_#@"
36397>>>>>>>>>>>>>
36397>>>>>>>>>>>>>    Function IsLegalColumnName String sName Returns Boolean
36400>>>>>>>>>>>>>        Integer iLen iPos
36400>>>>>>>>>>>>>        String sChar
36400>>>>>>>>>>>>>        Move (Trim(Uppercase(sName))) to sName
36401>>>>>>>>>>>>>        Move (Length(sName)) to iLen
36402>>>>>>>>>>>>>        If (iLen>0 and iLen<=15) Begin
36404>>>>>>>>>>>>>            For iPos from 1 to iLen
36410>>>>>>>>>>>>>>
36410>>>>>>>>>>>>>                Move (Mid(sName,1,iPos)) to sChar
36411>>>>>>>>>>>>>                If (iPos=1) Begin
36413>>>>>>>>>>>>>                    If (not(C_LegalColumnNameFirstLetters contains sChar)) Begin
36415>>>>>>>>>>>>>                        Function_Return False
36416>>>>>>>>>>>>>                    End
36416>>>>>>>>>>>>>>
36416>>>>>>>>>>>>>                End
36416>>>>>>>>>>>>>>
36416>>>>>>>>>>>>>                Else Begin
36417>>>>>>>>>>>>>                    If (not(C_LegalColumnNameSucceedingLetters contains sChar)) Begin
36419>>>>>>>>>>>>>                        Function_Return False
36420>>>>>>>>>>>>>                    End
36420>>>>>>>>>>>>>>
36420>>>>>>>>>>>>>                End
36420>>>>>>>>>>>>>>
36420>>>>>>>>>>>>>            Loop
36421>>>>>>>>>>>>>>
36421>>>>>>>>>>>>>            Function_Return True
36422>>>>>>>>>>>>>        End
36422>>>>>>>>>>>>>>
36422>>>>>>>>>>>>>        Function_Return False
36423>>>>>>>>>>>>>    End_Function
36424>>>>>>>>>>>>>    
36424>>>>>>>>>>>>>    //> Returns something that can be used with vfind command. -1 is returned of no index can me found
36424>>>>>>>>>>>>>    Function AnyIndex Integer iTable Returns Integer
36427>>>>>>>>>>>>>        Integer iTableIndex iTableIndexMax
36427>>>>>>>>>>>>>        Integer iSegments iIndexType
36427>>>>>>>>>>>>>        String sDriver
36427>>>>>>>>>>>>>        Boolean bEmbedded
36427>>>>>>>>>>>>>        
36427>>>>>>>>>>>>>        Get_Attribute DF_FILE_DRIVER of iTable to sDriver
36430>>>>>>>>>>>>>        Move (sDriver="DATAFLEX") to bEmbedded
36431>>>>>>>>>>>>>        If (bEmbedded) Begin
36433>>>>>>>>>>>>>            Function_Return 0
36434>>>>>>>>>>>>>        End
36434>>>>>>>>>>>>>>
36434>>>>>>>>>>>>>        
36434>>>>>>>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iTable to iTableIndexMax
36437>>>>>>>>>>>>>        For iTableIndex from 1 to iTableIndexMax
36443>>>>>>>>>>>>>>
36443>>>>>>>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iTable iTableIndex to iSegments
36446>>>>>>>>>>>>>            If (iSegments>0) Begin
36448>>>>>>>>>>>>>                Get_Attribute DF_INDEX_TYPE of iTable iTableIndex to iIndexType
36451>>>>>>>>>>>>>                If (iIndexType<>DF_INDEX_TYPE_BATCH) Begin
36453>>>>>>>>>>>>>                    Function_Return iTableIndex
36454>>>>>>>>>>>>>                End
36454>>>>>>>>>>>>>>
36454>>>>>>>>>>>>>            End
36454>>>>>>>>>>>>>>
36454>>>>>>>>>>>>>        Loop
36455>>>>>>>>>>>>>>
36455>>>>>>>>>>>>>        Function_Return -1 // vfind can't be used with this table
36456>>>>>>>>>>>>>    End_Function
36457>>>>>>>>>>>>>
36457>>>>>>>>>>>>>    Function IndexColumns Integer iTable Integer iIndex Returns Integer[]
36460>>>>>>>>>>>>>        Integer iSegmentMax iSegmentIndex
36460>>>>>>>>>>>>>        Integer[] aColumns
36461>>>>>>>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iTable iIndex to iSegmentMax
36464>>>>>>>>>>>>>        If (iSegmentIndex>=1) Begin
36466>>>>>>>>>>>>>            For iSegmentIndex from 1 to iSegmentMax
36472>>>>>>>>>>>>>>
36472>>>>>>>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD of iTable iIndex iSegmentIndex to aColumns[SizeOfArray(aColumns)]
36475>>>>>>>>>>>>>            Loop
36476>>>>>>>>>>>>>>
36476>>>>>>>>>>>>>        End
36476>>>>>>>>>>>>>>
36476>>>>>>>>>>>>>        Function_Return aColumns
36477>>>>>>>>>>>>>    End_Function
36478>>>>>>>>>>>>>    
36478>>>>>>>>>>>>>    Function PrimaryIndex Integer iTable Returns Integer
36481>>>>>>>>>>>>>        Integer iIndex
36481>>>>>>>>>>>>>        Get_Attribute DF_FILE_PRIMARY_INDEX of iTable to iIndex
36484>>>>>>>>>>>>>        Function_Return iIndex
36485>>>>>>>>>>>>>    End_Function
36486>>>>>>>>>>>>>    
36486>>>>>>>>>>>>>    Function RecordIdentityColumns Integer iTable Returns Integer[]
36489>>>>>>>>>>>>>    End_Function
36490>>>>>>>>>>>>>    
36490>>>>>>>>>>>>>    Function ColumnValues Integer iTable Integer[] aColumns Returns String[]
36493>>>>>>>>>>>>>        Integer iMax iIndex iColumn
36493>>>>>>>>>>>>>        String sValue
36493>>>>>>>>>>>>>        String[] aValues
36494>>>>>>>>>>>>>        Move (SizeOfArray(aColumns)-1) to iMax
36495>>>>>>>>>>>>>        For iIndex from 0 to iMax
36501>>>>>>>>>>>>>>
36501>>>>>>>>>>>>>            Move aColumns[iIndex] to iColumn
36502>>>>>>>>>>>>>            Get_Field_Value iTable iColumn to sValue
36505>>>>>>>>>>>>>            Move (Rtrim(sValue)) to aValues[iIndex]
36506>>>>>>>>>>>>>        Loop
36507>>>>>>>>>>>>>>
36507>>>>>>>>>>>>>        Function_Return aValues
36508>>>>>>>>>>>>>    End_Function
36509>>>>>>>>>>>>>    
36509>>>>>>>>>>>>>    Function DriversLoaded Returns Integer[]
36512>>>>>>>>>>>>>        Integer iDriverIndex iDriverMax
36512>>>>>>>>>>>>>        Integer[] aDrivers
36513>>>>>>>>>>>>>        String sDll
36513>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iDriverMax
36516>>>>>>>>>>>>>        For iDriverIndex from 1 to iDriverMax
36522>>>>>>>>>>>>>>
36522>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriverIndex to sDll
36525>>>>>>>>>>>>>            Get DriverDllToId of oTableDriverFunctions sDll to aDrivers[iDriverIndex-1]
36526>>>>>>>>>>>>>        Loop
36527>>>>>>>>>>>>>>
36527>>>>>>>>>>>>>        Function_Return aDrivers
36528>>>>>>>>>>>>>    End_Function
36529>>>>>>>>>>>>>    
36529>>>>>>>>>>>>>    Function DriversListedInFilelistCfg Returns Integer[] 
36532>>>>>>>>>>>>>        Integer iMax iIndex iDriver
36532>>>>>>>>>>>>>        Integer[] aTables aDrivers 
36534>>>>>>>>>>>>>        Get TableIntegerArray DF_FILE_NEXT_USED to aTables
36535>>>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
36536>>>>>>>>>>>>>        for iIndex from 0 to iMax
36542>>>>>>>>>>>>>>
36542>>>>>>>>>>>>>            Get TableDriver aTables[iIndex] to iDriver
36543>>>>>>>>>>>>>            If (not(IntegerIsOnStack(oStackFunctions,iDriver,aDrivers))) Begin
36545>>>>>>>>>>>>>                Send IntegerPush of oStackFunctions iDriver (&aDrivers)
36546>>>>>>>>>>>>>            End
36546>>>>>>>>>>>>>>
36546>>>>>>>>>>>>>        Loop
36547>>>>>>>>>>>>>>
36547>>>>>>>>>>>>>        Function_Return aDrivers
36548>>>>>>>>>>>>>    End_Function
36549>>>>>>>>>>>>>    
36549>>>>>>>>>>>>>End_Object // oTableAccessFunctions
36550>>>>>>>>>>>Use StackFunctions.pkg // Define oStackFunctions object
36550>>>>>>>>>>>Use RelationMapStruct.pkg // tRelationsDrawingMapItem struct
36550>>>>>>>>>>>Use TableDriverFunctions.pkg
36550>>>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
36550>>>>>>>>>>>
36550>>>>>>>>>>>Use cli.pkg
36550>>>>>>>>>>>
36550>>>>>>>>>>>Enum_List // Attribute types
36550>>>>>>>>>>>    Define ATYPE_NONE      // Not an attribute type
36550>>>>>>>>>>>    Define ATYPE_GLOBAL    // No parameters
36550>>>>>>>>>>>    Define ATYPE_DRIVER    // 1: Driver number
36550>>>>>>>>>>>    Define ATYPE_DRVSRV    // 1: Driver number  2: Server number
36550>>>>>>>>>>>    Define ATYPE_FILELIST  // 1: File  (No record buffer access, filelist only)
36550>>>>>>>>>>>    Define ATYPE_FILE      // 1: File
36550>>>>>>>>>>>    Define ATYPE_FIELD     // 1: File   2: Field
36550>>>>>>>>>>>    Define ATYPE_INDEX     // 1: File   2: Index
36550>>>>>>>>>>>    Define ATYPE_IDXSEG    // 1: File   2: Index   3: Segment
36550>>>>>>>>>>>    Define ATYPE_SPECIAL   // 1: File 2/3: Field/Field  (overlap check)
36550>>>>>>>>>>>    Define ATYPE_FLSTNAV   // 1: File (for navigating filelist)
36550>>>>>>>>>>>End_Enum_List
36550>>>>>>>>>>>
36550>>>>>>>>>>>//Enum_List // Calculated table attributes
36550>>>>>>>>>>>//    Define CTA_HAS_UNIQUE_INDEX
36550>>>>>>>>>>>//    Define CTA_HAS_UNIQUE_ONE_COLUMN_INDEX
36550>>>>>>>>>>>//    Define CTA_RELATES_BY_RECNUM
36550>>>>>>>>>>>//    Define CTA_HAS_OVERLAP_COLUMNS
36550>>>>>>>>>>>//End_Enum_List
36550>>>>>>>>>>>
36550>>>>>>>>>>>Struct tAttributeType
36550>>>>>>>>>>>    String  sName
36550>>>>>>>>>>>    Integer iParamCount
36550>>>>>>>>>>>    Integer iAttrNextAvailableIndex // array index that is
36550>>>>>>>>>>>End_Struct
36550>>>>>>>>>>>
36550>>>>>>>>>>>Struct tAttributeDiscreteValue
36550>>>>>>>>>>>    Integer iValue       // Actual attribute value
36550>>>>>>>>>>>    String  sCodeValue   // Value as written in source code
36550>>>>>>>>>>>    String  sDisplayName // Value as presented to an unknowing user
36550>>>>>>>>>>>End_Struct
36550>>>>>>>>>>>
36550>>>>>>>>>>>Struct tAttributeDefinition
36550>>>>>>>>>>>    String sName
36550>>>>>>>>>>>    Integer iAttrType              // Attribute type
36550>>>>>>>>>>>    String sDisplayName            // Attribute display name
36550>>>>>>>>>>>    Boolean bWrite                 // Write access?
36550>>>>>>>>>>>    Boolean bDawOnly               // Internal DAW use
36550>>>>>>>>>>>    Integer iValueType             // DF_BCD or DF_ASCII
36550>>>>>>>>>>>    Boolean bRuntimeOnly           // Runtime only attribute (FILE attr)
36550>>>>>>>>>>>    Boolean bDriverOnly            // Only query this (table-) attribute when driver is in use
36550>>>>>>>>>>>    tAttributeDiscreteValue[] aLegalValues // Legal values
36550>>>>>>>>>>>    tAttributeDiscreteValue[] aLegalValues // Legal values
36550>>>>>>>>>>>End_Struct
36550>>>>>>>>>>>
36550>>>>>>>>>>>Struct tAttributeValue
36550>>>>>>>>>>>    String  sValue
36550>>>>>>>>>>>End_Struct
36550>>>>>>>>>>>
36550>>>>>>>>>>>Global_Variable tAttributeValue[] gaEmptyAttributes
36550>>>>>>>>>>>
36550>>>>>>>>>>>Struct tFieldAttributes
36550>>>>>>>>>>>    tAttributeValue[] aFieldAttributes
36550>>>>>>>>>>>    tAttributeValue[] aFieldAttributes
36550>>>>>>>>>>>End_Struct
36550>>>>>>>>>>>
36550>>>>>>>>>>>Struct tIndexSegmentAttributes
36550>>>>>>>>>>>    tAttributeValue[] aIndexSegmentAttributes
36550>>>>>>>>>>>    tAttributeValue[] aIndexSegmentAttributes
36550>>>>>>>>>>>End_Struct
36550>>>>>>>>>>>
36550>>>>>>>>>>>Struct tIndexAttributes
36550>>>>>>>>>>>    tAttributeValue[] aIndexAttributes
36550>>>>>>>>>>>    tAttributeValue[] aIndexAttributes
36550>>>>>>>>>>>    tIndexSegmentAttributes[] aSegments
36550>>>>>>>>>>>    tIndexSegmentAttributes[] aSegments
36550>>>>>>>>>>>End_Struct
36550>>>>>>>>>>>
36550>>>>>>>>>>>Struct tTableAttributes
36550>>>>>>>>>>>    Integer iReadFromFileListEntryNo
36550>>>>>>>>>>>    String  sOpenAsPath
36550>>>>>>>>>>>    tAttributeValue[] aTableAttributes
36550>>>>>>>>>>>    tAttributeValue[] aTableAttributes
36550>>>>>>>>>>>    tFieldAttributes[] aFields
36550>>>>>>>>>>>    tFieldAttributes[] aFields
36550>>>>>>>>>>>    tIndexAttributes[] aIndices
36550>>>>>>>>>>>    tIndexAttributes[] aIndices
36550>>>>>>>>>>>End_Struct
36550>>>>>>>>>>>
36550>>>>>>>>>>>Struct tDataBaseServer
36550>>>>>>>>>>>    tAttributeValue[] aServerAttributes
36550>>>>>>>>>>>    tAttributeValue[] aServerAttributes
36550>>>>>>>>>>>End_Struct
36550>>>>>>>>>>>
36550>>>>>>>>>>>Struct tDataBaseDriver
36550>>>>>>>>>>>    tAttributeValue[] aDriverAttributes
36550>>>>>>>>>>>    tAttributeValue[] aDriverAttributes
36550>>>>>>>>>>>    tDataBaseServer[] aServers
36550>>>>>>>>>>>    tDataBaseServer[] aServers
36550>>>>>>>>>>>End_Struct
36550>>>>>>>>>>>
36550>>>>>>>>>>>Struct tFileList
36550>>>>>>>>>>>    tAttributeValue[] aGlobalAttributes
36550>>>>>>>>>>>    tAttributeValue[] aGlobalAttributes
36550>>>>>>>>>>>    tDataBaseDriver[] aDrivers
36550>>>>>>>>>>>    tDataBaseDriver[] aDrivers
36550>>>>>>>>>>>    tTableAttributes[] aTables
36550>>>>>>>>>>>    tTableAttributes[] aTables
36550>>>>>>>>>>>End_Struct
36550>>>>>>>>>>>
36550>>>>>>>>>>>Struct tTableField // Arg! This should have been named tTableIndexColumn
36550>>>>>>>>>>>    Integer iTable
36550>>>>>>>>>>>    Integer iField
36550>>>>>>>>>>>    Boolean bCapslock
36550>>>>>>>>>>>    Boolean bDescending
36550>>>>>>>>>>>End_Struct
36550>>>>>>>>>>>
36550>>>>>>>>>>>Struct tTableRelation
36550>>>>>>>>>>>    Integer iFromTable
36550>>>>>>>>>>>    Integer iToTable
36550>>>>>>>>>>>    tTableField[] aFromFields
36550>>>>>>>>>>>    tTableField[] aFromFields
36550>>>>>>>>>>>    tTableField[] aToFields
36550>>>>>>>>>>>    tTableField[] aToFields
36550>>>>>>>>>>>    Boolean bFunctioning // Relation sufficient for finding parent record
36550>>>>>>>>>>>    Integer[] aChildIndices // Indices that may be used for querying the child table records filtered by this relation
36550>>>>>>>>>>>End_Struct
36550>>>>>>>>>>>
36550>>>>>>>>>>>Struct tTableFieldExplicit
36550>>>>>>>>>>>    Integer iPosition
36550>>>>>>>>>>>    String  sName
36550>>>>>>>>>>>    Integer iType
36550>>>>>>>>>>>    Integer iLen
36550>>>>>>>>>>>    Integer iPrecision
36550>>>>>>>>>>>    Integer iRelFile
36550>>>>>>>>>>>    Integer iRelField
36550>>>>>>>>>>>    Integer iMainIndex
36550>>>>>>>>>>>    Integer iOffset
36550>>>>>>>>>>>    Integer iNativeLength
36550>>>>>>>>>>>    Integer iOverlapFieldStart
36550>>>>>>>>>>>    Integer iOverlapFieldEnd
36550>>>>>>>>>>>End_Struct
36550>>>>>>>>>>>
36550>>>>>>>>>>>Struct tTableIndexExplicit
36550>>>>>>>>>>>    Integer iType
36550>>>>>>>>>>>    Boolean bUnique
36550>>>>>>>>>>>    Integer iLevels
36550>>>>>>>>>>>    Integer iKeyLength
36550>>>>>>>>>>>    Integer[] aFields
36550>>>>>>>>>>>    Boolean[] aDescending
36550>>>>>>>>>>>    Boolean[] aCaseInsensitive
36550>>>>>>>>>>>End_Struct
36550>>>>>>>>>>>
36550>>>>>>>>>>>Struct tTableExplicit
36550>>>>>>>>>>>    Integer iFileListEntry
36550>>>>>>>>>>>    String  sRootName
36550>>>>>>>>>>>    String  sLogicalName
36550>>>>>>>>>>>    String  sDisplayName
36550>>>>>>>>>>>    String  sDriver
36550>>>>>>>>>>>    Boolean bSystemFile
36550>>>>>>>>>>>    Number  nMaxRecords
36550>>>>>>>>>>>    Number  nRecordsUsed
36550>>>>>>>>>>>    String  sPhysicalName
36550>>>>>>>>>>>    Integer iRecordLength
36550>>>>>>>>>>>    Integer iRecordLengthUsed
36550>>>>>>>>>>>    Integer iLockType
36550>>>>>>>>>>>    Integer iIntegrityCheck
36550>>>>>>>>>>>    tTableFieldExplicit[] aFields
36550>>>>>>>>>>>    tTableFieldExplicit[] aFields
36550>>>>>>>>>>>    tTableIndexExplicit[] aIndices
36550>>>>>>>>>>>    tTableIndexExplicit[] aIndices
36550>>>>>>>>>>>End_Struct
36550>>>>>>>>>>>
36550>>>>>>>>>>>Global_Variable tAttributeType[]       gaAttributeTypes   // AttrType definitions
36550>>>>>>>>>>>Global_Variable tAttributeDefinition[] gaAttributes       // Attr definitions
36550>>>>>>>>>>>Global_Variable Integer[][]            gaAttributesByType // Lists attributes by type (for speed)
36550>>>>>>>>>>>Global_Variable Integer[]              gaCompressedAttributeIndices // Look up an attribute and see it's compressed index
36550>>>>>>>>>>>Global_Variable Integer[][]            gaInverseCompressedAttributeIndices // [AttrType,compressed-Attr-index]-> Attr
36550>>>>>>>>>>>
36550>>>>>>>>>>>Global_Variable Integer oAttributeFunctions
36550>>>>>>>>>>>
36550>>>>>>>>>>>Class _cAttributeFunctions is a cObject
36551>>>>>>>>>>>
36551>>>>>>>>>>>    Procedure Construct_Object
36553>>>>>>>>>>>        Forward Send Construct_Object
36555>>>>>>>>>>>        Property Integer[] _paTableCompressedIndices
36556>>>>>>>>>>>        Property Integer _phProgressCallbackMsg 0
36557>>>>>>>>>>>        Property Integer _phProgressCallbackObj 0
36558>>>>>>>>>>>        Property Integer[] _paTempTableFilter
36559>>>>>>>>>>>        Send _BuildAttributeTypesArray
36560>>>>>>>>>>>        Send _BuildAttributesArray
36561>>>>>>>>>>>    End_Procedure
36562>>>>>>>>>>>
36562>>>>>>>>>>>    // **** Initialization of the object ***************************************************
36562>>>>>>>>>>>        Procedure _AddAttributeType Integer iAttrType String sName Integer iParams
36564>>>>>>>>>>>            Move sName to gaAttributeTypes[iAttrType].sName
36565>>>>>>>>>>>            Move iParams to gaAttributeTypes[iAttrType].iParamCount
36566>>>>>>>>>>>        End_Procedure
36567>>>>>>>>>>>
36567>>>>>>>>>>>    Procedure _BuildAttributeTypesArray
36569>>>>>>>>>>>        Send _AddAttributeType ATYPE_NONE     ""                   -1
36570>>>>>>>>>>>        Send _AddAttributeType ATYPE_GLOBAL   "Global"              0
36571>>>>>>>>>>>        Send _AddAttributeType ATYPE_DRIVER   "Driver"              1
36572>>>>>>>>>>>        Send _AddAttributeType ATYPE_DRVSRV   "Server"              2
36573>>>>>>>>>>>        Send _AddAttributeType ATYPE_FILELIST "Filelist"            1
36574>>>>>>>>>>>        Send _AddAttributeType ATYPE_FILE     "File"                1
36575>>>>>>>>>>>        Send _AddAttributeType ATYPE_FIELD    "Field"               2
36576>>>>>>>>>>>        Send _AddAttributeType ATYPE_INDEX    "Index"               2
36577>>>>>>>>>>>        Send _AddAttributeType ATYPE_IDXSEG   "Index segment"       3
36578>>>>>>>>>>>        Send _AddAttributeType ATYPE_SPECIAL  "Special1"            3
36579>>>>>>>>>>>        Send _AddAttributeType ATYPE_FLSTNAV  "Filelist navigation" 1
36580>>>>>>>>>>>    End_Procedure
36581>>>>>>>>>>>
36581>>>>>>>>>>>    Function AttributeType Integer iAttr Returns Integer
36583>>>>>>>>>>>        Function_Return gaAttributes[iAttr].iAttrType
36584>>>>>>>>>>>    End_Function
36585>>>>>>>>>>>    
36585>>>>>>>>>>>    Function AttributeName Integer iAttr Returns String
36587>>>>>>>>>>>        Function_Return gaAttributes[iAttr].sDisplayName
36588>>>>>>>>>>>    End_Function
36589>>>>>>>>>>>
36589>>>>>>>>>>>        Procedure _AddAttribute Integer iAttr String sName Integer iAttrType String sDisplayName Boolean bWrite Boolean bDawOnly Integer iValueType Boolean bRuntimeOnly Boolean bDriverOnly
36591>>>>>>>>>>>            Integer iNextAvailIndex
36591>>>>>>>>>>>            // Update gaAttributes containing all attributes regardless of type in a 1-dimensional array
36591>>>>>>>>>>>            Move sName to gaAttributes[iAttr].sName
36592>>>>>>>>>>>            Move iAttrType to gaAttributes[iAttr].iAttrType
36593>>>>>>>>>>>            Move sDisplayName to gaAttributes[iAttr].sDisplayName
36594>>>>>>>>>>>            Move bWrite to gaAttributes[iAttr].bWrite
36595>>>>>>>>>>>            Move bDawOnly to gaAttributes[iAttr].bDawOnly
36596>>>>>>>>>>>            Move iValueType to gaAttributes[iAttr].iValueType
36597>>>>>>>>>>>            Move bRuntimeOnly to gaAttributes[iAttr].bRuntimeOnly
36598>>>>>>>>>>>            Move bDriverOnly to gaAttributes[iAttr].bDriverOnly
36599>>>>>>>>>>>
36599>>>>>>>>>>>            // gaAttributesByType groups attributes by type:
36599>>>>>>>>>>>            Move iAttr to gaAttributesByType[iAttrType][SizeOfArray(gaAttributesByType[iAttrType])]
36600>>>>>>>>>>>
36600>>>>>>>>>>>            If (iAttrType=ATYPE_FILELIST) Move ATYPE_FILE to iAttrType
36603>>>>>>>>>>>            Move gaAttributeTypes[iAttrType].iAttrNextAvailableIndex to iNextAvailIndex
36604>>>>>>>>>>>            Move (iNextAvailIndex+1) to gaAttributeTypes[iAttrType].iAttrNextAvailableIndex
36605>>>>>>>>>>>            Move iNextAvailIndex to gaCompressedAttributeIndices[iAttr]
36606>>>>>>>>>>>            Move iAttr to gaInverseCompressedAttributeIndices[iAttrType][iNextAvailIndex]
36607>>>>>>>>>>>        End_Procedure
36608>>>>>>>>>>>
36608>>>>>>>>>>>        Procedure _AddAttributeLegalValue Integer iAttr Integer iValue String sCodeName String sDisplayName
36610>>>>>>>>>>>            Integer iIndex
36610>>>>>>>>>>>            Move (SizeOfArray(gaAttributes[iAttr].aLegalValues)) to iIndex
36611>>>>>>>>>>>            Move iValue to gaAttributes[iAttr].aLegalValues[iIndex].iValue
36612>>>>>>>>>>>            Move sCodeName to gaAttributes[iAttr].aLegalValues[iIndex].sCodeValue
36613>>>>>>>>>>>            Move sDisplayName to gaAttributes[iAttr].aLegalValues[iIndex].sDisplayName
36614>>>>>>>>>>>        End_Procedure
36615>>>>>>>>>>>
36615>>>>>>>>>>>    Procedure _BuildAttributesArray
36617>>>>>>>>>>>        //                                                                                                               Can    Daw            RT    Driver
36617>>>>>>>>>>>        //                DF symbol                  As written in source code    Attr. Type     Display name           Write   Only  Type     only  only
36617>>>>>>>>>>>        Send _AddAttribute DF_LOCK_DELAY              "DF_LOCK_DELAY"              ATYPE_GLOBAL   "Lock delay"            True  False DF_BCD   False False
36618>>>>>>>>>>>        Send _AddAttribute DF_LOCK_TIMEOUT            "DF_LOCK_TIMEOUT"            ATYPE_GLOBAL   "Lock timeout"          True  False DF_BCD   False False
36619>>>>>>>>>>>        Send _AddAttribute DF_OPEN_PATH               "DF_OPEN_PATH"               ATYPE_GLOBAL   "Open path"             True  False DF_ASCII False False
36620>>>>>>>>>>>        Send _AddAttribute DF_DATE_FORMAT             "DF_DATE_FORMAT"             ATYPE_GLOBAL   "Date format"           True  False DF_BCD   False False
36621>>>>>>>>>>>             Send _AddAttributeLegalValue DF_DATE_FORMAT DF_DATE_USA      "DF_DATE_USA"      "USA (mm/dd/yyyy)"
36622>>>>>>>>>>>             Send _AddAttributeLegalValue DF_DATE_FORMAT DF_DATE_EUROPEAN "DF_DATE_EUROPEAN" "European (dd/mm/yyyy)"
36623>>>>>>>>>>>             Send _AddAttributeLegalValue DF_DATE_FORMAT DF_DATE_MILITARY "DF_DATE_MILITARY" "Military (yyyy/mm/dd)"
36624>>>>>>>>>>>        Send _AddAttribute DF_DATE_SEPARATOR          "DF_DATE_SEPARATOR"          ATYPE_GLOBAL   "Date separator"        True  False DF_BCD   False False
36625>>>>>>>>>>>        Send _AddAttribute DF_DECIMAL_SEPARATOR       "DF_DECIMAL_SEPARATOR"       ATYPE_GLOBAL   "Decimal sep."          True  False DF_BCD   False False
36626>>>>>>>>>>>        Send _AddAttribute DF_THOUSANDS_SEPARATOR     "DF_THOUSANDS_SEPARATOR"     ATYPE_GLOBAL   "Thousands sep."        True  False DF_BCD   False False
36627>>>>>>>>>>>        Send _AddAttribute DF_ALL_FILES_TOUCHED       "DF_ALL_FILES_TOUCHED"       ATYPE_GLOBAL   "All files touched"     False False DF_BCD   True  False
36628>>>>>>>>>>>        Send _AddAttribute DF_HIGH_DATA_INTEGRITY     "DF_HIGH_DATA_INTEGRITY"     ATYPE_GLOBAL   "High data integr,"     True  False DF_BCD   False False
36629>>>>>>>>>>>        Send _AddAttribute DF_TRAN_COUNT              "DF_TRAN_COUNT"              ATYPE_GLOBAL   "Transact. nest. lev"   False False DF_BCD   True  False
36630>>>>>>>>>>>        Send _AddAttribute DF_TRANSACTION_ABORT       "DF_TRANSACTION_ABORT"       ATYPE_GLOBAL   "Transaction abort"     False False DF_BCD   False False
36631>>>>>>>>>>>        Send _AddAttribute DF_REREAD_REQUIRED         "DF_REREAD_REQUIRED"         ATYPE_GLOBAL   "Reread required"       False False DF_BCD   False False
36632>>>>>>>>>>>        Send _AddAttribute DF_FILELIST_NAME           "DF_FILELIST_NAME"           ATYPE_GLOBAL   "Filelist name"         True  False DF_ASCII False False
36633>>>>>>>>>>>        Send _AddAttribute DF_REPORT_UNSUPPORTED_ATTRIBUTES ;                                                      "DF_REPORT_UNSUPPORTED_ATTRIBUTES" ;                                                                                   ATYPE_GLOBAL   "Report unsup. attr."   True  False DF_BCD   False False
36634>>>>>>>>>>>        Send _AddAttribute DF_STRICT_ATTRIBUTES       "DF_STRICT_ATTRIBUTES"       ATYPE_GLOBAL   "Strict attributes"     True  False DF_BCD   False False
36635>>>>>>>>>>>        Send _AddAttribute DF_NUMBER_DRIVERS          "DF_NUMBER_DRIVERS"          ATYPE_GLOBAL   "Number drivers"        False False DF_BCD   False False
36636>>>>>>>>>>>        Send _AddAttribute DF_DRIVER_NAME             "DF_DRIVER_NAME"             ATYPE_DRIVER   "Driver name"           False False DF_ASCII False False
36637>>>>>>>>>>>        Send _AddAttribute DF_DRIVER_NUMBER_SERVERS   "DF_DRIVER_NUMBER_SERVERS"   ATYPE_DRIVER   "Driver number servers" False False DF_BCD   False True
36638>>>>>>>>>>>        Send _AddAttribute DF_DRIVER_CONFORMANCE      "DF_DRIVER_CONFORMANCE"      ATYPE_DRIVER   "Driver conformance"    False False DF_BCD   False True
36639>>>>>>>>>>>        Send _AddAttribute DF_DRIVER_SERVER_NAME      "DF_DRIVER_SERVER_NAME"      ATYPE_DRVSRV   "Driver server name"    False False DF_ASCII False False
36640>>>>>>>>>>>        Send _AddAttribute DF_API_DISABLED            "DF_API_DISABLED"            ATYPE_GLOBAL   "API disabled"          False True  DF_BCD   False False
36641>>>>>>>>>>>        Send _AddAttribute DF_API_DISABLED_ERROR      "DF_API_DISABLED_ERROR"      ATYPE_GLOBAL   "API disabled error"    False True  DF_BCD   False False
36642>>>>>>>>>>>        Send _AddAttribute DF_TRANABORT_ONERROR       "DF_TRANABORT_ONERROR"       ATYPE_GLOBAL   "Abort trans on error"  False False DF_BCD   False False
36643>>>>>>>>>>>        Send _AddAttribute DF_OPEN_FILE_COUNT         "DF_OPEN_FILE_COUNT"         ATYPE_GLOBAL   "Open tables count"     False False DF_BCD   False False
36644>>>>>>>>>>>        Send _AddAttribute DF_DATE_4_STATE            "DF_DATE_4_STATE"            ATYPE_GLOBAL   "Date 4 state"          False False DF_BCD   False False
36645>>>>>>>>>>>        Send _AddAttribute DF_EPOCH_VALUE             "DF_EPOCH_VALUE"             ATYPE_GLOBAL   "Epoch value"           False False DF_BCD   False False
36646>>>>>>>>>>>        Send _AddAttribute DF_SYSDATE_4_STATE         "DF_SYSDATE_4_STATE"         ATYPE_GLOBAL   "Sysdate 4 state"       False False DF_BCD   False False
36647>>>>>>>>>>>        Send _AddAttribute DF_NUMBER_FILES_SUPPORTED  "DF_NUMBER_FILES_SUPPORTED"  ATYPE_GLOBAL   "Max open tables"       False False DF_BCD   False False
36648>>>>>>>>>>>
36648>>>>>>>>>>>        Send _AddAttribute DF_FILE_STATUS             "DF_FILE_STATUS"             ATYPE_FILE     "Status"                False False DF_BCD   True  False
36649>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_STATUS DF_FILE_INACTIVE       "DF_FILE_INACTIVE"       "Inactive"
36650>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_STATUS DF_FILE_ACTIVE         "DF_FILE_ACTIVE"         "Active"
36651>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_STATUS DF_FILE_ACTIVE_CHANGED "DF_FILE_ACTIVE_CHANGED" "Changed"
36652>>>>>>>>>>>        Send _AddAttribute DF_FILE_MODE               "DF_FILE_MODE"               ATYPE_FILE     "Mode"                  True  False DF_BCD   True  False
36653>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_MODE DF_FILE_ALIAS_DEFAULT "DF_FILE_ALIAS_DEFAULT" "Default"
36654>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_MODE DF_FILE_IS_MASTER     "DF_FILE_IS_MASTER"     "Master"
36655>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_MODE DF_FILE_IS_ALIAS      "DF_FILE_IS_ALIAS"      "Alias"
36656>>>>>>>>>>>        Send _AddAttribute DF_FILE_MAX_RECORDS        "DF_FILE_MAX_RECORDS"        ATYPE_FILE     "Max records"           True  False DF_BCD   False False
36657>>>>>>>>>>>        Send _AddAttribute DF_FILE_RECORDS_USED       "DF_FILE_RECORDS_USED"       ATYPE_FILE     "Record count"          False False DF_BCD   False False
36658>>>>>>>>>>>        Send _AddAttribute DF_FILE_TYPE               "DF_FILE_TYPE"               ATYPE_FILE     "Type"                  False False DF_BCD   False False
36659>>>>>>>>>>>        Send _AddAttribute DF_FILE_MULTIUSER          "DF_FILE_MULTIUSER"          ATYPE_FILE     "Multiuser"             True  False DF_BCD   False False
36660>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_MULTIUSER DF_FILE_USER_SINGLE "DF_FILE_USER_SINGLE" "Single user"
36661>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_MULTIUSER DF_FILE_USER_MULTI  "DF_FILE_USER_MULTI"  "Multi user"
36662>>>>>>>>>>>        Send _AddAttribute DF_FILE_REUSE_DELETED      "DF_FILE_REUSE_DELETED"      ATYPE_FILE     "Reuse deleted"         True  False DF_BCD   False False
36663>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE "DF_FILE_DELETED_NOREUSE" "No reuse"
36664>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_REUSE_DELETED DF_FILE_DELETED_REUSE   "DF_FILE_DELETED_REUSE"   "Reuse"
36665>>>>>>>>>>>        Send _AddAttribute DF_FILE_NUMBER             "DF_FILE_NUMBER"             ATYPE_FILE     "Number"                False False DF_BCD   True  False
36666>>>>>>>>>>>        Send _AddAttribute DF_FILE_COMPRESSION        "DF_FILE_COMPRESSION"        ATYPE_FILE     "Compression"           True  False DF_BCD   False False
36667>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_COMPRESSION DF_FILE_COMPRESS_NONE     "DF_FILE_COMPRESS_NONE"     "None"
36668>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_COMPRESSION DF_FILE_COMPRESS_FAST     "DF_FILE_COMPRESS_FAST"     "Fast"
36669>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_COMPRESSION DF_FILE_COMPRESS_STANDARD "DF_FILE_COMPRESS_STANDARD" "Standard"
36670>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_COMPRESSION DF_FILE_COMPRESS_CUSTOM   "DF_FILE_COMPRESS_CUSTOM"   "Custom"
36671>>>>>>>>>>>        Send _AddAttribute DF_FILE_LAST_INDEX_NUMBER  "DF_FILE_LAST_INDEX_NUMBER"  ATYPE_FILE     "Highest index"         False False DF_BCD   False False
36672>>>>>>>>>>>        Send _AddAttribute DF_FILE_NUMBER_FIELDS      "DF_FILE_NUMBER_FIELDS"      ATYPE_FILE     "Number fields"         False False DF_BCD   False False
36673>>>>>>>>>>>        // Max 8 characters:
36673>>>>>>>>>>>        Send _AddAttribute DF_FILE_LOGICAL_NAME       "DF_FILE_LOGICAL_NAME"       ATYPE_FILELIST "Logical name"          True  False DF_ASCII False False
36674>>>>>>>>>>>        // Max 40 characters:
36674>>>>>>>>>>>        Send _AddAttribute DF_FILE_ROOT_NAME          "DF_FILE_ROOT_NAME"          ATYPE_FILELIST "Root name"             True  False DF_ASCII False False
36675>>>>>>>>>>>        Send _AddAttribute DF_FILE_CHANGED            "DF_FILE_CHANGED"            ATYPE_FILE     "Changed"               False False DF_BCD   True  False
36676>>>>>>>>>>>        Send _AddAttribute DF_FILE_ALIAS              "DF_FILE_ALIAS"              ATYPE_FILE     "Alias"                 True  False DF_BCD   True  False
36677>>>>>>>>>>>        //                                                                                                               Can    Daw            RT    Driver
36677>>>>>>>>>>>        //                DF symbol                  As written in source code    Attr. Type     Display name           Write   Only  Type     only  only
36677>>>>>>>>>>>        Send _AddAttribute DF_FILE_TOUCHED            "DF_FILE_TOUCHED"            ATYPE_FILE     "Touched"               False False DF_BCD   True  False
36678>>>>>>>>>>>        Send _AddAttribute DF_FILE_TRANSACTION        "DF_FILE_TRANSACTION"        ATYPE_FILE     "Transaction"           True  False DF_BCD   False False
36679>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_TRANSACTION DF_FILE_TRANSACTION_NONE          "DF_FILE_TRANSACTION_NONE"          "None"
36680>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_TRANSACTION DF_FILE_TRANSACTION_CLIENT_ATOMIC "DF_FILE_TRANSACTION_CLIENT_ATOMIC" "Client atomic"
36681>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_TRANSACTION DF_FILE_TRANSACTION_SERVER_ATOMIC "DF_FILE_TRANSACTION_SERVER_ATOMIC" "Server atomic"
36682>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_TRANSACTION DF_FILE_TRANSACTION_SERVER_LOGGED "DF_FILE_TRANSACTION_SERVER_LOGGED" "Server logged"
36683>>>>>>>>>>>        Send _AddAttribute DF_FILE_OPENED             "DF_FILE_OPENED"             ATYPE_FILE     "Opened"                False False DF_BCD   True  False
36684>>>>>>>>>>>        // Max 32 characters:
36684>>>>>>>>>>>        Send _AddAttribute DF_FILE_DISPLAY_NAME       "DF_FILE_DISPLAY_NAME"       ATYPE_FILELIST "Display name"          True  False DF_ASCII False False
36685>>>>>>>>>>>        Send _AddAttribute DF_FILE_PHYSICAL_NAME      "DF_FILE_PHYSICAL_NAME"      ATYPE_FILE     "Physical name"         False False DF_ASCII False False
36686>>>>>>>>>>>        Send _AddAttribute DF_FILE_NEXT_OPENED        "DF_FILE_NEXT_OPENED"        ATYPE_FLSTNAV  "Next opened"           False False DF_BCD   False False
36687>>>>>>>>>>>        Send _AddAttribute DF_FILE_NEXT_USED          "DF_FILE_NEXT_USED"          ATYPE_FLSTNAV  "Next used"             False False DF_BCD   False False
36688>>>>>>>>>>>        Send _AddAttribute DF_FILE_NEXT_EMPTY         "DF_FILE_NEXT_EMPTY"         ATYPE_FLSTNAV  "Next empty"            False False DF_BCD   False False
36689>>>>>>>>>>>        Send _AddAttribute DF_FILE_RECORD_LENGTH      "DF_FILE_RECORD_LENGTH"      ATYPE_FILE     "Record length"         True  False DF_BCD   False False
36690>>>>>>>>>>>        Send _AddAttribute DF_FILE_RESTRUCTURE        "DF_FILE_RESTRUCTURE"        ATYPE_FILE     "Restructure"           False False DF_BCD   True  False
36691>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_RESTRUCTURE DF_NO_RESTRUCTURE    "DF_NO_RESTRUCTURE"    "None"
36692>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_RESTRUCTURE DF_RESTRUCTURE_FILE  "DF_RESTRUCTURE_FILE"  "File"
36693>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_RESTRUCTURE DF_RESTRUCTURE_INDEX "DF_RESTRUCTURE_INDEX" "Index"
36694>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_RESTRUCTURE DF_RESTRUCTURE_BOTH  "DF_RESTRUCTURE_BOTH"  "File/Index"
36695>>>>>>>>>>>        Send _AddAttribute DF_FILE_OPEN_MODE          "DF_FILE_OPEN_MODE"          ATYPE_FILE     "Open mode"             False False DF_BCD   True  False
36696>>>>>>>>>>>              Send _AddAttributeLegalValue DF_FILE_OPEN_MODE DF_SHARE     "DF_SHARE"     "Share"
36697>>>>>>>>>>>              Send _AddAttributeLegalValue DF_FILE_OPEN_MODE DF_EXCLUSIVE "DF_EXCLUSIVE" "Exclusive"
36698>>>>>>>>>>>        Send _AddAttribute DF_FILE_INTEGRITY_CHECK    "DF_FILE_INTEGRITY_CHECK"    ATYPE_FILE     "Integrity check"       True  False DF_BCD   False False
36699>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_INTEGRITY_CHECK DFTRUE  "DFTRUE"  "True"
36700>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_INTEGRITY_CHECK DFFALSE "DFFALSE" "False"
36701>>>>>>>>>>>        Send _AddAttribute DF_FILE_OWNER              "DF_FILE_OWNER"              ATYPE_FILE     "Owner"                 False False DF_ASCII True  False
36702>>>>>>>>>>>        Send _AddAttribute DF_FILE_IS_SYSTEM_FILE     "DF_FILE_IS_SYSTEM_FILE"     ATYPE_FILE     "Is system file"        False False DF_BCD   False False
36703>>>>>>>>>>>        Send _AddAttribute DF_FILE_LOCK_TYPE          "DF_FILE_LOCK_TYPE"          ATYPE_FILE     "Lock type"             False False DF_BCD   False False
36704>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_LOCK_TYPE DF_LOCK_TYPE_NONE   "DF_LOCK_TYPE_NONE"   "None"
36705>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_LOCK_TYPE DF_LOCK_TYPE_FILE   "DF_LOCK_TYPE_FILE"   "File"
36706>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_LOCK_TYPE DF_LOCK_TYPE_RECORD "DF_LOCK_TYPE_RECORD" "Record"
36707>>>>>>>>>>>        Send _AddAttribute DF_FILE_COMMITTED          "DF_FILE_COMMITTED"          ATYPE_FILE     "Committed"             False False DF_BCD   True  False
36708>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_COMMITTED DFTRUE  "DFTRUE"  "True"
36709>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_COMMITTED DFFALSE "DFFALSE" "False"
36710>>>>>>>>>>>        Send _AddAttribute DF_FILE_DRIVER             "DF_FILE_DRIVER"             ATYPE_FILE     "Driver"                False False DF_ASCII False False
36711>>>>>>>>>>>        Send _AddAttribute DF_FILE_LOGIN              "DF_FILE_LOGIN"              ATYPE_FILE     "Driver login"          False False DF_ASCII False True
36712>>>>>>>>>>>        Send _AddAttribute DF_FILE_RECORD_LENGTH_USED "DF_FILE_RECORD_LENGTH_USED" ATYPE_FILE     "Record length used"    False False DF_BCD   False False
36713>>>>>>>>>>>        Send _AddAttribute DF_FILE_HANDLE_TYPE        "DF_FILE_HANDLE_TYPE"        ATYPE_FILE     "Handle type"           False True  DF_BCD   True  False
36714>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_HANDLE_TYPE DF_FILE_HANDLE_BAD                   "DF_FILE_HANDLE_BAD"                  "Bad"
36715>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_HANDLE_TYPE DF_FILE_HANDLE_CLOSED                "DF_FILE_HANDLE_CLOSED"               "Closed"
36716>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_HANDLE_TYPE DF_FILE_HANDLE_OPENED                "DF_FILE_HANDLE_OPENED"               "Opened"
36717>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_HANDLE_TYPE DF_FILE_HANDLE_EXISTING_RESTRUCTURE  "DF_FILE_HANDLE_EXISTING_RESTRUCTURE" "Existing restructure"
36718>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_HANDLE_TYPE DF_FILE_HANDLE_NEW_RESTRUCTURE       "DF_FILE_HANDLE_NEW_RESTRUCTURE"      "New restructure"
36719>>>>>>>>>>>        Send _AddAttribute DF_FILE_RECORD_IDENTITY    "DF_FILE_RECORD_IDENTITY"    ATYPE_FILE     "Record identity"       True  False DF_BCD   False False
36720>>>>>>>>>>>        //Send _AddAttribute DF_FILE_LOGIN              "DF_FILE_LOGIN"              ATYPE_FILE     "Login"                 True  False DF_ASCII True
36720>>>>>>>>>>>        Send _AddAttribute DF_FILE_RECORD_PRIVILEGE   "DF_FILE_RECORD_PRIVILEGE"   ATYPE_FILE     "Record privilege"      False True  DF_BCD   True  False
36721>>>>>>>>>>>        Send _AddAttribute DF_FILE_PRIVILEGE          "DF_FILE_PRIVILEGE"          ATYPE_FILE     "Privilege"             False True  DF_BCD   True  False
36722>>>>>>>>>>>        Send _AddAttribute DF_FILE_CREATION_SERIAL    "DF_FILE_CREATION_SERIAL"    ATYPE_FILE     "Creation serial"       False True  DF_BCD   True  False
36723>>>>>>>>>>>        Send _AddAttribute DF_FILE_REVISION           "DF_FILE_REVISION"           ATYPE_FILE     "Revision"              False False DF_ASCII False False
36724>>>>>>>>>>>        Send _AddAttribute DF_FILE_RELATED_COUNT      "DF_FILE_RELATED_COUNT"      ATYPE_FILE     "Related count"         False True  DF_BCD   True  False
36725>>>>>>>>>>>        Send _AddAttribute DF_FILE_RELATED_FIELDS     "DF_FILE_RELATED_FIELDS"     ATYPE_FILE     "Related fields"        False True  DF_BCD   True  False
36726>>>>>>>>>>>        Send _AddAttribute DF_FILE_SYSTEM_FILE        "DF_FILE_SYSTEM_FILE"        ATYPE_FILE     "System file"           False False DF_BCD   True  False
36727>>>>>>>>>>>        Send _AddAttribute DF_FILE_SYSTEM_FIELD       "DF_FILE_SYSTEM_FIELD"       ATYPE_FILE     "System field"          False False DF_BCD   True  False
36728>>>>>>>>>>>        Send _AddAttribute DF_FILE_RECORD_REREAD      "DF_FILE_RECORD_REREAD"      ATYPE_FILE     "Record reread"         False True  DF_BCD   True  False
36729>>>>>>>>>>>        Send _AddAttribute DF_FILE_RECNUM_TABLE       "DF_FILE_RECNUM_TABLE "      ATYPE_FILE     "Recnum table"          False False DF_BCD   False False
36730>>>>>>>>>>>        Send _AddAttribute DF_FILE_PRIMARY_INDEX      "DF_FILE_PRIMARY_INDEX"      ATYPE_FILE     "Primary index"         False False DF_BCD   False True
36731>>>>>>>>>>>        
36731>>>>>>>>>>>        //                                                                                                                Can    Daw           RT    Driver
36731>>>>>>>>>>>        //                 DF symbol                  As written in source code    Attr. Type     Display name            Write  Only  Type    only  only
36731>>>>>>>>>>>        Send _AddAttribute DF_FILE_REFIND_AFTER_SAVE  "DF_FILE_REFIND_AFTER_SAVE"  ATYPE_FILE     "Refind after save"     False False DF_BCD   False True
36732>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_REFIND_AFTER_SAVE DFTRUE  "DFTRUE"  "True"
36733>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_REFIND_AFTER_SAVE DFFALSE "DFFALSE" "False"
36734>>>>>>>>>>>        
36734>>>>>>>>>>>        Send _AddAttribute DF_FILE_GET_RID_AFTER_CREATE "DF_FILE_GET_RID_AFTER_CREATE" ATYPE_FILE "Get rid after create"  False False DF_BCD   False True
36735>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_GET_RID_AFTER_CREATE DFTRUE  "DFTRUE"  "True"
36736>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_GET_RID_AFTER_CREATE DFFALSE "DFFALSE" "False"
36737>>>>>>>>>>>             
36737>>>>>>>>>>>        Send _AddAttribute DF_FILE_JIT_BINDING "DF_FILE_JIT_BINDING" ATYPE_FILE "Get rid after create"  False False DF_BCD   False True
36738>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_JIT_BINDING DFTRUE  "DFTRUE"  "True"
36739>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_JIT_BINDING DFFALSE "DFFALSE" "False"
36740>>>>>>>>>>>
36740>>>>>>>>>>>        // ToDo: Send _AddAttribute DF_FILE_JIT_BINDING       "DF_FILE_"      ATYPE_FILE     "Primary index"         False False DF_BCD   False True
36740>>>>>>>>>>>        //       Send _AddAttribute DF_DRIVER_JIT_TRESHOLD       "DF_FILE_"      ATYPE_FILE     "Primary index"         False False DF_BCD   False True
36740>>>>>>>>>>>        //       Send _AddAttribute DF_FILE_USE_DUMMY_ZERO_DATE
36740>>>>>>>>>>>
36740>>>>>>>>>>>        Send _AddAttribute DF_FIELD_NUMBER            "DF_FIELD_NUMBER"            ATYPE_FIELD    "Number"                False False DF_BCD   False False
36741>>>>>>>>>>>        Send _AddAttribute DF_FIELD_TYPE              "DF_FIELD_TYPE"              ATYPE_FIELD    "Type"                  True  False DF_BCD   False False
36742>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FIELD_TYPE DF_ASCII    "DF_ASCII"    "Ascii"
36743>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FIELD_TYPE DF_BCD      "DF_BCD"      "Number"
36744>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FIELD_TYPE DF_DATE     "DF_DATE"     "Date"
36745>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FIELD_TYPE DF_DATETIME "DF_DATETIME" "DateTime"
36746>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FIELD_TYPE DF_OVERLAP  "DF_OVERLAP"  "Overlap"
36747>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FIELD_TYPE DF_TEXT     "DF_TEXT"     "Text"
36748>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FIELD_TYPE DF_BINARY   "DF_BINARY"  " Binary"
36749>>>>>>>>>>>        Send _AddAttribute DF_FIELD_LENGTH            "DF_FIELD_LENGTH"            ATYPE_FIELD    "Length"                True  False DF_BCD   False False
36750>>>>>>>>>>>        Send _AddAttribute DF_FIELD_PRECISION         "DF_FIELD_PRECISION"         ATYPE_FIELD    "Precision"             True  False DF_BCD   False False
36751>>>>>>>>>>>        Send _AddAttribute DF_FIELD_RELATED_FILE      "DF_FIELD_RELATED_FILE"      ATYPE_FIELD    "Related file"          True  False DF_BCD   False False
36752>>>>>>>>>>>        Send _AddAttribute DF_FIELD_RELATED_FIELD     "DF_FIELD_RELATED_FIELD"     ATYPE_FIELD    "Related field"         True  False DF_BCD   False False
36753>>>>>>>>>>>        Send _AddAttribute DF_FIELD_NAME              "DF_FIELD_NAME"              ATYPE_FIELD    "Name"                  True  False DF_ASCII False False
36754>>>>>>>>>>>        Send _AddAttribute DF_FIELD_INDEX             "DF_FIELD_INDEX"             ATYPE_FIELD    "Index"                 True  False DF_BCD   False False
36755>>>>>>>>>>>        Send _AddAttribute DF_FIELD_OFFSET            "DF_FIELD_OFFSET"            ATYPE_FIELD    "Offset"                True  False DF_BCD   False False
36756>>>>>>>>>>>        Send _AddAttribute DF_FIELD_OLD_NUMBER        "DF_FIELD_OLD_NUMBER"        ATYPE_FIELD    "Old number"            False True  DF_BCD   False False // Only during restruct!
36757>>>>>>>>>>>        Send _AddAttribute DF_FIELD_OVERLAP           "DF_FIELD_OVERLAP"           ATYPE_SPECIAL  "Overlap"               False False DF_BCD   False False
36758>>>>>>>>>>>        Send _AddAttribute DF_FIELD_NATIVE_LENGTH     "DF_FIELD_NATIVE_LENGTH"     ATYPE_FIELD    "Native length"         False False DF_BCD   False False
36759>>>>>>>>>>>
36759>>>>>>>>>>>        Send _AddAttribute DF_INDEX_NUMBER_SEGMENTS   "DF_INDEX_NUMBER_SEGMENTS"   ATYPE_INDEX    "Number segments"       True  False DF_BCD   False False
36760>>>>>>>>>>>        Send _AddAttribute DF_INDEX_NUMBER_BUFFERS    "DF_INDEX_NUMBER_BUFFERS"    ATYPE_INDEX    "Number buffers"        False False DF_BCD   False False
36761>>>>>>>>>>>        Send _AddAttribute DF_INDEX_TYPE              "DF_INDEX_TYPE"              ATYPE_INDEX    "Type"                  True  False DF_BCD   False False
36762>>>>>>>>>>>             Send _AddAttributeLegalValue DF_INDEX_TYPE DF_INDEX_TYPE_ONLINE "DF_INDEX_TYPE_ONLINE" "Online"
36763>>>>>>>>>>>             Send _AddAttributeLegalValue DF_INDEX_TYPE DF_INDEX_TYPE_BATCH  "DF_INDEX_TYPE_BATCH"  "Batch"
36764>>>>>>>>>>>        Send _AddAttribute DF_INDEX_LEVELS            "DF_INDEX_LEVELS"            ATYPE_INDEX    "Levels"                False False DF_BCD   False False
36765>>>>>>>>>>>        Send _AddAttribute DF_INDEX_KEY_LENGTH        "DF_INDEX_KEY_LENGTH"        ATYPE_INDEX    "Key length"            False False DF_BCD   False False
36766>>>>>>>>>>>
36766>>>>>>>>>>>        Send _AddAttribute DF_INDEX_SEGMENT_DIRECTION "DF_INDEX_SEGMENT_DIRECTION" ATYPE_IDXSEG   "Segment direction"     True  False DF_BCD   False False
36767>>>>>>>>>>>             Send _AddAttributeLegalValue DF_INDEX_SEGMENT_DIRECTION DF_ASCENDING  "DF_ASCENDING"  "Ascending"
36768>>>>>>>>>>>             Send _AddAttributeLegalValue DF_INDEX_SEGMENT_DIRECTION DF_DESCENDING "DF_DESCENDING" "Descending"
36769>>>>>>>>>>>        Send _AddAttribute DF_INDEX_SEGMENT_CASE      "DF_INDEX_SEGMENT_CASE"      ATYPE_IDXSEG   "Segment case"          True  False DF_BCD   False False
36770>>>>>>>>>>>             Send _AddAttributeLegalValue DF_INDEX_SEGMENT_CASE DF_CASE_USED    "DF_CASE_USED"    "Case used"
36771>>>>>>>>>>>             Send _AddAttributeLegalValue DF_INDEX_SEGMENT_CASE DF_CASE_IGNORED "DF_CASE_IGNORED" "Case ignored"
36772>>>>>>>>>>>        Send _AddAttribute DF_INDEX_SEGMENT_FIELD     "DF_INDEX_SEGMENT_FIELD"     ATYPE_IDXSEG   "Segment field"         True  False DF_BCD   False False
36773>>>>>>>>>>>    End_Procedure
36774>>>>>>>>>>>
36774>>>>>>>>>>>    // **** Functions for reading the attributes of a database *****************************************
36774>>>>>>>>>>>
36774>>>>>>>>>>>    Function _LegalValuesIndex Integer iAttr String sValue Returns Integer
36776>>>>>>>>>>>        Integer iMax iIndex
36776>>>>>>>>>>>        String sTest
36776>>>>>>>>>>>        Move (SizeOfArray(gaAttributes[iAttr].aLegalValues)-1) to iMax
36777>>>>>>>>>>>        For iIndex from 0 to iMax
36783>>>>>>>>>>>>
36783>>>>>>>>>>>            Move gaAttributes[iAttr].aLegalValues[iIndex].iValue to sTest
36784>>>>>>>>>>>            If (sValue=sTest) Function_Return iIndex
36787>>>>>>>>>>>            //If (sValue=gaAttributes[iAttr].aLegalValues[iIndex]) Function_Return iIndex
36787>>>>>>>>>>>        Loop
36788>>>>>>>>>>>>
36788>>>>>>>>>>>        Function_Return -1
36789>>>>>>>>>>>    End_Function
36790>>>>>>>>>>>
36790>>>>>>>>>>>    Function AttributeDisplayValue Integer iAttr String sValue Returns String
36792>>>>>>>>>>>        Integer iIndex
36792>>>>>>>>>>>        Get _LegalValuesIndex iAttr sValue to iIndex
36793>>>>>>>>>>>        If (iIndex=-1) Function_Return sValue
36796>>>>>>>>>>>        Function_Return gaAttributes[iAttr].aLegalValues[iIndex].sDisplayName // "European (dd/mm/yyyy)"
36797>>>>>>>>>>>    End_Function
36798>>>>>>>>>>>
36798>>>>>>>>>>>    Function AttributeSymbolicValue Integer iAttr String sValue Returns String
36800>>>>>>>>>>>        Integer iIndex
36800>>>>>>>>>>>        Get _LegalValuesIndex iAttr sValue to iIndex
36801>>>>>>>>>>>        If (iIndex=-1) Function_Return sValue
36804>>>>>>>>>>>        Function_Return gaAttributes[iAttr].aLegalValues[iIndex].sCodeValue // "DF_DATE_EUROPEAN"
36805>>>>>>>>>>>    End_Function
36806>>>>>>>>>>>    
36806>>>>>>>>>>>        Function _IsTableBufferAttributeType Integer iAttrType Returns Boolean
36808>>>>>>>>>>>            Function_Return (iAttrType=ATYPE_FILE or iAttrType=ATYPE_FIELD or ;                iAttrType=ATYPE_INDEX or iAttrType=ATYPE_INDEX or iAttrType=ATYPE_SPECIAL)
36809>>>>>>>>>>>        End_Function
36810>>>>>>>>>>>
36810>>>>>>>>>>>    Function _CanGetAttribute Integer hTable Integer iAttr Returns Boolean
36812>>>>>>>>>>>        Integer iHandleType iAttrType
36812>>>>>>>>>>>        Boolean bRestruct bOpen
36812>>>>>>>>>>>        String sDriver
36812>>>>>>>>>>>
36812>>>>>>>>>>>        //    Define ATYPE_GLOBAL    // No parameters
36812>>>>>>>>>>>        //    Define ATYPE_DRIVER    // 1: Driver number
36812>>>>>>>>>>>        //    Define ATYPE_DRVSRV    // 1: Driver number  2: Server number
36812>>>>>>>>>>>        //    Define ATYPE_FILELIST  // 1: File  (No record buffer access, filelist only)
36812>>>>>>>>>>>        //    Define ATYPE_FILE      // 1: File
36812>>>>>>>>>>>        //    Define ATYPE_FIELD     // 1: File   2: Field
36812>>>>>>>>>>>        //    Define ATYPE_INDEX     // 1: File   2: Index
36812>>>>>>>>>>>        //    Define ATYPE_IDXSEG    // 1: File   2: Index   3: Segment
36812>>>>>>>>>>>        //    Define ATYPE_SPECIAL   // 1: File 2/3: Field/Field  (overlap check)
36812>>>>>>>>>>>        //    Define ATYPE_FLSTNAV   // 1: File (for navigating filelist)
36812>>>>>>>>>>>
36812>>>>>>>>>>>        Move gaAttributes[iAttr].iAttrType to iAttrType
36813>>>>>>>>>>>        
36813>>>>>>>>>>>        If (_IsTableBufferAttributeType(Self,iAttrType) or iAttrType=ATYPE_FILELIST or iAttrType=ATYPE_FLSTNAV) Begin
36815>>>>>>>>>>>            Get_Attribute DF_FILE_HANDLE_TYPE of hTable to iHandleType
36818>>>>>>>>>>>
36818>>>>>>>>>>>                // Possible return values for iHandleType:
36818>>>>>>>>>>>                //   DF_FILE_HANDLE_BAD
36818>>>>>>>>>>>                //   DF_FILE_HANDLE_CLOSED
36818>>>>>>>>>>>                //   DF_FILE_HANDLE_OPENED
36818>>>>>>>>>>>                //   DF_FILE_HANDLE_EXISTING_RESTRUCTURE
36818>>>>>>>>>>>                //   DF_FILE_HANDLE_NEW_RESTRUCTURE
36818>>>>>>>>>>>
36818>>>>>>>>>>>            Move (iHandleType=DF_FILE_HANDLE_EXISTING_RESTRUCTURE or iHandleType=DF_FILE_HANDLE_NEW_RESTRUCTURE) to bRestruct
36819>>>>>>>>>>>
36819>>>>>>>>>>>            If (bRestruct and iAttrType=ATYPE_FILELIST) Begin
36821>>>>>>>>>>>                Function_Return False
36822>>>>>>>>>>>            End
36822>>>>>>>>>>>>
36822>>>>>>>>>>>    
36822>>>>>>>>>>>            If (not(bRestruct) and iAttr=DF_FIELD_OLD_NUMBER) Begin
36824>>>>>>>>>>>                Function_Return False
36825>>>>>>>>>>>            End
36825>>>>>>>>>>>>
36825>>>>>>>>>>>    
36825>>>>>>>>>>>            // Can't read those during a restructure
36825>>>>>>>>>>>            If (bRestruct and iAttr=DF_INDEX_NUMBER_BUFFERS or iAttr=DF_FILE_TOUCHED or iAttr=DF_FILE_OPENED) Begin
36827>>>>>>>>>>>                Function_Return False
36828>>>>>>>>>>>            End
36828>>>>>>>>>>>>
36828>>>>>>>>>>>
36828>>>>>>>>>>>            If (bRestruct or iHandleType=DF_FILE_OPENED) Begin
36830>>>>>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriver
36833>>>>>>>>>>>                If (sDriver="DFBTRDRV") Begin
36835>>>>>>>>>>>                    If (iAttr=DF_FILE_REFIND_AFTER_SAVE or ;                        iAttr=DF_FILE_GET_RID_AFTER_CREATE or ;                        iAttr=DF_FILE_JIT_BINDING) Begin
36837>>>>>>>>>>>                        Function_Return False
36838>>>>>>>>>>>                    End
36838>>>>>>>>>>>>
36838>>>>>>>>>>>                End
36838>>>>>>>>>>>>
36838>>>>>>>>>>>            End
36838>>>>>>>>>>>>
36838>>>>>>>>>>>        End
36838>>>>>>>>>>>>
36838>>>>>>>>>>>        Function_Return True
36839>>>>>>>>>>>    End_Function
36840>>>>>>>>>>>//
36840>>>>>>>>>>>//
36840>>>>>>>>>>>//        If (hTable>=1) Begin
36840>>>>>>>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bOpen
36840>>>>>>>>>>>//            If (bOpen) Begin
36840>>>>>>>>>>>//                Get_Attribute DF_FILE_DRIVER of hTable to sDriver
36840>>>>>>>>>>>//            End
36840>>>>>>>>>>>//            If (sDriver="DFBTRDRV") Begin
36840>>>>>>>>>>>//                If (iAttr=DF_FILE_REFIND_AFTER_SAVE or ;
36840>>>>>>>>>>>//                    iAttr=DF_FILE_GET_RID_AFTER_CREATE or ;
36840>>>>>>>>>>>//                    iAttr=DF_FILE_JIT_BINDING) Begin
36840>>>>>>>>>>>//                    Function_Return False
36840>>>>>>>>>>>//                End
36840>>>>>>>>>>>//            End
36840>>>>>>>>>>>//        End
36840>>>>>>>>>>>//
36840>>>>>>>>>>>//
36840>>>>>>>>>>>//        If (bRestruct and iAttrType=ATYPE_FILELIST) Begin
36840>>>>>>>>>>>//            Function_Return False
36840>>>>>>>>>>>//        End
36840>>>>>>>>>>>//
36840>>>>>>>>>>>//        If (not(bRestruct) and iAttr=DF_FIELD_OLD_NUMBER) Begin
36840>>>>>>>>>>>//            Function_Return False
36840>>>>>>>>>>>//        End
36840>>>>>>>>>>>//
36840>>>>>>>>>>>//        // Can't read those during a restructure
36840>>>>>>>>>>>//        If (bRestruct and iAttr=DF_INDEX_NUMBER_BUFFERS or iAttr=DF_FILE_TOUCHED or iAttr=DF_FILE_OPENED) Begin
36840>>>>>>>>>>>//            Function_Return False
36840>>>>>>>>>>>//        End
36840>>>>>>>>>>>//        Function_Return True
36840>>>>>>>>>>>
36840>>>>>>>>>>>//DF_FILE_HANDLE_OPENED
36840>>>>>>>>>>>//DF_FILE_HANDLE_EXISTING_RESTRUCTURE
36840>>>>>>>>>>>//DF_FILE_HANDLE_NEW_RESTRUCTURE
36840>>>>>>>>>>>
36840>>>>>>>>>>>
36840>>>>>>>>>>>
36840>>>>>>>>>>>        Procedure Set _AttributeValue tAttributeValue[] ByRef aAttributes Integer iAttr String sValue
36842>>>>>>>>>>>            Move sValue to aAttributes[gaCompressedAttributeIndices[iAttr]].sValue
36843>>>>>>>>>>>        End_Procedure
36844>>>>>>>>>>>
36844>>>>>>>>>>>        Function _AttributeValue tAttributeValue[] aAttributes Integer iAttr Returns String
36846>>>>>>>>>>>            Integer iIndex
36846>>>>>>>>>>>            If (SizeOfArray(aAttributes)<>0) Begin
36848>>>>>>>>>>>                Move gaCompressedAttributeIndices[iAttr] to iIndex
36849>>>>>>>>>>>                If (iIndex<SizeOfArray(aAttributes)) Function_Return aAttributes[iIndex].sValue
36852>>>>>>>>>>>            End
36852>>>>>>>>>>>>
36852>>>>>>>>>>>            Function_Return ""
36853>>>>>>>>>>>        End_Function
36854>>>>>>>>>>>
36854>>>>>>>>>>>        Procedure _GetAllAttributesOfType Integer iAttrType tAttributeValue[] ByRef aAttributes ;                                                            Integer iVal1 Integer iVal2 Integer iVal3
36856>>>>>>>>>>>            Boolean bOk bRestruct
36856>>>>>>>>>>>            Integer iIndex iMax iAttr iParams
36856>>>>>>>>>>>            String sValue sDriver
36856>>>>>>>>>>>            Move gaAttributeTypes[iAttrType].iParamCount to iParams
36857>>>>>>>>>>>            Move (SizeOfArray(gaAttributesByType[iAttrType])-1) to iMax
36858>>>>>>>>>>>            For iIndex from 0 to iMax
36864>>>>>>>>>>>>
36864>>>>>>>>>>>                Move gaAttributesByType[iAttrType][iIndex] to iAttr
36865>>>>>>>>>>>
36865>>>>>>>>>>>                If (not(gaAttributes[iAttr].bDawOnly)) Begin
36867>>>>>>>>>>>                    If (gaAttributes[iAttr].bDriverOnly) Begin
36869>>>>>>>>>>>                        If (iAttrType=ATYPE_DRIVER) Begin
36871>>>>>>>>>>>                            Get_Attribute DF_DRIVER_NAME of iVal1 to sDriver
36874>>>>>>>>>>>                            Move (sDriver<>"DATAFLEX") to bOk
36875>>>>>>>>>>>                        End
36875>>>>>>>>>>>>
36875>>>>>>>>>>>                        Else Begin
36876>>>>>>>>>>>                            Get_Attribute DF_FILE_DRIVER of iVal1 to sDriver
36879>>>>>>>>>>>                            Move (sDriver<>"DATAFLEX") to bOk
36880>>>>>>>>>>>                        End
36880>>>>>>>>>>>>
36880>>>>>>>>>>>                    End
36880>>>>>>>>>>>>
36880>>>>>>>>>>>                    Else begin
36881>>>>>>>>>>>                        Move True to bOk
36882>>>>>>>>>>>                    End
36882>>>>>>>>>>>>
36882>>>>>>>>>>>
36882>>>>>>>>>>>                    If (bOk) Begin
36884>>>>>>>>>>>                        If (iParams=0) Begin
36886>>>>>>>>>>>                            Get_Attribute iAttr to sValue
36889>>>>>>>>>>>                        End
36889>>>>>>>>>>>>
36889>>>>>>>>>>>                        Else Begin
36890>>>>>>>>>>>                            If (_CanGetAttribute(Self,iVal1,iAttr)) Begin
36892>>>>>>>>>>>                                If (iParams=1) Get_Attribute iAttr of iVal1 to sValue
36897>>>>>>>>>>>                                If (iParams=2) Get_Attribute iAttr of iVal1 iVal2 to sValue
36902>>>>>>>>>>>                                If (iParams=3) Get_Attribute iAttr of iVal1 iVal2 iVal3 to sValue
36907>>>>>>>>>>>                            End
36907>>>>>>>>>>>>
36907>>>>>>>>>>>                            Else Begin
36908>>>>>>>>>>>                                Move "" to sValue
36909>>>>>>>>>>>                            End
36909>>>>>>>>>>>>
36909>>>>>>>>>>>                        End
36909>>>>>>>>>>>>
36909>>>>>>>>>>>                        Set _AttributeValue (&aAttributes) iAttr to sValue
36910>>>>>>>>>>>                    End
36910>>>>>>>>>>>>
36910>>>>>>>>>>>                    Else begin
36911>>>>>>>>>>>                        Move "" to sValue
36912>>>>>>>>>>>                    End
36912>>>>>>>>>>>>
36912>>>>>>>>>>>                End
36912>>>>>>>>>>>>
36912>>>>>>>>>>>            Loop
36913>>>>>>>>>>>>
36913>>>>>>>>>>>        End_Procedure
36914>>>>>>>>>>>
36914>>>>>>>>>>>    Procedure _GetFieldAttributes tFieldAttributes ByRef strField Integer iTable Integer iField
36916>>>>>>>>>>>        // Make sure nothing lingers from a previous call
36916>>>>>>>>>>>        Move (ResizeArray(strField.aFieldAttributes,0)) to strField.aFieldAttributes
36917>>>>>>>>>>>        Send _GetAllAttributesOfType ATYPE_FIELD (&strField.aFieldAttributes) iTable iField
36918>>>>>>>>>>>    End_Procedure
36919>>>>>>>>>>>
36919>>>>>>>>>>>    Procedure _GetIndexSegmentAttributes tIndexSegmentAttributes ByRef strIndexSegment Integer iTable Integer iIndex Integer iSegment
36921>>>>>>>>>>>        // Make sure nothing lingers from a previous call
36921>>>>>>>>>>>        Move (ResizeArray(strIndexSegment.aIndexSegmentAttributes,0)) to strIndexSegment.aIndexSegmentAttributes
36922>>>>>>>>>>>        Send _GetAllAttributesOfType ATYPE_IDXSEG (&strIndexSegment.aIndexSegmentAttributes) iTable iIndex iSegment
36923>>>>>>>>>>>    End_Procedure
36924>>>>>>>>>>>
36924>>>>>>>>>>>    Procedure _GetIndexAttributes tIndexAttributes ByRef strIndex Integer iTable Integer iIndex
36926>>>>>>>>>>>        Integer iMaxSegment iSegment
36926>>>>>>>>>>>        tIndexSegmentAttributes strIndexSegment
36926>>>>>>>>>>>        tIndexSegmentAttributes strIndexSegment
36926>>>>>>>>>>>
36926>>>>>>>>>>>        // Make sure nothing lingers from a previous call
36926>>>>>>>>>>>        Move (ResizeArray(strIndex.aIndexAttributes,0)) to strIndex.aIndexAttributes
36927>>>>>>>>>>>        Move (ResizeArray(strIndex.aSegments,0)) to strIndex.aSegments
36928>>>>>>>>>>>
36928>>>>>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iTable iIndex to iMaxSegment
36931>>>>>>>>>>>        If (iMaxSegment>=1) Begin
36933>>>>>>>>>>>            Send _GetAllAttributesOfType ATYPE_INDEX (&strIndex.aIndexAttributes) iTable iIndex
36934>>>>>>>>>>>            For iSegment from 1 to iMaxSegment
36940>>>>>>>>>>>>
36940>>>>>>>>>>>                Send _GetIndexSegmentAttributes (&strIndexSegment) iTable iIndex iSegment
36941>>>>>>>>>>>                Move strIndexSegment to strIndex.aSegments[iSegment]
36942>>>>>>>>>>>            Loop
36943>>>>>>>>>>>>
36943>>>>>>>>>>>        End
36943>>>>>>>>>>>>
36943>>>>>>>>>>>    End_Procedure
36944>>>>>>>>>>>
36944>>>>>>>>>>>    //> Get table attributes for one table (must be open)
36944>>>>>>>>>>>    Procedure GetTableAttributes tTableAttributes ByRef strTable Integer iTable // iFile must be open. If not, empty tables are returned
36946>>>>>>>>>>>        Boolean bOpen
36946>>>>>>>>>>>        Integer iMaxField iField iMaxIndex iIndex iHandleType
36946>>>>>>>>>>>        String sDriver
36946>>>>>>>>>>>        tFieldAttributes strField
36946>>>>>>>>>>>        tFieldAttributes strField
36946>>>>>>>>>>>        tIndexAttributes strIndex
36946>>>>>>>>>>>        tIndexAttributes strIndex
36946>>>>>>>>>>>
36946>>>>>>>>>>>        // Make sure nothing lingers from a previous call
36946>>>>>>>>>>>        Move (ResizeArray(strTable.aTableAttributes,0)) to strTable.aTableAttributes
36947>>>>>>>>>>>        Move (ResizeArray(strTable.aFields,0)) to strTable.aFields
36948>>>>>>>>>>>        Move (ResizeArray(strTable.aIndices,0)) to strTable.aIndices
36949>>>>>>>>>>>
36949>>>>>>>>>>>        If (iTable<>0) Begin
36951>>>>>>>>>>>
36951>>>>>>>>>>>            Get_Attribute DF_FILE_HANDLE_TYPE of iTable to iHandleType
36954>>>>>>>>>>>            If (iHandleType=DF_FILE_HANDLE_EXISTING_RESTRUCTURE or iHandleType=DF_FILE_HANDLE_NEW_RESTRUCTURE) Begin
36956>>>>>>>>>>>                Move True to bOpen
36957>>>>>>>>>>>            End
36957>>>>>>>>>>>>
36957>>>>>>>>>>>            Else Begin
36958>>>>>>>>>>>                If (iHandleType=DF_FILE_HANDLE_BAD) Begin
36960>>>>>>>>>>>                    Move False to bOpen
36961>>>>>>>>>>>                End
36961>>>>>>>>>>>>
36961>>>>>>>>>>>                Else Begin
36962>>>>>>>>>>>                    Get_Attribute DF_FILE_OPENED of iTable to bOpen
36965>>>>>>>>>>>                End
36965>>>>>>>>>>>>
36965>>>>>>>>>>>            End
36965>>>>>>>>>>>>
36965>>>>>>>>>>>
36965>>>>>>>>>>>            Move iTable to strTable.iReadFromFileListEntryNo
36966>>>>>>>>>>>            Send _GetAllAttributesOfType ATYPE_FILELIST (&strTable.aTableAttributes) iTable
36967>>>>>>>>>>>            If (bOpen) Begin
36969>>>>>>>>>>>                Get TableOpenAsPath of oTableAccessFunctions iTable to strTable.sOpenAsPath
36970>>>>>>>>>>>
36970>>>>>>>>>>>                Send _GetAllAttributesOfType ATYPE_FILE (&strTable.aTableAttributes) iTable
36971>>>>>>>>>>>    
36971>>>>>>>>>>>                Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iMaxField
36974>>>>>>>>>>>                For iField from 1 to iMaxField
36980>>>>>>>>>>>>
36980>>>>>>>>>>>                    Send _GetFieldAttributes (&strField) iTable iField
36981>>>>>>>>>>>                    Move strField to strTable.aFields[iField]
36982>>>>>>>>>>>                Loop
36983>>>>>>>>>>>>
36983>>>>>>>>>>>    
36983>>>>>>>>>>>                Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iTable to iMaxIndex
36986>>>>>>>>>>>                For iIndex from 1 to iMaxIndex
36992>>>>>>>>>>>>
36992>>>>>>>>>>>                    Send _GetIndexAttributes (&strIndex) iTable iIndex
36993>>>>>>>>>>>                    Move strIndex to strTable.aIndices[iIndex]
36994>>>>>>>>>>>                Loop
36995>>>>>>>>>>>>
36995>>>>>>>>>>>            End
36995>>>>>>>>>>>>
36995>>>>>>>>>>>            Else Begin
36996>>>>>>>>>>>                Move "" to strTable.sOpenAsPath
36997>>>>>>>>>>>                // Even if the table isn't opened, we can still try to figure
36997>>>>>>>>>>>                // out which driver is supposed to be used
36997>>>>>>>>>>>                Get TableDriver of oTableAccessFunctions iTable to sDriver
36998>>>>>>>>>>>                Get DriverIdToDll of oTableDriverFunctions sDriver to sDriver
36999>>>>>>>>>>>                Set _AttributeValue (&strTable.aTableAttributes) DF_FILE_DRIVER to sDriver
37000>>>>>>>>>>>            End
37000>>>>>>>>>>>>
37000>>>>>>>>>>>        End
37000>>>>>>>>>>>>
37000>>>>>>>>>>>    End_Procedure
37001>>>>>>>>>>>
37001>>>>>>>>>>>            Function TableIndex tTableAttributes[] astTables Integer iTable Returns Integer
37003>>>>>>>>>>>                Integer iMax iIndex
37003>>>>>>>>>>>                Integer[] aTableCompressedIndices
37004>>>>>>>>>>>                Get _paTableCompressedIndices to aTableCompressedIndices
37005>>>>>>>>>>>                If (SizeOfArray(aTableCompressedIndices)>0) Begin
37007>>>>>>>>>>>                    If (iTable<=SizeOfArray(aTableCompressedIndices)) Begin
37009>>>>>>>>>>>                        Function_Return aTableCompressedIndices[iTable]
37010>>>>>>>>>>>                    End
37010>>>>>>>>>>>>
37010>>>>>>>>>>>                    Function_Return 0 // This should never happen
37011>>>>>>>>>>>                End
37011>>>>>>>>>>>>
37011>>>>>>>>>>>                Else Begin
37012>>>>>>>>>>>                    Move (SizeOfArray(astTables)-1) to iMax
37013>>>>>>>>>>>                    For iIndex from 0 to iMax
37019>>>>>>>>>>>>
37019>>>>>>>>>>>                        If (iTable=astTables[iIndex].iReadFromFileListEntryNo) Function_Return iIndex
37022>>>>>>>>>>>                    Loop
37023>>>>>>>>>>>>
37023>>>>>>>>>>>                End
37023>>>>>>>>>>>>
37023>>>>>>>>>>>                Function_Return -1
37024>>>>>>>>>>>            End_Function
37025>>>>>>>>>>>
37025>>>>>>>>>>>    //> Get table attributes for an array of tables
37025>>>>>>>>>>>    Procedure GetTablesAttributes tTableAttributes[] ByRef astTables Integer[] aSetOfTabels Boolean bAttemptOpen
37027>>>>>>>>>>>        Boolean bCanOpen bOpen bCloseAgain bIsOpen
37027>>>>>>>>>>>        Integer iTable iMax iIndex iTableIndex
37027>>>>>>>>>>>        Integer hProgressMsg hProgressObj
37027>>>>>>>>>>>        String sLogicalName
37027>>>>>>>>>>>        tTableAttributes strTable
37027>>>>>>>>>>>        tTableAttributes strTable
37027>>>>>>>>>>>        
37027>>>>>>>>>>>        Get _phProgressCallbackMsg to hProgressMsg
37028>>>>>>>>>>>        Get _phProgressCallbackObj to hProgressObj
37029>>>>>>>>>>>        
37029>>>>>>>>>>>        Move (ResizeArray(astTables,0)) to astTables
37030>>>>>>>>>>>        Move (SizeOfArray(aSetOfTabels)-1) to iMax
37031>>>>>>>>>>>        For iIndex from 0 to iMax
37037>>>>>>>>>>>>
37037>>>>>>>>>>>            Move aSetOfTabels[iIndex] to iTable
37038>>>>>>>>>>>
37038>>>>>>>>>>>            Move False to bCloseAgain
37039>>>>>>>>>>>            Get IsOpen of oTableAccessFunctions iTable to bIsOpen
37040>>>>>>>>>>>            If (not(bIsOpen) and bAttemptOpen) Begin
37042>>>>>>>>>>>                Get OpenTable of oTableAccessFunctions iTable DF_SHARE 0 to bCloseAgain
37043>>>>>>>>>>>            End
37043>>>>>>>>>>>>
37043>>>>>>>>>>>
37043>>>>>>>>>>>            If (hProgressMsg<>0) Begin
37045>>>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sLogicalName
37048>>>>>>>>>>>                Send hProgressMsg of hProgressObj ("Reading "+sLogicalName) (iIndex+1) (iMax+1)
37049>>>>>>>>>>>            End
37049>>>>>>>>>>>>
37049>>>>>>>>>>>            Send GetTableAttributes (&strTable) iTable // Whether its actually open or not we call _GetTableAttributes. If it's not open we will simply store an empty tTableAttributes value in our array (signaling that we actually tried to read the attributes)
37050>>>>>>>>>>>
37050>>>>>>>>>>>            Get TableIndex aSetOfTabels iTable to iTableIndex
37051>>>>>>>>>>>            If (iTableIndex=-1) Begin
37053>>>>>>>>>>>                Move (SizeOfArray(astTables)) to iTableIndex
37054>>>>>>>>>>>            End
37054>>>>>>>>>>>>
37054>>>>>>>>>>>            Move strTable to astTables[iTableIndex]
37055>>>>>>>>>>>
37055>>>>>>>>>>>            If bCloseAgain Begin
37057>>>>>>>>>>>                Close iTable
37058>>>>>>>>>>>            End
37058>>>>>>>>>>>>
37058>>>>>>>>>>>        Loop
37059>>>>>>>>>>>>
37059>>>>>>>>>>>    End_Procedure
37060>>>>>>>>>>>
37060>>>>>>>>>>>    Procedure _GetDrivers tDataBaseDriver[] ByRef aDrivers
37062>>>>>>>>>>>        Integer iDriverMax iDriverIndex iServerMax iServerIndex
37062>>>>>>>>>>>        String sName
37062>>>>>>>>>>>        tAttributeValue[] aAttributeValues
37062>>>>>>>>>>>        tAttributeValue[] aAttributeValues
37063>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iDriverMax
37066>>>>>>>>>>>        For iDriverIndex from 1 to iDriverMax
37072>>>>>>>>>>>>
37072>>>>>>>>>>>            Send _GetAllAttributesOfType ATYPE_DRIVER (&aDrivers[iDriverIndex].aDriverAttributes) iDriverIndex
37073>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriverIndex to sName
37076>>>>>>>>>>>            If (sName<>"DATAFLEX") Begin
37078>>>>>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriverIndex to iServerMax
37081>>>>>>>>>>>                For iServerIndex from 1 to iServerMax
37087>>>>>>>>>>>>
37087>>>>>>>>>>>//                    Send _GetAllAttributesOfType ATYPE_DRVSRV (&aDrivers[iDriverIndex].aServers[iServerIndex].aServerAttributes) iDriverIndex iServerIndex 0
37087>>>>>>>>>>>                    Send _GetAllAttributesOfType ATYPE_DRVSRV (&aAttributeValues) iDriverIndex iServerIndex 0
37088>>>>>>>>>>>                    Move aAttributeValues to aDrivers[iDriverIndex].aServers[iServerIndex].aServerAttributes
37089>>>>>>>>>>>                Loop
37090>>>>>>>>>>>>
37090>>>>>>>>>>>            End
37090>>>>>>>>>>>>
37090>>>>>>>>>>>        Loop
37091>>>>>>>>>>>>
37091>>>>>>>>>>>    End_Procedure
37092>>>>>>>>>>>
37092>>>>>>>>>>>    Procedure _GetGlobals tAttributeValue[] ByRef aGlobals
37094>>>>>>>>>>>        Send _GetAllAttributesOfType ATYPE_GLOBAL (&aGlobals)
37095>>>>>>>>>>>    End_Procedure
37096>>>>>>>>>>>
37096>>>>>>>>>>>    Procedure GetAllAttributes tFileList ByRef strFilelist
37098>>>>>>>>>>>        Integer[] aTables
37099>>>>>>>>>>>        Get _paTempTableFilter to aTables
37100>>>>>>>>>>>        If (SizeOfArray(aTables)=0) Begin
37102>>>>>>>>>>>            Get TableIntegerArray of oTableAccessFunctions DF_FILE_NEXT_USED to aTables
37103>>>>>>>>>>>        End
37103>>>>>>>>>>>>
37103>>>>>>>>>>>        Send _GetGlobals (&strFilelist.aGlobalAttributes)
37104>>>>>>>>>>>        Send GetTablesAttributes (&strFilelist.aTables) aTables True
37105>>>>>>>>>>>        Send _GetDrivers (&strFilelist.aDrivers)
37106>>>>>>>>>>>    End_Procedure
37107>>>>>>>>>>>
37107>>>>>>>>>>>    Procedure GetAllAttributesProgressCallback tFileList ByRef strFilelist Integer hMsg Integer hObj
37109>>>>>>>>>>>        Set _phProgressCallbackMsg to hMsg
37110>>>>>>>>>>>        Set _phProgressCallbackObj to hObj
37111>>>>>>>>>>>        Send GetAllAttributes (&strFilelist)
37112>>>>>>>>>>>        Set _phProgressCallbackMsg to 0
37113>>>>>>>>>>>        Set _phProgressCallbackObj to 0
37114>>>>>>>>>>>    End_Procedure
37115>>>>>>>>>>>
37115>>>>>>>>>>>    Function FilelistNavigationTableArray tTableAttributes[] astTables Integer iFileListNavAttr Returns Integer[]
37117>>>>>>>>>>>        Integer iTable iIndex
37117>>>>>>>>>>>        Integer[] aTables
37118>>>>>>>>>>>        If (iFileListNavAttr=DF_FILE_NEXT_OPENED or iFileListNavAttr=DF_FILE_NEXT_USED or iFileListNavAttr=DF_FILE_NEXT_EMPTY) Begin
37120>>>>>>>>>>>            Move 0 to iTable
37121>>>>>>>>>>>            Move 0 to iIndex
37122>>>>>>>>>>>            Repeat
37122>>>>>>>>>>>>
37122>>>>>>>>>>>                Get TableAttribute astTables iFileListNavAttr iTable 0 0 to iTable
37123>>>>>>>>>>>                If (iTable<>0) Begin
37125>>>>>>>>>>>                    Move iTable to aTables[iIndex]
37126>>>>>>>>>>>                    Increment iIndex
37127>>>>>>>>>>>                End
37127>>>>>>>>>>>>
37127>>>>>>>>>>>            Until (iTable=0)
37129>>>>>>>>>>>        End
37129>>>>>>>>>>>>
37129>>>>>>>>>>>        Function_Return aTables
37130>>>>>>>>>>>    End_Function
37131>>>>>>>>>>>
37131>>>>>>>>>>>    // iAttr=DF_FILE_NEXT_USED|DF_FILE_NEXT_EMPTY
37131>>>>>>>>>>>//    Function FilelistNavigation Integer iAttr Integer iTable Boolean bAscending Returns Integer
37131>>>>>>>>>>>//        If (iAttr=DF_FILE_NEXT_USED)
37131>>>>>>>>>>>//    End_Function
37131>>>>>>>>>>>
37131>>>>>>>>>>>    Function TableAttribute tTableAttributes[] astTables Integer iAttr Integer iTable Integer iVal1 Integer iVal2 Returns String
37133>>>>>>>>>>>        Integer iTableIndex iAttrType
37133>>>>>>>>>>>        Integer iStart1 iEnd1 iStart2 iEnd2 iRecordLength
37133>>>>>>>>>>>        String sRval
37133>>>>>>>>>>>
37133>>>>>>>>>>>        Move "" to sRval
37134>>>>>>>>>>>        Move gaAttributes[iAttr].iAttrType to iAttrType
37135>>>>>>>>>>>
37135>>>>>>>>>>>        If (iAttrType=ATYPE_FLSTNAV) Begin
37137>>>>>>>>>>>            Repeat
37137>>>>>>>>>>>>
37137>>>>>>>>>>>                Increment iTable
37138>>>>>>>>>>>                Get TableIndex astTables iTable to iTableIndex
37139>>>>>>>>>>>                If (iAttr=DF_FILE_NEXT_OPENED) Begin
37141>>>>>>>>>>>                    // This makes no sense except that of course the table was open at the time its definition was recorded.
37141>>>>>>>>>>>                    If (iTableIndex<>-1) Move iTable to sRval
37144>>>>>>>>>>>                End
37144>>>>>>>>>>>>
37144>>>>>>>>>>>                If (iAttr=DF_FILE_NEXT_USED) Begin
37146>>>>>>>>>>>                    If (iTableIndex<>-1) Move iTable to sRval
37149>>>>>>>>>>>                End
37149>>>>>>>>>>>>
37149>>>>>>>>>>>                If (iAttr=DF_FILE_NEXT_EMPTY) Begin
37151>>>>>>>>>>>                    If (iTableIndex=-1) Move iTable to sRval
37154>>>>>>>>>>>                End
37154>>>>>>>>>>>>
37154>>>>>>>>>>>            Until (sRval<>"" or iTable>4096)
37156>>>>>>>>>>>        End
37156>>>>>>>>>>>>
37156>>>>>>>>>>>        Else Begin
37157>>>>>>>>>>>            Get TableIndex astTables iTable to iTableIndex
37158>>>>>>>>>>>            If (iTableIndex<>-1) Begin
37160>>>>>>>>>>>                If (iAttrType=ATYPE_FILELIST or iAttrType=ATYPE_FILE) Begin
37162>>>>>>>>>>>                    If (iAttr=DF_FILE_OPENED) Begin // If table can be found => it's open
37164>>>>>>>>>>>                        Get _AttributeValue astTables[iTableIndex].aTableAttributes DF_FILE_RECORD_LENGTH to iRecordLength
37165>>>>>>>>>>>                        If (iRecordLength<>0) Begin
37167>>>>>>>>>>>                            Move 1 to sRval
37168>>>>>>>>>>>                        End
37168>>>>>>>>>>>>
37168>>>>>>>>>>>                    End
37168>>>>>>>>>>>>
37168>>>>>>>>>>>                    Else Begin
37169>>>>>>>>>>>                        Get _AttributeValue astTables[iTableIndex].aTableAttributes iAttr to sRval
37170>>>>>>>>>>>                    End
37170>>>>>>>>>>>>
37170>>>>>>>>>>>                End
37170>>>>>>>>>>>>
37170>>>>>>>>>>>                Else If (iAttrType=ATYPE_FIELD) Begin
37173>>>>>>>>>>>                    If (SizeOfArray(astTables[iTableIndex].aFields)>0) Begin
37175>>>>>>>>>>>                        Get _AttributeValue astTables[iTableIndex].aFields[iVal1].aFieldAttributes iAttr to sRval
37176>>>>>>>>>>>                    End
37176>>>>>>>>>>>>
37176>>>>>>>>>>>                End
37176>>>>>>>>>>>>
37176>>>>>>>>>>>                Else If (iAttrType=ATYPE_INDEX) Begin
37179>>>>>>>>>>>                    If (iVal1>=SizeOfArray(astTables[iTableIndex].aIndices)) Begin
37181>>>>>>>>>>>                        Move "" to sRval
37182>>>>>>>>>>>                    End
37182>>>>>>>>>>>>
37182>>>>>>>>>>>                    Else Begin
37183>>>>>>>>>>>                        Get _AttributeValue astTables[iTableIndex].aIndices[iVal1].aIndexAttributes iAttr to sRval
37184>>>>>>>>>>>                    End
37184>>>>>>>>>>>>
37184>>>>>>>>>>>                End
37184>>>>>>>>>>>>
37184>>>>>>>>>>>                Else If (iAttrType=ATYPE_IDXSEG) Begin
37187>>>>>>>>>>>                    Get _AttributeValue astTables[iTableIndex].aIndices[iVal1].aSegments[iVal2].aIndexSegmentAttributes iAttr to sRval
37188>>>>>>>>>>>                End
37188>>>>>>>>>>>>
37188>>>>>>>>>>>                Else If (iAttrType=ATYPE_SPECIAL) Begin
37191>>>>>>>>>>>                    If (iAttr=DF_FIELD_OVERLAP) Begin // Must be calculated
37193>>>>>>>>>>>                        Get _AttributeValue astTables[iTableIndex].aFields[iVal1].aFieldAttributes DF_FIELD_OFFSET to iStart1
37194>>>>>>>>>>>                        Get _AttributeValue astTables[iTableIndex].aFields[iVal2].aFieldAttributes DF_FIELD_OFFSET to iStart2
37195>>>>>>>>>>>                        Get _AttributeValue astTables[iTableIndex].aFields[iVal1].aFieldAttributes DF_FIELD_NATIVE_LENGTH to iEnd1
37196>>>>>>>>>>>                        Get _AttributeValue astTables[iTableIndex].aFields[iVal2].aFieldAttributes DF_FIELD_NATIVE_LENGTH to iEnd2
37197>>>>>>>>>>>                        Move (iStart1+iEnd1-1) to iEnd1
37198>>>>>>>>>>>                        Move (iStart2+iEnd2-1) to iEnd2
37199>>>>>>>>>>>                        Move (iStart1<=iEnd2 and iStart2<=iEnd1) to sRval
37200>>>>>>>>>>>                    End
37200>>>>>>>>>>>>
37200>>>>>>>>>>>                End
37200>>>>>>>>>>>>
37200>>>>>>>>>>>            End
37200>>>>>>>>>>>>
37200>>>>>>>>>>>        End
37200>>>>>>>>>>>>
37200>>>>>>>>>>>        Function_Return sRval
37201>>>>>>>>>>>    End_Function
37202>>>>>>>>>>>
37202>>>>>>>>>>>    Procedure Set TableAttribute tTableAttributes[] ByRef astTables Integer iAttr Integer iTable Integer iVal1 Integer iVal2 String sValue 
37204>>>>>>>>>>>        Integer iTableIndex iAttrType
37204>>>>>>>>>>>        Move gaAttributes[iAttr].iAttrType to iAttrType
37205>>>>>>>>>>>        Get TableIndex astTables iTable to iTableIndex
37206>>>>>>>>>>>        If (iTableIndex<>-1) Begin
37208>>>>>>>>>>>            If (iAttrType=ATYPE_FILELIST or iAttrType=ATYPE_FILE) Begin
37210>>>>>>>>>>>                Set _AttributeValue astTables[iTableIndex].aTableAttributes iAttr to sValue
37211>>>>>>>>>>>            End
37211>>>>>>>>>>>>
37211>>>>>>>>>>>            Else If (iAttrType=ATYPE_FIELD) Begin
37214>>>>>>>>>>>                Set _AttributeValue astTables[iTableIndex].aFields[iVal1].aFieldAttributes iAttr to sValue
37215>>>>>>>>>>>            End
37215>>>>>>>>>>>>
37215>>>>>>>>>>>            Else If (iAttrType=ATYPE_INDEX) Begin
37218>>>>>>>>>>>                Set _AttributeValue astTables[iTableIndex].aIndices[iVal1].aIndexAttributes iAttr to sValue
37219>>>>>>>>>>>            End
37219>>>>>>>>>>>>
37219>>>>>>>>>>>            Else If (iAttrType=ATYPE_IDXSEG) Begin
37222>>>>>>>>>>>                Set _AttributeValue astTables[iTableIndex].aIndices[iVal1].aSegments[iVal2].aIndexSegmentAttributes iAttr to sValue
37223>>>>>>>>>>>            End
37223>>>>>>>>>>>>
37223>>>>>>>>>>>            Else If (iAttrType=ATYPE_SPECIAL) Begin
37226>>>>>>>>>>>                // It's an overlap calculation to be done when neeeded sometime
37226>>>>>>>>>>>                Error 811 "Read only attributes"
37227>>>>>>>>>>>>
37227>>>>>>>>>>>            End
37227>>>>>>>>>>>>
37227>>>>>>>>>>>        End
37227>>>>>>>>>>>>
37227>>>>>>>>>>>    End_Procedure
37228>>>>>>>>>>>
37228>>>>>>>>>>>    Function DriverAttribute tDataBaseDriver[] aDrivers Integer iAttr Integer iDriverIndex Integer iServerIndex Returns String
37230>>>>>>>>>>>        Integer iAttrType
37230>>>>>>>>>>>        String sRval
37230>>>>>>>>>>>        Move gaAttributes[iAttr].iAttrType to iAttrType
37231>>>>>>>>>>>        If (iAttrType=ATYPE_DRIVER) Begin
37233>>>>>>>>>>>            Get _AttributeValue aDrivers[iDriverIndex].aDriverAttributes iAttr to sRval
37234>>>>>>>>>>>        End
37234>>>>>>>>>>>>
37234>>>>>>>>>>>        Else If (iAttrType=ATYPE_DRVSRV) Begin
37237>>>>>>>>>>>            Get _AttributeValue aDrivers[iDriverIndex].aServers[iServerIndex].aServerAttributes iAttr to sRval
37238>>>>>>>>>>>        End
37238>>>>>>>>>>>>
37238>>>>>>>>>>>        Function_Return sRval
37239>>>>>>>>>>>    End_Function
37240>>>>>>>>>>>
37240>>>>>>>>>>>    Procedure Set DriverAttribute tDataBaseDriver[] aDrivers Integer iAttr Integer iDriverIndex Integer iServerIndex String sValue
37242>>>>>>>>>>>        Integer iAttrType
37242>>>>>>>>>>>        Move gaAttributes[iAttr].iAttrType to iAttrType
37243>>>>>>>>>>>        If (iAttrType=ATYPE_DRIVER) Begin
37245>>>>>>>>>>>            Set _AttributeValue aDrivers[iDriverIndex].aDriverAttributes iAttr to sValue
37246>>>>>>>>>>>        End
37246>>>>>>>>>>>>
37246>>>>>>>>>>>        Else If (iAttrType=ATYPE_DRVSRV) Begin
37249>>>>>>>>>>>            Set _AttributeValue aDrivers[iDriverIndex].aServers[iServerIndex].aServerAttributes iAttr to sValue
37250>>>>>>>>>>>        End
37250>>>>>>>>>>>>
37250>>>>>>>>>>>    End_Procedure
37251>>>>>>>>>>>
37251>>>>>>>>>>>    Function Attrib tFileList strFilelist Integer iAttr Integer iVal1 Integer iVal2 Integer iVal3 Returns String
37253>>>>>>>>>>>        Integer iAttrType
37253>>>>>>>>>>>        String sRval
37253>>>>>>>>>>>        Move gaAttributes[iAttr].iAttrType to iAttrType
37254>>>>>>>>>>>        If (iAttrType=ATYPE_GLOBAL) begin
37256>>>>>>>>>>>            Get _AttributeValue strFilelist.aGlobalAttributes iAttr to sRval
37257>>>>>>>>>>>        End
37257>>>>>>>>>>>>
37257>>>>>>>>>>>        Else If (iAttrType=ATYPE_DRIVER or iAttrType=ATYPE_DRVSRV) begin
37260>>>>>>>>>>>            Get DriverAttribute strFilelist.aDrivers iAttr iVal1 iVal2 to sRval
37261>>>>>>>>>>>        End
37261>>>>>>>>>>>>
37261>>>>>>>>>>>        Else Begin
37262>>>>>>>>>>>            Get TableAttribute strFilelist.aTables iAttr iVal1 iVal2 iVal3 to sRval
37263>>>>>>>>>>>        End
37263>>>>>>>>>>>>
37263>>>>>>>>>>>        Function_Return sRval
37264>>>>>>>>>>>    End_Function
37265>>>>>>>>>>>
37265>>>>>>>>>>>    Procedure Set Attrib tFileList ByRef strFilelist Integer iAttr Integer iVal1 Integer iVal2 Integer iVal3 String sValue
37267>>>>>>>>>>>        Integer iAttrType
37267>>>>>>>>>>>        Move gaAttributes[iAttr].iAttrType to iAttrType
37268>>>>>>>>>>>        If (iAttrType=ATYPE_GLOBAL) Begin
37270>>>>>>>>>>>            Set _AttributeValue (&strFilelist.aGlobalAttributes) iAttr to sValue
37271>>>>>>>>>>>        End
37271>>>>>>>>>>>>
37271>>>>>>>>>>>        Else If (iAttrType=ATYPE_DRIVER or iAttrType=ATYPE_DRVSRV) Begin
37274>>>>>>>>>>>            Set DriverAttribute (&strFilelist.aDrivers) iAttr iVal1 iVal2 to sValue
37275>>>>>>>>>>>        End
37275>>>>>>>>>>>>
37275>>>>>>>>>>>        Else Begin
37276>>>>>>>>>>>            Set TableAttribute (&strFilelist.aTables) iAttr iVal1 iVal2 iVal3 to sValue
37277>>>>>>>>>>>        End
37277>>>>>>>>>>>>
37277>>>>>>>>>>>    End_Procedure
37278>>>>>>>>>>>
37278>>>>>>>>>>>    // Procedure _HandleAttribute tTableAttributes[] astTables integer iAttr integer iTable integer iVal1 integer iVal2 string sValue String sDisplayValue
37278>>>>>>>>>>>    Procedure CallBackAttributeValues Integer hMsg Integer hObj tFileList strFilelist Integer iAttrType Integer iTable Integer iVal1 Integer iVal2
37280>>>>>>>>>>>        Integer iMax iIndex iAttr
37280>>>>>>>>>>>        String sValue
37280>>>>>>>>>>>        String sDisplayValue
37280>>>>>>>>>>>        Move (SizeOfArray(gaAttributesByType[iAttrType])-1) to iMax
37281>>>>>>>>>>>        For iIndex from 0 to iMax
37287>>>>>>>>>>>>
37287>>>>>>>>>>>            Move gaAttributesByType[iAttrType][iIndex] to iAttr
37288>>>>>>>>>>>            Get Attrib strFilelist iAttr iTable iVal1 iVal2 to sValue
37289>>>>>>>>>>>            Get AttributeDisplayValue iAttr sValue to sDisplayValue
37290>>>>>>>>>>>            Send hMsg of hObj strFilelist iAttr iTable iVal1 iVal2 sValue sDisplayValue
37291>>>>>>>>>>>        Loop
37292>>>>>>>>>>>>
37292>>>>>>>>>>>    End_Procedure
37293>>>>>>>>>>>
37293>>>>>>>>>>>    // Procedure HandleAttribute integer iAttr tAttributeDefinition stAttrDef
37293>>>>>>>>>>>    Procedure CallBackAttributes Integer hMsg Integer hObj Integer iAttrType
37295>>>>>>>>>>>        Integer iMax iIndex iAttr
37295>>>>>>>>>>>        Move (SizeOfArray(gaAttributesByType[iAttrType])-1) to iMax
37296>>>>>>>>>>>        For iIndex from 0 to iMax
37302>>>>>>>>>>>>
37302>>>>>>>>>>>            Move gaAttributesByType[iAttrType][iIndex] to iAttr
37303>>>>>>>>>>>            Send hMsg of hObj iAttr gaAttributes[iAttr]
37304>>>>>>>>>>>        Loop
37305>>>>>>>>>>>>
37305>>>>>>>>>>>    End_Procedure
37306>>>>>>>>>>>
37306>>>>>>>>>>>    Function FieldAttributesToExplicit tFieldAttributes strField Returns tTableFieldExplicit
37308>>>>>>>>>>>        tTableFieldExplicit stFieldExplicit
37308>>>>>>>>>>>        tTableFieldExplicit stFieldExplicit
37308>>>>>>>>>>>
37308>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_NUMBER to stFieldExplicit.iPosition
37309>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_NAME to stFieldExplicit.sName
37310>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_TYPE to stFieldExplicit.iType
37311>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_LENGTH to stFieldExplicit.iLen
37312>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_PRECISION to stFieldExplicit.iPrecision
37313>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_RELATED_FILE to stFieldExplicit.iRelFile
37314>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_RELATED_FIELD to stFieldExplicit.iRelField
37315>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_INDEX to stFieldExplicit.iMainIndex
37316>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_OFFSET to stFieldExplicit.iOffset
37317>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_NATIVE_LENGTH to stFieldExplicit.iNativeLength
37318>>>>>>>>>>>
37318>>>>>>>>>>>        Function_Return stFieldExplicit
37319>>>>>>>>>>>    End_Function
37320>>>>>>>>>>>
37320>>>>>>>>>>>    Function IndexAttributesToExplicit tIndexAttributes strIndex Returns tTableIndexExplicit
37322>>>>>>>>>>>        Integer iSegmentIndex iSegmentMax
37322>>>>>>>>>>>        Integer iDirection iCase
37322>>>>>>>>>>>        tTableIndexExplicit stIndexExplicit
37322>>>>>>>>>>>        tTableIndexExplicit stIndexExplicit
37322>>>>>>>>>>>
37322>>>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegmentMax
37323>>>>>>>>>>>        If (iSegmentMax>=0) Begin
37325>>>>>>>>>>>            Get _AttributeValue strIndex.aIndexAttributes DF_INDEX_TYPE to stIndexExplicit.iType
37326>>>>>>>>>>>            Get _AttributeValue strIndex.aIndexAttributes DF_INDEX_LEVELS to stIndexExplicit.iLevels
37327>>>>>>>>>>>            Get _AttributeValue strIndex.aIndexAttributes DF_INDEX_KEY_LENGTH to stIndexExplicit.iKeyLength
37328>>>>>>>>>>>            For iSegmentIndex from 0 to iSegmentMax
37334>>>>>>>>>>>>
37334>>>>>>>>>>>                Get _AttributeValue strIndex.aSegments[iSegmentIndex].aIndexSegmentAttributes DF_INDEX_SEGMENT_FIELD to stIndexExplicit.aFields[iSegmentIndex]
37335>>>>>>>>>>>                Get _AttributeValue strIndex.aSegments[iSegmentIndex].aIndexSegmentAttributes DF_INDEX_SEGMENT_DIRECTION to iDirection
37336>>>>>>>>>>>                Move (iDirection=DF_DESCENDING) to stIndexExplicit.aDescending[iSegmentIndex]
37337>>>>>>>>>>>                Get _AttributeValue strIndex.aSegments[iSegmentIndex].aIndexSegmentAttributes DF_INDEX_SEGMENT_CASE to iCase
37338>>>>>>>>>>>                Move (iCase=DF_CASE_IGNORED) to stIndexExplicit.aCaseInsensitive[iSegmentIndex]
37339>>>>>>>>>>>            Loop
37340>>>>>>>>>>>>
37340>>>>>>>>>>>            Move (stIndexExplicit.aFields[iSegmentMax]<>0) to stIndexExplicit.bUnique
37341>>>>>>>>>>>        End
37341>>>>>>>>>>>>
37341>>>>>>>>>>>        Function_Return stIndexExplicit
37342>>>>>>>>>>>    End_Function
37343>>>>>>>>>>>    
37343>>>>>>>>>>>    Function TableAttributesToExplicit tTableAttributes strTable Returns tTableExplicit
37345>>>>>>>>>>>        Integer iFieldIndex iFieldMax
37345>>>>>>>>>>>        Integer iIndexIndex iIndexMax
37345>>>>>>>>>>>        Integer iValue
37345>>>>>>>>>>>        Integer[] aOverlappedFields
37346>>>>>>>>>>>        tTableExplicit strTableExplicit
37346>>>>>>>>>>>        tTableExplicit strTableExplicit
37346>>>>>>>>>>>        Move strTable.iReadFromFileListEntryNo                              to strTableExplicit.iFileListEntry   
37347>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_DRIVER        to strTableExplicit.sDriver
37348>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_MAX_RECORDS   to strTableExplicit.nMaxRecords      
37349>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_RECORDS_USED  to strTableExplicit.nRecordsUsed     
37350>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_PHYSICAL_NAME to strTableExplicit.sPhysicalName    
37351>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_RECORD_LENGTH to strTableExplicit.iRecordLength    
37352>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_RECORD_LENGTH_USED to strTableExplicit.iRecordLengthUsed
37353>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_LOCK_TYPE     to strTableExplicit.iLockType
37354>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_INTEGRITY_CHECK to strTableExplicit.iIntegrityCheck
37355>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_IS_SYSTEM_FILE to iValue
37356>>>>>>>>>>>        Move (iValue<>0) to strTableExplicit.bSystemFile
37357>>>>>>>>>>>        
37357>>>>>>>>>>>        // Columns:
37357>>>>>>>>>>>        Move (SizeOfArray(strTable.aFields)-1) to iFieldMax
37358>>>>>>>>>>>        For iFieldIndex from 0 to iFieldMax
37364>>>>>>>>>>>>
37364>>>>>>>>>>>            Get FieldAttributesToExplicit strTable.aFields[iFieldIndex] to strTableExplicit.aFields[iFieldIndex]
37365>>>>>>>>>>>            If (strTableExplicit.aFields[iFieldIndex].iType=DF_OVERLAP) Begin
37367>>>>>>>>>>>                Get OverlapToColumns strTable iFieldIndex to aOverlappedFields
37368>>>>>>>>>>>                If (SizeOfArray(aOverlappedFields)<>0) Begin // We need this condition because an overlap field may defined to overlap nothing at all (length 0, for example)
37370>>>>>>>>>>>                    Move aOverlappedFields[0] to strTableExplicit.aFields[iFieldIndex].iOverlapFieldStart
37371>>>>>>>>>>>                    Move aOverlappedFields[SizeOfArray(aOverlappedFields)-1] to strTableExplicit.aFields[iFieldIndex].iOverlapFieldEnd
37372>>>>>>>>>>>                End
37372>>>>>>>>>>>>
37372>>>>>>>>>>>            End
37372>>>>>>>>>>>>
37372>>>>>>>>>>>        Loop
37373>>>>>>>>>>>>
37373>>>>>>>>>>>
37373>>>>>>>>>>>        // Indices:
37373>>>>>>>>>>>        Move (SizeOfArray(strTable.aIndices)-1) to iIndexMax
37374>>>>>>>>>>>        For iIndexIndex from 0 to iIndexMax
37380>>>>>>>>>>>>
37380>>>>>>>>>>>            Get IndexAttributesToExplicit strTable.aIndices[iIndexIndex] to strTableExplicit.aIndices[iIndexIndex]
37381>>>>>>>>>>>        Loop
37382>>>>>>>>>>>>
37382>>>>>>>>>>>
37382>>>>>>>>>>>        Function_Return strTableExplicit
37383>>>>>>>>>>>    End_Function
37384>>>>>>>>>>>    
37384>>>>>>>>>>>    Function FilelistEntryToExplicit tFileList strFilelist Integer iTable Returns tTableExplicit
37386>>>>>>>>>>>        tTableAttributes strTable
37386>>>>>>>>>>>        tTableAttributes strTable
37386>>>>>>>>>>>        String sValue
37386>>>>>>>>>>>        tTableExplicit strTableExplicit
37386>>>>>>>>>>>        tTableExplicit strTableExplicit
37386>>>>>>>>>>>        
37386>>>>>>>>>>>        Move iTable to strTableExplicit.iFileListEntry
37387>>>>>>>>>>>        // Convert to array index:
37387>>>>>>>>>>>        Get TableIndex strFilelist.aTables iTable to iTable 
37388>>>>>>>>>>>        
37388>>>>>>>>>>>        Move strFilelist.aTables[iTable] to strTable
37389>>>>>>>>>>>        Get TableAttributesToExplicit strTable to strTableExplicit
37390>>>>>>>>>>>        
37390>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_ROOT_NAME to strTableExplicit.sRootName   
37391>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_LOGICAL_NAME to strTableExplicit.sLogicalName
37392>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_DISPLAY_NAME to strTableExplicit.sDisplayName
37393>>>>>>>>>>>        
37393>>>>>>>>>>>        Function_Return strTableExplicit
37394>>>>>>>>>>>    End_Function
37395>>>>>>>>>>>    
37395>>>>>>>>>>>    Function FilelistToExplicitArray tFileList strFilelist Returns tTableExplicit[]
37397>>>>>>>>>>>        Integer iItem iMax iTable 
37397>>>>>>>>>>>        Integer[] aTables
37398>>>>>>>>>>>        tTableExplicit[] aTableExplicits
37398>>>>>>>>>>>        tTableExplicit[] aTableExplicits
37399>>>>>>>>>>>        
37399>>>>>>>>>>>        Get FilelistNavigationTableArray strFilelist.aTables DF_FILE_NEXT_USED to aTables
37400>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
37401>>>>>>>>>>>        For iItem from 0 to iMax
37407>>>>>>>>>>>>
37407>>>>>>>>>>>            Get FilelistEntryToExplicit strFilelist aTables[iItem] to aTableExplicits[iItem]
37408>>>>>>>>>>>        Loop
37409>>>>>>>>>>>>
37409>>>>>>>>>>>        
37409>>>>>>>>>>>        Function_Return aTableExplicits
37410>>>>>>>>>>>    End_Function
37411>>>>>>>>>>>    
37411>>>>>>>>>>>    Procedure CallBackTableAttributes Integer hMsg Integer hObj tTableAttributes strTable
37413>>>>>>>>>>>        Integer iMax iIndex iAttr
37413>>>>>>>>>>>        String sValue
37413>>>>>>>>>>>        Move (SizeOfArray(gaAttributesByType[ATYPE_FILE])-1) to iMax
37414>>>>>>>>>>>        For iIndex from 0 to iMax
37420>>>>>>>>>>>>
37420>>>>>>>>>>>            Move gaAttributesByType[ATYPE_FILE][iIndex] to iAttr
37421>>>>>>>>>>>            Get _AttributeValue strTable.aTableAttributes iAttr to sValue
37422>>>>>>>>>>>            Send hMsg of hObj strTable iAttr sValue
37423>>>>>>>>>>>        Loop
37424>>>>>>>>>>>>
37424>>>>>>>>>>>    End_Procedure
37425>>>>>>>>>>>    
37425>>>>>>>>>>>    Procedure AppendArrays Variant[] ByRef aArray1 Variant[] aArray2
37427>>>>>>>>>>>        Integer iIndex1 iIndex2 iMax2
37427>>>>>>>>>>>        Move (SizeOfArray(aArray1)) to iIndex1
37428>>>>>>>>>>>        Move (SizeOfArray(aArray2)-1) to iMax2
37429>>>>>>>>>>>        For iIndex2 from 0 to iMax2
37435>>>>>>>>>>>>
37435>>>>>>>>>>>            Move aArray2[iIndex2] to aArray1[iIndex1]
37436>>>>>>>>>>>            Increment iIndex1
37437>>>>>>>>>>>        Loop
37438>>>>>>>>>>>>
37438>>>>>>>>>>>    End_Procedure
37439>>>>>>>>>>>
37439>>>>>>>>>>>    Function FieldArrayReplaceOverlap tTableAttributes[] astTables tTableField strField Returns tTableField[]
37441>>>>>>>>>>>        Boolean bOverlaps
37441>>>>>>>>>>>        Integer iTableIndex iResultIndex iFieldType
37441>>>>>>>>>>>        Integer iFieldMax iFieldIndex
37441>>>>>>>>>>>        tTableField[] aResultFields
37441>>>>>>>>>>>        tTableField[] aResultFields
37442>>>>>>>>>>>        tFieldAttributes[] aFields
37442>>>>>>>>>>>        tFieldAttributes[] aFields
37443>>>>>>>>>>>
37443>>>>>>>>>>>        Move 0 to iResultIndex
37444>>>>>>>>>>>
37444>>>>>>>>>>>        Get TableIndex astTables strField.iTable to iTableIndex
37445>>>>>>>>>>>        If (iTableIndex<>-1) Begin
37447>>>>>>>>>>>            Get TableAttribute astTables DF_FIELD_TYPE strField.iTable strField.iField to iFieldType
37448>>>>>>>>>>>            If (iFieldType=DF_OVERLAP) Begin
37450>>>>>>>>>>>                Move astTables[iTableIndex].aFields to aFields
37451>>>>>>>>>>>                Move (SizeOfArray(aFields)-1) to iFieldMax
37452>>>>>>>>>>>                For iFieldIndex from 1 to iFieldMax
37458>>>>>>>>>>>>
37458>>>>>>>>>>>                    Get TableAttribute astTables DF_FIELD_TYPE strField.iTable iFieldIndex to iFieldType
37459>>>>>>>>>>>                    If (iFieldIndex<>strField.iField and iFieldType<>DF_OVERLAP) Begin
37461>>>>>>>>>>>                        Get TableAttribute astTables DF_FIELD_OVERLAP strField.iTable strField.iField iFieldIndex to bOverlaps
37462>>>>>>>>>>>                        If (bOverlaps) Begin
37464>>>>>>>>>>>                            Move strField.iTable to aResultFields[iResultIndex].iTable
37465>>>>>>>>>>>                            Move iFieldIndex to aResultFields[iResultIndex].iField
37466>>>>>>>>>>>                            Move strField.bCapslock to aResultFields[iResultIndex].bCapslock
37467>>>>>>>>>>>                            Move strField.bDescending to aResultFields[iResultIndex].bDescending
37468>>>>>>>>>>>                            Increment iResultIndex
37469>>>>>>>>>>>                        End
37469>>>>>>>>>>>>
37469>>>>>>>>>>>                    End
37469>>>>>>>>>>>>
37469>>>>>>>>>>>                Loop
37470>>>>>>>>>>>>
37470>>>>>>>>>>>            End
37470>>>>>>>>>>>>
37470>>>>>>>>>>>            Else Move strField to aResultFields[0] // If it's not an overlap field we just return the field itself
37472>>>>>>>>>>>        End
37472>>>>>>>>>>>>
37472>>>>>>>>>>>        Else Move strField to aResultFields[0] // This is pointless. If iTable is not in astTable we are in an error condition anyway.
37474>>>>>>>>>>>        Function_Return aResultFields
37475>>>>>>>>>>>    End_Function
37476>>>>>>>>>>>    
37476>>>>>>>>>>>    Function FieldArrayReplaceOverlaps tTableAttributes[] astTables tTableField[] aFields Returns tTableField[]
37478>>>>>>>>>>>        Integer iFieldIndex iFieldMax
37478>>>>>>>>>>>        tTableField[] aTemp
37478>>>>>>>>>>>        tTableField[] aTemp
37479>>>>>>>>>>>        tTableField[] aResultFields
37479>>>>>>>>>>>        tTableField[] aResultFields
37480>>>>>>>>>>>        Move (SizeOfArray(aFields)-1) to iFieldMax
37481>>>>>>>>>>>        For iFieldIndex from 0 to iFieldMax
37487>>>>>>>>>>>>
37487>>>>>>>>>>>            Get FieldArrayReplaceOverlap astTables aFields[iFieldIndex] to aTemp
37488>>>>>>>>>>>            Send AppendArrays (&aResultFields) aTemp
37489>>>>>>>>>>>        Loop
37490>>>>>>>>>>>>
37490>>>>>>>>>>>        Function_Return aResultFields
37491>>>>>>>>>>>    End_Function
37492>>>>>>>>>>>    
37492>>>>>>>>>>>    Function OverlapToColumns tTableAttributes strTable Integer iField Returns Integer[]
37494>>>>>>>>>>>        Integer iMax iIndex
37494>>>>>>>>>>>        Integer[] aFields
37495>>>>>>>>>>>        tTableAttributes[] astTables
37495>>>>>>>>>>>        tTableAttributes[] astTables
37496>>>>>>>>>>>        tTableField strField
37496>>>>>>>>>>>        tTableField strField
37496>>>>>>>>>>>        tTableField[] astFields
37496>>>>>>>>>>>        tTableField[] astFields
37497>>>>>>>>>>>        
37497>>>>>>>>>>>        Move strTable to astTables[0]
37498>>>>>>>>>>>        Move strTable.iReadFromFileListEntryNo to strField.iTable
37499>>>>>>>>>>>        Move iField to strField.iField
37500>>>>>>>>>>>        Get FieldArrayReplaceOverlap astTables strField to astFields
37501>>>>>>>>>>>        Move (SizeOfArray(astFields)-1) to iMax
37502>>>>>>>>>>>        
37502>>>>>>>>>>>        For iIndex from 0 to iMax
37508>>>>>>>>>>>>
37508>>>>>>>>>>>            Move astFields[iIndex].iField to aFields[iIndex]
37509>>>>>>>>>>>        Loop
37510>>>>>>>>>>>>
37510>>>>>>>>>>>        Function_Return aFields
37511>>>>>>>>>>>    End_Function
37512>>>>>>>>>>>
37512>>>>>>>>>>>    Procedure OverlapColumnBoundaries tTableAttributes[] astTables Integer iTable Integer iColumn Integer ByRef iStartColumn Integer ByRef iEndColumn
37514>>>>>>>>>>>        tTableField strField 
37514>>>>>>>>>>>        tTableField strField 
37514>>>>>>>>>>>        tTableField[] aFields
37514>>>>>>>>>>>        tTableField[] aFields
37515>>>>>>>>>>>        Move iTable to strField.iTable
37516>>>>>>>>>>>        Move iColumn to strField.iField
37517>>>>>>>>>>>        Get FieldArrayReplaceOverlap astTables strField to aFields
37518>>>>>>>>>>>        Move aFields[0].iField to iStartColumn
37519>>>>>>>>>>>        Move aFields[SizeOfArray(aFields)-1] to iEndColumn
37520>>>>>>>>>>>    End_Procedure
37521>>>>>>>>>>>    
37521>>>>>>>>>>>// **** Procedure for reading and writing to sequential files
37521>>>>>>>>>>>
37521>>>>>>>>>>>    Procedure Write_Attributes Integer iChannel Integer iAttrType tAttributeValue[] aAttributes
37523>>>>>>>>>>>        Integer iIndex iMax iAttr
37523>>>>>>>>>>>        Move (SizeOfArray(aAttributes)-1) to iMax
37524>>>>>>>>>>>        Writeln channel iChannel iMax
37527>>>>>>>>>>>        For iIndex from 0 to iMax
37533>>>>>>>>>>>>
37533>>>>>>>>>>>            Move gaInverseCompressedAttributeIndices[iAttrType][iIndex] to iAttr
37534>>>>>>>>>>>            Writeln iAttr
37536>>>>>>>>>>>            Writeln (Length(aAttributes[iIndex].sValue))
37538>>>>>>>>>>>            Write aAttributes[iIndex].sValue
37539>>>>>>>>>>>        Loop
37540>>>>>>>>>>>>
37540>>>>>>>>>>>    End_Procedure
37541>>>>>>>>>>>    
37541>>>>>>>>>>>    Procedure Read_Attributes Integer iChannel Integer iAttrType tAttributeValue[] ByRef aAttributes
37543>>>>>>>>>>>        Integer iIndex iMax iAttr iLen
37543>>>>>>>>>>>        String sValue
37543>>>>>>>>>>>        Move (ResizeArray(aAttributes,0)) to aAttributes
37544>>>>>>>>>>>        Readln channel iChannel iMax
37546>>>>>>>>>>>        For iIndex from 0 to iMax
37552>>>>>>>>>>>>
37552>>>>>>>>>>>           Readln iAttr
37553>>>>>>>>>>>           Readln iLen
37554>>>>>>>>>>>           Read_Block sValue iLen
37555>>>>>>>>>>>           Set _AttributeValue (&aAttributes) iAttr to sValue
37556>>>>>>>>>>>        Loop
37557>>>>>>>>>>>>
37557>>>>>>>>>>>    End_Procedure
37558>>>>>>>>>>>    
37558>>>>>>>>>>>    Procedure Write_TableAttributes Integer iChannel tTableAttributes astTableAttributes
37560>>>>>>>>>>>        Integer iMax iIndex iSegmentMax iSegmentIndex
37560>>>>>>>>>>>        Writeln channel iChannel astTableAttributes.iReadFromFileListEntryNo
37563>>>>>>>>>>>        Writeln channel iChannel astTableAttributes.sOpenAsPath
37566>>>>>>>>>>>        Send Write_Attributes iChannel ATYPE_FILE astTableAttributes.aTableAttributes
37567>>>>>>>>>>>        
37567>>>>>>>>>>>        Move (SizeOfArray(astTableAttributes.aFields)-1) to iMax
37568>>>>>>>>>>>        Writeln iMax
37570>>>>>>>>>>>        For iIndex from 0 to iMax
37576>>>>>>>>>>>>
37576>>>>>>>>>>>            Send Write_Attributes iChannel ATYPE_FIELD astTableAttributes.aFields[iIndex].aFieldAttributes
37577>>>>>>>>>>>        Loop
37578>>>>>>>>>>>>
37578>>>>>>>>>>>        
37578>>>>>>>>>>>        Move (SizeOfArray(astTableAttributes.aIndices)-1) to iMax
37579>>>>>>>>>>>        Writeln iMax
37581>>>>>>>>>>>        For iIndex from 0 to iMax
37587>>>>>>>>>>>>
37587>>>>>>>>>>>            Send Write_Attributes iChannel ATYPE_INDEX astTableAttributes.aIndices[iIndex].aIndexAttributes
37588>>>>>>>>>>>            Move (SizeOfArray(astTableAttributes.aIndices[iIndex].aSegments)-1) to iSegmentMax
37589>>>>>>>>>>>            Writeln iSegmentMax
37591>>>>>>>>>>>            For iSegmentIndex from 0 to iSegmentMax
37597>>>>>>>>>>>>
37597>>>>>>>>>>>                Send Write_Attributes iChannel ATYPE_IDXSEG astTableAttributes.aIndices[iIndex].aSegments[iSegmentIndex].aIndexSegmentAttributes
37598>>>>>>>>>>>            Loop
37599>>>>>>>>>>>>
37599>>>>>>>>>>>        Loop    
37600>>>>>>>>>>>>
37600>>>>>>>>>>>    End_Procedure
37601>>>>>>>>>>>    
37601>>>>>>>>>>>    Procedure Read_TableAttributes Integer iChannel tTableAttributes ByRef astTableAttributes
37603>>>>>>>>>>>        Integer iMax iIndex iSegmentMax iSegmentIndex
37603>>>>>>>>>>>        Readln channel iChannel astTableAttributes.iReadFromFileListEntryNo
37605>>>>>>>>>>>        Readln channel iChannel astTableAttributes.sOpenAsPath
37607>>>>>>>>>>>        Send Read_Attributes iChannel ATYPE_FILE (&astTableAttributes.aTableAttributes)
37608>>>>>>>>>>>        
37608>>>>>>>>>>>        Readln iMax
37609>>>>>>>>>>>        For iIndex from 0 to iMax
37615>>>>>>>>>>>>
37615>>>>>>>>>>>            Move gaEmptyAttributes to astTableAttributes.aFields[iIndex].aFieldAttributes
37616>>>>>>>>>>>            Send Read_Attributes iChannel ATYPE_FIELD (&astTableAttributes.aFields[iIndex].aFieldAttributes)
37617>>>>>>>>>>>        Loop
37618>>>>>>>>>>>>
37618>>>>>>>>>>>        
37618>>>>>>>>>>>        Readln iMax
37619>>>>>>>>>>>        For iIndex from 0 to iMax
37625>>>>>>>>>>>>
37625>>>>>>>>>>>            Move gaEmptyAttributes to astTableAttributes.aIndices[iIndex].aIndexAttributes
37626>>>>>>>>>>>            Send Read_Attributes iChannel ATYPE_INDEX (&astTableAttributes.aIndices[iIndex].aIndexAttributes)
37627>>>>>>>>>>>            Readln iSegmentMax
37628>>>>>>>>>>>            For iSegmentIndex from 0 to iSegmentMax
37634>>>>>>>>>>>>
37634>>>>>>>>>>>                Move gaEmptyAttributes to astTableAttributes.aIndices[iIndex].aSegments[iSegmentIndex].aIndexSegmentAttributes
37635>>>>>>>>>>>                Send Read_Attributes iChannel ATYPE_IDXSEG (&astTableAttributes.aIndices[iIndex].aSegments[iSegmentIndex].aIndexSegmentAttributes)
37636>>>>>>>>>>>            Loop
37637>>>>>>>>>>>>
37637>>>>>>>>>>>        Loop
37638>>>>>>>>>>>>
37638>>>>>>>>>>>    End_Procedure
37639>>>>>>>>>>>    
37639>>>>>>>>>>>    Procedure Write_TablesAttributes Integer iChannel tTableAttributes[] aTables
37641>>>>>>>>>>>        Integer iMax iIndex
37641>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
37642>>>>>>>>>>>        Writeln channel iChannel iMax
37645>>>>>>>>>>>        For iIndex from 0 to iMax
37651>>>>>>>>>>>>
37651>>>>>>>>>>>            Send Write_TableAttributes iChannel aTables[iIndex]
37652>>>>>>>>>>>        Loop 
37653>>>>>>>>>>>>
37653>>>>>>>>>>>    End_Procedure
37654>>>>>>>>>>>    
37654>>>>>>>>>>>    Procedure Read_TablesAttributes Integer iChannel tTableAttributes[] ByRef aTables
37656>>>>>>>>>>>        Integer iMax iIndex
37656>>>>>>>>>>>        Move (ResizeArray(aTables,0)) to aTables
37657>>>>>>>>>>>        Readln channel iChannel iMax
37659>>>>>>>>>>>        For iIndex from 0 to iMax
37665>>>>>>>>>>>>
37665>>>>>>>>>>>            Send Read_TableAttributes iChannel (&aTables[iIndex])
37666>>>>>>>>>>>        Loop
37667>>>>>>>>>>>>
37667>>>>>>>>>>>    End_Procedure
37668>>>>>>>>>>>                                                     
37668>>>>>>>>>>>    Procedure Write_ServerAttributes Integer iChannel tDataBaseServer stServer
37670>>>>>>>>>>>        Send Write_Attributes iChannel ATYPE_DRVSRV stServer.aServerAttributes
37671>>>>>>>>>>>    End_Procedure
37672>>>>>>>>>>>    
37672>>>>>>>>>>>    Procedure Read_ServerAttributes Integer iChannel tDataBaseServer ByRef stServer
37674>>>>>>>>>>>        Send Read_Attributes iChannel ATYPE_DRVSRV (&stServer.aServerAttributes)
37675>>>>>>>>>>>    End_Procedure
37676>>>>>>>>>>>                                                     
37676>>>>>>>>>>>    Procedure Write_DriverAttributes Integer iChannel tDataBaseDriver[] aDrivers
37678>>>>>>>>>>>        Integer iDriverMax iDriverIndex iServerMax iServerIndex
37678>>>>>>>>>>>        
37678>>>>>>>>>>>        Move (SizeOfArray(aDrivers)-1) to iDriverMax
37679>>>>>>>>>>>        Writeln channel iChannel iDriverMax
37682>>>>>>>>>>>        
37682>>>>>>>>>>>        For iDriverIndex from 0 to iDriverMax
37688>>>>>>>>>>>>
37688>>>>>>>>>>>            Send Write_Attributes iChannel ATYPE_DRIVER aDrivers[iDriverIndex].aDriverAttributes
37689>>>>>>>>>>>            Move (SizeOfArray(aDrivers[iDriverIndex].aServers)-1) to iServerMax
37690>>>>>>>>>>>            Writeln iServerMax
37692>>>>>>>>>>>            For iServerIndex from 0 to iServerMax
37698>>>>>>>>>>>>
37698>>>>>>>>>>>                Send Write_Attributes iChannel ATYPE_IDXSEG aDrivers[iDriverIndex].aServers[iServerIndex].aServerAttributes
37699>>>>>>>>>>>            Loop
37700>>>>>>>>>>>>
37700>>>>>>>>>>>        Loop
37701>>>>>>>>>>>>
37701>>>>>>>>>>>    End_Procedure
37702>>>>>>>>>>>    
37702>>>>>>>>>>>    Procedure Read_DriverAttributes Integer iChannel tDataBaseDriver[] ByRef aDrivers
37704>>>>>>>>>>>        Integer iDriverMax iDriverIndex iServerMax iServerIndex
37704>>>>>>>>>>>        Readln channel iChannel iDriverMax
37706>>>>>>>>>>>        For iDriverIndex from 0 to iDriverMax
37712>>>>>>>>>>>>
37712>>>>>>>>>>>            Move gaEmptyAttributes to aDrivers[iDriverIndex].aDriverAttributes
37713>>>>>>>>>>>            Send Read_Attributes iChannel ATYPE_DRIVER (&aDrivers[iDriverIndex].aDriverAttributes)
37714>>>>>>>>>>>            Readln iServerMax 
37715>>>>>>>>>>>            For iServerIndex from 0 to iServerMax
37721>>>>>>>>>>>>
37721>>>>>>>>>>>                Move gaEmptyAttributes to aDrivers[iDriverIndex].aServers[iServerIndex]
37722>>>>>>>>>>>                Send Read_Attributes iChannel ATYPE_IDXSEG (&aDrivers[iDriverIndex].aServers[iServerIndex].aServerAttributes)
37723>>>>>>>>>>>            Loop
37724>>>>>>>>>>>>
37724>>>>>>>>>>>        Loop
37725>>>>>>>>>>>>
37725>>>>>>>>>>>    End_Procedure
37726>>>>>>>>>>>    
37726>>>>>>>>>>>    //> Write tFileList variable to sequential channel iChannel
37726>>>>>>>>>>>    Procedure WriteChannel_FilelistAttributes Integer iChannel tFileList strFilelist
37728>>>>>>>>>>>        Send Write_Attributes iChannel ATYPE_GLOBAL strFilelist.aGlobalAttributes
37729>>>>>>>>>>>        Send Write_DriverAttributes iChannel strFilelist.aDrivers
37730>>>>>>>>>>>        Send Write_TablesAttributes iChannel strFilelist.aTables
37731>>>>>>>>>>>    End_Procedure
37732>>>>>>>>>>>
37732>>>>>>>>>>>    //> Read tFileList variable from sequential channel iChannel
37732>>>>>>>>>>>    Procedure ReadChannel_FilelistAttributes Integer iChannel tFileList ByRef strFilelist
37734>>>>>>>>>>>        Send Read_Attributes iChannel ATYPE_GLOBAL (&strFilelist.aGlobalAttributes)
37735>>>>>>>>>>>        Send Read_DriverAttributes iChannel (&strFilelist.aDrivers)
37736>>>>>>>>>>>        Send Read_TablesAttributes iChannel (&strFilelist.aTables)
37737>>>>>>>>>>>    End_Procedure
37738>>>>>>>>>>>
37738>>>>>>>>>>>    //> Write tFileList variable to sequential file with filename sFilename
37738>>>>>>>>>>>    Procedure WriteFile_FileListAttributes String sFilename tFileList strFilelist
37740>>>>>>>>>>>        Integer iChannel
37740>>>>>>>>>>>        Get DirectOutput of oFileFunctions sFilename to iChannel
37741>>>>>>>>>>>        If (iChannel>=0) Begin
37743>>>>>>>>>>>            Send WriteChannel_FilelistAttributes iChannel strFilelist
37744>>>>>>>>>>>            Send CloseOutput of oFileFunctions iChannel
37745>>>>>>>>>>>        End
37745>>>>>>>>>>>>
37745>>>>>>>>>>>    End_Procedure
37746>>>>>>>>>>>
37746>>>>>>>>>>>    //> Read tFileList variable from sequential file with filename sFilename
37746>>>>>>>>>>>    Procedure ReadFile_FileListAttributes String sFilename tFileList ByRef strFilelist
37748>>>>>>>>>>>        Integer iChannel
37748>>>>>>>>>>>        Get DirectInput of oFileFunctions sFilename to iChannel
37749>>>>>>>>>>>        If (iChannel>=0) Begin
37751>>>>>>>>>>>            Send ReadChannel_FilelistAttributes iChannel (&strFilelist)
37752>>>>>>>>>>>            Send CloseInput of oFileFunctions iChannel
37753>>>>>>>>>>>        End
37753>>>>>>>>>>>>
37753>>>>>>>>>>>    End_Procedure
37754>>>>>>>>>>>    
37754>>>>>>>>>>>// **** Utility function TableRelations that extracts all the relations within a tTableAttributes array and return them as a tTableRelation array. ****
37754>>>>>>>>>>>
37754>>>>>>>>>>>            Function RelationIndex tTableRelation[] aRelations Integer iFromTable Integer iToTable Returns Integer
37756>>>>>>>>>>>                Integer iRelMax iRelIndex
37756>>>>>>>>>>>                Move (SizeOfArray(aRelations)-1) to iRelMax
37757>>>>>>>>>>>                For iRelIndex from 0 to iRelMax
37763>>>>>>>>>>>>
37763>>>>>>>>>>>                    If (aRelations[iRelIndex].iFromTable=iFromTable and aRelations[iRelIndex].iToTable=iToTable) Function_Return iRelIndex
37766>>>>>>>>>>>                Loop
37767>>>>>>>>>>>>
37767>>>>>>>>>>>                Function_Return -1
37768>>>>>>>>>>>            End_Function
37769>>>>>>>>>>>
37769>>>>>>>>>>>    Procedure AddRelationSegment tTableRelation[] ByRef aRelations Integer iFromTable Integer iFromField Integer iToTable Integer iToField
37771>>>>>>>>>>>        Integer iRelIndex iRelSegmentIndex
37771>>>>>>>>>>>        Get RelationIndex aRelations iFromTable iToTable to iRelIndex
37772>>>>>>>>>>>        If (iRelIndex=-1) Begin
37774>>>>>>>>>>>            Move (SizeOfArray(aRelations)) to iRelIndex
37775>>>>>>>>>>>            Move iFromTable to aRelations[iRelIndex].iFromTable
37776>>>>>>>>>>>            Move iToTable to aRelations[iRelIndex].iToTable
37777>>>>>>>>>>>        End
37777>>>>>>>>>>>>
37777>>>>>>>>>>>        Move (SizeOfArray(aRelations[iRelIndex].aFromFields)) to iRelSegmentIndex
37778>>>>>>>>>>>        Move iFromTable to aRelations[iRelIndex].aFromFields[iRelSegmentIndex].iTable
37779>>>>>>>>>>>        Move iFromField to aRelations[iRelIndex].aFromFields[iRelSegmentIndex].iField
37780>>>>>>>>>>>        Move iToTable to aRelations[iRelIndex].aToFields[iRelSegmentIndex].iTable
37781>>>>>>>>>>>        Move iToField to aRelations[iRelIndex].aToFields[iRelSegmentIndex].iField
37782>>>>>>>>>>>    End_Procedure
37783>>>>>>>>>>>    
37783>>>>>>>>>>>            Procedure _ValidateRelations tTableAttributes[] astTables tTableRelation[] ByRef aRelations
37785>>>>>>>>>>>                Integer iRelIndex iRelMax iIndex
37785>>>>>>>>>>>                Move (SizeOfArray(aRelations)-1) to iRelMax
37786>>>>>>>>>>>                For iRelIndex from 0 to iRelMax
37792>>>>>>>>>>>>
37792>>>>>>>>>>>                    // In this place it should be checked that the fields in the relation makes up
37792>>>>>>>>>>>                    // sufficient information to look up a record in the parent table.
37792>>>>>>>>>>>                    // Futhermore it should be checked whether the index could be used for header-detail like queries.
37792>>>>>>>>>>>                    // But for now I'll just stamp them all with an OK.
37792>>>>>>>>>>>                    Move -1 to iIndex
37793>>>>>>>>>>>                    If (Integer(TableAttribute(Self,astTables,DF_FILE_NUMBER_FIELDS,aRelations[iRelIndex].iToTable))>0) Begin // Was it opened?
37795>>>>>>>>>>>                        Get FindIndexUnique astTables aRelations[iRelIndex].iToTable aRelations[iRelIndex].aToFields to iIndex
37796>>>>>>>>>>>                    End
37796>>>>>>>>>>>>
37796>>>>>>>>>>>                    Move (iIndex<>-1) to aRelations[iRelIndex].bFunctioning
37797>>>>>>>>>>>                    Get ConstrainIndexArray astTables aRelations[iRelIndex].iFromTable aRelations[iRelIndex].aFromFields to aRelations[iRelIndex].aChildIndices
37798>>>>>>>>>>>                Loop
37799>>>>>>>>>>>>
37799>>>>>>>>>>>            End_Procedure
37800>>>>>>>>>>>            
37800>>>>>>>>>>>            Procedure _SetTableCompressedIndices tTableAttributes[] astTables
37802>>>>>>>>>>>                Integer iItem iMax
37802>>>>>>>>>>>                Integer[] aCompressedIndices
37803>>>>>>>>>>>                Move (SizeOfArray(astTables)-1) to iMax
37804>>>>>>>>>>>                For iItem from 0 to iMax
37810>>>>>>>>>>>>
37810>>>>>>>>>>>                    Move iItem to aCompressedIndices[astTables[iItem].iReadFromFileListEntryNo]
37811>>>>>>>>>>>                Loop
37812>>>>>>>>>>>>
37812>>>>>>>>>>>                Set _paTableCompressedIndices to aCompressedIndices
37813>>>>>>>>>>>            End_Procedure
37814>>>>>>>>>>>            
37814>>>>>>>>>>>            Procedure _ClearTableCompressedIndices 
37816>>>>>>>>>>>                Integer[] aCompressedIndices
37817>>>>>>>>>>>                Set _paTableCompressedIndices to aCompressedIndices
37818>>>>>>>>>>>            End_Procedure
37819>>>>>>>>>>>
37819>>>>>>>>>>>    Function TableRelations tTableAttributes[] astTables Returns tTableRelation[]
37821>>>>>>>>>>>        Integer iTableMax iTableIndex iTable
37821>>>>>>>>>>>        Integer iFieldMax iField
37821>>>>>>>>>>>        Integer iRelTable iRelField
37821>>>>>>>>>>>        Integer iRelIndex
37821>>>>>>>>>>>        tTableRelation[] aRelations
37821>>>>>>>>>>>        tTableRelation[] aRelations
37822>>>>>>>>>>>        
37822>>>>>>>>>>>        Send _SetTableCompressedIndices astTables
37823>>>>>>>>>>>
37823>>>>>>>>>>>        Move (SizeOfArray(astTables)-1) to iTableMax
37824>>>>>>>>>>>        For iTableIndex from 0 to iTableMax
37830>>>>>>>>>>>>
37830>>>>>>>>>>>            Move astTables[iTableIndex].iReadFromFileListEntryNo to iTable
37831>>>>>>>>>>>            Move (SizeOfArray(astTables[iTableIndex].aFields)-1) to iFieldMax
37832>>>>>>>>>>>            For iField from 1 to iFieldMax
37838>>>>>>>>>>>>
37838>>>>>>>>>>>                Get TableAttribute astTables DF_FIELD_RELATED_FILE iTable iField to iRelTable
37839>>>>>>>>>>>                If (iRelTable<>0) Begin
37841>>>>>>>>>>>                    Get TableAttribute astTables DF_FIELD_RELATED_FIELD iTable iField to iRelField
37842>>>>>>>>>>>                    Send AddRelationSegment (&aRelations) iTable iField iRelTable iRelField
37843>>>>>>>>>>>                End
37843>>>>>>>>>>>>
37843>>>>>>>>>>>            Loop
37844>>>>>>>>>>>>
37844>>>>>>>>>>>        Loop
37845>>>>>>>>>>>>
37845>>>>>>>>>>>        Send _ValidateRelations astTables (&aRelations)
37846>>>>>>>>>>>        Send _ClearTableCompressedIndices
37847>>>>>>>>>>>        Function_Return aRelations
37848>>>>>>>>>>>    End_Function
37849>>>>>>>>>>>
37849>>>>>>>>>>>    // Define call back procedure like this: Procedure HandleTableRelation integer iFromTable integer iToTable tTableRelation stRelation
37849>>>>>>>>>>>    Procedure CallBackTableRelations Integer hMsg Integer hObj Boolean bFrom Integer iTable tTableRelation[] aRelations
37851>>>>>>>>>>>        Integer iRelMax iRelIndex
37851>>>>>>>>>>>        Move (SizeOfArray(aRelations)-1) to iRelMax
37852>>>>>>>>>>>         
37852>>>>>>>>>>>        If (bFrom) Begin // Parent tables
37854>>>>>>>>>>>            For iRelIndex from 0 to iRelMax
37860>>>>>>>>>>>>
37860>>>>>>>>>>>                If (aRelations[iRelIndex].iFromTable=iTable) Begin
37862>>>>>>>>>>>                    Send hMsg of hObj iTable aRelations[iRelIndex].iToTable aRelations[iRelIndex]  
37863>>>>>>>>>>>                End
37863>>>>>>>>>>>>
37863>>>>>>>>>>>            Loop
37864>>>>>>>>>>>>
37864>>>>>>>>>>>        End
37864>>>>>>>>>>>>
37864>>>>>>>>>>>        Else Begin // Child tables
37865>>>>>>>>>>>            For iRelIndex from 0 to iRelMax
37871>>>>>>>>>>>>
37871>>>>>>>>>>>                If (aRelations[iRelIndex].iToTable=iTable) Begin
37873>>>>>>>>>>>                    Send hMsg of hObj aRelations[iRelIndex].iFromTable iTable aRelations[iRelIndex]  
37874>>>>>>>>>>>                End
37874>>>>>>>>>>>>
37874>>>>>>>>>>>            Loop
37875>>>>>>>>>>>>
37875>>>>>>>>>>>        End
37875>>>>>>>>>>>>
37875>>>>>>>>>>>    End_Procedure
37876>>>>>>>>>>>    
37876>>>>>>>>>>>//    Procedure CallBackTableRelations2 Integer hMsg Integer hObj Integer iFromTable Integer iToTable tTableRelation[] aRelations
37876>>>>>>>>>>>//    End_Procedure
37876>>>>>>>>>>>    
37876>>>>>>>>>>>        Function _IntegerRemoveDublettes Integer[] aValues Returns Integer[]
37878>>>>>>>>>>>            Integer iMax iIndex iResultItem iPrevValue
37878>>>>>>>>>>>            Integer[] aResult
37879>>>>>>>>>>>            Move 0 to iResultItem
37880>>>>>>>>>>>            Move (SortArray(aValues)) to aValues
37881>>>>>>>>>>>            Move (SizeOfArray(aValues)-1) to iMax
37882>>>>>>>>>>>            For iIndex from 0 to iMax
37888>>>>>>>>>>>>
37888>>>>>>>>>>>                If (iIndex=0 or aValues[iIndex]<>iPrevValue) Begin
37890>>>>>>>>>>>                    Move aValues[iIndex] to aResult[iResultItem]
37891>>>>>>>>>>>                    Increment iResultItem
37892>>>>>>>>>>>                    Move aValues[iIndex] to iPrevValue
37893>>>>>>>>>>>                End
37893>>>>>>>>>>>>
37893>>>>>>>>>>>            Loop
37894>>>>>>>>>>>>
37894>>>>>>>>>>>            Function_Return aResult
37895>>>>>>>>>>>        End_Function
37896>>>>>>>>>>>
37896>>>>>>>>>>>    //> 
37896>>>>>>>>>>>    Function ParentTableArray tTableRelation[] astRelations Integer iTable Returns Integer[]
37898>>>>>>>>>>>        Integer iRelMax iRelIndex iParentTableIndex
37898>>>>>>>>>>>        Integer[] aParentTable
37899>>>>>>>>>>>
37899>>>>>>>>>>>        Move 0 to iParentTableIndex
37900>>>>>>>>>>>
37900>>>>>>>>>>>        Move (SizeOfArray(astRelations)-1) to iRelMax
37901>>>>>>>>>>>        For iRelIndex from 0 to iRelMax
37907>>>>>>>>>>>>
37907>>>>>>>>>>>            If (astRelations[iRelIndex].iFromTable=iTable) Begin
37909>>>>>>>>>>>                Move astRelations[iRelIndex].iToTable to aParentTable[iParentTableIndex]
37910>>>>>>>>>>>                Increment iParentTableIndex
37911>>>>>>>>>>>            End
37911>>>>>>>>>>>>
37911>>>>>>>>>>>        Loop
37912>>>>>>>>>>>>
37912>>>>>>>>>>>        Function_Return (_IntegerRemoveDublettes(Self,aParentTable))
37913>>>>>>>>>>>    End_Function
37914>>>>>>>>>>>    
37914>>>>>>>>>>>    //> 
37914>>>>>>>>>>>    Function ChildTableArray tTableRelation[] astRelations Integer iTable Returns Integer[]
37916>>>>>>>>>>>        Integer iRelMax iRelIndex iChildTableIndex
37916>>>>>>>>>>>        Integer[] aChildTable
37917>>>>>>>>>>>
37917>>>>>>>>>>>        Move 0 to iChildTableIndex
37918>>>>>>>>>>>
37918>>>>>>>>>>>        Move (SizeOfArray(astRelations)-1) to iRelMax
37919>>>>>>>>>>>        For iRelIndex from 0 to iRelMax
37925>>>>>>>>>>>>
37925>>>>>>>>>>>            If (astRelations[iRelIndex].iToTable=iTable) Begin
37927>>>>>>>>>>>                Move astRelations[iRelIndex].iFromTable to aChildTable[iChildTableIndex]
37928>>>>>>>>>>>                Increment iChildTableIndex
37929>>>>>>>>>>>            End
37929>>>>>>>>>>>>
37929>>>>>>>>>>>        Loop
37930>>>>>>>>>>>>
37930>>>>>>>>>>>        Function_Return (_IntegerRemoveDublettes(Self,aChildTable))
37931>>>>>>>>>>>    End_Function
37932>>>>>>>>>>>    
37932>>>>>>>>>>>    //> Returns a sorted array of tables numbers that has the same physical name (a.k.a. root-name) as the
37932>>>>>>>>>>>    //> one passed in parameter iTable. The result array will return the iTable itself
37932>>>>>>>>>>>    Function AliasTableArray tTableAttributes[] astTables Integer iTable Returns Integer[]
37934>>>>>>>>>>>        Integer iTableMax iTableIndex iResultIndex
37934>>>>>>>>>>>        Integer[] aRval
37935>>>>>>>>>>>        String sRootName
37935>>>>>>>>>>>        Move 0 to iResultIndex
37936>>>>>>>>>>>        Get TableAttribute astTables DF_FILE_ROOT_NAME iTable to sRootName
37937>>>>>>>>>>>        If (sRootName<>"") Begin
37939>>>>>>>>>>>            Move (SizeOfArray(astTables)-1) to iTableMax
37940>>>>>>>>>>>            For iTableIndex from 0 to iTableMax
37946>>>>>>>>>>>>
37946>>>>>>>>>>>                If (Uppercase(TableAttribute(Self,astTables,DF_FILE_ROOT_NAME,astTables[iTableIndex].iReadFromFileListEntryNo))=Uppercase(sRootName)) Begin
37948>>>>>>>>>>>                    Move astTables[iTableIndex].iReadFromFileListEntryNo to aRval[iResultIndex]
37949>>>>>>>>>>>                    Increment iResultIndex
37950>>>>>>>>>>>                End
37950>>>>>>>>>>>>
37950>>>>>>>>>>>            Loop
37951>>>>>>>>>>>>
37951>>>>>>>>>>>            Move (SortArray(aRval)) to aRval
37952>>>>>>>>>>>        End
37952>>>>>>>>>>>>
37952>>>>>>>>>>>        Function_Return aRval
37953>>>>>>>>>>>    End_Function
37954>>>>>>>>>>>    
37954>>>>>>>>>>>    Function IsAlias tTableAttributes[] astTables Integer iTable Returns Boolean
37956>>>>>>>>>>>        Boolean bAlias
37956>>>>>>>>>>>        Integer[] aLogicalTables
37957>>>>>>>>>>>        Move False to bAlias
37958>>>>>>>>>>>        Get AliasTableArray astTables iTable to aLogicalTables
37959>>>>>>>>>>>        If (SizeOfArray(aLogicalTables)>0) Begin
37961>>>>>>>>>>>            Move (iTable<>aLogicalTables[0]) to bAlias // An ad-hoc definition of 'aliasness' that may do for many purposes
37962>>>>>>>>>>>        End
37962>>>>>>>>>>>>
37962>>>>>>>>>>>        Function_Return bAlias
37963>>>>>>>>>>>    End_Function
37964>>>>>>>>>>>    
37964>>>>>>>>>>>    Function TableDefinitionOk tTableAttributes[] astTables Integer iTable Returns Boolean
37966>>>>>>>>>>>        Get TableIndex astTables iTable to iTable
37967>>>>>>>>>>>        Function_Return (SizeOfArray(astTables[iTable].aFields)<>0)
37968>>>>>>>>>>>    End_Function
37969>>>>>>>>>>>    
37969>>>>>>>>>>>    Function RemoveAliasesFromTableArray tTableAttributes[] astTables Integer[] aTables Returns Integer[]
37971>>>>>>>>>>>        Integer iMax iIndex iTable
37971>>>>>>>>>>>        Integer[] aResult
37972>>>>>>>>>>>        String[] aMaster
37973>>>>>>>>>>>        String sRootName
37973>>>>>>>>>>>
37973>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
37974>>>>>>>>>>>        For iIndex from 0 to iMax
37980>>>>>>>>>>>>
37980>>>>>>>>>>>            Move aTables[iIndex] to iTable
37981>>>>>>>>>>>            Get TableAttribute astTables DF_FILE_ROOT_NAME iTable to sRootName
37982>>>>>>>>>>>            If (StringAddToSet(oStackFunctions,&aMaster,Lowercase(sRootName))) Begin
37984>>>>>>>>>>>                Move iTable to aResult[SizeOfArray(aResult)]
37985>>>>>>>>>>>            End
37985>>>>>>>>>>>>
37985>>>>>>>>>>>        Loop
37986>>>>>>>>>>>>
37986>>>>>>>>>>>        Function_Return aResult
37987>>>>>>>>>>>    End_Function
37988>>>>>>>>>>>
37988>>>>>>>>>>>    // Removes "flexerrs", "codemast" and "codetype" from aTables array
37988>>>>>>>>>>>    Function RemoveUtilityTablesFromArray tTableAttributes[] astTables Integer[] aTables Returns Integer[]
37990>>>>>>>>>>>        Integer iMax iIndex iTable
37990>>>>>>>>>>>        Integer[] aResult
37991>>>>>>>>>>>        String sRootName
37991>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
37992>>>>>>>>>>>        For iIndex from 0 to iMax
37998>>>>>>>>>>>>
37998>>>>>>>>>>>            Move aTables[iIndex] to iTable
37999>>>>>>>>>>>            Get TableAttribute astTables DF_FILE_ROOT_NAME iTable 0 0 to sRootName
38000>>>>>>>>>>>            Move (Lowercase(sRootName)) to sRootName
38001>>>>>>>>>>>            If (not(sRootName contains "flexerrs") and not(sRootName contains "codemast") and not(sRootName contains "codetype")) Begin
38003>>>>>>>>>>>                Move iTable to aResult[SizeOfArray(aResult)]
38004>>>>>>>>>>>            End
38004>>>>>>>>>>>>
38004>>>>>>>>>>>        Loop
38005>>>>>>>>>>>>
38005>>>>>>>>>>>        Function_Return aResult
38006>>>>>>>>>>>    End_Function
38007>>>>>>>>>>>    
38007>>>>>>>>>>>    Function RemoveSystemTablesFromArray tTableAttributes[] astTables Integer[] aTables Returns Integer[]
38009>>>>>>>>>>>        Integer iMax iIndex iTable iIsSystem
38009>>>>>>>>>>>        Integer[] aResult
38010>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
38011>>>>>>>>>>>        For iIndex from 0 to iMax
38017>>>>>>>>>>>>
38017>>>>>>>>>>>            Move aTables[iIndex] to iTable
38018>>>>>>>>>>>            Get TableAttribute of oAttributeFunctions astTables DF_FILE_IS_SYSTEM_FILE iTable to iIsSystem
38019>>>>>>>>>>>            If (iIsSystem=0) Begin
38021>>>>>>>>>>>                Move iTable to aResult[SizeOfArray(aResult)]
38022>>>>>>>>>>>            End
38022>>>>>>>>>>>>
38022>>>>>>>>>>>        Loop
38023>>>>>>>>>>>>
38023>>>>>>>>>>>        Function_Return aResult
38024>>>>>>>>>>>    End_Function
38025>>>>>>>>>>>    
38025>>>>>>>>>>>            Function TableFieldIndex tTableField[] astFields tTableField strField Returns Integer
38027>>>>>>>>>>>                Integer iFieldIndex iFieldMax
38027>>>>>>>>>>>                Move (SizeOfArray(astFields)-1) to iFieldMax
38028>>>>>>>>>>>                For iFieldIndex from 0 to iFieldMax
38034>>>>>>>>>>>>
38034>>>>>>>>>>>                    If (strField.iTable=astFields[iFieldIndex].iTable and strField.iField=astFields[iFieldIndex].iField) Function_Return iFieldIndex
38037>>>>>>>>>>>                Loop
38038>>>>>>>>>>>>
38038>>>>>>>>>>>                Function_Return -1
38039>>>>>>>>>>>            End_Function
38040>>>>>>>>>>>            
38040>>>>>>>>>>>            Function FindFieldWithOffset tTableAttributes[] astTables Integer iTable Integer iOffset Returns Integer
38042>>>>>>>>>>>                Integer iField iFieldMax iFieldType iFieldOffset
38042>>>>>>>>>>>                Get TableAttribute astTables DF_FILE_NUMBER_FIELDS iTable to iFieldMax
38043>>>>>>>>>>>                For iField from 1 to iFieldMax
38049>>>>>>>>>>>>
38049>>>>>>>>>>>                    Get TableAttribute astTables DF_FIELD_OFFSET iTable iField to iFieldOffset
38050>>>>>>>>>>>                    If (iFieldOffset=iOffset) begin
38052>>>>>>>>>>>                        Get TableAttribute astTables DF_FIELD_TYPE iTable iField to iFieldType
38053>>>>>>>>>>>                        If (iFieldType<>DF_OVERLAP) Function_Return iField
38056>>>>>>>>>>>                    End
38056>>>>>>>>>>>>
38056>>>>>>>>>>>                Loop
38057>>>>>>>>>>>>
38057>>>>>>>>>>>                Function_Return -1
38058>>>>>>>>>>>            End_Function 
38059>>>>>>>>>>>
38059>>>>>>>>>>>            Procedure BuildTableRelationsConnectedFieldsChildren tTableAttributes[] astTables tTableRelation[] astRelations tTableField stRelField tTableField[] ByRef astConnectedFields Integer[] aChildTables
38061>>>>>>>>>>>                Integer iMaxField iField
38061>>>>>>>>>>>                Integer iRelationMax iRelationIndex
38061>>>>>>>>>>>                Integer iRelationSegmentMax iRelationSegmentIndex
38061>>>>>>>>>>>                Integer iFieldOffSet iOverlapFieldOffset iRelFieldOffset
38061>>>>>>>>>>>                Integer iChildTableMax iChildTableIndex
38061>>>>>>>>>>>                tTableField strField
38061>>>>>>>>>>>                tTableField strField
38061>>>>>>>>>>>            
38061>>>>>>>>>>>                Get TableAttribute astTables DF_FIELD_OFFSET stRelField.iTable stRelField.iField to iRelFieldOffset
38062>>>>>>>>>>>                
38062>>>>>>>>>>>                Move (SizeOfArray(aChildTables)-1) to iChildTableMax
38063>>>>>>>>>>>                For iChildTableIndex from 0 to iChildTableMax
38069>>>>>>>>>>>>
38069>>>>>>>>>>>
38069>>>>>>>>>>>                    // Now go through astRelations to find connected fields (rather than going through the table fields themselves)
38069>>>>>>>>>>>                    Move (SizeOfArray(astRelations)-1) to iRelationMax
38070>>>>>>>>>>>                    For iRelationIndex from 0 to iRelationMax
38076>>>>>>>>>>>>
38076>>>>>>>>>>>                        If (astRelations[iRelationIndex].iToTable=stRelField.iTable) Begin
38078>>>>>>>>>>>                            
38078>>>>>>>>>>>                            // Fact: this is a relation to the table that we are currently examining (stRelField.iTable)
38078>>>>>>>>>>>                            Move (SizeOfArray(astRelations[iRelationIndex].aToFields)-1) to iRelationSegmentMax
38079>>>>>>>>>>>                            For iRelationSegmentIndex from 0 to iRelationSegmentMax
38085>>>>>>>>>>>>
38085>>>>>>>>>>>                                If (astRelations[iRelationIndex].aToFields[iRelationSegmentIndex].iField=stRelField.iField) Begin
38087>>>>>>>>>>>                                    Move astRelations[iRelationIndex].aFromFields[iRelationSegmentIndex].iTable to strField.iTable
38088>>>>>>>>>>>                                    Move astRelations[iRelationIndex].aFromFields[iRelationSegmentIndex].iField to strField.iField
38089>>>>>>>>>>>                                    Send BuildTableRelationsConnectedFields astTables astRelations strField (&astConnectedFields)  
38090>>>>>>>>>>>                                End
38090>>>>>>>>>>>>
38090>>>>>>>>>>>                            Loop
38091>>>>>>>>>>>>
38091>>>>>>>>>>>                            
38091>>>>>>>>>>>                        End
38091>>>>>>>>>>>>
38091>>>>>>>>>>>                    Loop
38092>>>>>>>>>>>>
38092>>>>>>>>>>>                    
38092>>>>>>>>>>>                    // Now we will go through all the fields of strField.iTable to see if we are overlapped by fields
38092>>>>>>>>>>>                    // that relates themselves (and thereby indirectly may link strField to something)
38092>>>>>>>>>>>                    Get TableAttribute astTables DF_FILE_NUMBER_FIELDS strField.iTable to iMaxField
38093>>>>>>>>>>>                    For iField from 1 to iMaxField
38099>>>>>>>>>>>>
38099>>>>>>>>>>>                        If (iField<>strField.iField) Begin // We will skip ourself
38101>>>>>>>>>>>                            If (TableAttribute(Self,astTables,DF_FIELD_TYPE,strField.iTable,iField)=DF_OVERLAP) Begin
38103>>>>>>>>>>>                                Get TableAttribute astTables DF_FIELD_RELATED_FILE strField.iTable iField to stRelField.iTable
38104>>>>>>>>>>>                                If (stRelField.iTable<>0) Begin
38106>>>>>>>>>>>                                    Get TableAttribute astTables DF_FIELD_RELATED_FIELD strField.iTable iField to stRelField.iField
38107>>>>>>>>>>>                                
38107>>>>>>>>>>>                                    // It's an overlap field! Does it overlap strField?
38107>>>>>>>>>>>                                    If (Integer(TableAttribute(Self,astTables,DF_FIELD_OVERLAP,strField.iTable,strField.iField,iField))) Begin
38109>>>>>>>>>>>                                        // OK! We know that they overlap. Now we have to figure out
38109>>>>>>>>>>>                                        // which field in the related file corresponds to our strField
38109>>>>>>>>>>>                                        Get TableAttribute astTables DF_FIELD_OFFSET strField.iTable iField to iOverlapFieldOffset
38110>>>>>>>>>>>
38110>>>>>>>>>>>                                        // Now we calculate the offset of our strField clone (remember: it's NOT the overlap
38110>>>>>>>>>>>                                        // field that we currently have in our hand).
38110>>>>>>>>>>>                                        Move (iRelFieldOffset-iOverlapFieldOffset+iFieldOffSet) to iRelFieldOffset
38111>>>>>>>>>>>                                        Get FindFieldWithOffset astTables stRelField.iTable iRelFieldOffset to stRelField.iField
38112>>>>>>>>>>>                                        If (iRelFieldOffset>0) begin
38114>>>>>>>>>>>                                            Send BuildTableRelationsConnectedFields astTables astRelations stRelField (&astConnectedFields)
38115>>>>>>>>>>>                                        End
38115>>>>>>>>>>>>
38115>>>>>>>>>>>                                        Else begin
38116>>>>>>>>>>>                                            Error 813 "Overlap structure mis-match"
38117>>>>>>>>>>>>
38117>>>>>>>>>>>                                        End
38117>>>>>>>>>>>>
38117>>>>>>>>>>>                                    End
38117>>>>>>>>>>>>
38117>>>>>>>>>>>                                End
38117>>>>>>>>>>>>
38117>>>>>>>>>>>                            End
38117>>>>>>>>>>>>
38117>>>>>>>>>>>                        End
38117>>>>>>>>>>>>
38117>>>>>>>>>>>                    Loop
38118>>>>>>>>>>>>
38118>>>>>>>>>>>                Loop
38119>>>>>>>>>>>>
38119>>>>>>>>>>>            End_Procedure
38120>>>>>>>>>>>
38120>>>>>>>>>>>    Procedure BuildTableRelationsConnectedFields tTableAttributes[] astTables ;                                                 tTableRelation[] astRelations ;                                                 tTableField strField ;                                                 tTableField[] ByRef astConnectedFields
38122>>>>>>>>>>>        Integer iMaxField iField
38122>>>>>>>>>>>        Integer iRelationMax iRelationIndex
38122>>>>>>>>>>>        Integer iRelationSegmentMax iRelationSegmentIndex
38122>>>>>>>>>>>        Integer iFieldOffSet iOverlapFieldOffset iRelFieldOffset
38122>>>>>>>>>>>        Integer iAliasMax iAliasIndex
38122>>>>>>>>>>>        Integer[] aChildTables aAliasTables
38124>>>>>>>>>>>        tTableField strRelField
38124>>>>>>>>>>>        tTableField strRelField
38124>>>>>>>>>>>
38124>>>>>>>>>>>        Get TableAttribute astTables DF_FIELD_OFFSET strField.iTable strField.iField to iFieldOffSet // We *may* need it later
38125>>>>>>>>>>>        If (TableFieldIndex(Self,astConnectedFields,strField)=-1) Begin
38127>>>>>>>>>>>            Move strField to astConnectedFields[SizeOfArray(astConnectedFields)] // Add field to result set
38128>>>>>>>>>>>            
38128>>>>>>>>>>>            // Now go through astRelations to find connected fields (rather than going through the table fields themselves)
38128>>>>>>>>>>>            Move (SizeOfArray(astRelations)-1) to iRelationMax
38129>>>>>>>>>>>            For iRelationIndex from 0 to iRelationMax
38135>>>>>>>>>>>>
38135>>>>>>>>>>>                If (astRelations[iRelationIndex].iFromTable=strField.iTable) Begin
38137>>>>>>>>>>>                    
38137>>>>>>>>>>>                    // Fact: this is a relation from the table that we are currently examining (strField.iTable)
38137>>>>>>>>>>>                    Move (SizeOfArray(astRelations[iRelationIndex].aFromFields)-1) to iRelationSegmentMax
38138>>>>>>>>>>>                    For iRelationSegmentIndex from 0 to iRelationSegmentMax
38144>>>>>>>>>>>>
38144>>>>>>>>>>>                        If (astRelations[iRelationIndex].aFromFields[iRelationSegmentIndex].iField=strField.iField) Begin
38146>>>>>>>>>>>                            Move astRelations[iRelationIndex].aFromFields[iRelationSegmentIndex].iTable to strRelField.iTable
38147>>>>>>>>>>>                            Move astRelations[iRelationIndex].aFromFields[iRelationSegmentIndex].iField to strRelField.iField
38148>>>>>>>>>>>                            Send BuildTableRelationsConnectedFields astTables astRelations strRelField (&astConnectedFields)  
38149>>>>>>>>>>>                        End
38149>>>>>>>>>>>>
38149>>>>>>>>>>>                    Loop
38150>>>>>>>>>>>>
38150>>>>>>>>>>>                    
38150>>>>>>>>>>>                End
38150>>>>>>>>>>>>
38150>>>>>>>>>>>            Loop
38151>>>>>>>>>>>>
38151>>>>>>>>>>>            
38151>>>>>>>>>>>            // Now we will go through all the fields of strField.iTable to see if we are overlapped by fields
38151>>>>>>>>>>>            // that relates themselves (and thereby indirectly may link strField to something)
38151>>>>>>>>>>>            Get TableAttribute astTables DF_FILE_NUMBER_FIELDS strField.iTable to iMaxField
38152>>>>>>>>>>>            For iField from 1 to iMaxField
38158>>>>>>>>>>>>
38158>>>>>>>>>>>                If (iField<>strField.iField) Begin // We will skip ourself
38160>>>>>>>>>>>                    If (TableAttribute(Self,astTables,DF_FIELD_TYPE,strField.iTable,iField)=DF_OVERLAP) Begin
38162>>>>>>>>>>>                        Get TableAttribute astTables DF_FIELD_RELATED_FILE strField.iTable iField to strRelField.iTable
38163>>>>>>>>>>>                        If (strRelField.iTable<>0) Begin
38165>>>>>>>>>>>                            Get TableAttribute astTables DF_FIELD_RELATED_FIELD strField.iTable iField to strRelField.iField
38166>>>>>>>>>>>                        
38166>>>>>>>>>>>                            // It's an overlap field! Does it overlap strField?
38166>>>>>>>>>>>                            If (Integer(TableAttribute(Self,astTables,DF_FIELD_OVERLAP,strField.iTable,strField.iField,iField))) Begin
38168>>>>>>>>>>>                                // OK! We know that they overlap. Now we have to figure out
38168>>>>>>>>>>>                                // which field in the related file corresponds to our strField
38168>>>>>>>>>>>                                Get TableAttribute astTables DF_FIELD_OFFSET strField.iTable iField to iOverlapFieldOffset
38169>>>>>>>>>>>                                Get TableAttribute astTables DF_FIELD_OFFSET strRelField.iTable strRelField.iField to iRelFieldOffset
38170>>>>>>>>>>>                                
38170>>>>>>>>>>>                                // Now we calculate the offset of our strField clone (remember: it's NOT the overlap
38170>>>>>>>>>>>                                // field that we currently have in our hand).
38170>>>>>>>>>>>                                Move (iRelFieldOffset-iOverlapFieldOffset+iFieldOffSet) to iRelFieldOffset
38171>>>>>>>>>>>                                Get FindFieldWithOffset astTables strRelField.iTable iRelFieldOffset to strRelField.iField
38172>>>>>>>>>>>                                If (iRelFieldOffset>0) Send BuildTableRelationsConnectedFields astTables astRelations strRelField (&astConnectedFields)
38175>>>>>>>>>>>                                Else Error 812 "Overlap structure mis-match"
38177>>>>>>>>>>>                            End
38177>>>>>>>>>>>>
38177>>>>>>>>>>>                        End
38177>>>>>>>>>>>>
38177>>>>>>>>>>>                    End
38177>>>>>>>>>>>>
38177>>>>>>>>>>>                End
38177>>>>>>>>>>>>
38177>>>>>>>>>>>            Loop                     
38178>>>>>>>>>>>>
38178>>>>>>>>>>>            
38178>>>>>>>>>>>            // Here comes the branch that takes care of searching for connected field in child direction:
38178>>>>>>>>>>>            Get ChildTableArray astRelations strField.iTable to aChildTables
38179>>>>>>>>>>>            Send BuildTableRelationsConnectedFieldsChildren astTables astRelations strField (&astConnectedFields) aChildTables
38180>>>>>>>>>>>            
38180>>>>>>>>>>>            Get AliasTableArray astTables strField.iTable to aAliasTables
38181>>>>>>>>>>>            Move (SizeOfArray(aAliasTables)-1) to iAliasMax
38182>>>>>>>>>>>            For iAliasIndex from 0 to iAliasMax
38188>>>>>>>>>>>>
38188>>>>>>>>>>>                Move aAliasTables[iAliasMax] to strField.iTable
38189>>>>>>>>>>>                Send BuildTableRelationsConnectedFields astTables astRelations strField (&astConnectedFields)
38190>>>>>>>>>>>            Loop
38191>>>>>>>>>>>>
38191>>>>>>>>>>>
38191>>>>>>>>>>>        End
38191>>>>>>>>>>>>
38191>>>>>>>>>>>    End_Procedure
38192>>>>>>>>>>>    
38192>>>>>>>>>>>    // -------------------------------------------------------------------------------------------------
38192>>>>>>>>>>>    
38192>>>>>>>>>>>    // Returns an integer value representing the driver used for iTable as 
38192>>>>>>>>>>>    // enumerated in TableDriverFunctions.pkg
38192>>>>>>>>>>>    Function TableDriverIntegerId tTableAttributes[] astTables Integer iTable Returns Integer
38194>>>>>>>>>>>        Integer iDriver
38194>>>>>>>>>>>        String sDriver
38194>>>>>>>>>>>        Get TableAttribute astTables DF_FILE_DRIVER iTable 0 0 to sDriver
38195>>>>>>>>>>>        Get DriverDllToId of oTableDriverFunctions sDriver to iDriver
38196>>>>>>>>>>>        Function_Return iDriver
38197>>>>>>>>>>>    End_Function
38198>>>>>>>>>>>
38198>>>>>>>>>>>    // Filters away all tables that do not use the driver passed in the iDriver argument.
38198>>>>>>>>>>>    Function TableArrayFilterDriver tTableAttributes[] astTables Integer[] aTables Integer iDriver Returns Integer[]
38200>>>>>>>>>>>        Integer iTableDriver iTable iMax iIndex
38200>>>>>>>>>>>        Integer[] aResult
38201>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
38202>>>>>>>>>>>        For iIndex from 0 to iMax
38208>>>>>>>>>>>>
38208>>>>>>>>>>>            Move aTables[iIndex] to iTable
38209>>>>>>>>>>>            Get TableDriverIntegerId astTables iTable to iTableDriver
38210>>>>>>>>>>>            If (iTableDriver=iDriver) Begin
38212>>>>>>>>>>>                Move iTable to aResult[SizeOfArray(aResult)]
38213>>>>>>>>>>>            End
38213>>>>>>>>>>>>
38213>>>>>>>>>>>        Loop
38214>>>>>>>>>>>>
38214>>>>>>>>>>>        Function_Return aResult
38215>>>>>>>>>>>    End_Function
38216>>>>>>>>>>>    
38216>>>>>>>>>>>    Function TableRootNameStripDriver String sRootName Returns String
38218>>>>>>>>>>>        Integer iPos
38218>>>>>>>>>>>        Move (Pos(":",sRootName)) to iPos
38219>>>>>>>>>>>        If (iPos>2) Begin
38221>>>>>>>>>>>            Move (Remove(sRootName,1,iPos)) to sRootName
38222>>>>>>>>>>>        End
38222>>>>>>>>>>>>
38222>>>>>>>>>>>        Function_Return sRootName
38223>>>>>>>>>>>    End_Function
38224>>>>>>>>>>>    
38224>>>>>>>>>>>    Function TableRootNameStripAll String sRootName Returns String
38226>>>>>>>>>>>        Get TableRootNameStripDriver sRootName to sRootName
38227>>>>>>>>>>>        Get PathToFileRootName of oFileFunctions sRootName to sRootName
38228>>>>>>>>>>>        Function_Return sRootName
38229>>>>>>>>>>>    End_Function
38230>>>>>>>>>>>    
38230>>>>>>>>>>>    Function TableColumnName tTableAttributes[] astTables Integer iTable Integer iColumn Boolean bInclTableName Returns String
38232>>>>>>>>>>>        String sColumnName sTableName
38232>>>>>>>>>>>        If (iColumn<0) Begin
38234>>>>>>>>>>>            Function_Return ""
38235>>>>>>>>>>>        End
38235>>>>>>>>>>>>
38235>>>>>>>>>>>        Get TableAttribute astTables DF_FIELD_NAME iTable iColumn 0 to sColumnName
38236>>>>>>>>>>>
38236>>>>>>>>>>>        If (sColumnName="") Begin
38238>>>>>>>>>>>            If (iColumn=0) Begin
38240>>>>>>>>>>>                Move "Recnum" to sColumnName
38241>>>>>>>>>>>            End
38241>>>>>>>>>>>>
38241>>>>>>>>>>>            Else Begin
38242>>>>>>>>>>>                Move ("Column"+IntegerToStringRzf(oStringFunctions,iColumn,3)) to sColumnName
38243>>>>>>>>>>>            End
38243>>>>>>>>>>>>
38243>>>>>>>>>>>        End
38243>>>>>>>>>>>>
38243>>>>>>>>>>>        If (bInclTableName and sColumnName<>"") Begin
38245>>>>>>>>>>>            Get TableAttribute astTables DF_FILE_LOGICAL_NAME iTable to sTableName
38246>>>>>>>>>>>            If (sTableName="") Begin
38248>>>>>>>>>>>                Move ("Table"+String(iTable)) to sTableName
38249>>>>>>>>>>>            End
38249>>>>>>>>>>>>
38249>>>>>>>>>>>            Move (sTableName+"."+sColumnName) to sColumnName
38250>>>>>>>>>>>        End
38250>>>>>>>>>>>>
38250>>>>>>>>>>>        Function_Return sColumnName
38251>>>>>>>>>>>    End_Function
38252>>>>>>>>>>>    
38252>>>>>>>>>>>    Function TableColumnNameToNumber tTableAttributes[] astTables Integer iTable String sColumnName Returns Integer
38254>>>>>>>>>>>        Integer iFieldMax iFieldIndex
38254>>>>>>>>>>>        String sTest
38254>>>>>>>>>>>        
38254>>>>>>>>>>>        Move (Uppercase(sColumnName)) to sColumnName
38255>>>>>>>>>>>        If (sColumnName="RECNUM") Begin
38257>>>>>>>>>>>            Function_Return 0
38258>>>>>>>>>>>        End
38258>>>>>>>>>>>>
38258>>>>>>>>>>>        
38258>>>>>>>>>>>        Get TableAttribute astTables DF_FILE_NUMBER_FIELDS iTable to iFieldMax
38259>>>>>>>>>>>        
38259>>>>>>>>>>>        For iFieldIndex from 1 to iFieldMax
38265>>>>>>>>>>>>
38265>>>>>>>>>>>            Get TableAttribute astTables DF_FIELD_NAME iTable iFieldIndex to sTest
38266>>>>>>>>>>>            If (sColumnName=Uppercase(sTest)) Begin
38268>>>>>>>>>>>                Function_Return iFieldIndex
38269>>>>>>>>>>>            End
38269>>>>>>>>>>>>
38269>>>>>>>>>>>        Loop
38270>>>>>>>>>>>>
38270>>>>>>>>>>>        
38270>>>>>>>>>>>        Function_Return -1 // Not Found
38271>>>>>>>>>>>    End_Function
38272>>>>>>>>>>>    
38272>>>>>>>>>>>    Function TableColumnTypeAndLength tTableAttributes[] astTables Integer iTable Integer iColumn Returns String
38274>>>>>>>>>>>        Integer iColumnType iLen iPrecision
38274>>>>>>>>>>>        String sRval
38274>>>>>>>>>>>        Get TableAttribute astTables DF_FIELD_TYPE iTable iColumn to iColumnType
38275>>>>>>>>>>>        Get AttributeDisplayValue DF_FIELD_TYPE iColumnType to sRval
38276>>>>>>>>>>>        Get TableAttribute astTables DF_FIELD_LENGTH iTable iColumn to iLen
38277>>>>>>>>>>>        Get TableAttribute astTables DF_FIELD_PRECISION iTable iColumn to iPrecision
38278>>>>>>>>>>>        If (iColumnType=DF_BCD) Begin
38280>>>>>>>>>>>            Move (sRval+", "+String(iLen)+"."+String(iPrecision)) to sRval
38281>>>>>>>>>>>        End 
38281>>>>>>>>>>>>
38281>>>>>>>>>>>        Else Begin
38282>>>>>>>>>>>            Move (sRval+", "+String(iLen)) to sRval
38283>>>>>>>>>>>        End
38283>>>>>>>>>>>>
38283>>>>>>>>>>>        Function_Return sRval
38284>>>>>>>>>>>    End_Function
38285>>>>>>>>>>>    
38285>>>>>>>>>>>    Function TableNameToNumber tTableAttributes[] astTables String sLogicalName Returns Integer
38287>>>>>>>>>>>        Integer iTableMax iTableIndex
38287>>>>>>>>>>>        String sTest
38287>>>>>>>>>>>        Move (Uppercase(sLogicalName)) to sLogicalName
38288>>>>>>>>>>>        Move (SizeOfArray(astTables)-1) to iTableMax
38289>>>>>>>>>>>        For iTableIndex from 0 to iTableMax
38295>>>>>>>>>>>>
38295>>>>>>>>>>>            Get TableAttribute astTables DF_FILE_LOGICAL_NAME astTables[iTableIndex].iReadFromFileListEntryNo to sTest
38296>>>>>>>>>>>            If (sLogicalName=Uppercase(sTest)) Begin
38298>>>>>>>>>>>                Function_Return astTables[iTableIndex].iReadFromFileListEntryNo
38299>>>>>>>>>>>            End
38299>>>>>>>>>>>>
38299>>>>>>>>>>>        Loop
38300>>>>>>>>>>>>
38300>>>>>>>>>>>        Function_Return -1
38301>>>>>>>>>>>    End_Function
38302>>>>>>>>>>>
38302>>>>>>>>>>>        Procedure _TablesCallbackRelatingUpwards Boolean[] aVisitedTables tTableAttributes[] astTables Integer iRootTable Integer hMsg Integer hObj
38304>>>>>>>>>>>            Integer iColumn iColumnMax iRelTable
38304>>>>>>>>>>>
38304>>>>>>>>>>>            If (SizeOfArray(aVisitedTables)<=iRootTable or aVisitedTables[iRootTable]=False) Begin
38306>>>>>>>>>>>                Move True to aVisitedTables[iRootTable]
38307>>>>>>>>>>>                Send hMsg of hObj iRootTable
38308>>>>>>>>>>>
38308>>>>>>>>>>>                Get TableAttribute astTables DF_FILE_NUMBER_FIELDS iRootTable 0 0 to iColumnMax
38309>>>>>>>>>>>                For iColumn from 1 to iColumnMax
38315>>>>>>>>>>>>
38315>>>>>>>>>>>                    Get TableAttribute astTables DF_FIELD_RELATED_FILE iRootTable iColumn 0 to iRelTable
38316>>>>>>>>>>>                    If (iRelTable<>0) Begin
38318>>>>>>>>>>>                        Send _TablesCallbackRelatingUpwards aVisitedTables astTables iRelTable hMsg hObj
38319>>>>>>>>>>>                    End
38319>>>>>>>>>>>>
38319>>>>>>>>>>>                Loop
38320>>>>>>>>>>>>
38320>>>>>>>>>>>
38320>>>>>>>>>>>            End
38320>>>>>>>>>>>>
38320>>>>>>>>>>>        End_Procedure
38321>>>>>>>>>>>    
38321>>>>>>>>>>>    Procedure TablesCallbackRelatingUpwards tTableAttributes[] astTables Integer iRootTable Integer hMsg Integer hObj
38323>>>>>>>>>>>        Boolean[] aVisitedTables
38324>>>>>>>>>>>        Send _TablesCallbackRelatingUpwards aVisitedTables astTables iRootTable hMsg hObj
38325>>>>>>>>>>>    End_Procedure
38326>>>>>>>>>>>    
38326>>>>>>>>>>>    // -- Index functions -----------------------------------------------------------------------------
38326>>>>>>>>>>>    
38326>>>>>>>>>>>    Function IsIndexUnique tTableAttributes[] astTables Integer iTable Integer iIndex Returns Boolean
38328>>>>>>>>>>>        Integer iSegmentMax iField
38328>>>>>>>>>>>        Get TableAttribute astTables DF_INDEX_NUMBER_SEGMENTS iTable iIndex 0 0 to iSegmentMax
38329>>>>>>>>>>>        If (iSegmentMax>0) Begin
38331>>>>>>>>>>>            Get TableAttribute astTables DF_INDEX_SEGMENT_FIELD iTable iIndex iSegmentMax to iField
38332>>>>>>>>>>>            Function_Return (iField<>0)
38333>>>>>>>>>>>        End                                                                                                          
38333>>>>>>>>>>>>
38333>>>>>>>>>>>        Function_Return False
38334>>>>>>>>>>>    End_Function
38335>>>>>>>>>>>    
38335>>>>>>>>>>>    Function IsIndexOnline tTableAttributes[] astTables Integer iTable Integer iIndex Returns Boolean
38337>>>>>>>>>>>        Integer iSegmentMax iType
38337>>>>>>>>>>>        Get TableAttribute astTables DF_INDEX_NUMBER_SEGMENTS iTable iIndex 0 0 to iSegmentMax
38338>>>>>>>>>>>        If (iSegmentMax>0) Begin
38340>>>>>>>>>>>            Get TableAttribute astTables DF_INDEX_TYPE iTable iIndex 0 to iType
38341>>>>>>>>>>>            Function_Return (iType=DF_INDEX_TYPE_ONLINE)
38342>>>>>>>>>>>        End                                                                                                          
38342>>>>>>>>>>>>
38342>>>>>>>>>>>        Function_Return False
38343>>>>>>>>>>>    End_Function
38344>>>>>>>>>>>    
38344>>>>>>>>>>>    // Code: 0=All 1:Unique 2:Off-line 3:On-line
38344>>>>>>>>>>>    Function IndexArray tTableAttributes[] astTables Integer iTable Integer iCode Returns Integer[]
38346>>>>>>>>>>>        Integer iIndex iSegments
38346>>>>>>>>>>>        Integer[] aIndices
38347>>>>>>>>>>>        Boolean bOnLine
38347>>>>>>>>>>>        For iIndex from 1 to 15
38353>>>>>>>>>>>>
38353>>>>>>>>>>>            Get TableAttribute astTables DF_INDEX_NUMBER_SEGMENTS iTable iIndex 0 to iSegments
38354>>>>>>>>>>>            If (iSegments>0) Begin
38356>>>>>>>>>>>                If (iCode=0) Begin // All
38358>>>>>>>>>>>                    Move iIndex to aIndices[SizeOfArray(aIndices)]
38359>>>>>>>>>>>                End
38359>>>>>>>>>>>>
38359>>>>>>>>>>>                If (iCode=1) Begin // Unique
38361>>>>>>>>>>>                    If (IsIndexUnique(Self,astTables,iTable,iIndex)) Begin
38363>>>>>>>>>>>                        Move iIndex to aIndices[SizeOfArray(aIndices)]
38364>>>>>>>>>>>                    End
38364>>>>>>>>>>>>
38364>>>>>>>>>>>                End
38364>>>>>>>>>>>>
38364>>>>>>>>>>>                If (iCode=2) Begin // Off-line
38366>>>>>>>>>>>                    If (not(IsIndexOnline(Self,astTables,iTable,iIndex))) Begin
38368>>>>>>>>>>>                        Move iIndex to aIndices[SizeOfArray(aIndices)]
38369>>>>>>>>>>>                    End
38369>>>>>>>>>>>>
38369>>>>>>>>>>>                End
38369>>>>>>>>>>>>
38369>>>>>>>>>>>                If (iCode=3) Begin // On-line
38371>>>>>>>>>>>                    If (IsIndexOnline(Self,astTables,iTable,iIndex)) Begin
38373>>>>>>>>>>>                        Move iIndex to aIndices[SizeOfArray(aIndices)]
38374>>>>>>>>>>>                    End
38374>>>>>>>>>>>>
38374>>>>>>>>>>>                End
38374>>>>>>>>>>>>
38374>>>>>>>>>>>            End
38374>>>>>>>>>>>>
38374>>>>>>>>>>>        Loop
38375>>>>>>>>>>>>
38375>>>>>>>>>>>        Function_Return aIndices
38376>>>>>>>>>>>    End_Function
38377>>>>>>>>>>>    
38377>>>>>>>>>>>    Function IndexAsSegments tTableAttributes[] astTables Integer iTable Integer iIndex Returns tTableField[]
38379>>>>>>>>>>>        Integer iSegmentIndex iSegmentMax iVal
38379>>>>>>>>>>>        tTableField[] aSegments
38379>>>>>>>>>>>        tTableField[] aSegments
38380>>>>>>>>>>>        Get TableAttribute astTables DF_INDEX_NUMBER_SEGMENTS iTable iIndex 0 0 to iSegmentMax
38381>>>>>>>>>>>        If (iSegmentMax>0) Begin
38383>>>>>>>>>>>            For iSegmentIndex from 1 to iSegmentMax
38389>>>>>>>>>>>>
38389>>>>>>>>>>>                Move iTable to aSegments[iSegmentIndex-1].iTable
38390>>>>>>>>>>>                Get TableAttribute astTables DF_INDEX_SEGMENT_FIELD iTable iIndex iSegmentIndex to aSegments[iSegmentIndex-1].iField
38391>>>>>>>>>>>                Get TableAttribute astTables DF_INDEX_SEGMENT_CASE iTable iIndex iSegmentIndex to iVal
38392>>>>>>>>>>>                Move (iVal=DF_CASE_IGNORED) to aSegments[iSegmentIndex-1].bCapslock
38393>>>>>>>>>>>                Get TableAttribute astTables DF_INDEX_SEGMENT_DIRECTION iTable iIndex iSegmentIndex to iVal
38394>>>>>>>>>>>                Move (iVal=DF_DESCENDING) to aSegments[iSegmentIndex-1].bDescending
38395>>>>>>>>>>>            Loop
38396>>>>>>>>>>>>
38396>>>>>>>>>>>        End
38396>>>>>>>>>>>>
38396>>>>>>>>>>>        Function_Return aSegments
38397>>>>>>>>>>>    End_Function
38398>>>>>>>>>>>    
38398>>>>>>>>>>>    // Calling this function only has meaning if all iTable members of aSegments AND aFields are identical. The
38398>>>>>>>>>>>    // function just assumes this is the case, but does not check for it.
38398>>>>>>>>>>>    Function IndexSegmentsMatch tTableField[] aSegments tTableField[] aFields Returns Integer
38400>>>>>>>>>>>        Integer iSegmentIndex iSegmentMax
38400>>>>>>>>>>>        Integer iFieldIndex iFieldMax
38400>>>>>>>>>>>        Integer iRval
38400>>>>>>>>>>>        Move (SizeOfArray(aSegments)-1) to iSegmentMax
38401>>>>>>>>>>>        Move (SizeOfArray(aFields)-1) to iFieldMax
38402>>>>>>>>>>>        
38402>>>>>>>>>>>        For iSegmentIndex from 0 to iSegmentMax
38408>>>>>>>>>>>>
38408>>>>>>>>>>>            For iFieldIndex from 0 to iFieldMax
38414>>>>>>>>>>>>
38414>>>>>>>>>>>                If (aSegments[iSegmentIndex].iField=aFields[iFieldIndex].iField) Begin
38416>>>>>>>>>>>                    Move -1 to aSegments[iSegmentIndex].iTable // Mark as matched
38417>>>>>>>>>>>                    Move iFieldMax to iFieldIndex // Break the loop.
38418>>>>>>>>>>>                End
38418>>>>>>>>>>>>
38418>>>>>>>>>>>            Loop
38419>>>>>>>>>>>>
38419>>>>>>>>>>>        Loop
38420>>>>>>>>>>>>
38420>>>>>>>>>>>        
38420>>>>>>>>>>>        Move 0 to iRval
38421>>>>>>>>>>>        
38421>>>>>>>>>>>        For iSegmentIndex from 0 to iSegmentMax
38427>>>>>>>>>>>>
38427>>>>>>>>>>>            If (aSegments[iSegmentIndex].iTable>-1) Begin
38429>>>>>>>>>>>                Function_Return iRval
38430>>>>>>>>>>>            End
38430>>>>>>>>>>>>
38430>>>>>>>>>>>            Increment iRval
38431>>>>>>>>>>>        Loop
38432>>>>>>>>>>>>
38432>>>>>>>>>>>        
38432>>>>>>>>>>>        Function_Return iRval // All segments matched
38433>>>>>>>>>>>    End_Function
38434>>>>>>>>>>>    
38434>>>>>>>>>>>    // This function returns the number of the an index that is fully specified by the fields listed in the 
38434>>>>>>>>>>>    // aFields parameter.
38434>>>>>>>>>>>    Function FindIndexUnique tTableAttributes[] astTables Integer iTable tTableField[] aFields Returns Integer
38436>>>>>>>>>>>        Integer iIndexIndex iIndexMax iMatchCount
38436>>>>>>>>>>>        Integer[] aIndices
38437>>>>>>>>>>>        tTableField[] aSegments 
38437>>>>>>>>>>>        tTableField[] aSegments 
38438>>>>>>>>>>>        
38438>>>>>>>>>>>        Get FieldArrayReplaceOverlaps astTables aFields to aFields
38439>>>>>>>>>>>
38439>>>>>>>>>>>        Get IndexArray astTables iTable 1 to aIndices // Get array of unique indices on table iTable
38440>>>>>>>>>>>        Move (SizeOfArray(aIndices)-1) to iIndexMax
38441>>>>>>>>>>>        For iIndexIndex from 0 to iIndexMax
38447>>>>>>>>>>>>
38447>>>>>>>>>>>            Get IndexAsSegments astTables iTable aIndices[iIndexIndex] to aSegments
38448>>>>>>>>>>>            Get FieldArrayReplaceOverlaps astTables aSegments to aSegments
38449>>>>>>>>>>>            Get IndexSegmentsMatch aSegments aFields to iMatchCount
38450>>>>>>>>>>>            If (iMatchCount=SizeOfArray(aSegments)) Begin
38452>>>>>>>>>>>                Function_Return aIndices[iIndexIndex]
38453>>>>>>>>>>>            End
38453>>>>>>>>>>>>
38453>>>>>>>>>>>        Loop
38454>>>>>>>>>>>>
38454>>>>>>>>>>>        Function_Return -1 // No index found
38455>>>>>>>>>>>    End_Function
38456>>>>>>>>>>>    
38456>>>>>>>>>>>    Function ConstrainIndexArray tTableAttributes[] astTables Integer iTable tTableField[] aConstrainFields Returns Integer[]
38458>>>>>>>>>>>        Integer[] aIndices aRval
38460>>>>>>>>>>>        Integer iIndexIndex iIndexMax iMatchCount
38460>>>>>>>>>>>        tTableField[] aSegments
38460>>>>>>>>>>>        tTableField[] aSegments
38461>>>>>>>>>>>
38461>>>>>>>>>>>        Get FieldArrayReplaceOverlaps astTables aConstrainFields to aConstrainFields
38462>>>>>>>>>>>        Get IndexArray astTables iTable 0 to aIndices // Get array of all indices on table iTable
38463>>>>>>>>>>>
38463>>>>>>>>>>>        Move (SizeOfArray(aIndices)-1) to iIndexMax
38464>>>>>>>>>>>        For iIndexIndex from 0 to iIndexMax
38470>>>>>>>>>>>>
38470>>>>>>>>>>>            Get IndexAsSegments astTables iTable aIndices[iIndexIndex] to aSegments
38471>>>>>>>>>>>            Get FieldArrayReplaceOverlaps astTables aSegments to aSegments
38472>>>>>>>>>>>            Get IndexSegmentsMatch aSegments aConstrainFields to iMatchCount
38473>>>>>>>>>>>            If (iMatchCount=SizeOfArray(aConstrainFields)) Begin
38475>>>>>>>>>>>                Move aIndices[iIndexIndex] to aRval[SizeOfArray(aRval)]
38476>>>>>>>>>>>            End
38476>>>>>>>>>>>>
38476>>>>>>>>>>>        Loop
38477>>>>>>>>>>>>
38477>>>>>>>>>>>
38477>>>>>>>>>>>        Function_Return aRval
38478>>>>>>>>>>>    End_Function
38479>>>>>>>>>>>    
38479>>>>>>>>>>>    Function IndexColumnNames tFileList strFilelist Integer iTable Integer iIndex Boolean bMinusOnDescending String sSep Returns String
38481>>>>>>>>>>>        Integer iMax iSegment iDir iColumn
38481>>>>>>>>>>>        Boolean bDesc
38481>>>>>>>>>>>        String sColumnName sRval
38481>>>>>>>>>>>        Get Attrib strFilelist DF_INDEX_NUMBER_SEGMENTS iTable iIndex 0 to iMax
38482>>>>>>>>>>>        For iSegment from 1 to iMax
38488>>>>>>>>>>>>
38488>>>>>>>>>>>            Get Attrib strFilelist DF_INDEX_SEGMENT_FIELD iTable iIndex iSegment to iColumn
38489>>>>>>>>>>>            Get Attrib strFilelist DF_FIELD_NAME iTable iColumn 0 to sColumnName
38490>>>>>>>>>>>            If (sColumnName="" and iColumn=0) Begin
38492>>>>>>>>>>>                Move "Recnum" to sColumnName
38493>>>>>>>>>>>            End
38493>>>>>>>>>>>>
38493>>>>>>>>>>>            If (bMinusOnDescending) Begin
38495>>>>>>>>>>>                Get Attrib strFilelist DF_INDEX_SEGMENT_DIRECTION iTable iIndex iSegment to iDir
38496>>>>>>>>>>>                If (iDir=DF_DESCENDING) Begin
38498>>>>>>>>>>>                    Move ("-"+sColumnName) to sColumnName
38499>>>>>>>>>>>                End
38499>>>>>>>>>>>>
38499>>>>>>>>>>>            End
38499>>>>>>>>>>>>
38499>>>>>>>>>>>            If (iSegment<>1) Begin
38501>>>>>>>>>>>                Move (sRval+sSep) to sRval
38502>>>>>>>>>>>            End
38502>>>>>>>>>>>>
38502>>>>>>>>>>>            Move (sRval+sColumnName) to sRval
38503>>>>>>>>>>>        Loop
38504>>>>>>>>>>>>
38504>>>>>>>>>>>        Function_Return sRval
38505>>>>>>>>>>>    End_Function
38506>>>>>>>>>>>
38506>>>>>>>>>>>// -------------- Build "character graphical" representation of table relationships -----------------
38506>>>>>>>>>>>
38506>>>>>>>>>>>                Global_Variable Integer[]          __gaTablesVisited
38506>>>>>>>>>>>                Global_Variable tTableRelation[]   __gaRelations
38506>>>>>>>>>>>                Global_Variable Boolean[]          __gaVerticalLines
38506>>>>>>>>>>>
38506>>>>>>>>>>>                Function _AlreadyMappedAtRow Integer iTable tRelationsDrawingMapItem[] aMap Returns Integer
38508>>>>>>>>>>>                    Integer iMax iIndex
38508>>>>>>>>>>>                    Move (SizeOfArray(aMap)-1) to iMax
38509>>>>>>>>>>>                    For iIndex from 0 to iMax
38515>>>>>>>>>>>>
38515>>>>>>>>>>>                        If (iTable=aMap[iIndex].iItemId) Begin
38517>>>>>>>>>>>                            Function_Return iIndex // hDDO already mapped at row iIndex
38518>>>>>>>>>>>                        End
38518>>>>>>>>>>>>
38518>>>>>>>>>>>                    Loop
38519>>>>>>>>>>>>
38519>>>>>>>>>>>                    Function_Return -1 // not mapped
38520>>>>>>>>>>>                End_Function
38521>>>>>>>>>>>
38521>>>>>>>>>>>                Function _RemoveValueFromArray Integer iValue Integer[] aValues Returns Integer[]
38523>>>>>>>>>>>                    Integer iMax iIndex
38523>>>>>>>>>>>                    Integer[] aRval
38524>>>>>>>>>>>                    Move (SizeOfArray(aValues)-1) to iMax
38525>>>>>>>>>>>                    For iIndex from 0 to iMax
38531>>>>>>>>>>>>
38531>>>>>>>>>>>                        If (iValue<>aValues[iIndex]) Begin
38533>>>>>>>>>>>                            Move aValues[iIndex] to aRval[SizeOfArray(aRval)]
38534>>>>>>>>>>>                        End
38534>>>>>>>>>>>>
38534>>>>>>>>>>>                    Loop
38535>>>>>>>>>>>>
38535>>>>>>>>>>>                    Function_Return aRval
38536>>>>>>>>>>>                End_Function
38537>>>>>>>>>>>
38537>>>>>>>>>>>                Procedure _DmrAddToVisited Integer iTable
38539>>>>>>>>>>>                    Move iTable to __gaTablesVisited[SizeOfArray(__gaTablesVisited)]
38540>>>>>>>>>>>                End_Procedure
38541>>>>>>>>>>>
38541>>>>>>>>>>>                Function _DmrAlreadyVisited Integer iTable Returns Boolean
38543>>>>>>>>>>>                    Integer iMax iIndex
38543>>>>>>>>>>>                    Move (SizeOfArray(__gaTablesVisited)-1) to iMax
38544>>>>>>>>>>>                    For iIndex from 0 to iMax
38550>>>>>>>>>>>>
38550>>>>>>>>>>>                        If (iTable=__gaTablesVisited[iIndex]) Begin
38552>>>>>>>>>>>                            Function_Return True
38553>>>>>>>>>>>                        End
38553>>>>>>>>>>>>
38553>>>>>>>>>>>                    Loop
38554>>>>>>>>>>>>
38554>>>>>>>>>>>                    Function_Return False
38555>>>>>>>>>>>                End_Function
38556>>>>>>>>>>>
38556>>>>>>>>>>>        Procedure _doTableRelationsMap Integer iTable Integer iIgnoreTable Integer iLevel tRelationsDrawingMapItem[] ByRef aMap Boolean bFirst Boolean bLast Boolean bParent Boolean bChild
38558>>>>>>>>>>>            Integer iMax iIndex
38558>>>>>>>>>>>            Integer iAlreadyMappedAtRow
38558>>>>>>>>>>>            Boolean bUp bDown bLeft bRight
38558>>>>>>>>>>>            Integer[] aParentTables aChildTables
38560>>>>>>>>>>>            String sValue
38560>>>>>>>>>>>            Boolean bAlreadyVisited
38560>>>>>>>>>>>
38560>>>>>>>>>>>            Get _AlreadyMappedAtRow iTable aMap to iAlreadyMappedAtRow //Has the DDO already been mapped?
38561>>>>>>>>>>>
38561>>>>>>>>>>>            Get _DmrAlreadyVisited iTable to bAlreadyVisited
38562>>>>>>>>>>>            If (not(bAlreadyVisited)) Begin
38564>>>>>>>>>>>                Send _DmrAddToVisited iTable
38565>>>>>>>>>>>            End
38565>>>>>>>>>>>>
38565>>>>>>>>>>>
38565>>>>>>>>>>>            If (not(bAlreadyVisited)) Begin
38567>>>>>>>>>>>                Get ParentTableArray __gaRelations iTable to aParentTables              // If not already visited we get the relations
38568>>>>>>>>>>>                Get ChildTableArray __gaRelations iTable to aChildTables                // to and from this table (iTable)
38569>>>>>>>>>>>                Get _RemoveValueFromArray iIgnoreTable aParentTables to aParentTables   // We should remove the table that sent us here (iIgnoreTable)
38570>>>>>>>>>>>                Get _RemoveValueFromArray iIgnoreTable aChildTables to aChildTables
38571>>>>>>>>>>>            End
38571>>>>>>>>>>>>
38571>>>>>>>>>>>
38571>>>>>>>>>>>            Move (SizeOfArray(aMap)-1) to iIndex
38572>>>>>>>>>>>            
38572>>>>>>>>>>>            Move False to __gaVerticalLines[iLevel]   // <-----------------------------------------------------------
38573>>>>>>>>>>>            
38573>>>>>>>>>>>            If (not(bAlreadyVisited)) Begin
38575>>>>>>>>>>>                Move (SizeOfArray(aParentTables)-1) to iMax
38576>>>>>>>>>>>                For iIndex from 0 to iMax
38582>>>>>>>>>>>>
38582>>>>>>>>>>>                    Send _doTableRelationsMap aParentTables[iIndex] iTable (iLevel+1) (&aMap) (iIndex=0) (iIndex=iMax) True False
38583>>>>>>>>>>>                Loop
38584>>>>>>>>>>>>
38584>>>>>>>>>>>            End
38584>>>>>>>>>>>>
38584>>>>>>>>>>>            If (bParent and bFirst and iLevel>0) Begin
38586>>>>>>>>>>>                Move True to __gaVerticalLines[iLevel-1] // Turn on parent vertical line
38587>>>>>>>>>>>            End
38587>>>>>>>>>>>>
38587>>>>>>>>>>>            
38587>>>>>>>>>>>            Send BooleanDrop of oStackFunctions (&__gaVerticalLines) // <----------------------------------------
38588>>>>>>>>>>>
38588>>>>>>>>>>>            Move (SizeOfArray(aMap)) to iIndex // Point to next available entry in aMap array.
38589>>>>>>>>>>>            Move iTable to aMap[iIndex].iItemId
38590>>>>>>>>>>>            Move iLevel to aMap[iIndex].iLevel
38591>>>>>>>>>>>            Move __gaVerticalLines to aMap[iIndex].aVerticalLines
38592>>>>>>>>>>>            
38592>>>>>>>>>>>            If (iAlreadyMappedAtRow=-1 and bAlreadyVisited) Begin
38594>>>>>>>>>>>                Move -2 to iAlreadyMappedAtRow // Means that we don't yet know in what row the it "was" mapped in (may be fixed in a second pass)
38595>>>>>>>>>>>            End
38595>>>>>>>>>>>>
38595>>>>>>>>>>>
38595>>>>>>>>>>>            Move iAlreadyMappedAtRow to aMap[iIndex].iAlreadyMappedAtRow
38596>>>>>>>>>>>            Move bFirst  to aMap[iIndex].bFirst
38597>>>>>>>>>>>            Move bLast   to aMap[iIndex].bLast
38598>>>>>>>>>>>            Move bParent to aMap[iIndex].bParent
38599>>>>>>>>>>>            Move bChild  to aMap[iIndex].bChild
38600>>>>>>>>>>>
38600>>>>>>>>>>>            If (bChild and bLast and iLevel>0) Begin
38602>>>>>>>>>>>                Move False to __gaVerticalLines[iLevel-1]
38603>>>>>>>>>>>            End
38603>>>>>>>>>>>>
38603>>>>>>>>>>>
38603>>>>>>>>>>>            If (not(bAlreadyVisited)) Begin
38605>>>>>>>>>>>                Move True to __gaVerticalLines[iLevel] // <-----------------------------------------------------------------
38606>>>>>>>>>>>                Move (SizeOfArray(aChildTables)-1) to iMax
38607>>>>>>>>>>>                For iIndex from 0 to iMax
38613>>>>>>>>>>>>
38613>>>>>>>>>>>                    Send _doTableRelationsMap aChildTables[iIndex] iTable (iLevel+1) (&aMap) (iIndex=0) (iIndex=iMax) False True
38614>>>>>>>>>>>                Loop
38615>>>>>>>>>>>>
38615>>>>>>>>>>>                Send BooleanDrop of oStackFunctions (&__gaVerticalLines) // <----------------------------------------
38616>>>>>>>>>>>            End
38616>>>>>>>>>>>>
38616>>>>>>>>>>>       End_Procedure // _doTableRelationsMap
38617>>>>>>>>>>>
38617>>>>>>>>>>>
38617>>>>>>>>>>>    Function TableRelationsDrawingMap tTableRelation[] aRelations Integer iTable Returns tRelationsDrawingMapItem[]
38619>>>>>>>>>>>        tRelationsDrawingMapItem[] aMap
38619>>>>>>>>>>>        tRelationsDrawingMapItem[] aMap
38620>>>>>>>>>>>        Move aRelations to __gaRelations
38621>>>>>>>>>>>        Move (ResizeArray(__gaTablesVisited,0)) to __gaTablesVisited
38622>>>>>>>>>>>        Move (ResizeArray(__gaVerticalLines,0)) to __gaVerticalLines
38623>>>>>>>>>>>        Send _doTableRelationsMap iTable 0 0 (&aMap) False False False False
38624>>>>>>>>>>>        Function_Return aMap
38625>>>>>>>>>>>    End_Function
38626>>>>>>>>>>>
38626>>>>>>>>>>>// -------------------- Aux functions ----------------------------------------------------------------------------
38626>>>>>>>>>>>
38626>>>>>>>>>>>    Function DriversListedInFilelistCfg tFileList strFilelist Returns Integer[]
38628>>>>>>>>>>>        Integer iMax iIndex iDriver
38628>>>>>>>>>>>        Integer[] aTables aDrivers
38630>>>>>>>>>>>        String sDriver
38630>>>>>>>>>>>        Get FilelistNavigationTableArray strFilelist.aTables DF_FILE_NEXT_USED to aTables
38631>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
38632>>>>>>>>>>>        For iIndex from 0 to iMax
38638>>>>>>>>>>>>
38638>>>>>>>>>>>            Get Attrib strFilelist DF_FILE_DRIVER aTables[iIndex] 0 0 to sDriver
38639>>>>>>>>>>>            Get DriverDllToId of oTableDriverFunctions sDriver to iDriver
38640>>>>>>>>>>>            If (not(IntegerIsOnStack(oStackFunctions,iDriver,aDrivers))) Begin
38642>>>>>>>>>>>                Send IntegerPush of oStackFunctions iDriver (&aDrivers)
38643>>>>>>>>>>>            End
38643>>>>>>>>>>>>
38643>>>>>>>>>>>        Loop
38644>>>>>>>>>>>>
38644>>>>>>>>>>>        Function_Return aDrivers
38645>>>>>>>>>>>    End_Function
38646>>>>>>>>>>>
38646>>>>>>>>>>>    Function AttributeNameToID Integer iAttrType String sName Boolean bDisplayName Returns Integer
38648>>>>>>>>>>>        Integer iAttrMax iAttr
38648>>>>>>>>>>>        Move (SizeOfArray(gaAttributes)-1) to iAttrMax
38649>>>>>>>>>>>        For iAttr from 0 to iAttrMax
38655>>>>>>>>>>>>
38655>>>>>>>>>>>            If (iAttrType=gaAttributes[iAttr].iAttrType) Begin
38657>>>>>>>>>>>                If ((bDisplayName and sName=gaAttributes[iAttr].sDisplayName) or ;                    (not(bDisplayName) and sName=gaAttributes[iAttr].sName)) Begin
38659>>>>>>>>>>>                        Function_Return iAttr   
38660>>>>>>>>>>>                    End
38660>>>>>>>>>>>>
38660>>>>>>>>>>>            End
38660>>>>>>>>>>>>
38660>>>>>>>>>>>        Loop
38661>>>>>>>>>>>>
38661>>>>>>>>>>>        Function_Return -1
38662>>>>>>>>>>>    End_Function
38663>>>>>>>>>>>
38663>>>>>>>>>>>End_Class // _cAttributeFunctions
38664>>>>>>>>>>>
38664>>>>>>>>>>>Object _oAttributeFunctions is a _cAttributeFunctions
38666>>>>>>>>>>>    Move Self to oAttributeFunctions
38667>>>>>>>>>>>End_Object
38668>>>>>>>>>>>
38668>>>>>>>>>>>
38668>>>>>>>>>Use TableStructure.pkg
Including file: TableStructure.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\TableStructure.pkg)
38668>>>>>>>>>>>Use ErrorEventHandlerClass.pkg //
Including file: ErrorEventHandlerClass.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\ErrorEventHandlerClass.pkg)
38668>>>>>>>>>>>>>// Use ErrorEventHandlerClass.pkg // cErrorEventHandler class and oErrorSilence object
38668>>>>>>>>>>>>>
38668>>>>>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
38668>>>>>>>>>>>>>
38668>>>>>>>>>>>>>Struct tErrorEvent
38668>>>>>>>>>>>>>    Integer iError
38668>>>>>>>>>>>>>    Integer iErrorLine
38668>>>>>>>>>>>>>    String sErrorText
38668>>>>>>>>>>>>>End_Struct
38668>>>>>>>>>>>>>
38668>>>>>>>>>>>>>Class cErrorEventHandler is a cObject
38669>>>>>>>>>>>>>    Procedure Construct_Object
38671>>>>>>>>>>>>>        Forward Send Construct_Object
38673>>>>>>>>>>>>>
38673>>>>>>>>>>>>>        Property Integer _phPreviousErrorHandler public -1
38674>>>>>>>>>>>>>        Property Integer _error_processing_state public False
38675>>>>>>>>>>>>>
38675>>>>>>>>>>>>>        // These properties are used internally to enable forwarding of errors to the previous error handler.
38675>>>>>>>>>>>>>        Property Integer _piError
38676>>>>>>>>>>>>>        Property Integer _piErrorLine
38677>>>>>>>>>>>>>        Property String  _psErrMsg
38678>>>>>>>>>>>>>        
38678>>>>>>>>>>>>>        Property tErrorEvent[] paErrors
38679>>>>>>>>>>>>>    End_Procedure
38680>>>>>>>>>>>>>    
38680>>>>>>>>>>>>>    Function Error_Processing_State Returns Integer
38682>>>>>>>>>>>>>        Function_Return (_error_processing_state(Self))
38683>>>>>>>>>>>>>    End_Function
38684>>>>>>>>>>>>>
38684>>>>>>>>>>>>>    //> Forwards the error event to the previous errorhandler
38684>>>>>>>>>>>>>    Procedure Forward_Error_Report
38686>>>>>>>>>>>>>        Integer hPreviousErrorHandler
38686>>>>>>>>>>>>>        Get _phPreviousErrorHandler to hPreviousErrorHandler
38687>>>>>>>>>>>>>        If (hPreviousErrorHandler<>-1) Send error_report to hPreviousErrorHandler (_piError(Self)) (_piErrorLine(Self)) (_psErrMsg(Self))
38690>>>>>>>>>>>>>    End_Procedure
38691>>>>>>>>>>>>>    
38691>>>>>>>>>>>>>    Function ErrorEventCount Returns Integer
38693>>>>>>>>>>>>>        tErrorEvent[] aErrors
38693>>>>>>>>>>>>>        tErrorEvent[] aErrors
38694>>>>>>>>>>>>>        Get paErrors to aErrors
38695>>>>>>>>>>>>>        Function_Return (SizeOfArray(aErrors))
38696>>>>>>>>>>>>>    End_Function
38697>>>>>>>>>>>>>    
38697>>>>>>>>>>>>>    Function ErrorEvent Integer iIndex Returns tErrorEvent
38699>>>>>>>>>>>>>        tErrorEvent[] aErrors
38699>>>>>>>>>>>>>        tErrorEvent[] aErrors
38700>>>>>>>>>>>>>        Get paErrors to aErrors
38701>>>>>>>>>>>>>        Function_Return aErrors[iIndex]
38702>>>>>>>>>>>>>    End_Function
38703>>>>>>>>>>>>>
38703>>>>>>>>>>>>>    Procedure OnError Integer iError String sErrorText Integer iErrorLine
38705>>>>>>>>>>>>>        Integer iErrIndex
38705>>>>>>>>>>>>>        tErrorEvent[] aErrors
38705>>>>>>>>>>>>>        tErrorEvent[] aErrors
38706>>>>>>>>>>>>>        Get paErrors to aErrors
38707>>>>>>>>>>>>>        Move (SizeOfArray(aErrors)) to iErrIndex
38708>>>>>>>>>>>>>        Move iError to aErrors[iErrIndex].iError
38709>>>>>>>>>>>>>        Move sErrorText to aErrors[iErrIndex].sErrorText
38710>>>>>>>>>>>>>        Move iErrorLine to aErrors[iErrIndex].iErrorLine
38711>>>>>>>>>>>>>        Set paErrors to aErrors
38712>>>>>>>>>>>>>    End_Procedure
38713>>>>>>>>>>>>>
38713>>>>>>>>>>>>>    Procedure DoReset
38715>>>>>>>>>>>>>        tErrorEvent[] aErrors
38715>>>>>>>>>>>>>        tErrorEvent[] aErrors
38716>>>>>>>>>>>>>        Set paErrors to (ResizeArray(aErrors,0))
38717>>>>>>>>>>>>>    End_Procedure
38718>>>>>>>>>>>>>
38718>>>>>>>>>>>>>    Procedure Activate
38720>>>>>>>>>>>>>        Send DoReset
38721>>>>>>>>>>>>>        If (_phPreviousErrorHandler(Self)=-1) Begin
38723>>>>>>>>>>>>>            Set _phPreviousErrorHandler to Error_Object_Id
38724>>>>>>>>>>>>>            Move Self to Error_Object_Id
38725>>>>>>>>>>>>>        End
38725>>>>>>>>>>>>>>
38725>>>>>>>>>>>>>    End_Procedure
38726>>>>>>>>>>>>>    
38726>>>>>>>>>>>>>    Procedure Deactivate
38728>>>>>>>>>>>>>        If (_phPreviousErrorHandler(Self)<>-1) Begin
38730>>>>>>>>>>>>>            Get _phPreviousErrorHandler to Error_Object_Id
38731>>>>>>>>>>>>>            Set _phPreviousErrorHandler to -1
38732>>>>>>>>>>>>>        End
38732>>>>>>>>>>>>>>
38732>>>>>>>>>>>>>    End_Procedure
38733>>>>>>>>>>>>>    
38733>>>>>>>>>>>>>    Function Error_Description Integer iError String sErrorText Returns String
38735>>>>>>>>>>>>>        Integer hPreviousErrorHandler
38735>>>>>>>>>>>>>        Get _phPreviousErrorHandler to hPreviousErrorHandler
38736>>>>>>>>>>>>>        If (hPreviousErrorHandler<>-1) Get Error_Description of hPreviousErrorHandler iError sErrorText to sErrorText
38739>>>>>>>>>>>>>        Function_Return sErrorText
38740>>>>>>>>>>>>>    End_Function
38741>>>>>>>>>>>>>
38741>>>>>>>>>>>>>    Procedure Error_Report Integer iError Integer iErrorLine String sErrMsg
38743>>>>>>>>>>>>>        String  sErrorText
38743>>>>>>>>>>>>>        Integer hPrevErrHandler
38743>>>>>>>>>>>>>
38743>>>>>>>>>>>>>        If (_error_processing_state(Self)) Procedure_Return // this prevents recursion
38746>>>>>>>>>>>>>        Set _error_processing_state to True
38747>>>>>>>>>>>>>
38747>>>>>>>>>>>>>        Set _piError     to iError
38748>>>>>>>>>>>>>        Set _piErrorLine to iErrorLine
38749>>>>>>>>>>>>>        Set _psErrMsg    to sErrMsg
38750>>>>>>>>>>>>>
38750>>>>>>>>>>>>>        Get _phPreviousErrorHandler to hPrevErrHandler
38751>>>>>>>>>>>>>
38751>>>>>>>>>>>>>        Move (Error_Description(hPrevErrHandler,iError,sErrMsg)) to sErrorText
38752>>>>>>>>>>>>>        Send OnError iError sErrorText iErrorLine
38753>>>>>>>>>>>>>        Set _error_processing_state to False
38754>>>>>>>>>>>>>    End_Procedure
38755>>>>>>>>>>>>>End_Class // cErrorEventHandler
38756>>>>>>>>>>>>>
38756>>>>>>>>>>>>>Global_Variable Integer oErrorSilence
38756>>>>>>>>>>>>>
38756>>>>>>>>>>>>>Object _oErrorSilence is a cErrorEventHandler
38758>>>>>>>>>>>>>    Move Self to oErrorSilence
38759>>>>>>>>>>>>>End_Object
38760>>>>>>>>>>>Use AttributeFunctions.pkg
38760>>>>>>>>>>>Use TableAccessFunctions.pkg
38760>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
38760>>>>>>>>>>>Use TableDriverFunctions.pkg
38760>>>>>>>>>>>Use TableExplicitFunctions.pkg
Including file: TableExplicitFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\TableExplicitFunctions.pkg)
38760>>>>>>>>>>>>>Use AttributeFunctions.pkg
38760>>>>>>>>>>>>>Use StackFunctions.pkg // Define oStackFunctions object
38760>>>>>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
38760>>>>>>>>>>>>>Use TableAccessFunctions.pkg
38760>>>>>>>>>>>>>
38760>>>>>>>>>>>>>Object oTableExplicitFunctions is a cObject
38762>>>>>>>>>>>>>    Function TrimTableDefinitionToEmbedded tTableExplicit ByRef strTable Returns Boolean
38765>>>>>>>>>>>>>        Boolean bSucces
38765>>>>>>>>>>>>>        Integer iColumnMax iColumnIndex
38765>>>>>>>>>>>>>        String sColumnName
38765>>>>>>>>>>>>>        String[] aCheckDublettes
38766>>>>>>>>>>>>>        
38766>>>>>>>>>>>>>        Move True to bSucces
38767>>>>>>>>>>>>>        
38767>>>>>>>>>>>>>        Move (SizeOfArray(strTable.aFields)-1) to iColumnMax
38768>>>>>>>>>>>>>        For iColumnIndex from 1 to iColumnMax
38774>>>>>>>>>>>>>>
38774>>>>>>>>>>>>>            
38774>>>>>>>>>>>>>            // Embedded driver does not support DateTime type columns. We convert to ASCII: YYYY-MM-DD HH:MM:SS.nnn
38774>>>>>>>>>>>>>            If (strTable.aFields[iColumnIndex].iType=DF_DATETIME) Begin
38776>>>>>>>>>>>>>                Move DF_ASCII to strTable.aFields[iColumnIndex].iType
38777>>>>>>>>>>>>>                Move 23 to strTable.aFields[iColumnIndex].iLen
38778>>>>>>>>>>>>>            End
38778>>>>>>>>>>>>>>
38778>>>>>>>>>>>>>            
38778>>>>>>>>>>>>>            Move strTable.aFields[iColumnIndex].sName to sColumnName
38779>>>>>>>>>>>>>            If (Length(sColumnName)>32) Begin
38781>>>>>>>>>>>>>                Move (Left(sColumnName,32)) to strTable.aFields[iColumnIndex].sName
38782>>>>>>>>>>>>>            End
38782>>>>>>>>>>>>>>
38782>>>>>>>>>>>>>            If (not(StringAddToSet(oStackFunctions,&aCheckDublettes,strTable.aFields[iColumnIndex].sName))) Begin
38784>>>>>>>>>>>>>                Move False to bSucces
38785>>>>>>>>>>>>>            End
38785>>>>>>>>>>>>>>
38785>>>>>>>>>>>>>        Loop
38786>>>>>>>>>>>>>>
38786>>>>>>>>>>>>>        
38786>>>>>>>>>>>>>        If (strTable.bSystemFile) Begin
38788>>>>>>>>>>>>>            Move 1 to strTable.nMaxRecords
38789>>>>>>>>>>>>>        End
38789>>>>>>>>>>>>>>
38789>>>>>>>>>>>>>        Else If (strTable.nMaxRecords>C_MaxNumberOfRecordsInEmbeddedTable) Begin
38792>>>>>>>>>>>>>            Move C_MaxNumberOfRecordsInEmbeddedTable to strTable.nMaxRecords
38793>>>>>>>>>>>>>        End
38793>>>>>>>>>>>>>>
38793>>>>>>>>>>>>>        
38793>>>>>>>>>>>>>        Move "DATAFLEX" to strTable.sDriver
38794>>>>>>>>>>>>>        
38794>>>>>>>>>>>>>        Function_Return bSucces
38795>>>>>>>>>>>>>    End_Function
38796>>>>>>>>>>>>>    
38796>>>>>>>>>>>>>    Function TrimTableDefinitionToDriver tTableExplicit ByRef strTable Returns Boolean
38799>>>>>>>>>>>>>        Boolean bSucces
38799>>>>>>>>>>>>>        Integer iDriver
38799>>>>>>>>>>>>>        Get DriverDllToId of oTableDriverFunctions strTable.sDriver to iDriver
38800>>>>>>>>>>>>>        If (iDriver=TD_DRIVER_DATAFLEX) Get TrimTableDefinitionToEmbedded (&strTable) to bSucces
38803>>>>>>>>>>>>>        Function_Return bSucces
38804>>>>>>>>>>>>>    End_Function
38805>>>>>>>>>>>>>
38805>>>>>>>>>>>>>    Function ExplicitTabelToStringArray tTableExplicit strTable Returns String[]
38808>>>>>>>>>>>>>        tTableFieldExplicit strField
38808>>>>>>>>>>>>>        tTableFieldExplicit strField
38808>>>>>>>>>>>>>        tTableIndexExplicit strIndex
38808>>>>>>>>>>>>>        tTableIndexExplicit strIndex
38808>>>>>>>>>>>>>        Integer iField iFieldMax
38808>>>>>>>>>>>>>        Integer iIndex iIndexMax
38808>>>>>>>>>>>>>        Integer iSegment iSegmentMax
38808>>>>>>>>>>>>>        String sValue sFieldName
38808>>>>>>>>>>>>>        String[] aValues
38809>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("Table definition for "+strTable.sDriver+" table, file handle: "+String(strTable.iFileListEntry)) (&aValues)
38810>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("Root name: "+strTable.sRootName) (&aValues)
38811>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("Logical name: "+strTable.sLogicalName) (&aValues)
38812>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("Display name: "+strTable.sDisplayName) (&aValues)
38813>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("Physical name: "+strTable.sPhysicalName) (&aValues)
38814>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("SystemFile: "+String(strTable.bSystemFile)) (&aValues)
38815>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("MaxRecords: "+String(strTable.nMaxRecords)) (&aValues)
38816>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("RecordsUsed: "+String(strTable.nRecordsUsed)) (&aValues)
38817>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("RecordLength: "+String(strTable.iRecordLength)) (&aValues)
38818>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("RecordLengthUsed: "+String(strTable.iRecordLengthUsed)) (&aValues)
38819>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("LockType: "+String(strTable.iLockType)) (&aValues)
38820>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("IntegrityCheck: "+String(strTable.iIntegrityCheck)) (&aValues)
38821>>>>>>>>>>>>>        Send StringPush of oStackFunctions "" (&aValues)
38822>>>>>>>>>>>>>        Send StringPush of oStackFunctions "Columns: " (&aValues)
38823>>>>>>>>>>>>>        
38823>>>>>>>>>>>>>        Move (SizeOfArray(strTable.aFields)-1) to iFieldMax
38824>>>>>>>>>>>>>        For iField from 1 to iFieldMax
38830>>>>>>>>>>>>>>
38830>>>>>>>>>>>>>            Move strTable.aFields[iField] to strField
38831>>>>>>>>>>>>>            Move (String(iField)+": "+pad(strField.sName,15)+" "+FieldTypeText(oTableAccessFunctions,strField.iType,1)+" ") to sValue
38832>>>>>>>>>>>>>            Move (sValue+String(strField.iLen)+"."+String(strField.iPrecision)+" Offset/Native len: "+String(strField.iOffset)+"/"+String(strField.iNativeLength)+" ") to sValue
38833>>>>>>>>>>>>>            If (strField.iMainIndex<>0) Begin
38835>>>>>>>>>>>>>                Move (sValue+"Index: "+String(strField.iMainIndex)+" ") to sValue
38836>>>>>>>>>>>>>            End
38836>>>>>>>>>>>>>>
38836>>>>>>>>>>>>>            If (strField.iRelFile<>0) Begin
38838>>>>>>>>>>>>>                Move (sValue+"Relation: "+String(strField.iRelFile)+"."+String(strField.iRelField)+" ") to sValue
38839>>>>>>>>>>>>>            End
38839>>>>>>>>>>>>>>
38839>>>>>>>>>>>>>            Send StringPush of oStackFunctions sValue (&aValues)
38840>>>>>>>>>>>>>        Loop
38841>>>>>>>>>>>>>>
38841>>>>>>>>>>>>>        
38841>>>>>>>>>>>>>        Send StringPush of oStackFunctions "" (&aValues)
38842>>>>>>>>>>>>>        Send StringPush of oStackFunctions "Indices: " (&aValues)
38843>>>>>>>>>>>>>        Move (SizeOfArray(strTable.aIndices)-1) to iIndexMax
38844>>>>>>>>>>>>>        For iIndex from 1 to iIndexMax
38850>>>>>>>>>>>>>>
38850>>>>>>>>>>>>>            Move (SizeOfArray(strTable.aIndices[iIndex].aFields)-1) to iSegmentMax
38851>>>>>>>>>>>>>            If (iSegmentMax>=1) Begin
38853>>>>>>>>>>>>>                Move strTable.aIndices[iIndex] to strIndex
38854>>>>>>>>>>>>>                Send StringPush of oStackFunctions ("  Index: "+String(iIndex)) (&aValues)
38855>>>>>>>>>>>>>                For iSegment from 1 to iSegmentMax
38861>>>>>>>>>>>>>>
38861>>>>>>>>>>>>>                    If (strIndex.aFields[iSegment]<>0) Begin
38863>>>>>>>>>>>>>                        Move strTable.aFields[strIndex.aFields[iSegment]].sName to sFieldName
38864>>>>>>>>>>>>>                    End
38864>>>>>>>>>>>>>>
38864>>>>>>>>>>>>>                    Else Begin
38865>>>>>>>>>>>>>                        Move "Recnum" to sFieldName
38866>>>>>>>>>>>>>                    End
38866>>>>>>>>>>>>>>
38866>>>>>>>>>>>>>                    Send StringPush of oStackFunctions ("    "+sFieldName+" "+If(strIndex.aCaseInsensitive[iSegment],"UC","")+" "+If(strIndex.aDescending[iSegment],"desc","")) (&aValues)
38867>>>>>>>>>>>>>                Loop
38868>>>>>>>>>>>>>>
38868>>>>>>>>>>>>>            End
38868>>>>>>>>>>>>>>
38868>>>>>>>>>>>>>        Loop
38869>>>>>>>>>>>>>>
38869>>>>>>>>>>>>>        Function_Return aValues
38870>>>>>>>>>>>>>    End_Function
38871>>>>>>>>>>>>>    
38871>>>>>>>>>>>>>    Function ExplicitTabelToString tTableExplicit strTable Returns String
38874>>>>>>>>>>>>>        String[] aValues
38875>>>>>>>>>>>>>        Get ExplicitTabelToStringArray strTable to aValues
38876>>>>>>>>>>>>>        Function_Return (JoinString(oStringFunctions,aValues,Character(10),0,0))
38877>>>>>>>>>>>>>    End_Function
38878>>>>>>>>>>>>>    
38878>>>>>>>>>>>>>End_Object
38879>>>>>>>>>>>>>
38879>>>>>>>>>>>Use FilelistFunctions.pkg
Including file: FilelistFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\FilelistFunctions.pkg)
38879>>>>>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
38879>>>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
38879>>>>>>>>>>>>>Use StackFunctions.pkg
38879>>>>>>>>>>>>>
38879>>>>>>>>>>>>>
38879>>>>>>>>>>>>>Use TableAccessFunctions.pkg
38879>>>>>>>>>>>>>
38879>>>>>>>>>>>>>Global_Variable Integer oFilelistFunctions
38879>>>>>>>>>>>>>
38879>>>>>>>>>>>>>Object _oFilelistFunctions is a cObject
38881>>>>>>>>>>>>>    Move Self to oFilelistFunctions
38882>>>>>>>>>>>>>    
38882>>>>>>>>>>>>>    Property String[] _paFilelistStack
38884>>>>>>>>>>>>>    
38884>>>>>>>>>>>>>    Procedure PushAndSetFilelist String sFileListName
38887>>>>>>>>>>>>>        String sFilelistPush
38887>>>>>>>>>>>>>        String[] aFilelistStack
38888>>>>>>>>>>>>>        
38888>>>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilelistPush
38891>>>>>>>>>>>>>        Set_Attribute DF_FILELIST_NAME to (ToAnsi(sFileListName))
38894>>>>>>>>>>>>>        
38894>>>>>>>>>>>>>        Get _paFilelistStack to aFilelistStack
38895>>>>>>>>>>>>>        Send StringPush of oStackFunctions sFilelistPush (&aFilelistStack)
38896>>>>>>>>>>>>>        Set _paFilelistStack to aFilelistStack
38897>>>>>>>>>>>>>    End_Procedure
38898>>>>>>>>>>>>>    
38898>>>>>>>>>>>>>    Procedure PopFilelist
38901>>>>>>>>>>>>>        String sFilelistPush
38901>>>>>>>>>>>>>        String[] aFilelistStack
38902>>>>>>>>>>>>>
38902>>>>>>>>>>>>>        Get _paFilelistStack to aFilelistStack
38903>>>>>>>>>>>>>        Get StringPop of oStackFunctions (&aFilelistStack) to sFilelistPush 
38904>>>>>>>>>>>>>        Set _paFilelistStack to aFilelistStack
38905>>>>>>>>>>>>>
38905>>>>>>>>>>>>>        Set_Attribute DF_FILELIST_NAME to (ToAnsi(sFilelistPush))
38908>>>>>>>>>>>>>    End_Procedure
38909>>>>>>>>>>>>>
38909>>>>>>>>>>>>>    Function CreateEmptyFilelist String sFilename Returns Boolean
38912>>>>>>>>>>>>>        Integer liCount liOrg liChannel
38912>>>>>>>>>>>>>        String lsFiller sFilelistPush
38912>>>>>>>>>>>>>
38912>>>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilelistPush // Remember who we were
38915>>>>>>>>>>>>>
38915>>>>>>>>>>>>>        Get DirectOutput of oFileFunctions ("binary:"+sFilename) to liChannel
38916>>>>>>>>>>>>>
38916>>>>>>>>>>>>>        If (liChannel>=0) Begin
38918>>>>>>>>>>>>>            Get_Argument_Size to liOrg      // Create the filelist. It has to be of size
38919>>>>>>>>>>>>>            Set_Argument_Size 524277        // 32128, if it is any smaller errors occur
38920>>>>>>>>>>>>>>
38920>>>>>>>>>>>>>            pad "" to lsFiller 524277       // when setting the filelist attributes.
38922>>>>>>>>>>>>>>
38922>>>>>>>>>>>>>            Move (Repeat(character(0),524277)) to lsFiller
38923>>>>>>>>>>>>>            Write channel liChannel "filelist.cfg"            // This has to be the first 12 characters
38925>>>>>>>>>>>>>            Write lsFiller                  //
38926>>>>>>>>>>>>>            Send CloseOutput of oFileFunctions liChannel
38927>>>>>>>>>>>>>            Set_Argument_Size liOrg         // Restore max argument size.
38928>>>>>>>>>>>>>>
38928>>>>>>>>>>>>>            //      set_attribute DF_FILELIST_NAME To lsFileListPathAndName // Setup the file list for DataFlex.
38928>>>>>>>>>>>>>            Set_Attribute DF_FILELIST_NAME to (ToAnsi(sFilename))
38931>>>>>>>>>>>>>
38931>>>>>>>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of 4095 to "temp"
38934>>>>>>>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of 4095 to "temp"
38937>>>>>>>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of 4095 to "temp"
38940>>>>>>>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of 4095 to ""
38943>>>>>>>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of 4095 to ""
38946>>>>>>>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of 4095 to ""
38949>>>>>>>>>>>>>
38949>>>>>>>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of 50 to "flexerrs"
38952>>>>>>>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of 50 to "FLEXERRS"
38955>>>>>>>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of 50 to "@DataFlex Error File"
38958>>>>>>>>>>>>>
38958>>>>>>>>>>>>>            //for liCount from 1 to 250                               // Fill the filelist.
38958>>>>>>>>>>>>>            //  set_attribute DF_FILE_ROOT_NAME    of liCount to ""   // Every slot must be
38958>>>>>>>>>>>>>            //  set_attribute DF_FILE_LOGICAL_NAME of liCount to ""   // emptied out. Otherwise
38958>>>>>>>>>>>>>            //  set_attribute DF_FILE_DISPLAY_NAME of liCount to ""   // the API thinks some of
38958>>>>>>>>>>>>>            //loop                                                    // the slots are used.
38958>>>>>>>>>>>>>//            Set_Attribute DF_FILELIST_NAME to sFilelistPush
38958>>>>>>>>>>>>>            Function_Return (FileExists(oFileFunctions,sFilename)=1)
38959>>>>>>>>>>>>>        End
38959>>>>>>>>>>>>>>
38959>>>>>>>>>>>>>        Function_Return False
38960>>>>>>>>>>>>>    End_Function
38961>>>>>>>>>>>>>
38961>>>>>>>>>>>>>    Function FindEntryByRootname Integer iStartEntry String sTableRootName Returns Integer
38964>>>>>>>>>>>>>        Integer iTable
38964>>>>>>>>>>>>>        String sValue
38964>>>>>>>>>>>>>        Move iStartEntry to iTable
38965>>>>>>>>>>>>>        Repeat
38965>>>>>>>>>>>>>>
38965>>>>>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of iTable to iTable
38968>>>>>>>>>>>>>            If (iTable<>0) Begin
38970>>>>>>>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of iTable to sValue
38973>>>>>>>>>>>>>                If (Uppercase(sValue)=Uppercase(sTableRootName)) Begin
38975>>>>>>>>>>>>>                    Function_Return iTable
38976>>>>>>>>>>>>>                End
38976>>>>>>>>>>>>>>
38976>>>>>>>>>>>>>            End
38976>>>>>>>>>>>>>>
38976>>>>>>>>>>>>>        Until (iTable=0)
38978>>>>>>>>>>>>>        Function_Return 0
38979>>>>>>>>>>>>>    End_Function
38980>>>>>>>>>>>>>
38980>>>>>>>>>>>>>    Function FindEntryByLogicalName Integer iStartEntry String sLogicalName Returns Integer
38983>>>>>>>>>>>>>        Integer iTable
38983>>>>>>>>>>>>>        String sValue
38983>>>>>>>>>>>>>        Move iStartEntry to iTable
38984>>>>>>>>>>>>>        Repeat
38984>>>>>>>>>>>>>>
38984>>>>>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of iTable to iTable
38987>>>>>>>>>>>>>            If (iTable<>0) Begin
38989>>>>>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sValue
38992>>>>>>>>>>>>>                If (Uppercase(sValue)=Uppercase(sLogicalName)) Begin
38994>>>>>>>>>>>>>                    Function_Return iTable
38995>>>>>>>>>>>>>                End
38995>>>>>>>>>>>>>>
38995>>>>>>>>>>>>>            End
38995>>>>>>>>>>>>>>
38995>>>>>>>>>>>>>        Until (iTable=0)
38997>>>>>>>>>>>>>        Function_Return 0
38998>>>>>>>>>>>>>    End_Function
38999>>>>>>>>>>>>>
38999>>>>>>>>>>>>>    Procedure UpdateEntry Integer iTable String sRoot String sLogical String sDisplay
39002>>>>>>>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of iTable to sRoot
39005>>>>>>>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of iTable to sLogical
39008>>>>>>>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of iTable to sDisplay
39011>>>>>>>>>>>>>    End_Procedure
39012>>>>>>>>>>>>>
39012>>>>>>>>>>>>>    Function EntryInUse Integer iTable Returns Boolean
39015>>>>>>>>>>>>>        String sRoot
39015>>>>>>>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME of iTable to sRoot
39018>>>>>>>>>>>>>        Function_Return (sRoot<>"")
39019>>>>>>>>>>>>>    End_Function
39020>>>>>>>>>>>>>
39020>>>>>>>>>>>>>    Function TableEntryArray Integer iFileListNavAttr Returns Integer[]
39023>>>>>>>>>>>>>        Integer iTable iIndex
39023>>>>>>>>>>>>>        Integer[] aTables
39024>>>>>>>>>>>>>        If (iFileListNavAttr=DF_FILE_NEXT_OPENED or iFileListNavAttr=DF_FILE_NEXT_USED or iFileListNavAttr=DF_FILE_NEXT_EMPTY) Begin
39026>>>>>>>>>>>>>            Move 0 to iTable
39027>>>>>>>>>>>>>            Move 0 to iIndex
39028>>>>>>>>>>>>>            Repeat
39028>>>>>>>>>>>>>>
39028>>>>>>>>>>>>>                Get_Attribute iFileListNavAttr of iTable to iTable
39031>>>>>>>>>>>>>                If (iTable<>0) Begin
39033>>>>>>>>>>>>>                    Move iTable to aTables[iIndex]
39034>>>>>>>>>>>>>                    Increment iIndex
39035>>>>>>>>>>>>>                End
39035>>>>>>>>>>>>>>
39035>>>>>>>>>>>>>            Until (iTable=0)
39037>>>>>>>>>>>>>        End
39037>>>>>>>>>>>>>>
39037>>>>>>>>>>>>>        Else begin
39038>>>>>>>>>>>>>            Error 810 "Illegal attribute passed to TableIntegerArray function"
39039>>>>>>>>>>>>>>
39039>>>>>>>>>>>>>        End
39039>>>>>>>>>>>>>>
39039>>>>>>>>>>>>>        Function_Return aTables
39040>>>>>>>>>>>>>    End_Function
39041>>>>>>>>>>>>>    
39041>>>>>>>>>>>>>End_Object
39042>>>>>>>>>>>Use StackFunctions.pkg // Define oStackFunctions object
39042>>>>>>>>>>>//Use Win\TableStructureErrorPanel.dg
39042>>>>>>>>>>>
39042>>>>>>>>>>>Use TableStructureErrorStruct.pkg
Including file: TableStructureErrorStruct.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\TableStructureErrorStruct.pkg)
39042>>>>>>>>>>>>>Use ErrorEventHandlerClass.pkg // cErrorEventHandler class and oErrorSilence object
39042>>>>>>>>>>>>>
39042>>>>>>>>>>>>>Struct tRestructureError
39042>>>>>>>>>>>>>    String           sOperation         // While executing this instruction
39042>>>>>>>>>>>>>    tErrorEvent      stError            // this error occured
39042>>>>>>>>>>>>>    tErrorEvent      stError            // this error occured
39042>>>>>>>>>>>>>    tTableExplicit stTableDefInitial  //
39042>>>>>>>>>>>>>    tTableExplicit stTableDefInitial  //
39042>>>>>>>>>>>>>End_Struct
39042>>>>>>>>>>>>>
39042>>>>>>>>>>>>>Global_Variable tRestructureError _gstTempRestructureError
39042>>>>>>>>>>>>>Global_Variable Integer oTableStructureFunctions
39042>>>>>>>>>>>>>
39042>>>>>>>>>>>
39042>>>>>>>>>>>Class _cTableStructureFunctionsErrorHandler is a cErrorEventHandler
39043>>>>>>>>>>>    Procedure DoReset // Prevent each activation from resetting the error data
39045>>>>>>>>>>>    End_Procedure
39046>>>>>>>>>>>    Procedure _NewDoReset // Sent by function Structure_Start of cTableStructure class
39048>>>>>>>>>>>        tErrorEvent[] aEvents
39048>>>>>>>>>>>        tErrorEvent[] aEvents
39049>>>>>>>>>>>        tRestructureError[] aErrorLog
39049>>>>>>>>>>>        tRestructureError[] aErrorLog
39050>>>>>>>>>>>        Set paErrors to (ResizeArray(aEvents,0))
39051>>>>>>>>>>>        Set paErrorLog to (ResizeArray(aErrorLog,0))
39052>>>>>>>>>>>    End_Procedure
39053>>>>>>>>>>>    Procedure OnError Integer iError String sErrorText Integer iErrorLine
39055>>>>>>>>>>>        Forward Send OnError iError sErrorText iErrorLine
39057>>>>>>>>>>>        Move iError to _gstTempRestructureError.stError.iError
39058>>>>>>>>>>>        Move sErrorText to _gstTempRestructureError.stError.sErrorText
39059>>>>>>>>>>>        Move iErrorLine to _gstTempRestructureError.stError.iErrorLine
39060>>>>>>>>>>>        Set _pbWasError to True
39061>>>>>>>>>>>//        Send Popup of oTableStructureErrorPanel // Du'r desvrre ikke
39061>>>>>>>>>>>        Send Info_Box (_gstTempRestructureError.sOperation+Character(10)+ExplicitTabelToString(oTableExplicitFunctions,_gstTempRestructureError.stTableDefInitial)) "Structure error"
39062>>>>>>>>>>>    End_Procedure
39063>>>>>>>>>>>End_Class
39064>>>>>>>>>>>
39064>>>>>>>>>>>Class cTableStructure is a cObject
39065>>>>>>>>>>>
39065>>>>>>>>>>>    Procedure Construct_Object
39067>>>>>>>>>>>        Forward send Construct_Object
39069>>>>>>>>>>>        Property tRestructureError[] paErrorLog
39070>>>>>>>>>>>
39070>>>>>>>>>>>        Property Integer _phTable      // Private
39071>>>>>>>>>>>        Property Boolean _pbWasError  // Private
39072>>>>>>>>>>>
39072>>>>>>>>>>>        Property Integer piStructureEndOptions DF_STRUCTEND_OPT_NONE
39073>>>>>>>>>>>
39073>>>>>>>>>>>        Object _oErrorHandler is a _cTableStructureFunctionsErrorHandler
39075>>>>>>>>>>>        End_Object
39076>>>>>>>>>>>
39076>>>>>>>>>>>        Property Integer _piWriteSourceChannel
39077>>>>>>>>>>>        Property Boolean[] _paWriteSourceSuspended
39078>>>>>>>>>>>        Property Integer _piSourceIndent
39079>>>>>>>>>>>    End_Procedure
39080>>>>>>>>>>>
39080>>>>>>>>>>>    Function _IsSuspended Returns Boolean
39082>>>>>>>>>>>        Boolean bWriteSuspend
39082>>>>>>>>>>>        Boolean[] aWriteSourceSuspended
39083>>>>>>>>>>>        Get _paWriteSourceSuspended to aWriteSourceSuspended
39084>>>>>>>>>>>        If (BooleanIsEmpty(oStackFunctions,aWriteSourceSuspended)) Begin
39086>>>>>>>>>>>            Function_Return False
39087>>>>>>>>>>>        End
39087>>>>>>>>>>>>
39087>>>>>>>>>>>        Get BooleanCopy of oStackFunctions aWriteSourceSuspended to bWriteSuspend
39088>>>>>>>>>>>        Function_Return bWriteSuspend
39089>>>>>>>>>>>    End_Function
39090>>>>>>>>>>>    
39090>>>>>>>>>>>    Procedure WriteSource String sValue
39092>>>>>>>>>>>        Integer iChannel
39092>>>>>>>>>>>        If (not(_IsSuspended(Self))) Begin
39094>>>>>>>>>>>            Get _piWriteSourceChannel to iChannel
39095>>>>>>>>>>>            If (iChannel>=0) Begin
39097>>>>>>>>>>>                Write channel iChannel (Repeat("    ",_piSourceIndent(Self)))
39099>>>>>>>>>>>                Writeln sValue
39101>>>>>>>>>>>            End
39101>>>>>>>>>>>>
39101>>>>>>>>>>>        End
39101>>>>>>>>>>>>
39101>>>>>>>>>>>    End_Procedure
39102>>>>>>>>>>>    
39102>>>>>>>>>>>    Procedure SuspendWriteSource
39104>>>>>>>>>>>        Boolean[] aWriteSourceSuspended
39105>>>>>>>>>>>        Get _paWriteSourceSuspended to aWriteSourceSuspended
39106>>>>>>>>>>>        Send BooleanPush of oStackFunctions True (&aWriteSourceSuspended)
39107>>>>>>>>>>>        Set _paWriteSourceSuspended to aWriteSourceSuspended
39108>>>>>>>>>>>    End_Procedure
39109>>>>>>>>>>>    
39109>>>>>>>>>>>    Procedure UnsuspendWriteSource 
39111>>>>>>>>>>>        Boolean[] aWriteSourceSuspended
39112>>>>>>>>>>>        Get _paWriteSourceSuspended to aWriteSourceSuspended
39113>>>>>>>>>>>        Send BooleanDrop of oStackFunctions (&aWriteSourceSuspended)
39114>>>>>>>>>>>        Set _paWriteSourceSuspended to aWriteSourceSuspended
39115>>>>>>>>>>>    End_Procedure 
39116>>>>>>>>>>>    
39116>>>>>>>>>>>    Procedure IndentSource
39118>>>>>>>>>>>        Set _piSourceIndent to (_piSourceIndent(Self)+1)
39119>>>>>>>>>>>    End_Procedure
39120>>>>>>>>>>>
39120>>>>>>>>>>>    Procedure UnindentSource
39122>>>>>>>>>>>        Set _piSourceIndent to (_piSourceIndent(Self)-1)
39123>>>>>>>>>>>    End_Procedure
39124>>>>>>>>>>>
39124>>>>>>>>>>>    Procedure OnOperationBegin String sOperation // called before each modification of the structure (for each changing of an attribute value)
39126>>>>>>>>>>>        tTableAttributes strTable
39126>>>>>>>>>>>        tTableAttributes strTable
39126>>>>>>>>>>>        Set _pbWasError to False
39127>>>>>>>>>>>        Move sOperation to _gstTempRestructureError.sOperation
39128>>>>>>>>>>>        Send GetTableAttributes of oAttributeFunctions (&strTable) (_phTable(Self))
39129>>>>>>>>>>>        Get TableAttributesToExplicit of oAttributeFunctions strTable to _gstTempRestructureError.stTableDefInitial
39130>>>>>>>>>>>        Send Activate of _oErrorHandler
39131>>>>>>>>>>>      //If (Left(sOperation,5)<>"Struc") Begin
39131>>>>>>>>>>>      //    Error 789 "Tudse i suppen"
39131>>>>>>>>>>>      //End
39131>>>>>>>>>>>    End_Procedure
39132>>>>>>>>>>>
39132>>>>>>>>>>>    Procedure OnOperationEnd // Called immediately after each modification
39134>>>>>>>>>>>        Boolean bWasSuspended
39134>>>>>>>>>>>        Integer iMax iIndex
39134>>>>>>>>>>>        String[] aValues
39135>>>>>>>>>>>        tRestructureError[] aErrorLog
39135>>>>>>>>>>>        tRestructureError[] aErrorLog
39136>>>>>>>>>>>        Send Deactivate of _oErrorHandler
39137>>>>>>>>>>>        If (_pbWasError(Self)) Begin
39139>>>>>>>>>>>
39139>>>>>>>>>>>//            Send GetTableAttributes of oAttributeFunctions (&_gstTempRestructureError.stTableDefResult) (_phTable(Self))
39139>>>>>>>>>>>            Get paErrorLog to aErrorLog
39140>>>>>>>>>>>            Move _gstTempRestructureError to aErrorLog[SizeOfArray(aErrorLog)]
39141>>>>>>>>>>>            Set paErrorLog to aErrorLog
39142>>>>>>>>>>>            
39142>>>>>>>>>>>            Get _IsSuspended to bWasSuspended
39143>>>>>>>>>>>            If (bWasSuspended) Begin
39145>>>>>>>>>>>                Send UnsuspendWriteSource
39146>>>>>>>>>>>            End
39146>>>>>>>>>>>>
39146>>>>>>>>>>>
39146>>>>>>>>>>>            Send WriteSource ("// ERROR: "+String(_gstTempRestructureError.stError.iError)+" "+_gstTempRestructureError.stError.sErrorText+" on line "+String(_gstTempRestructureError.stError.iErrorLine))
39147>>>>>>>>>>>            Send WriteSource ("// Occurred while executing this instruction on the definition below: "+_gstTempRestructureError.sOperation)
39148>>>>>>>>>>>            Get ExplicitTabelToStringArray of oTableExplicitFunctions _gstTempRestructureError.stTableDefInitial to aValues
39149>>>>>>>>>>>            Move (SizeOfArray(aValues)-1) to iMax
39150>>>>>>>>>>>            For iIndex from 0 to iMax
39156>>>>>>>>>>>>
39156>>>>>>>>>>>                Send WriteSource ("// "+aValues[iIndex])
39157>>>>>>>>>>>            Loop
39158>>>>>>>>>>>>
39158>>>>>>>>>>>            
39158>>>>>>>>>>>            If (bWasSuspended) Begin
39160>>>>>>>>>>>                Send SuspendWriteSource
39161>>>>>>>>>>>            End
39161>>>>>>>>>>>>
39161>>>>>>>>>>>
39161>>>>>>>>>>>        End
39161>>>>>>>>>>>>
39161>>>>>>>>>>>    End_Procedure
39162>>>>>>>>>>>    
39162>>>>>>>>>>>        Procedure _MakeFinalLogEntry String sFinalRemark
39164>>>>>>>>>>>            tRestructureError[] aErrorLog
39164>>>>>>>>>>>            tRestructureError[] aErrorLog
39165>>>>>>>>>>>          
39165>>>>>>>>>>>            Get paErrorLog to aErrorLog
39166>>>>>>>>>>>            
39166>>>>>>>>>>>//            Send GetTableAttributes of oAttributeFunctions (&_gstTempRestructureError.stTableDefResult) (_phTable(Self))
39166>>>>>>>>>>>            Move "Structure on exit" to _gstTempRestructureError.sOperation
39167>>>>>>>>>>>            Move 0 to _gstTempRestructureError.stError.iError
39168>>>>>>>>>>>            Move 0 to _gstTempRestructureError.stError.iErrorLine
39169>>>>>>>>>>>            Move sFinalRemark to _gstTempRestructureError.stError.sErrorText
39170>>>>>>>>>>> 
39170>>>>>>>>>>>            Move _gstTempRestructureError to aErrorLog[SizeOfArray(aErrorLog)]
39171>>>>>>>>>>>            Set paErrorLog to aErrorLog
39172>>>>>>>>>>>        End_Procedure
39173>>>>>>>>>>>    
39173>>>>>>>>>>>    Function ErrorCount Returns Integer
39175>>>>>>>>>>>        Function_Return (SizeOfArray(paErrors(_oErrorHandler)))
39176>>>>>>>>>>>    End_Function
39177>>>>>>>>>>>    
39177>>>>>>>>>>>    Function ErrorEventArray Returns tErrorEvent[]
39179>>>>>>>>>>>        Function_Return (paErrors(_oErrorHandler))
39180>>>>>>>>>>>    End_Function
39181>>>>>>>>>>>
39181>>>>>>>>>>>    Function Structure_Start Integer hTable String sDriver Returns Boolean
39183>>>>>>>>>>>        Send _NewDoReset of _oErrorHandler
39184>>>>>>>>>>>        If (sDriver<>"") Begin
39186>>>>>>>>>>>            Send WriteSource ('Get Structure_Start hTable "'+sDriver+'" to bSucces')
39187>>>>>>>>>>>            Send OnOperationBegin ("Structure_Start hTable: "+String(hTable)+" driver: "+sDriver)
39188>>>>>>>>>>>            Structure_Start hTable sDriver
39189>>>>>>>>>>>        End
39189>>>>>>>>>>>>
39189>>>>>>>>>>>        Else Begin
39190>>>>>>>>>>>            Send WriteSource ("Get Structure_Start "+hTable+" to bSucces")
39191>>>>>>>>>>>            Send OnOperationBegin ("Get Structure_Start "+String(hTable)+" to bSucces")
39192>>>>>>>>>>>            Structure_Start hTable
39193>>>>>>>>>>>        End
39193>>>>>>>>>>>>
39193>>>>>>>>>>>        Send OnOperationEnd
39194>>>>>>>>>>>        Set _phTable to hTable
39195>>>>>>>>>>>        Function_Return (ErrorCount(Self)=0)
39196>>>>>>>>>>>    End_Function
39197>>>>>>>>>>>
39197>>>>>>>>>>>    Function Structure_Start_New_Table String sTableName String sFolder String sDriver Returns Boolean
39199>>>>>>>>>>>        Integer hTable
39199>>>>>>>>>>>        Boolean bSuccess
39199>>>>>>>>>>>
39199>>>>>>>>>>>        If (sFolder="") Begin // If folder is not specified, we will use the data folder (where filelist.cfg most likely resides)
39201>>>>>>>>>>>            Get VdfFolderPath of oFileFunctions VDF_FILELIST to sFolder
39202>>>>>>>>>>>        End
39202>>>>>>>>>>>>
39202>>>>>>>>>>>
39202>>>>>>>>>>>        Move 0 to hTable // This is a signal to the Structure_Start command to create a new table.
39203>>>>>>>>>>>
39203>>>>>>>>>>>        Get Structure_Start hTable sDriver to bSuccess
39204>>>>>>>>>>>        If (bSuccess) Begin
39206>>>>>>>>>>>            Set Table_Attribute DF_FILE_MULTIUSER     to DF_FILE_USER_MULTI
39207>>>>>>>>>>>            Set Table_Attribute DF_FILE_REUSE_DELETED to DF_FILE_DELETED_REUSE
39208>>>>>>>>>>>            Send SuspendWriteSource
39209>>>>>>>>>>>            Set Table_Attribute DF_FILE_PHYSICAL_NAME to (ToAnsi(AppendPath(oFileFunctions,sFolder,sTableName)))
39210>>>>>>>>>>>            Send UnsuspendWriteSource
39211>>>>>>>>>>>//            Send WriteSource ('Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to (ToAnsi(AppendPath(oFileFunctions,sFolder,"'+sTableName+'")))')
39211>>>>>>>>>>>            Send WriteSource ('Set Table_Attribute DF_FILE_PHYSICAL_NAME to (ToAnsi(AppendPath(oFileFunctions,sFolder,"'+sTableName+'")))')
39212>>>>>>>>>>>        End
39212>>>>>>>>>>>>
39212>>>>>>>>>>>        Function_Return bSuccess
39213>>>>>>>>>>>    End_Function
39214>>>>>>>>>>>
39214>>>>>>>>>>>    //> Table can be opened or closed on call
39214>>>>>>>>>>>    Function Structure_Start_Filelist_Table Integer iFilelistNumber Returns Boolean
39216>>>>>>>>>>>        Integer hTable
39216>>>>>>>>>>>        Boolean bSuccess bOpen
39216>>>>>>>>>>>
39216>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFilelistNumber to bOpen
39219>>>>>>>>>>>        If (not(bOpen)) Begin
39221>>>>>>>>>>>            Get OpenTable of oTableAccessFunctions iFilelistNumber DF_SHARE 0 to bSuccess
39222>>>>>>>>>>>        End
39222>>>>>>>>>>>>
39222>>>>>>>>>>>
39222>>>>>>>>>>>        Move iFilelistNumber to hTable
39223>>>>>>>>>>>
39223>>>>>>>>>>>        Get Structure_Start hTable "" to bSuccess
39224>>>>>>>>>>>        Function_Return bSuccess
39225>>>>>>>>>>>    End_Function
39226>>>>>>>>>>>
39226>>>>>>>>>>>    //> Table must be closed on call
39226>>>>>>>>>>>    Function Structure_Start_Existing_Table String sAbsoluteFileName Returns Boolean
39228>>>>>>>>>>>        Integer hTable
39228>>>>>>>>>>>        Boolean bSuccess
39228>>>>>>>>>>>
39228>>>>>>>>>>>        Get TempFilelistEntry of oTableAccessFunctions 2000 to hTable // First available entry GE 2000
39229>>>>>>>>>>>        Get OpenTableAs of oTableAccessFunctions sAbsoluteFileName hTable DF_SHARE 0 to bSuccess
39230>>>>>>>>>>>
39230>>>>>>>>>>>        If (bSuccess) Begin
39232>>>>>>>>>>>            Get Structure_Start hTable to bSuccess
39233>>>>>>>>>>>        End
39233>>>>>>>>>>>>
39233>>>>>>>>>>>
39233>>>>>>>>>>>        Function_Return bSuccess
39234>>>>>>>>>>>    End_Function
39235>>>>>>>>>>>    
39235>>>>>>>>>>>    Function Structure_End Returns Boolean
39237>>>>>>>>>>>        Boolean bSuccess
39237>>>>>>>>>>>        Integer hTable iHandleType
39237>>>>>>>>>>>        String sValue
39237>>>>>>>>>>>        tErrorEvent[] aErrors
39237>>>>>>>>>>>        tErrorEvent[] aErrors
39238>>>>>>>>>>>        
39238>>>>>>>>>>>        Get _phTable to hTable
39239>>>>>>>>>>>        Send WriteSource ("Get Structure_End to bSucces")
39240>>>>>>>>>>>        Send OnOperationBegin ("Structure_End options: "+String(piStructureEndOptions(Self)))
39241>>>>>>>>>>>            Structure_End hTable (piStructureEndOptions(Self)) "."
39243>>>>>>>>>>>        Send OnOperationEnd
39244>>>>>>>>>>>        
39244>>>>>>>>>>>         
39244>>>>>>>>>>>        Move (ErrorCount(Self)=0) to bSuccess
39245>>>>>>>>>>>        
39245>>>>>>>>>>>        Move "Exiting" to sValue
39246>>>>>>>>>>>        
39246>>>>>>>>>>>        If (not(bSuccess)) Begin
39248>>>>>>>>>>>            Get ErrorEventArray to aErrors
39249>>>>>>>>>>>            Move (sValue+" (errors occurred)") to sValue
39250>>>>>>>>>>>        End
39250>>>>>>>>>>>>
39250>>>>>>>>>>>        
39250>>>>>>>>>>>        Send _MakeFinalLogEntry sValue
39251>>>>>>>>>>>        Set _phTable to 0 //hTable
39252>>>>>>>>>>>        Get_Attribute DF_FILE_HANDLE_TYPE of hTable to iHandleType
39255>>>>>>>>>>>        If (iHandleType<>DF_FILE_HANDLE_BAD) Begin
39257>>>>>>>>>>>            Close hTable
39258>>>>>>>>>>>        End
39258>>>>>>>>>>>>
39258>>>>>>>>>>>        Function_Return bSuccess
39259>>>>>>>>>>>    End_Function
39260>>>>>>>>>>>    
39260>>>>>>>>>>>    Procedure Structure_Abort
39262>>>>>>>>>>>        Integer hTable
39262>>>>>>>>>>>        Get _phTable to hTable
39263>>>>>>>>>>>        Send WriteSource "Structure_Abort hTable"
39264>>>>>>>>>>>        Send OnOperationBegin ("Structure_Abort "+String(hTable))
39265>>>>>>>>>>>            Structure_Abort hTable
39266>>>>>>>>>>>        Send OnOperationEnd
39267>>>>>>>>>>>        Set _phTable to hTable
39268>>>>>>>>>>>        Send _MakeFinalLogEntry "Restructure aborted"
39269>>>>>>>>>>>    End_Procedure
39270>>>>>>>>>>>    
39270>>>>>>>>>>>    Procedure Structure_Copy Integer hSourceTable
39272>>>>>>>>>>>        Integer hTable
39272>>>>>>>>>>>        Get _phTable to hTable
39273>>>>>>>>>>>        Send WriteSource "Structure_Copy hSourceTable to hTable"
39274>>>>>>>>>>>        Send OnOperationBegin ("Structure_Copy source-table: "+String(hSourceTable))
39275>>>>>>>>>>>            Structure_Copy hSourceTable to hTable
39276>>>>>>>>>>>        Send OnOperationEnd
39277>>>>>>>>>>>    End_Procedure
39278>>>>>>>>>>>    
39278>>>>>>>>>>>    Procedure Load_Def String sDefFile
39280>>>>>>>>>>>        Integer hTable
39280>>>>>>>>>>>        Get _phTable to hTable
39281>>>>>>>>>>>        Send WriteSource ("Load_Def "+sDefFile+" Onto hTable")
39282>>>>>>>>>>>        Send OnOperationBegin ("Load_Def def-file: "+String(sDefFile))
39283>>>>>>>>>>>            Load_Def sDefFile Onto hTable
39284>>>>>>>>>>>        Send OnOperationEnd
39285>>>>>>>>>>>    End_Procedure
39286>>>>>>>>>>>
39286>>>>>>>>>>>    Procedure Create_Field Integer iPosition // iPosition=0 => Field is appended
39288>>>>>>>>>>>        Integer hTable
39288>>>>>>>>>>>        Get _phTable to hTable
39289>>>>>>>>>>>        Send WriteSource ("Send Create_Field "+String(iPosition))
39290>>>>>>>>>>>        Send OnOperationBegin ("Create_Field position: "+String(iPosition))
39291>>>>>>>>>>>            Create_Field hTable At iPosition
39292>>>>>>>>>>>        Send OnOperationEnd
39293>>>>>>>>>>>    End_Procedure
39294>>>>>>>>>>>
39294>>>>>>>>>>>    Function Append_Field Returns Integer
39296>>>>>>>>>>>        Integer hTable iPosition
39296>>>>>>>>>>>        Get _phTable to hTable
39297>>>>>>>>>>>        Send WriteSource
39298>>>>>>>>>>>        Send WriteSource ("Send Append_Field hTable 0 // Append")
39299>>>>>>>>>>>        Send OnOperationBegin  "Create_Field position: 0 (append)"
39300>>>>>>>>>>>            Move 0 to iPosition // 0 means: append
39301>>>>>>>>>>>            Create_Field hTable At iPosition
39302>>>>>>>>>>>        Send OnOperationEnd
39303>>>>>>>>>>>        Function_Return iPosition
39304>>>>>>>>>>>    End_Function
39305>>>>>>>>>>>
39305>>>>>>>>>>>    Procedure Delete_Field Integer iPosition
39307>>>>>>>>>>>        Integer hTable
39307>>>>>>>>>>>        Get _phTable to hTable
39308>>>>>>>>>>>        Send WriteSource ("Send Delete_Field "+String(iPosition))
39309>>>>>>>>>>>        Send OnOperationBegin  ("Delete_Field position: "+String(iPosition))
39310>>>>>>>>>>>            Delete_Field hTable iPosition
39311>>>>>>>>>>>        Send OnOperationEnd
39312>>>>>>>>>>>    End_Procedure
39313>>>>>>>>>>>
39313>>>>>>>>>>>    Procedure Create_Index Integer iIndexNumber
39315>>>>>>>>>>>        Integer hTable
39315>>>>>>>>>>>        Integer iIndexHandle iMax
39315>>>>>>>>>>>        Boolean[] aTempIndices
39316>>>>>>>>>>>        Get _phTable to hTable
39317>>>>>>>>>>>        Move iIndexNumber to iIndexHandle
39318>>>>>>>>>>>
39318>>>>>>>>>>>        Send WriteSource ("Send Create_Index "+String(iIndexNumber))
39319>>>>>>>>>>>        Send OnOperationBegin ("Create_Index index: "+String(iIndexNumber))
39320>>>>>>>>>>>            Repeat
39320>>>>>>>>>>>>
39320>>>>>>>>>>>                Create_Index hTable at iIndexNumber
39321>>>>>>>>>>>                If (iIndexNumber<>iIndexHandle) Begin
39323>>>>>>>>>>>                    Move True to aTempIndices[iIndexNumber]
39324>>>>>>>>>>>                End
39324>>>>>>>>>>>>
39324>>>>>>>>>>>            Until (iIndexHandle=iIndexNumber)
39326>>>>>>>>>>>            Move (SizeOfArray(aTempIndices)-1) to iMax
39327>>>>>>>>>>>            For iIndexNumber from 1 to iMax
39333>>>>>>>>>>>>
39333>>>>>>>>>>>                If (aTempIndices[iIndexNumber]) Begin
39335>>>>>>>>>>>                    Send SuspendWriteSource
39336>>>>>>>>>>>                    Send Delete_Index iIndexNumber
39337>>>>>>>>>>>                    Send UnsuspendWriteSource
39338>>>>>>>>>>>                End
39338>>>>>>>>>>>>
39338>>>>>>>>>>>            Loop
39339>>>>>>>>>>>>
39339>>>>>>>>>>>        Send OnOperationEnd
39340>>>>>>>>>>>    End_Procedure
39341>>>>>>>>>>>
39341>>>>>>>>>>>    Procedure Delete_Index Integer iIndexNumber
39343>>>>>>>>>>>        Integer hTable
39343>>>>>>>>>>>        Get _phTable to hTable
39344>>>>>>>>>>>        Send WriteSource ('Send Delete_Index '+String(iIndexNumber))
39345>>>>>>>>>>>        Send OnOperationBegin ("Delete_Index index: "+String(iIndexNumber))
39346>>>>>>>>>>>            Delete_Index hTable iIndexNumber
39347>>>>>>>>>>>        Send OnOperationEnd
39348>>>>>>>>>>>    End_Procedure
39349>>>>>>>>>>>
39349>>>>>>>>>>>    Procedure Set Table_Attribute Integer iAttribute String sValue
39351>>>>>>>>>>>        Boolean bQuotes
39351>>>>>>>>>>>        Integer hTable iAttrType
39351>>>>>>>>>>>        Get _phTable to hTable
39352>>>>>>>>>>>        Get AttributeType of oAttributeFunctions iAttribute to iAttrType
39353>>>>>>>>>>>        If (iAttrType=ATYPE_FILE) Begin
39355>>>>>>>>>>>            Move (gaAttributes[iAttribute].iValueType=DF_ASCII) to bQuotes
39356>>>>>>>>>>>            Send WriteSource ("Set Table_Attribute "+gaAttributes[iAttribute].sName+" to "+If(bQuotes,'"','')+AttributeSymbolicValue(oAttributeFunctions,iAttribute,sValue)+If(bQuotes,'"',''))
39357>>>>>>>>>>>            Send OnOperationBegin ("Set_Attribute "+gaAttributes[iAttribute].sName+" to "+AttributeSymbolicValue(oAttributeFunctions,iAttribute,sValue))
39358>>>>>>>>>>>            Set_Attribute iAttribute of hTable to sValue
39361>>>>>>>>>>>            Send OnOperationEnd
39362>>>>>>>>>>>        End
39362>>>>>>>>>>>>
39362>>>>>>>>>>>        Else Begin
39363>>>>>>>>>>>            Error 814 "Attribute must be of type table"
39364>>>>>>>>>>>>
39364>>>>>>>>>>>        End
39364>>>>>>>>>>>>
39364>>>>>>>>>>>    End_Procedure
39365>>>>>>>>>>>
39365>>>>>>>>>>>    Function Table_Attribute Integer iAttribute Returns String
39367>>>>>>>>>>>        Integer hTable iAttrType
39367>>>>>>>>>>>        String sValue
39367>>>>>>>>>>>        Get _phTable to hTable
39368>>>>>>>>>>>        Get AttributeType of oAttributeFunctions iAttribute to iAttrType
39369>>>>>>>>>>>        If (iAttrType=ATYPE_FILELIST or iAttrType=ATYPE_FILE) Begin // You may get filelist attributes (but you can't set them)
39371>>>>>>>>>>>            Send WriteSource ("Get Table_Attribute "+gaAttributes[iAttribute].sName+" to sValue")
39372>>>>>>>>>>>            Send OnOperationBegin ("Get_Attribute "+gaAttributes[iAttribute].sName)
39373>>>>>>>>>>>            Get_Attribute iAttribute of hTable to sValue
39376>>>>>>>>>>>            Send OnOperationEnd
39377>>>>>>>>>>>        End
39377>>>>>>>>>>>>
39377>>>>>>>>>>>        Else Begin
39378>>>>>>>>>>>            Error 815 "Attribute must be of type table"
39379>>>>>>>>>>>>
39379>>>>>>>>>>>        End
39379>>>>>>>>>>>>
39379>>>>>>>>>>>        Function_Return sValue
39380>>>>>>>>>>>    End_Function
39381>>>>>>>>>>>
39381>>>>>>>>>>>    Procedure Set Field_Attribute Integer iAttribute Integer iField String sValue
39383>>>>>>>>>>>        Integer hTable iAttrType
39383>>>>>>>>>>>        Get _phTable to hTable
39384>>>>>>>>>>>        Get AttributeType of oAttributeFunctions iAttribute to iAttrType
39385>>>>>>>>>>>        If (iAttrType=ATYPE_FIELD) Begin
39387>>>>>>>>>>>            Send WriteSource ("Set Field_Attribute "+gaAttributes[iAttribute].sName+" "+String(iField)+" to "+AttributeSymbolicValue(oAttributeFunctions,iAttribute,sValue))
39388>>>>>>>>>>>            Send OnOperationBegin ("Set_Attribute "+gaAttributes[iAttribute].sName+" field: "+String(iField)+" to "+AttributeSymbolicValue(oAttributeFunctions,iAttribute,sValue))
39389>>>>>>>>>>>            Set_Attribute iAttribute of hTable iField to sValue
39392>>>>>>>>>>>            Send OnOperationEnd
39393>>>>>>>>>>>        End
39393>>>>>>>>>>>>
39393>>>>>>>>>>>        Else Begin
39394>>>>>>>>>>>            Error 816 "Attribute must be of type field"
39395>>>>>>>>>>>>
39395>>>>>>>>>>>        End
39395>>>>>>>>>>>>
39395>>>>>>>>>>>    End_Procedure
39396>>>>>>>>>>>
39396>>>>>>>>>>>    Function Field_Attribute Integer iAttribute Integer iField Returns String
39398>>>>>>>>>>>        Integer hTable iAttrType
39398>>>>>>>>>>>        String sValue
39398>>>>>>>>>>>        Get _phTable to hTable
39399>>>>>>>>>>>        Get AttributeType of oAttributeFunctions iAttribute to iAttrType
39400>>>>>>>>>>>        If (iAttrType=ATYPE_FIELD) Begin
39402>>>>>>>>>>>            Send WriteSource ("Get Field_Attribute "+gaAttributes[iAttribute].sName+" "+String(iField)+" to sValue")
39403>>>>>>>>>>>            Send OnOperationBegin ("Get_Attribute "+gaAttributes[iAttribute].sName+" field: "+String(iField))
39404>>>>>>>>>>>            Get_Attribute iAttribute of hTable iField to sValue
39407>>>>>>>>>>>            Send OnOperationEnd
39408>>>>>>>>>>>        End
39408>>>>>>>>>>>>
39408>>>>>>>>>>>        Else Begin
39409>>>>>>>>>>>            Error 815 "Attribute must be of type field"
39410>>>>>>>>>>>>
39410>>>>>>>>>>>        End
39410>>>>>>>>>>>>
39410>>>>>>>>>>>        Function_Return sValue
39411>>>>>>>>>>>    End_Function
39412>>>>>>>>>>>
39412>>>>>>>>>>>    Procedure Set Index_Attribute Integer iAttribute Integer iIndex String sValue
39414>>>>>>>>>>>        Integer hTable iAttrType
39414>>>>>>>>>>>        Get _phTable to hTable
39415>>>>>>>>>>>        Get AttributeType of oAttributeFunctions iAttribute to iAttrType
39416>>>>>>>>>>>        If (iAttrType=ATYPE_INDEX) Begin
39418>>>>>>>>>>>            Send WriteSource ("Set Index_Attribute "+gaAttributes[iAttribute].sName+" "+String(iIndex)+" to "+AttributeSymbolicValue(oAttributeFunctions,iAttribute,sValue))
39419>>>>>>>>>>>            Send OnOperationBegin ("Set_Attribute "+gaAttributes[iAttribute].sName+" index: "+String(iIndex)+" to "+AttributeSymbolicValue(oAttributeFunctions,iAttribute,sValue))
39420>>>>>>>>>>>            Set_Attribute iAttribute of hTable iIndex to sValue
39423>>>>>>>>>>>            Send OnOperationEnd
39424>>>>>>>>>>>        End
39424>>>>>>>>>>>>
39424>>>>>>>>>>>        Else Begin
39425>>>>>>>>>>>            Error 817 "Attribute must be of type index"
39426>>>>>>>>>>>>
39426>>>>>>>>>>>        End
39426>>>>>>>>>>>>
39426>>>>>>>>>>>    End_Procedure
39427>>>>>>>>>>>
39427>>>>>>>>>>>    Function Index_Attribute Integer iAttribute Integer iIndex Returns String
39429>>>>>>>>>>>        Integer hTable iAttrType
39429>>>>>>>>>>>        String sValue
39429>>>>>>>>>>>        Get _phTable to hTable
39430>>>>>>>>>>>        Get AttributeType of oAttributeFunctions iAttribute to iAttrType
39431>>>>>>>>>>>        If (iAttrType=ATYPE_INDEX) Begin
39433>>>>>>>>>>>            Send WriteSource ("Get Index_Attribute "+gaAttributes[iAttribute].sName+" "+String(iIndex)+" to sValue")
39434>>>>>>>>>>>            Send OnOperationBegin ("Get_Attribute "+gaAttributes[iAttribute].sName+" index: "+String(iIndex))
39435>>>>>>>>>>>            Get_Attribute iAttribute of hTable iIndex to sValue
39438>>>>>>>>>>>            Send OnOperationEnd
39439>>>>>>>>>>>        End
39439>>>>>>>>>>>>
39439>>>>>>>>>>>        Else Begin
39440>>>>>>>>>>>            Error 818 "Attribute must be of type index"
39441>>>>>>>>>>>>
39441>>>>>>>>>>>        End
39441>>>>>>>>>>>>
39441>>>>>>>>>>>        Function_Return sValue
39442>>>>>>>>>>>    End_Function
39443>>>>>>>>>>>
39443>>>>>>>>>>>    Procedure Set Index_Segment_Attribute Integer iAttribute Integer iIndex Integer iSegment String sValue
39445>>>>>>>>>>>        Integer hTable iAttrType
39445>>>>>>>>>>>        Get _phTable to hTable
39446>>>>>>>>>>>        Get AttributeType of oAttributeFunctions iAttribute to iAttrType
39447>>>>>>>>>>>        If (iAttrType=ATYPE_IDXSEG) Begin
39449>>>>>>>>>>>            Send WriteSource ("Set Index_Segment_Attribute "+gaAttributes[iAttribute].sName+" "+String(iIndex)+" "+String(iSegment)+" to "+AttributeSymbolicValue(oAttributeFunctions,iAttribute,sValue))
39450>>>>>>>>>>>            Send OnOperationBegin ("Set_Attribute "+gaAttributes[iAttribute].sName+" index: "+String(iIndex)+" segment: "+String(iSegment)+" to "+AttributeSymbolicValue(oAttributeFunctions,iAttribute,sValue))
39451>>>>>>>>>>>            Set_Attribute iAttribute of hTable iIndex iSegment to sValue
39454>>>>>>>>>>>            Send OnOperationEnd
39455>>>>>>>>>>>        End
39455>>>>>>>>>>>>
39455>>>>>>>>>>>        Else Begin
39456>>>>>>>>>>>            Error 819 "Attribute must be of type index-segment"
39457>>>>>>>>>>>>
39457>>>>>>>>>>>        End
39457>>>>>>>>>>>>
39457>>>>>>>>>>>    End_Procedure
39458>>>>>>>>>>>
39458>>>>>>>>>>>    Function Index_Segment_Attribute Integer iAttribute Integer iIndex Integer iSegment Returns String
39460>>>>>>>>>>>        Integer hTable iAttrType
39460>>>>>>>>>>>        String sValue
39460>>>>>>>>>>>        Get _phTable to hTable
39461>>>>>>>>>>>        Get AttributeType of oAttributeFunctions iAttribute to iAttrType
39462>>>>>>>>>>>        If (iAttrType=ATYPE_IDXSEG) Begin
39464>>>>>>>>>>>            Send WriteSource ("Get Index_Segment_Attribute "+gaAttributes[iAttribute].sName+" "+String(iIndex)+" "+String(iSegment)+" to sValue")
39465>>>>>>>>>>>            Send OnOperationBegin ("Get_Attribute "+gaAttributes[iAttribute].sName+" index: "+String(iIndex)+" segment: "+String(iSegment))
39466>>>>>>>>>>>            Get_Attribute iAttribute of hTable iIndex iSegment to sValue
39469>>>>>>>>>>>            Send OnOperationEnd
39470>>>>>>>>>>>        End
39470>>>>>>>>>>>>
39470>>>>>>>>>>>        Else Begin
39471>>>>>>>>>>>            Error 820 "Attribute must be of type index-segment"
39472>>>>>>>>>>>>
39472>>>>>>>>>>>        End
39472>>>>>>>>>>>>
39472>>>>>>>>>>>        Function_Return sValue
39473>>>>>>>>>>>    End_Function
39474>>>>>>>>>>>
39474>>>>>>>>>>>    Function Field_Map String sFieldName Returns Integer
39476>>>>>>>>>>>        Integer hTable iPos
39476>>>>>>>>>>>        Get _phTable to hTable
39477>>>>>>>>>>>        Send Activate of oErrorSilence // We do not want an error message if the field name is not present
39478>>>>>>>>>>>        Field_Map hTable sFieldName to iPos
39480>>>>>>>>>>>        Send Deactivate of oErrorSilence
39481>>>>>>>>>>>        If (ErrorEventCount(oErrorSilence)<>0) Begin
39483>>>>>>>>>>>            Move -1 to iPos
39484>>>>>>>>>>>        End
39484>>>>>>>>>>>>
39484>>>>>>>>>>>        Function_Return iPos
39485>>>>>>>>>>>    End_Function
39486>>>>>>>>>>>
39486>>>>>>>>>>>    Function Append_Field_2 String sColumnName Integer iType Integer iLen Integer iPrecision Returns Integer
39488>>>>>>>>>>>        Integer iPosition
39488>>>>>>>>>>>
39488>>>>>>>>>>>        Send WriteSource ('Get Append_Field_2 "'+sColumnName+'" '+FieldTypeText(oTableAccessFunctions,iType,2)+' '+String(iLen)+' '+String(iPrecision)+' to iPosition')
39489>>>>>>>>>>>
39489>>>>>>>>>>>        Send SuspendWriteSource
39490>>>>>>>>>>>        Get Append_Field to iPosition
39491>>>>>>>>>>>        Set Field_Attribute DF_FIELD_NAME iPosition to sColumnName
39492>>>>>>>>>>>        Set Field_Attribute DF_FIELD_TYPE iPosition to iType
39493>>>>>>>>>>>        If (iType<>DF_DATE) Begin
39495>>>>>>>>>>>            If (iType=DF_BCD) Begin
39497>>>>>>>>>>>                Set Field_Attribute DF_FIELD_LENGTH iPosition to iLen
39498>>>>>>>>>>>            End
39498>>>>>>>>>>>>
39498>>>>>>>>>>>            Else Begin
39499>>>>>>>>>>>                Set Field_Attribute DF_FIELD_LENGTH iPosition to iLen
39500>>>>>>>>>>>            End
39500>>>>>>>>>>>>
39500>>>>>>>>>>>            If (iType=DF_BCD) Begin
39502>>>>>>>>>>>                Set Field_Attribute DF_FIELD_PRECISION iPosition to iPrecision
39503>>>>>>>>>>>            End
39503>>>>>>>>>>>>
39503>>>>>>>>>>>        End
39503>>>>>>>>>>>>
39503>>>>>>>>>>>        Send UnsuspendWriteSource
39504>>>>>>>>>>>        Function_Return iPosition
39505>>>>>>>>>>>    End_Function
39506>>>>>>>>>>>
39506>>>>>>>>>>>    Function Append_Field_3 String sColumnName Integer iType Integer iLen Integer iPrecision Integer iRelFile Integer iRelField Returns Integer
39508>>>>>>>>>>>        Integer iPosition
39508>>>>>>>>>>>
39508>>>>>>>>>>>        Send WriteSource ('Get Append_Field_3 "'+sColumnName+'" '+FieldTypeText(oTableAccessFunctions,iType,2)+' '+String(iLen)+' '+String(iPrecision)+' '+String(iRelFile)+' '+String(iRelField)+' to iPosition')
39509>>>>>>>>>>>
39509>>>>>>>>>>>        Send SuspendWriteSource
39510>>>>>>>>>>>        Get Append_Field to iPosition
39511>>>>>>>>>>>        Set Field_Attribute DF_FIELD_NAME iPosition to sColumnName
39512>>>>>>>>>>>        Set Field_Attribute DF_FIELD_TYPE iPosition to iType
39513>>>>>>>>>>>        If (iType<>DF_DATE) Begin
39515>>>>>>>>>>>            If (iType=DF_BCD) Begin
39517>>>>>>>>>>>                Set Field_Attribute DF_FIELD_LENGTH iPosition to iLen
39518>>>>>>>>>>>            End
39518>>>>>>>>>>>>
39518>>>>>>>>>>>            Else Begin
39519>>>>>>>>>>>                Set Field_Attribute DF_FIELD_LENGTH iPosition to iLen
39520>>>>>>>>>>>            End
39520>>>>>>>>>>>>
39520>>>>>>>>>>>            If (iType=DF_BCD) Begin
39522>>>>>>>>>>>                Set Field_Attribute DF_FIELD_PRECISION iPosition to iPrecision
39523>>>>>>>>>>>            End
39523>>>>>>>>>>>>
39523>>>>>>>>>>>        End
39523>>>>>>>>>>>>
39523>>>>>>>>>>>        If (iRelFile<>0) Begin
39525>>>>>>>>>>>            Set Field_Attribute DF_FIELD_RELATED_FILE iPosition to iRelFile
39526>>>>>>>>>>>            Set Field_Attribute DF_FIELD_RELATED_FIELD iPosition to iRelField
39527>>>>>>>>>>>        End
39527>>>>>>>>>>>>
39527>>>>>>>>>>>        Send UnsuspendWriteSource
39528>>>>>>>>>>>        Function_Return iPosition
39529>>>>>>>>>>>    End_Function
39530>>>>>>>>>>>    
39530>>>>>>>>>>>    Procedure _AppendTableFieldExplicit tTableFieldExplicit strField 
39532>>>>>>>>>>>        Integer iColumn
39532>>>>>>>>>>>        Get Append_Field_3 strField.sName strField.iType strField.iLen strField.iPrecision strField.iRelFile strField.iRelField to iColumn
39533>>>>>>>>>>>//        Set Field_Attribute DF_FIELD_RELATED_FILE iColumn to strField.iRelFile
39533>>>>>>>>>>>//        Set Field_Attribute DF_FIELD_RELATED_FIELD iColumn to strField.iRelField
39533>>>>>>>>>>>    End_Procedure
39534>>>>>>>>>>>
39534>>>>>>>>>>>//    Function Append_Field_2 String sColumnName Integer iType Integer iLen Integer iPrecision Returns Integer
39534>>>>>>>>>>>//    Function Append_Field_3 String sColumnName Integer iType Integer iLen Integer iPrecision Integer iRelFile Integer iRelField Returns Integer
39534>>>>>>>>>>>
39534>>>>>>>>>>>    Procedure _DefineIndexExplicit tTableIndexExplicit strIndex Integer iIndex
39536>>>>>>>>>>>        Integer iSegmentIndex iSegmentMax
39536>>>>>>>>>>>        Move (SizeOfArray(strIndex.aFields)-1) to iSegmentMax
39537>>>>>>>>>>>        If (SizeOfArray(strIndex.aFields)<>0) Begin
39539>>>>>>>>>>>            Send WriteSource ''
39540>>>>>>>>>>>            Send WriteSource ('// Index '+String(iIndex)+":")
39541>>>>>>>>>>>            Send Create_Index iIndex
39542>>>>>>>>>>>            Set Index_Attribute DF_INDEX_NUMBER_SEGMENTS iIndex to iSegmentMax
39543>>>>>>>>>>>            For iSegmentIndex from 1 to iSegmentMax
39549>>>>>>>>>>>>
39549>>>>>>>>>>>                Send WriteSource ''
39550>>>>>>>>>>>                Set Index_Segment_Attribute DF_INDEX_SEGMENT_FIELD iIndex iSegmentIndex to strIndex.aFields[iSegmentIndex]
39551>>>>>>>>>>>                Set Index_Segment_Attribute DF_INDEX_SEGMENT_DIRECTION iIndex iSegmentIndex to (If(strIndex.aDescending[iSegmentIndex],DF_DESCENDING,DF_ASCENDING))
39552>>>>>>>>>>>                Set Index_Segment_Attribute DF_INDEX_SEGMENT_CASE iIndex iSegmentIndex to (If(strIndex.aCaseInsensitive[iSegmentIndex],DF_CASE_IGNORED,DF_CASE_USED))
39553>>>>>>>>>>>            Loop
39554>>>>>>>>>>>>
39554>>>>>>>>>>>            Set Index_Attribute DF_INDEX_TYPE iIndex to strIndex.iType
39555>>>>>>>>>>>        End
39555>>>>>>>>>>>>
39555>>>>>>>>>>>    End_Procedure
39556>>>>>>>>>>>
39556>>>>>>>>>>>        Function _FieldRangeNativeLengthSum Integer iFieldStart Integer iFieldEnd Returns Integer
39558>>>>>>>>>>>            Integer iField iLen iLenSum hTable iType
39558>>>>>>>>>>>            Move 0 to iLenSum
39559>>>>>>>>>>>            Get _phTable to hTable
39560>>>>>>>>>>>            For iField from iFieldStart to iFieldEnd
39566>>>>>>>>>>>>
39566>>>>>>>>>>>                Get_Attribute DF_FIELD_TYPE of hTable iField to iType
39569>>>>>>>>>>>                If (iType<>DF_OVERLAP) Begin
39571>>>>>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_LENGTH of hTable iField to iLen
39574>>>>>>>>>>>                    Move (iLenSum+iLen) to iLenSum
39575>>>>>>>>>>>                End
39575>>>>>>>>>>>>
39575>>>>>>>>>>>            Loop
39576>>>>>>>>>>>>
39576>>>>>>>>>>>            Function_Return iLenSum
39577>>>>>>>>>>>        End_Function
39578>>>>>>>>>>>    
39578>>>>>>>>>>>    Function CreateTableExplicit tTableExplicit strTable String sFolder Returns Boolean
39580>>>>>>>>>>>        Integer iColumnIndex iColumnMax
39580>>>>>>>>>>>        Integer iIndexIndex iIndexMax
39580>>>>>>>>>>>        Integer iOffSet iLength
39580>>>>>>>>>>>        Integer hTable
39580>>>>>>>>>>>        Boolean bSucces
39580>>>>>>>>>>>        String sTableName
39580>>>>>>>>>>>
39580>>>>>>>>>>>        // Prepare root- and physical table names
39580>>>>>>>>>>>        Move strTable.sRootName to sTableName
39581>>>>>>>>>>>        Get TableRootNameStripDriver of oAttributeFunctions sTableName to sTableName
39582>>>>>>>>>>>        Get PathToFileRootName of oFileFunctions sTableName to sTableName
39583>>>>>>>>>>>        Move sTableName to strTable.sRootName
39584>>>>>>>>>>>
39584>>>>>>>>>>>        // We must fork certain parameters to abide with the driver (most notably the embedded database, max records etc...)
39584>>>>>>>>>>>        Get TrimTableDefinitionToDriver of oTableExplicitFunctions (&strTable) to bSucces
39585>>>>>>>>>>>        If (bSucces) Begin
39587>>>>>>>>>>>            If (Structure_Start_New_Table(Self, strTable.sRootName, sFolder, strTable.sDriver)) Begin
39589>>>>>>>>>>>                Set Table_Attribute DF_FILE_MAX_RECORDS to strTable.nMaxRecords
39590>>>>>>>>>>>                Set Table_Attribute DF_FILE_INTEGRITY_CHECK to strTable.iIntegrityCheck
39591>>>>>>>>>>>                Set Table_Attribute DF_FILE_IS_SYSTEM_FILE to (If(strTable.bSystemFile,1,0))
39592>>>>>>>>>>>                Move (SizeOfArray(strTable.aFields)-1) to iColumnMax
39593>>>>>>>>>>>
39593>>>>>>>>>>>                // Create columns
39593>>>>>>>>>>>                For iColumnIndex from 1 to iColumnMax
39599>>>>>>>>>>>>
39599>>>>>>>>>>>                    Send _AppendTableFieldExplicit strTable.aFields[iColumnIndex]
39600>>>>>>>>>>>                Loop
39601>>>>>>>>>>>>
39601>>>>>>>>>>>                
39601>>>>>>>>>>>                // Create indices
39601>>>>>>>>>>>                Move (SizeOfArray(strTable.aIndices)-1) to iIndexMax
39602>>>>>>>>>>>                For iIndexIndex from 1 to iIndexMax
39608>>>>>>>>>>>>
39608>>>>>>>>>>>                    Send _DefineIndexExplicit strTable.aIndices[iIndexIndex] iIndexIndex
39609>>>>>>>>>>>                Loop
39610>>>>>>>>>>>>
39610>>>>>>>>>>>
39610>>>>>>>>>>>                // Update overlap boundaries
39610>>>>>>>>>>>                Get _phTable to hTable
39611>>>>>>>>>>>                For iColumnIndex from 1 to iColumnMax
39617>>>>>>>>>>>>
39617>>>>>>>>>>>                    If (strTable.aFields[iColumnIndex].iType=DF_OVERLAP) Begin
39619>>>>>>>>>>>                        Get_Attribute DF_FIELD_OFFSET of hTable strTable.aFields[iColumnIndex].iOverlapFieldStart to iOffSet
39622>>>>>>>>>>>                        Set Field_Attribute DF_FIELD_OFFSET iColumnIndex to iOffSet
39623>>>>>>>>>>>                        Get _FieldRangeNativeLengthSum strTable.aFields[iColumnIndex].iOverlapFieldStart strTable.aFields[iColumnIndex].iOverlapFieldEnd to iLength
39624>>>>>>>>>>>                        Set Field_Attribute DF_FIELD_LENGTH iColumnIndex to iLength
39625>>>>>>>>>>>                    End
39625>>>>>>>>>>>>
39625>>>>>>>>>>>                Loop
39626>>>>>>>>>>>>
39626>>>>>>>>>>>
39626>>>>>>>>>>>                // Set field main index:
39626>>>>>>>>>>>                For iColumnIndex from 1 to iColumnMax
39632>>>>>>>>>>>>
39632>>>>>>>>>>>                    If (strTable.aFields[iColumnIndex].iMainIndex<>0) Begin
39634>>>>>>>>>>>                        Set Field_Attribute DF_FIELD_INDEX iColumnIndex to strTable.aFields[iColumnIndex].iMainIndex
39635>>>>>>>>>>>                    End
39635>>>>>>>>>>>>
39635>>>>>>>>>>>                Loop
39636>>>>>>>>>>>>
39636>>>>>>>>>>>
39636>>>>>>>>>>>                Get Structure_End to bSucces
39637>>>>>>>>>>>                If (not(bSucces)) Begin
39639>>>>>>>>>>>//                    Error 492 "Structure_End unsuccessful!"
39639>>>>>>>>>>>//                    Send WriteSource '// There were errors during the creation of this table'
39639>>>>>>>>>>>                End
39639>>>>>>>>>>>>
39639>>>>>>>>>>>            End
39639>>>>>>>>>>>>
39639>>>>>>>>>>>            Else Begin
39640>>>>>>>>>>>                Move False to bSucces
39641>>>>>>>>>>>            End
39641>>>>>>>>>>>>
39641>>>>>>>>>>>        End
39641>>>>>>>>>>>>
39641>>>>>>>>>>>        Function_Return bSucces
39642>>>>>>>>>>>    End_Function
39643>>>>>>>>>>>End_Class // cTableStructureFunctions
39644>>>>>>>>>>>
39644>>>>>>>>>>>Object _oTableStructureFunctions is a cTableStructure
39646>>>>>>>>>>>    Move Self to oTableStructureFunctions
39647>>>>>>>>>>>End_Object
39648>>>>>>>>>>>
39648>>>>>>>>>>>
39648>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
39648>>>>>>>>>Use TableAccessFunctions.pkg
39648>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
39648>>>>>>>>>
39648>>>>>>>>>
39648>>>>>>>>>Struct tTempTableDefinitionField
39648>>>>>>>>>    String sName            // Field name
39648>>>>>>>>>    Integer iType           // DF_BCD, DF_ASCII, DF_DATE, DF_TEXT, DF_BINARY, DF_DATETIME
39648>>>>>>>>>    Integer iLen
39648>>>>>>>>>    Integer iPrecision
39648>>>>>>>>>End_Struct
39648>>>>>>>>>
39648>>>>>>>>>Struct tTempTableDefinitionIndex
39648>>>>>>>>>    String sName
39648>>>>>>>>>    Boolean bOnline
39648>>>>>>>>>    Integer[] aFields
39648>>>>>>>>>    Boolean[] aCaseInsensitive
39648>>>>>>>>>    Boolean[] aDescending
39648>>>>>>>>>End_Struct
39648>>>>>>>>>
39648>>>>>>>>>Struct tTempTableDefinition
39648>>>>>>>>>    String sFolder     // Absolute location of table files. If blank, the data folder will be used.
39648>>>>>>>>>    String sSubFolder  // 
39648>>>>>>>>>    String sFileName   // Disk file name of table
39648>>>>>>>>>//    String sTableLongName
39648>>>>>>>>>    Integer iMaxRecords
39648>>>>>>>>>    Boolean bCompression
39648>>>>>>>>>    Boolean bSingleUser
39648>>>>>>>>>//    Integer iDriverId // TA_DRIVER_DATAFLEX TA_DRIVER_PERVASIVE TA_DRIVER_ORACLE TA_DRIVER_MS_SQL TA_DRIVER_DB2 TA_DRIVER_ODBC TA_DRIVER_MS_SQL_DAW TA_DRIVER_MAX
39648>>>>>>>>>    tTempTableDefinitionField[] aFields
39648>>>>>>>>>    tTempTableDefinitionField[] aFields
39648>>>>>>>>>    tTempTableDefinitionIndex[] aIndices
39648>>>>>>>>>    tTempTableDefinitionIndex[] aIndices
39648>>>>>>>>>End_Struct
39648>>>>>>>>>
39648>>>>>>>>>Struct tTempTableIndexSeederSegment
39648>>>>>>>>>    Integer iColumn
39648>>>>>>>>>    String sValue
39648>>>>>>>>>End_Struct
39648>>>>>>>>>
39648>>>>>>>>>Struct tTempTableHandle
39648>>>>>>>>>    String sDiskFileName
39648>>>>>>>>>    Integer hTable
39648>>>>>>>>>    String[] aIndexNames
39648>>>>>>>>>End_Struct
39648>>>>>>>>>
39648>>>>>>>>>Global_Variable Integer oTemporaryTablesFunctions
39648>>>>>>>>>Global_Variable tTempTableIndexSeederSegment[][] _gaTableSeeds
39648>>>>>>>>>
39648>>>>>>>>>Object _oTemporaryTablesFunctions is a cObject
39650>>>>>>>>>    Move Self to oTemporaryTablesFunctions
39651>>>>>>>>>
39651>>>>>>>>>    //> Returns an empty TempTable definition with only a few very basic attributes set.
39651>>>>>>>>>    Function EmptyTempTableDefinition Returns tTempTableDefinition
39654>>>>>>>>>        tTempTableDefinition strRval
39654>>>>>>>>>        tTempTableDefinition strRval
39654>>>>>>>>>        Move 10000 to strRval.iMaxRecords
39655>>>>>>>>>        Move False to strRval.bCompression
39656>>>>>>>>>        Move False to strRval.bSingleUser
39657>>>>>>>>>        Function_Return strRval
39658>>>>>>>>>    End_Function
39659>>>>>>>>>    
39659>>>>>>>>>    Procedure AddColumn tTempTableDefinition ByRef strTempTable String sName Integer iType Integer iLen Integer iPrecision
39662>>>>>>>>>        Integer iFieldIndex
39662>>>>>>>>>        Move (SizeOfArray(strTempTable.aFields)) to iFieldIndex
39663>>>>>>>>>        Move sName to strTempTable.aFields[iFieldIndex].sName
39664>>>>>>>>>        Move iType to strTempTable.aFields[iFieldIndex].iType
39665>>>>>>>>>        Move iLen to strTempTable.aFields[iFieldIndex].iLen
39666>>>>>>>>>        Move iPrecision to strTempTable.aFields[iFieldIndex].iPrecision
39667>>>>>>>>>    End_Procedure
39668>>>>>>>>>    
39668>>>>>>>>>    Procedure AddIndex tTempTableDefinition ByRef strTempTable Boolean bOnline
39671>>>>>>>>>        Integer iIndex
39671>>>>>>>>>        Move (SizeOfArray(strTempTable.aIndices)) to iIndex
39672>>>>>>>>>        If (iIndex=0) Begin
39674>>>>>>>>>            Move 1 to iIndex // First index is index 1. Not index 0.
39675>>>>>>>>>        End
39675>>>>>>>>>>
39675>>>>>>>>>        Move bOnline to strTempTable.aIndices[iIndex].bOnline
39676>>>>>>>>>    End_Procedure
39677>>>>>>>>>    
39677>>>>>>>>>    Procedure Set IndexName tTempTableDefinition ByRef strTempTable String sName
39680>>>>>>>>>        Integer iIndex
39680>>>>>>>>>        Move (SizeOfArray(strTempTable.aIndices)-1) to iIndex
39681>>>>>>>>>        Move sName to strTempTable.aIndices[iIndex].sName
39682>>>>>>>>>    End_Procedure
39683>>>>>>>>>
39683>>>>>>>>>                Function _FindColumnName tTempTableDefinition strTempTable String sName Returns Integer
39686>>>>>>>>>                    Integer iFieldIndex iFieldMax
39686>>>>>>>>>                    Move (Uppercase(sName)) to sName
39687>>>>>>>>>                    If (sName="RECNUM") Function_Return 0
39690>>>>>>>>>                    Move (SizeOfArray(strTempTable.aFields)-1) to iFieldMax
39691>>>>>>>>>                    For iFieldIndex from 0 to iFieldMax
39697>>>>>>>>>>
39697>>>>>>>>>                        If (sName=Uppercase(strTempTable.aFields[iFieldIndex].sName)) Begin
39699>>>>>>>>>                            Function_Return (iFieldIndex+1)
39700>>>>>>>>>                        End
39700>>>>>>>>>>
39700>>>>>>>>>                    Loop
39701>>>>>>>>>>
39701>>>>>>>>>                    Function_Return -1 // Not found
39702>>>>>>>>>                End_Function
39703>>>>>>>>>
39703>>>>>>>>>    Procedure AddIndexSegment tTempTableDefinition ByRef strTempTable String sColumnName Boolean bCaseInSensitive Boolean bDescending
39706>>>>>>>>>        Integer iSegmentIndex iIndex iField
39706>>>>>>>>>        
39706>>>>>>>>>        Get _FindColumnName strTempTable sColumnName to iField
39707>>>>>>>>>        
39707>>>>>>>>>        If (iField>=0) Begin
39709>>>>>>>>>            Move (SizeOfArray(strTempTable.aIndices)-1) to iIndex
39710>>>>>>>>>            Move (SizeOfArray(strTempTable.aIndices[iIndex].aFields)) to iSegmentIndex
39711>>>>>>>>>            Move iField to strTempTable.aIndices[iIndex].aFields[iSegmentIndex]
39712>>>>>>>>>            Move bCaseInSensitive to strTempTable.aIndices[iIndex].aCaseInsensitive[iSegmentIndex]
39713>>>>>>>>>            Move bDescending to strTempTable.aIndices[iIndex].aDescending[iSegmentIndex]
39714>>>>>>>>>        End
39714>>>>>>>>>>
39714>>>>>>>>>        Else Begin
39715>>>>>>>>>            Error 826 "Field not found"
39716>>>>>>>>>>
39716>>>>>>>>>        End
39716>>>>>>>>>>
39716>>>>>>>>>    End_Procedure
39717>>>>>>>>>
39717>>>>>>>>>    Function DropTable tTempTableDefinition strTempTable Boolean bOverWrite Returns Boolean
39720>>>>>>>>>        Integer iRval
39720>>>>>>>>>        String sFolder sTableRoot
39720>>>>>>>>>
39720>>>>>>>>>        Get TablePath strTempTable to sTableRoot
39721>>>>>>>>>
39721>>>>>>>>>        Get DeleteFileNew of oFileFunctions (sTableRoot+".dat") False to iRval
39722>>>>>>>>>        If (iRval=0) Begin
39724>>>>>>>>>            Get DeleteFileNew of oFileFunctions (sTableRoot+".k?") False to iRval
39725>>>>>>>>>        End
39725>>>>>>>>>>
39725>>>>>>>>>        If (iRval=0) Begin
39727>>>>>>>>>            Get DeleteFileNew of oFileFunctions (sTableRoot+".hdr") False to iRval
39728>>>>>>>>>        End
39728>>>>>>>>>>
39728>>>>>>>>>        If (iRval=0) Begin
39730>>>>>>>>>            Get DeleteFileNew of oFileFunctions (sTableRoot+".tag") False to iRval
39731>>>>>>>>>        End
39731>>>>>>>>>>
39731>>>>>>>>>        If (iRval=0) Begin
39733>>>>>>>>>            Get DeleteFileNew of oFileFunctions (sTableRoot+".vld") False to iRval
39734>>>>>>>>>        End
39734>>>>>>>>>>
39734>>>>>>>>>        If (iRval=0) Begin
39736>>>>>>>>>            Get DeleteFileNew of oFileFunctions (sTableRoot+".dat") False to iRval
39737>>>>>>>>>        End
39737>>>>>>>>>>
39737>>>>>>>>>        Function_Return (iRval=0)
39738>>>>>>>>>    End_Function
39739>>>>>>>>>    
39739>>>>>>>>>    //> Create table
39739>>>>>>>>>    Function CreateTable tTempTableDefinition strTempTable Boolean bOverWrite Returns Boolean
39742>>>>>>>>>        Integer iFieldIndex iFieldMax iGrb
39742>>>>>>>>>        Integer iIndexIndex iIndexMax iIndex
39742>>>>>>>>>        Integer iSegmentIndex iSegmentMax iSegment
39742>>>>>>>>>        Boolean bSuccess bOnline
39742>>>>>>>>>        String sFolder
39742>>>>>>>>>        tTempTableDefinitionField strField
39742>>>>>>>>>        tTempTableDefinitionField strField
39742>>>>>>>>>        tTempTableDefinitionIndex strIndex
39742>>>>>>>>>        tTempTableDefinitionIndex strIndex
39742>>>>>>>>>
39742>>>>>>>>>        // Calculate the desired folder:
39742>>>>>>>>>        If (strTempTable.sFolder="") begin
39744>>>>>>>>>            Get VdfFolderPath of oFileFunctions VDF_FILELIST to sFolder
39745>>>>>>>>>        End
39745>>>>>>>>>>
39745>>>>>>>>>        Else Begin
39746>>>>>>>>>            Move strTempTable.sFolder to sFolder
39747>>>>>>>>>        End
39747>>>>>>>>>>
39747>>>>>>>>>
39747>>>>>>>>>        If (strTempTable.sSubFolder<>"") Begin
39749>>>>>>>>>            Get CreateFolderMultiLevel of oFileFunctions sFolder strTempTable.sSubFolder to bSuccess
39750>>>>>>>>>            Get AppendPath of oFileFunctions sFolder strTempTable.sSubFolder to sFolder
39751>>>>>>>>>        End
39751>>>>>>>>>>
39751>>>>>>>>>        Else Begin
39752>>>>>>>>>            Move True to bSuccess
39753>>>>>>>>>            Move strTempTable.sFolder to sFolder
39754>>>>>>>>>        End
39754>>>>>>>>>>
39754>>>>>>>>>
39754>>>>>>>>>        If (bSuccess) Begin
39756>>>>>>>>>            Get Structure_Start_New_Table of oTableStructureFunctions strTempTable.sFileName sFolder "DATAFLEX" to bSuccess
39757>>>>>>>>>            If bSuccess Begin
39759>>>>>>>>>
39759>>>>>>>>>                Set Table_Attribute of oTableStructureFunctions DF_FILE_MAX_RECORDS to strTempTable.iMaxRecords
39760>>>>>>>>>
39760>>>>>>>>>                If (strTempTable.bSingleUser) Begin
39762>>>>>>>>>                    Set Table_Attribute of oTableStructureFunctions DF_FILE_MULTIUSER to DF_FILE_USER_SINGLE
39763>>>>>>>>>                End
39763>>>>>>>>>>
39763>>>>>>>>>                If (strTempTable.bCompression) Begin
39765>>>>>>>>>                    Set Table_Attribute of oTableStructureFunctions DF_FILE_COMPRESSION to DF_FILE_COMPRESS_FAST
39766>>>>>>>>>                End
39766>>>>>>>>>>
39766>>>>>>>>>
39766>>>>>>>>>                // Create fields:
39766>>>>>>>>>                Move (SizeOfArray(strTempTable.aFields)-1) to iFieldMax
39767>>>>>>>>>                For iFieldIndex from 0 to iFieldMax
39773>>>>>>>>>>
39773>>>>>>>>>                    Move strTempTable.aFields[iFieldIndex] to strField
39774>>>>>>>>>                    Get Append_Field_2 of oTableStructureFunctions strField.sName strField.iType strField.iLen strField.iPrecision to iGrb
39775>>>>>>>>>                Loop
39776>>>>>>>>>>
39776>>>>>>>>>
39776>>>>>>>>>                // Create indices:
39776>>>>>>>>>                Move (SizeOfArray(strTempTable.aIndices)-1) to iIndexMax
39777>>>>>>>>>                For iIndexIndex from 1 to iIndexMax
39783>>>>>>>>>>
39783>>>>>>>>>                    Move strTempTable.aIndices[iIndexIndex] to strIndex
39784>>>>>>>>>                    Move (SizeOfArray(strIndex.aFields)-1) to iSegmentMax
39785>>>>>>>>>
39785>>>>>>>>>                    If (iSegmentMax>=0) Begin
39787>>>>>>>>>                        Move iIndexIndex to iIndex
39788>>>>>>>>>                        Send Create_Index of oTableStructureFunctions iIndex
39789>>>>>>>>>                        Move strTempTable.aIndices[iIndexIndex].bOnline to bOnline
39790>>>>>>>>>                        Set Index_Attribute of oTableStructureFunctions DF_INDEX_TYPE iIndex to (If(bOnline,DF_INDEX_TYPE_ONLINE,DF_INDEX_TYPE_BATCH))
39791>>>>>>>>>                        Set Index_Attribute of oTableStructureFunctions DF_INDEX_NUMBER_SEGMENTS iIndex to (iSegmentMax+1)
39792>>>>>>>>>                        For iSegmentIndex from 0 to iSegmentMax
39798>>>>>>>>>>
39798>>>>>>>>>                            Move (iSegmentIndex+1) to iSegment
39799>>>>>>>>>                            Set Index_Segment_Attribute of oTableStructureFunctions DF_INDEX_SEGMENT_FIELD iIndex iSegment to strIndex.aFields[iSegmentIndex]
39800>>>>>>>>>                            Set Index_Segment_Attribute of oTableStructureFunctions DF_INDEX_SEGMENT_CASE iIndex iSegment to (If(strIndex.aCaseInsensitive[iSegmentIndex],DF_CASE_IGNORED,DF_CASE_USED))
39801>>>>>>>>>                            Set Index_Segment_Attribute of oTableStructureFunctions DF_INDEX_SEGMENT_DIRECTION iIndex iSegment to (If(strIndex.aDescending[iSegmentIndex],DF_DESCENDING,DF_ASCENDING))
39802>>>>>>>>>                        Loop
39803>>>>>>>>>>
39803>>>>>>>>>                    End
39803>>>>>>>>>>
39803>>>>>>>>>                Loop
39804>>>>>>>>>>
39804>>>>>>>>>                
39804>>>>>>>>>                // Round it up:
39804>>>>>>>>>                Get Structure_End of oTableStructureFunctions DF_STRUCTEND_OPT_NONE to bSuccess
39805>>>>>>>>>            End
39805>>>>>>>>>>
39805>>>>>>>>>        End
39805>>>>>>>>>>
39805>>>>>>>>>        Function_Return bSuccess
39806>>>>>>>>>    End_Function
39807>>>>>>>>>    
39807>>>>>>>>>    //> Returns path that may be used to open table (... as)
39807>>>>>>>>>    Function TablePath tTempTableDefinition strTempTable Returns String
39810>>>>>>>>>        String sFolder sTablePath
39810>>>>>>>>>        // Calculate the desired folder:
39810>>>>>>>>>        If (strTempTable.sFolder="") Begin
39812>>>>>>>>>            Get VdfFolderPath of oFileFunctions VDF_FILELIST to sFolder
39813>>>>>>>>>        End
39813>>>>>>>>>>
39813>>>>>>>>>        Else Begin
39814>>>>>>>>>            Move strTempTable.sFolder to sFolder
39815>>>>>>>>>        End
39815>>>>>>>>>>
39815>>>>>>>>>        
39815>>>>>>>>>        If (strTempTable.sSubFolder<>"") Begin
39817>>>>>>>>>            Get AppendPath of oFileFunctions sFolder strTempTable.sSubFolder to sFolder
39818>>>>>>>>>        End
39818>>>>>>>>>>
39818>>>>>>>>>        
39818>>>>>>>>>        Get AppendPath of oFileFunctions sFolder strTempTable.sFileName to sTablePath
39819>>>>>>>>>        Get PathStripType of oFileFunctions sTablePath to sTablePath
39820>>>>>>>>>        Function_Return sTablePath
39821>>>>>>>>>    End_Function
39822>>>>>>>>>    
39822>>>>>>>>>    Function OpenTable tTempTableDefinition strTempTable Boolean bExclusive Returns Integer 
39825>>>>>>>>>        Integer iTable iCode
39825>>>>>>>>>
39825>>>>>>>>>        Get TableExists strTempTable to iCode
39826>>>>>>>>>        
39826>>>>>>>>>        If (iCode=0) Begin // Does not exist
39828>>>>>>>>>            Get CreateTableAndOpen strTempTable True bExclusive to iTable
39829>>>>>>>>>        End
39829>>>>>>>>>>
39829>>>>>>>>>        If (iCode=1) Begin // Exists but does not match
39831>>>>>>>>>            Get OpenTableAsAutoHandle of oTableAccessFunctions (TablePath(Self,strTempTable)) (If(bExclusive,DF_EXCLUSIVE,DF_SHARE)) 0 to iTable
39832>>>>>>>>>        End
39832>>>>>>>>>>
39832>>>>>>>>>        If (iCode=2) Begin // Exists and matches the definition
39834>>>>>>>>>            Get OpenTableAsAutoHandle of oTableAccessFunctions (TablePath(Self,strTempTable)) (If(bExclusive,DF_EXCLUSIVE,DF_SHARE)) 0 to iTable
39835>>>>>>>>>        End
39835>>>>>>>>>>
39835>>>>>>>>>        Function_Return iTable
39836>>>>>>>>>    End_Function
39837>>>>>>>>>    
39837>>>>>>>>>    Function CreateTableAndOpen tTempTableDefinition strTempTable Boolean bOverWrite Boolean bExclusive Returns Integer
39840>>>>>>>>>        Integer iTable
39840>>>>>>>>>        Boolean bSuccess
39840>>>>>>>>>        Get CreateTable strTempTable bOverWrite to bSuccess
39841>>>>>>>>>        Move 0 to iTable
39842>>>>>>>>>        If (bSuccess) Begin
39844>>>>>>>>>            Get OpenTableAsAutoHandle of oTableAccessFunctions (TablePath(Self,strTempTable)) (If(bExclusive,DF_EXCLUSIVE,DF_SHARE)) 0 to iTable
39845>>>>>>>>>        End
39845>>>>>>>>>>
39845>>>>>>>>>        Function_Return iTable
39846>>>>>>>>>    End_Function
39847>>>>>>>>>    
39847>>>>>>>>>                Function _CompareTableToDefinitionColumns tTempTableDefinition strTempTable Integer iTable Returns Integer
39850>>>>>>>>>                    Integer iLen iPrec iType
39850>>>>>>>>>                    Integer iColumn iColumns
39850>>>>>>>>>                    Integer iColumnNumber
39850>>>>>>>>>                    Move (SizeOfArray(strTempTable.aFields)-1) to iColumns
39851>>>>>>>>>                    For iColumn from 0 to iColumns
39857>>>>>>>>>>
39857>>>>>>>>>                        Move strTempTable.aFields[iColumn].iPrecision to iPrec
39858>>>>>>>>>                        Get FieldNameToNumber of oTableAccessFunctions iTable strTempTable.aFields[iColumn].sName to iColumnNumber
39859>>>>>>>>>                        If (iColumnNumber=-1) Function_Return 1 // Missing column
39862>>>>>>>>>                        Get_Attribute DF_FIELD_TYPE of iTable iColumnNumber to iType
39865>>>>>>>>>                        If (iType<>strTempTable.aFields[iColumn].iType) Function_Return 2 // Column type mismatch
39868>>>>>>>>>                        Get_Attribute DF_FIELD_LENGTH of iTable iColumnNumber to iLen
39871>>>>>>>>>                        If (iLen<strTempTable.aFields[iColumn].iLen) Function_Return 3 // Column length mismatch
39874>>>>>>>>>                        Get_Attribute DF_FIELD_PRECISION of iTable iColumnNumber to iPrec
39877>>>>>>>>>                        If (iPrec<strTempTable.aFields[iColumn].iPrecision) Function_Return 4 // Column precision mismatch
39880>>>>>>>>>                    Loop
39881>>>>>>>>>>
39881>>>>>>>>>                    Function_Return 0 // Columns are defined
39882>>>>>>>>>                End_Function
39883>>>>>>>>>                    
39883>>>>>>>>>                Function _CompareTableToDefinitionIndices tTempTableDefinition strTempTable Integer iTable Returns Integer
39886>>>>>>>>>                    Integer iIndex iIndices
39886>>>>>>>>>                    Move (SizeOfArray(strTempTable.aIndices)-1) to iIndices
39887>>>>>>>>>                    For iIndex from 0 to iIndices
39893>>>>>>>>>>
39893>>>>>>>>>                        // Unfinished!
39893>>>>>>>>>                    Loop
39894>>>>>>>>>>
39894>>>>>>>>>                    Function_Return 0 // Indices are defined
39895>>>>>>>>>                End_Function
39896>>>>>>>>>                
39896>>>>>>>>>        Function _CompareTableToDefinition tTempTableDefinition strTempTable Integer iTable Returns Integer
39899>>>>>>>>>            Integer iError
39899>>>>>>>>>            Get _CompareTableToDefinitionColumns strTempTable iTable to iError
39900>>>>>>>>>            If (iError=0) Begin
39902>>>>>>>>>                Get _CompareTableToDefinitionIndices strTempTable iTable to iError
39903>>>>>>>>>            End
39903>>>>>>>>>>
39903>>>>>>>>>            Function_Return iError
39904>>>>>>>>>        End_Function
39905>>>>>>>>>
39905>>>>>>>>>    //> Returns  2: Exists and matches the definition.  1: Exists but does not match  0: Does not exist
39905>>>>>>>>>    Function TableExists tTempTableDefinition strTempTable Returns Integer
39908>>>>>>>>>        Integer iTable iError iRval
39908>>>>>>>>>        Get OpenTableAsAutoHandle of oTableAccessFunctions (TablePath(Self,strTempTable)) DF_SHARE 0 to iTable
39909>>>>>>>>>        If (iTable>0) Begin
39911>>>>>>>>>            Get _CompareTableToDefinition strTempTable iTable to iError
39912>>>>>>>>>            If (iError=0) Begin
39914>>>>>>>>>                Move 2 to iRval // Table exists and matches definition
39915>>>>>>>>>            End
39915>>>>>>>>>>
39915>>>>>>>>>            Else Begin
39916>>>>>>>>>                Move 1 to iRval // Table exists but does not match definition
39917>>>>>>>>>            End
39917>>>>>>>>>>
39917>>>>>>>>>            Close iTable
39918>>>>>>>>>        End
39918>>>>>>>>>>
39918>>>>>>>>>        Else Begin
39919>>>>>>>>>            Move 0 to iRval // Table does not exist
39920>>>>>>>>>        End
39920>>>>>>>>>>
39920>>>>>>>>>        Function_Return iRval
39921>>>>>>>>>    End_Function
39922>>>>>>>>>    
39922>>>>>>>>>    // This function creates a tTempTableDefinition value that resembles the one handed over in the
39922>>>>>>>>>    // strTableAttributes parameter. We say 'resembles' because a number of details are lost in the
39922>>>>>>>>>    // transformation (such as specific numbering of indices, overlaps makes no sense)
39922>>>>>>>>>    Function AttributesToTempTableDefinition tTableAttributes strTableAttributes Returns tTempTableDefinition
39925>>>>>>>>>        Integer iTable iRecords
39925>>>>>>>>>        Integer iColumn iColumns
39925>>>>>>>>>        Integer iIndex iIndices
39925>>>>>>>>>        Integer iSegment iSegments
39925>>>>>>>>>        Integer iColumnType iColumnLength iColumnPrecision
39925>>>>>>>>>        Integer iIndexColumn 
39925>>>>>>>>>        Boolean bCaseSense bDescending
39925>>>>>>>>>        String sColumnName
39925>>>>>>>>>        tTableAttributes[] aTables
39925>>>>>>>>>        tTableAttributes[] aTables
39926>>>>>>>>>        tTempTableDefinition strTableDefinition
39926>>>>>>>>>        tTempTableDefinition strTableDefinition
39926>>>>>>>>>        
39926>>>>>>>>>        // This we (irritatingly) have to do to be able to use the TableAttribute function
39926>>>>>>>>>        // of oAttributeFunctions for querying the strTableAttributes parameter:
39926>>>>>>>>>        Move strTableAttributes.iReadFromFileListEntryNo to iTable
39927>>>>>>>>>        Move strTableAttributes to aTables[0]
39928>>>>>>>>>
39928>>>>>>>>>        Get EmptyTempTableDefinition to strTableDefinition
39929>>>>>>>>>        Get TableAttribute of oAttributeFunctions aTables DF_FILE_MAX_RECORDS iTable 0 0 to strTableDefinition.iMaxRecords
39930>>>>>>>>>        
39930>>>>>>>>>        // Add columns:
39930>>>>>>>>>        Get TableAttribute of oAttributeFunctions aTables DF_FILE_NUMBER_FIELDS iTable 0 0 to iColumns
39931>>>>>>>>>        For iColumn from 1 to iColumns
39937>>>>>>>>>>
39937>>>>>>>>>            Get TableAttribute of oAttributeFunctions aTables DF_FIELD_NAME iTable iColumn 0 0 to sColumnName
39938>>>>>>>>>            Get TableAttribute of oAttributeFunctions aTables DF_FIELD_TYPE iTable iColumn 0 0 to iColumnType     
39939>>>>>>>>>            Get TableAttribute of oAttributeFunctions aTables DF_FIELD_LENGTH iTable iColumn 0 0 to iColumnLength   
39940>>>>>>>>>            Get TableAttribute of oAttributeFunctions aTables DF_FIELD_PRECISION iTable iColumn 0 0 to iColumnPrecision
39941>>>>>>>>>            If (iColumnType<>DF_OVERLAP) Begin
39943>>>>>>>>>                Send AddColumn (&strTableDefinition) sColumnName iColumnType iColumnLength iColumnPrecision
39944>>>>>>>>>            End
39944>>>>>>>>>>
39944>>>>>>>>>        Loop
39945>>>>>>>>>>
39945>>>>>>>>>        
39945>>>>>>>>>        // Add indices:
39945>>>>>>>>>        Get TableAttribute of oAttributeFunctions aTables DF_FILE_LAST_INDEX_NUMBER iTable 0 0 to iIndices
39946>>>>>>>>>        For iIndex from 1 to iIndices
39952>>>>>>>>>>
39952>>>>>>>>>            Get TableAttribute of oAttributeFunctions aTables DF_INDEX_NUMBER_SEGMENTS iTable iIndex 0 to iSegments
39953>>>>>>>>>            If (iSegments<>0) Begin
39955>>>>>>>>>                Send AddIndex (&strTableDefinition) True
39956>>>>>>>>>                For iSegment from 1 to iSegments
39962>>>>>>>>>>
39962>>>>>>>>>                    Get TableAttribute of oAttributeFunctions aTables DF_INDEX_SEGMENT_FIELD iTable iIndex iSegment to iIndexColumn
39963>>>>>>>>>                    Get TableAttribute of oAttributeFunctions aTables DF_INDEX_SEGMENT_CASE iTable iIndex iSegment to bCaseSense
39964>>>>>>>>>                    Move (Integer(TableAttribute(oAttributeFunctions,aTables,DF_INDEX_SEGMENT_CASE,iTable,iIndex,iSegment))=DF_CASE_USED) to bCaseSense
39965>>>>>>>>>                    Move (Integer(TableAttribute(oAttributeFunctions,aTables,DF_INDEX_SEGMENT_DIRECTION,iTable,iIndex,iSegment))=DF_DESCENDING) to bDescending
39966>>>>>>>>>                    Get TableAttribute of oAttributeFunctions aTables DF_FIELD_NAME iTable iIndexColumn 0 0 to sColumnName
39967>>>>>>>>>                    Send AddIndexSegment (&strTableDefinition) sColumnName (not(bCaseSense)) bDescending
39968>>>>>>>>>                Loop
39969>>>>>>>>>>
39969>>>>>>>>>            End
39969>>>>>>>>>>
39969>>>>>>>>>        Loop
39970>>>>>>>>>>
39970>>>>>>>>>        
39970>>>>>>>>>        Function_Return strTableDefinition
39971>>>>>>>>>    End_Function
39972>>>>>>>>>    
39972>>>>>>>>>    Function ValidateTempTableHandles tTempTableHandle[] aTableHandles Returns Boolean
39975>>>>>>>>>        Integer iIndex iMax iTable
39975>>>>>>>>>        
39975>>>>>>>>>        Move (SizeOfArray(aTableHandles)-1) to iMax
39976>>>>>>>>>        For iIndex from 0 to iMax
39982>>>>>>>>>>
39982>>>>>>>>>            Move aTableHandles[iIndex].hTable to iTable
39983>>>>>>>>>            If (iTable<=0) Begin
39985>>>>>>>>>                Function_Return False
39986>>>>>>>>>            End
39986>>>>>>>>>>
39986>>>>>>>>>        Loop
39987>>>>>>>>>>
39987>>>>>>>>>        Function_Return True
39988>>>>>>>>>    End_Function
39989>>>>>>>>>
39989>>>>>>>>>    Function OpenTemporaryTables tTempTableDefinition[] aTables Boolean bExclusive Returns tTempTableHandle[]
39992>>>>>>>>>        Integer iTableIndex iTableMax iTable
39992>>>>>>>>>        Integer iIndexIndex iIndexMax 
39992>>>>>>>>>        tTempTableHandle[] aTableHandles aEmpty
39992>>>>>>>>>        tTempTableHandle[] aTableHandles aEmpty
39994>>>>>>>>>        
39994>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iTableMax
39995>>>>>>>>>        For iTableIndex from 0 to iTableMax
40001>>>>>>>>>>
40001>>>>>>>>>            Get OpenTable aTables[iTableIndex] bExclusive to iTable
40002>>>>>>>>>            Move iTable to aTableHandles[iTableIndex].hTable
40003>>>>>>>>>            Move aTables[iTableIndex].sFileName to aTableHandles[iTableIndex].sDiskFileName
40004>>>>>>>>>            // Copy index names to tTempTableHandle
40004>>>>>>>>>            Move (SizeOfArray(aTables[iTableIndex].aIndices)-1) to iIndexMax
40005>>>>>>>>>            For iIndexIndex from 0 to iIndexMax
40011>>>>>>>>>>
40011>>>>>>>>>                Move aTables[iTableIndex].aIndices[iIndexIndex].sName to aTableHandles[iTableIndex].aIndexNames[iIndexIndex]
40012>>>>>>>>>            Loop
40013>>>>>>>>>>
40013>>>>>>>>>        Loop
40014>>>>>>>>>>
40014>>>>>>>>>        
40014>>>>>>>>>        If (not(ValidateTempTableHandles(Self,aTableHandles))) Begin
40016>>>>>>>>>            Send CloseTemporaryTables aTableHandles
40017>>>>>>>>>            Move aEmpty to aTableHandles // Empty return value signals "error" to the caller
40018>>>>>>>>>        End
40018>>>>>>>>>>
40018>>>>>>>>>        
40018>>>>>>>>>        Function_Return aTableHandles
40019>>>>>>>>>    End_Function
40020>>>>>>>>>    
40020>>>>>>>>>    Procedure CloseTemporaryTables tTempTableHandle[] aTableHandles
40023>>>>>>>>>        Integer iIndex iMax iTable
40023>>>>>>>>>        
40023>>>>>>>>>        Move (SizeOfArray(aTableHandles)-1) to iMax
40024>>>>>>>>>        For iIndex from 0 to iMax
40030>>>>>>>>>>
40030>>>>>>>>>            Move aTableHandles[iIndex].hTable to iTable
40031>>>>>>>>>            If (iTable>0) Begin
40033>>>>>>>>>                Close iTable
40034>>>>>>>>>            End
40034>>>>>>>>>>
40034>>>>>>>>>        Loop
40035>>>>>>>>>>
40035>>>>>>>>>    End_Procedure
40036>>>>>>>>>    
40036>>>>>>>>>End_Object // _oTemporaryTablesFunctions
40037>>>>>>>>>
40037>>>>>>>>>Class cTemporaryTablesHandler is a cObject
40038>>>>>>>>>    Procedure Construct_Object
40040>>>>>>>>>        Forward Send Construct_Object
40042>>>>>>>>>        Property tTempTableDefinition[] paTableDefinitions
40043>>>>>>>>>        Property tTempTableHandle[] _paTableHandles
40044>>>>>>>>>    End_Procedure
40045>>>>>>>>>    
40045>>>>>>>>>    Function OpenTables Boolean bExclusive Returns Boolean
40047>>>>>>>>>        tTempTableHandle[] aTableHandles
40047>>>>>>>>>        tTempTableHandle[] aTableHandles
40048>>>>>>>>>        tTempTableDefinition[] aTables
40048>>>>>>>>>        tTempTableDefinition[] aTables
40049>>>>>>>>>        Get paTableDefinitions to aTables
40050>>>>>>>>>        Get OpenTemporaryTables of oTemporaryTablesFunctions aTables bExclusive to aTableHandles
40051>>>>>>>>>        Set _paTableHandles to aTableHandles
40052>>>>>>>>>        Function_Return (SizeOfArray(aTableHandles)>0)
40053>>>>>>>>>    End_Function
40054>>>>>>>>>    
40054>>>>>>>>>    Procedure CloseTables
40056>>>>>>>>>        tTempTableHandle[] aTableHandles aEmpty
40056>>>>>>>>>        tTempTableHandle[] aTableHandles aEmpty
40058>>>>>>>>>        Get _paTableHandles to aTableHandles
40059>>>>>>>>>        Send CloseTemporaryTables of oTemporaryTablesFunctions aTableHandles
40060>>>>>>>>>        Set _paTableHandles to aEmpty
40061>>>>>>>>>    End_Procedure
40062>>>>>>>>>
40062>>>>>>>>>
40062>>>>>>>>>            Function _FindTable String sTable Integer ByRef iTable Boolean bQuietOnError Returns Boolean
40064>>>>>>>>>                Integer iIndex iMax
40064>>>>>>>>>                tTempTableHandle[] aTableHandles
40064>>>>>>>>>                tTempTableHandle[] aTableHandles
40065>>>>>>>>>
40065>>>>>>>>>                Get _paTableHandles to aTableHandles
40066>>>>>>>>>                Move 0 to iTable
40067>>>>>>>>>                
40067>>>>>>>>>                Move (SizeOfArray(aTableHandles)-1) to iMax
40068>>>>>>>>>                For iIndex from 0 to iMax 
40074>>>>>>>>>>
40074>>>>>>>>>                    If (Uppercase(sTable)=Uppercase(aTableHandles[iIndex].sDiskFileName)) Begin
40076>>>>>>>>>                        Move aTableHandles[iIndex].hTable to iTable
40077>>>>>>>>>                        Function_Return True 
40078>>>>>>>>>                    End
40078>>>>>>>>>>
40078>>>>>>>>>                Loop
40079>>>>>>>>>>
40079>>>>>>>>>                If (bQuietOnError) Begin
40081>>>>>>>>>                    Error 424 ("Table-name not recognized ("+sTable+")")
40082>>>>>>>>>>
40082>>>>>>>>>                End
40082>>>>>>>>>>
40082>>>>>>>>>                Function_Return False
40083>>>>>>>>>            End_Function
40084>>>>>>>>>
40084>>>>>>>>>            Function _FindTableAndIndex String sTable String sIndex Integer ByRef iTable Integer ByRef iIndex Boolean bQuietOnError Returns Boolean
40086>>>>>>>>>                Integer iHandleIndex iHandleMax
40086>>>>>>>>>                Integer iIndexIndex iIndexMax
40086>>>>>>>>>                tTempTableHandle[] aTableHandles
40086>>>>>>>>>                tTempTableHandle[] aTableHandles
40087>>>>>>>>>                                    
40087>>>>>>>>>                Get _paTableHandles to aTableHandles
40088>>>>>>>>>                Move 0 to iTable
40089>>>>>>>>>                Move 0 to iIndex
40090>>>>>>>>>                
40090>>>>>>>>>                Move (SizeOfArray(aTableHandles)-1) to iHandleMax
40091>>>>>>>>>                For iHandleIndex from 0 to iHandleMax 
40097>>>>>>>>>>
40097>>>>>>>>>                    If (Uppercase(sTable)=Uppercase(aTableHandles[iHandleIndex].sDiskFileName)) Begin
40099>>>>>>>>>                        Move aTableHandles[iHandleIndex].hTable to iTable
40100>>>>>>>>>
40100>>>>>>>>>                        // If sIndex is an integer we take it for an index number
40100>>>>>>>>>                        If (IsInteger(oStringFunctions,sIndex)) Begin
40102>>>>>>>>>                            Move sIndex to iIndex
40103>>>>>>>>>                            Function_Return True
40104>>>>>>>>>                        End
40104>>>>>>>>>>
40104>>>>>>>>>                        
40104>>>>>>>>>                        // Else it must be an index name and we must look for it:
40104>>>>>>>>>                        Move (Lowercase(sIndex)) to sIndex
40105>>>>>>>>>                        Move (SizeOfArray(aTableHandles[iHandleIndex].aIndexNames)-1) to iIndexMax
40106>>>>>>>>>                        For iIndexIndex from 0 to iIndexMax
40112>>>>>>>>>>
40112>>>>>>>>>                            If (sIndex=aTableHandles[iHandleIndex].aIndexNames[iIndexIndex]) Begin
40114>>>>>>>>>                                Move iIndexIndex to iIndex
40115>>>>>>>>>                                Function_Return True
40116>>>>>>>>>                            End
40116>>>>>>>>>>
40116>>>>>>>>>                        Loop
40117>>>>>>>>>>
40117>>>>>>>>>                        
40117>>>>>>>>>                        If (not(bQuietOnError)) Begin
40119>>>>>>>>>                            Error 424 ("Table index not found ("+sTable+", index: "+sIndex+")")
40120>>>>>>>>>>
40120>>>>>>>>>                        End
40120>>>>>>>>>>
40120>>>>>>>>>                        Function_Return False // No sense in going through the rest of the tables,
40121>>>>>>>>>                    End
40121>>>>>>>>>>
40121>>>>>>>>>                Loop
40122>>>>>>>>>>
40122>>>>>>>>>                If (not(bQuietOnError)) Begin
40124>>>>>>>>>                    Error 425 ("Table index not found ("+sTable+", index: "+sIndex+")")
40125>>>>>>>>>>
40125>>>>>>>>>                End
40125>>>>>>>>>>
40125>>>>>>>>>                Function_Return False
40126>>>>>>>>>            End_Function
40127>>>>>>>>>    
40127>>>>>>>>>            Function _FindTableAndColumn String sTable String sColumn Integer ByRef iTable Integer ByRef iColumn Boolean bQuietOnError Returns Boolean
40129>>>>>>>>>                Integer iIndex iMax
40129>>>>>>>>>                tTempTableHandle[] aTableHandles
40129>>>>>>>>>                tTempTableHandle[] aTableHandles
40130>>>>>>>>>                                    
40130>>>>>>>>>                Get _paTableHandles to aTableHandles
40131>>>>>>>>>                Move 0 to iTable
40132>>>>>>>>>                Move 0 to iColumn
40133>>>>>>>>>                
40133>>>>>>>>>                Move (SizeOfArray(aTableHandles)-1) to iMax
40134>>>>>>>>>                For iIndex from 0 to iMax 
40140>>>>>>>>>>
40140>>>>>>>>>                    If (Uppercase(sTable)=Uppercase(aTableHandles[iIndex].sDiskFileName)) Begin
40142>>>>>>>>>                        Move aTableHandles[iIndex].hTable to iTable
40143>>>>>>>>>                        Get FieldNameToNumber of oTableAccessFunctions iTable sColumn to iColumn
40144>>>>>>>>>                        If (iColumn>=0) Begin
40146>>>>>>>>>                            Function_Return True
40147>>>>>>>>>                        End
40147>>>>>>>>>>
40147>>>>>>>>>                        If (not(bQuietOnError)) Begin
40149>>>>>>>>>                            Error 422 ("Table column not found ("+sTable+"."+sColumn+")")
40150>>>>>>>>>>
40150>>>>>>>>>                        End
40150>>>>>>>>>>
40150>>>>>>>>>                        Function_Return False // No sense in going through the rest of the tables,
40151>>>>>>>>>                    End
40151>>>>>>>>>>
40151>>>>>>>>>                Loop
40152>>>>>>>>>>
40152>>>>>>>>>                If (not(bQuietOnError)) Begin
40154>>>>>>>>>                    Error 423 ("Table column not found ("+sTable+"."+sColumn+")")
40155>>>>>>>>>>
40155>>>>>>>>>                End
40155>>>>>>>>>>
40155>>>>>>>>>                Function_Return False
40156>>>>>>>>>            End_Function
40157>>>>>>>>>            
40157>>>>>>>>>    Procedure Set Column_Value String sTable String sColumn String sValue
40159>>>>>>>>>        Integer iTable iColumn
40159>>>>>>>>>        If (_FindTableAndColumn(Self,sTable,sColumn,&iTable,&iColumn,False)) Begin
40161>>>>>>>>>            Set_Field_Value iTable iColumn to sValue
40164>>>>>>>>>        End
40164>>>>>>>>>>
40164>>>>>>>>>    End_Procedure
40165>>>>>>>>>    
40165>>>>>>>>>    Function Column_Value String sTable String sColumn Returns String
40167>>>>>>>>>        Integer iTable iColumn
40167>>>>>>>>>        String sRval
40167>>>>>>>>>        If (_FindTableAndColumn(Self,sTable,sColumn,&iTable,&iColumn,False)) Begin
40169>>>>>>>>>            Get_Field_Value iTable iColumn to sRval
40172>>>>>>>>>        End
40172>>>>>>>>>>
40172>>>>>>>>>        Else Begin
40173>>>>>>>>>            Move "" to sRval
40174>>>>>>>>>        End
40174>>>>>>>>>>
40174>>>>>>>>>        Function_Return (Rtrim(sRval))
40175>>>>>>>>>    End_Function
40176>>>>>>>>>    
40176>>>>>>>>>    Procedure SaveRecord String sTable
40178>>>>>>>>>        Integer iTable
40178>>>>>>>>>        If (_FindTable(Self,sTable,&iTable,False)) Begin
40180>>>>>>>>>            SaveRecord iTable
40181>>>>>>>>>        End
40181>>>>>>>>>>
40181>>>>>>>>>    End_Procedure
40182>>>>>>>>>    
40182>>>>>>>>>    Procedure Clear String sTable
40184>>>>>>>>>        Integer iTable
40184>>>>>>>>>        If (_FindTable(Self,sTable,&iTable,False)) Begin
40186>>>>>>>>>            Clear iTable
40187>>>>>>>>>            // Clear all preseeding seeds:
40187>>>>>>>>>            If (SizeOfArray(_gaTableSeeds)>iTable) Begin
40189>>>>>>>>>                Move (ResizeArray(_gaTableSeeds[iTable],0)) to _gaTableSeeds[iTable]
40190>>>>>>>>>            End
40190>>>>>>>>>>
40190>>>>>>>>>        End
40190>>>>>>>>>>
40190>>>>>>>>>    End_Procedure
40191>>>>>>>>>    
40191>>>>>>>>>    Procedure DeleteString String sTable
40193>>>>>>>>>        Integer iTable
40193>>>>>>>>>        If (_FindTable(Self,sTable,&iTable,False)) Begin
40195>>>>>>>>>            Delete iTable
40196>>>>>>>>>        End
40196>>>>>>>>>>
40196>>>>>>>>>    End_Procedure
40197>>>>>>>>>    
40197>>>>>>>>>    Procedure SeedIndex String sTable String sColumn String sValue
40199>>>>>>>>>        Integer iTable iColumn iSegment
40199>>>>>>>>>        If (_FindTableAndColumn(Self,sTable,sColumn,&iTable,&iColumn,False)) Begin
40201>>>>>>>>>            If (SizeOfArray(_gaTableSeeds)>iTable) Begin
40203>>>>>>>>>                Move (SizeOfArray(_gaTableSeeds[iTable])) to iSegment
40204>>>>>>>>>            End
40204>>>>>>>>>>
40204>>>>>>>>>            Else Begin
40205>>>>>>>>>                Move 0 to iSegment
40206>>>>>>>>>            End
40206>>>>>>>>>>
40206>>>>>>>>>            Move iColumn to _gaTableSeeds[iTable][iSegment].iColumn
40207>>>>>>>>>            Move sValue to _gaTableSeeds[iTable][iSegment].sValue
40208>>>>>>>>>            Set_Field_Value iTable iColumn to sValue
40211>>>>>>>>>        End
40211>>>>>>>>>>
40211>>>>>>>>>    End_Procedure
40212>>>>>>>>>    
40212>>>>>>>>>    Function Find String sTable String sIndex Integer iMode Boolean bConstrained Returns Boolean
40214>>>>>>>>>        Boolean bFound
40214>>>>>>>>>        Integer iTable iIndex
40214>>>>>>>>>        Integer iSegmentIndex iSegmentMax
40214>>>>>>>>>        Integer iColumn iType
40214>>>>>>>>>        String sValue
40214>>>>>>>>>        If (_FindTableAndIndex(Self,sTable,sIndex,&iTable,&iIndex,False)) Begin
40216>>>>>>>>>            Vfind iTable iIndex iMode
40218>>>>>>>>>            Move (Found) to bFound
40219>>>>>>>>>            If (bFound and bConstrained) Begin
40221>>>>>>>>>                // Check that seeded values are identical with the record found:
40221>>>>>>>>>                Move (SizeOfArray(_gaTableSeeds[iTable])-1) to iSegmentMax
40222>>>>>>>>>                For iSegmentIndex from 0 to iSegmentMax
40228>>>>>>>>>>
40228>>>>>>>>>                    Move _gaTableSeeds[iTable][iSegmentIndex].iColumn to iColumn
40229>>>>>>>>>                    Get_Field_Value iTable iColumn to sValue
40232>>>>>>>>>                    Get_Attribute DF_FIELD_TYPE of iTable iColumn to iType
40235>>>>>>>>>                    If (iType=DF_ASCII) Begin
40237>>>>>>>>>                        Move (_gaTableSeeds[iTable][iSegmentIndex].sValue=sValue) to bFound
40238>>>>>>>>>                    End
40238>>>>>>>>>>
40238>>>>>>>>>                    Else If (iType=DF_BCD) Begin
40241>>>>>>>>>                        Move (Number(_gaTableSeeds[iTable][iSegmentIndex].sValue)=Number(sValue)) to bFound
40242>>>>>>>>>                    End
40242>>>>>>>>>>
40242>>>>>>>>>                    Else If (iType=DF_DATE) Begin
40245>>>>>>>>>                        Move (Date(_gaTableSeeds[iTable][iSegmentIndex].sValue)=Date(sValue)) to bFound
40246>>>>>>>>>                    End
40246>>>>>>>>>>
40246>>>>>>>>>                    Else Begin
40247>>>>>>>>>                        Error 426 "Find was seeded by a TEXT or BINARY field"
40248>>>>>>>>>>
40248>>>>>>>>>                    End
40248>>>>>>>>>>
40248>>>>>>>>>                Loop
40249>>>>>>>>>>
40249>>>>>>>>>            End
40249>>>>>>>>>>
40249>>>>>>>>>            Function_Return (bFound)
40250>>>>>>>>>        End
40250>>>>>>>>>>
40250>>>>>>>>>        Function_Return False
40251>>>>>>>>>    End_Function
40252>>>>>>>>>End_Class
40253>>>>>>>>>
40253>>>>>>>>>
40253>>>>>>>>>//Procedure TestrTempTable
40253>>>>>>>>>//    tTempTableDefinition stDef
40253>>>>>>>>>//    Get EmptyTempTableDefinition of oTemporaryTablesFunctions to stDef
40253>>>>>>>>>//
40253>>>>>>>>>//    Move 200000 to stDef.iMaxRecords
40253>>>>>>>>>//    Move "badseeds" to stDef.sFileName
40253>>>>>>>>>//    Move "" to stDef.sFolder // blank means it goes in the data folder
40253>>>>>>>>>//    Move "test" to stDef.sSubFolder // means it goes in a subfolder of the data folder called test
40253>>>>>>>>>//    
40253>>>>>>>>>//    Send AddColumn of oTemporaryTablesFunctions (&stDef) "FirstName"   DF_ASCII 20 0  // field no 1
40253>>>>>>>>>//    Send AddColumn of oTemporaryTablesFunctions (&stDef) "LastName"    DF_ASCII 20 0  // field no 2
40253>>>>>>>>>//    Send AddColumn of oTemporaryTablesFunctions (&stDef) "Address"     DF_TEXT 256 0  // field no 3
40253>>>>>>>>>//    Send AddColumn of oTemporaryTablesFunctions (&stDef) "DateOfBirth" DF_DATE 0 0    // field no 4
40253>>>>>>>>>//    Send AddColumn of oTemporaryTablesFunctions (&stDef) "ArrestCount" DF_BCD 4 0     // field no 5
40253>>>>>>>>>//    Send AddColumn of oTemporaryTablesFunctions (&stDef) "HighestPct"  DF_BCD 4 2     // field no 6
40253>>>>>>>>>//    
40253>>>>>>>>>//    Send AddIndex of oTemporaryTablesFunctions (&stDef) True
40253>>>>>>>>>//    Send AddIndexSegment of oTemporaryTablesFunctions (&stDef) "FirstName" True False // FirstName
40253>>>>>>>>>//    Send AddIndexSegment of oTemporaryTablesFunctions (&stDef) "LastName"  True False // LastName
40253>>>>>>>>>//    
40253>>>>>>>>>//    Send AddIndex of oTemporaryTablesFunctions (&stDef) True
40253>>>>>>>>>//    Send AddIndexSegment of oTemporaryTablesFunctions (&stDef) "DateOfBirth" False False // DateOfBirth
40253>>>>>>>>>//    Send AddIndexSegment of oTemporaryTablesFunctions (&stDef) "Recnum"      False False // Recnum
40253>>>>>>>>>//    
40253>>>>>>>>>//    Send AddIndex of oTemporaryTablesFunctions (&stDef) True
40253>>>>>>>>>//    Send AddIndexSegment of oTemporaryTablesFunctions (&stDef) "HighestPct"  False True // HighestPct
40253>>>>>>>>>//    Send AddIndexSegment of oTemporaryTablesFunctions (&stDef) "ArrestCount" False True // ArrestCount
40253>>>>>>>>>//    
40253>>>>>>>>>//    If (CreateTable(oTemporaryTablesFunctions,stDef,True)) Begin
40253>>>>>>>>>//        Showln "Success"
40253>>>>>>>>>//    End
40253>>>>>>>>>//    Else Begin
40253>>>>>>>>>//        Showln "Failure"
40253>>>>>>>>>//    End
40253>>>>>>>>>//End_Procedure
40253>>>>>>>Use WindowsInfo.pkg
40253>>>>>>>Use SQLStatementHandles.pkg
Including file: SQLStatementHandles.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\SQLStatementHandles.pkg)
40253>>>>>>>>>// SQLStatementHandles.pkg // StureApsPublicLib
40253>>>>>>>>>//
40253>>>>>>>>>// A SQL connection can execute one SQL statement at a time. It can generate
40253>>>>>>>>>// multiple statements but only one may execute at any given time.
40253>>>>>>>>>//
40253>>>>>>>>>// If you need to be able to execute multiple SQL statements simultaneously
40253>>>>>>>>>// you need to create a new connection and this is an un-welcome complication
40253>>>>>>>>>// of what should be simple. This package does away with this complexity by
40253>>>>>>>>>// automatically creating and reusing connections and therefore a minimum
40253>>>>>>>>>// will be created.
40253>>>>>>>>>//
40253>>>>>>>>>// It also means that at any time the application will have a number of open
40253>>>>>>>>>// connections in its 'cache'. If you want to reset this cache and close all
40253>>>>>>>>>// the connections (if you change filelist.cfg for example) here is how:
40253>>>>>>>>>//
40253>>>>>>>>>//  Send DisconnectAllConnections of oSQLStatementHandles
40253>>>>>>>>>//
40253>>>>>>>>>// (This implementation does not assume MARS to be enabled on ms sql driver)
40253>>>>>>>>>//
40253>>>>>>>>>// Do it like this:
40253>>>>>>>>>//
40253>>>>>>>>>//
40253>>>>>>>>>// Use SQLStatementHandles.pkg // Declare singleton object oSQLStatementHandles
40253>>>>>>>>>//
40253>>>>>>>>>// Procedure Something
40253>>>>>>>>>//     tSQLStatementHandle strStatement // Clever statement handle
40253>>>>>>>>>//     If (OpenStatementOnTable(oSQLStatementHandles,Customer.File_Number,&strStatement)) Begin
40253>>>>>>>>>//
40253>>>>>>>>>//         // Do anything with the strStatement.hHandle (except SQLClose'ing it)
40253>>>>>>>>>//         // At this point strStatement.hStatement is your normal statement handle.
40253>>>>>>>>>//
40253>>>>>>>>>//         // Close the statement and hand the corresponding connection back to the pool:
40253>>>>>>>>>//         Send CloseStatement of oSQLStatementHandles strStatement
40253>>>>>>>>>//     End
40253>>>>>>>>>// End_Procedure
40253>>>>>>>>>//
40253>>>>>>>>>
40253>>>>>>>>>Use sql.pkg
40253>>>>>>>>>
40253>>>>>>>>>Struct tSQLConnectionHandle
40253>>>>>>>>>    String sDriver
40253>>>>>>>>>    String sConnectString
40253>>>>>>>>>    Handle hHandle
40253>>>>>>>>>End_Struct
40253>>>>>>>>>
40253>>>>>>>>>Struct tSQLStatementHandle
40253>>>>>>>>>    Handle hHandle
40253>>>>>>>>>    tSQLConnectionHandle strConnectionHandle
40253>>>>>>>>>    tSQLConnectionHandle strConnectionHandle
40253>>>>>>>>>End_Struct
40253>>>>>>>>>
40253>>>>>>>>>Global_Variable tSQLConnectionHandle[] _gaSQLConnectionPool // Array of available SQL connections
40253>>>>>>>>>
40253>>>>>>>>>Global_Variable Integer oSQLStatementHandles
40253>>>>>>>>>Object _oSQLStatementHandles is a cObject
40255>>>>>>>>>    Move Self to oSQLStatementHandles
40256>>>>>>>>>
40256>>>>>>>>>    Property String _psCurrentFilelist
40258>>>>>>>>>
40258>>>>>>>>>    Procedure DisconnectAllConnections // and destroy them
40261>>>>>>>>>        Integer iMax iItem
40261>>>>>>>>>        Handle hConnection
40261>>>>>>>>>        Move (SizeOfArray(_gaSQLConnectionPool)-1) to iMax
40262>>>>>>>>>        For iItem from 0 to iMax
40268>>>>>>>>>>
40268>>>>>>>>>            Move _gaSQLConnectionPool[iItem].hHandle to hConnection
40269>>>>>>>>>            If (hConnection<>0) Begin
40271>>>>>>>>>                Send SQLDisconnect of hConnection
40272>>>>>>>>>                Send Destroy of hConnection
40273>>>>>>>>>            End
40273>>>>>>>>>>
40273>>>>>>>>>        Loop
40274>>>>>>>>>>
40274>>>>>>>>>        Move (ResizeArray(_gaSQLConnectionPool,0)) to _gaSQLConnectionPool
40275>>>>>>>>>    End_Procedure
40276>>>>>>>>>
40276>>>>>>>>>        Function _FilelistChanged Returns Boolean
40279>>>>>>>>>            String sFilelist
40279>>>>>>>>>            Get_Attribute DF_FILELIST_NAME to sFilelist
40282>>>>>>>>>            Function_Return (sFilelist<>_psCurrentFilelist(Self))
40283>>>>>>>>>        End_Function
40284>>>>>>>>>
40284>>>>>>>>>        // Every time a connection is requested we check if the database
40284>>>>>>>>>        // as been switched underneath our feet. This happens only in
40284>>>>>>>>>        // applications like VDFxray where a new workspace may be selected
40284>>>>>>>>>        // at any time. If it has then we must close all the connection we
40284>>>>>>>>>        // have in stock and remove them from our connection "cache":
40284>>>>>>>>>        Procedure _CheckIfFilelistChanged
40287>>>>>>>>>            String sFilelist
40287>>>>>>>>>            If (_FilelistChanged(Self)) Begin
40289>>>>>>>>>                Send DisconnectAllConnections
40290>>>>>>>>>                Get_Attribute DF_FILELIST_NAME to sFilelist
40293>>>>>>>>>                Set _psCurrentFilelist to sFilelist
40294>>>>>>>>>            End
40294>>>>>>>>>>
40294>>>>>>>>>        End_Procedure
40295>>>>>>>>>
40295>>>>>>>>>        Function _FindConnectionInPool String sDriver String sConnectString Returns Integer
40298>>>>>>>>>            Integer iMax iItem
40298>>>>>>>>>            Move (SizeOfArray(_gaSQLConnectionPool)-1) to iMax
40299>>>>>>>>>            For iItem from 0 to iMax
40305>>>>>>>>>>
40305>>>>>>>>>                If (sDriver=_gaSQLConnectionPool[iItem].sDriver and sConnectString=_gaSQLConnectionPool[iItem].sConnectString) Begin
40307>>>>>>>>>                    Function_Return iItem
40308>>>>>>>>>                End
40308>>>>>>>>>>
40308>>>>>>>>>            Loop
40309>>>>>>>>>>
40309>>>>>>>>>            Function_Return -1 // not found
40310>>>>>>>>>        End_Function
40311>>>>>>>>>
40311>>>>>>>>>
40311>>>>>>>>>    Function OpenConnection String sDriver String sConnectString tSQLConnectionHandle ByRef strConnectionHandle Returns Boolean
40314>>>>>>>>>        Boolean bSuccess
40314>>>>>>>>>        Integer iConnectionIndex hConnection hDataBaseConnection
40314>>>>>>>>>
40314>>>>>>>>>        Send _CheckIfFilelistChanged
40315>>>>>>>>>        Move True to bSuccess
40316>>>>>>>>>        Get _FindConnectionInPool sDriver sConnectString to iConnectionIndex // Do we already have one?
40317>>>>>>>>>        If (iConnectionIndex=-1) Begin // Create one
40319>>>>>>>>>            Get Create U_cSQLConnection to hConnection // Create SQL connection. Such a connection can only handle the execution of one statetment at a time.
40320>>>>>>>>>            Get SQLConnect of hConnection sDriver sConnectString to hDataBaseConnection
40321>>>>>>>>>            // The only thing we use the hDataBaseConnection for is:
40321>>>>>>>>>            If (hDataBaseConnection=0) Begin
40323>>>>>>>>>                Move False to bSuccess
40324>>>>>>>>>                Error 231 (sDriver+" could not connect to: "+sConnectString)
40325>>>>>>>>>>
40325>>>>>>>>>            End
40325>>>>>>>>>>
40325>>>>>>>>>            Move sDriver to strConnectionHandle.sDriver
40326>>>>>>>>>            Move sConnectString to strConnectionHandle.sConnectString
40327>>>>>>>>>            Move hConnection to strConnectionHandle.hHandle
40328>>>>>>>>>        End
40328>>>>>>>>>>
40328>>>>>>>>>        Else Begin // Take that one out of the pool
40329>>>>>>>>>            Move _gaSQLConnectionPool[iConnectionIndex] to strConnectionHandle
40330>>>>>>>>>            Move (RemoveFromArray(_gaSQLConnectionPool,iConnectionIndex)) to _gaSQLConnectionPool // Take it out of the pool
40331>>>>>>>>>        End
40331>>>>>>>>>>
40331>>>>>>>>>        Function_Return bSuccess
40332>>>>>>>>>    End_Function
40333>>>>>>>>>
40333>>>>>>>>>    Procedure CloseConnection tSQLConnectionHandle strConnectionHandle
40336>>>>>>>>>        Move strConnectionHandle to _gaSQLConnectionPool[SizeOfArray(_gaSQLConnectionPool)] // Put back in pool
40337>>>>>>>>>    End_Procedure
40338>>>>>>>>>
40338>>>>>>>>>    Function OpenStatement String sDriver String sConnectString tSQLStatementHandle ByRef strStatementHandle Returns Boolean
40341>>>>>>>>>        Boolean bSuccess
40341>>>>>>>>>        Move 0 to strStatementHandle.hHandle
40342>>>>>>>>>        Get OpenConnection sDriver sConnectString (&strStatementHandle.strConnectionHandle) to bSuccess
40343>>>>>>>>>        If (bSuccess) Begin
40345>>>>>>>>>            Get SQLOpen of strStatementHandle.strConnectionHandle.hHandle to strStatementHandle.hHandle
40346>>>>>>>>>        End
40346>>>>>>>>>>
40346>>>>>>>>>        Function_Return bSuccess
40347>>>>>>>>>    End_Function
40348>>>>>>>>>
40348>>>>>>>>>    Function OpenStatementOnTable Integer iTable tSQLStatementHandle ByRef strStatementHandle Returns Boolean
40351>>>>>>>>>        String sDriver sConnectString
40351>>>>>>>>>        Get_Attribute DF_FILE_DRIVER of iTable to sDriver
40354>>>>>>>>>        Get_Attribute DF_FILE_LOGIN of iTable to sConnectString
40357>>>>>>>>>        Function_Return (OpenStatement(Self,sDriver,sConnectString,&strStatementHandle))
40358>>>>>>>>>    End_Function
40359>>>>>>>>>
40359>>>>>>>>>    Procedure CloseStatement tSQLStatementHandle strStatement
40362>>>>>>>>>        Send SQLClose of strStatement.hHandle // obliterates it!
40363>>>>>>>>>        Send CloseConnection strStatement.strConnectionHandle // Connection back in pool!
40364>>>>>>>>>    End_Procedure
40365>>>>>>>>>
40365>>>>>>>>>End_Object
40366>>>>>>>Use TableDriverFunctions.pkg
40366>>>>>>>Use StructFunctions.pkg
40366>>>>>>>Use RecordBufferFunctions.pkg
Including file: RecordBufferFunctions.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\RecordBufferFunctions.pkg)
40366>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
40366>>>>>>>>>
40366>>>>>>>>>Struct _trbfRecordBuffer
40366>>>>>>>>>    Integer iTable
40366>>>>>>>>>    RowID rRowId
40366>>>>>>>>>End_Struct
40366>>>>>>>>>
40366>>>>>>>>>Global_Variable Integer oRecordBufferFunctions
40366>>>>>>>>>_trbfRecordBuffer[] _gartbfBufferStates
40366>>>>>>>>>_trbfRecordBuffer[] _gartbfBufferStates
40366>>>>>>>>>
40366>>>>>>>>>Object _oRecordBufferFunctions is a cObject
40368>>>>>>>>>    Move Self to oRecordBufferFunctions
40369>>>>>>>>>
40369>>>>>>>>>    Property _trbfRecordBuffer[] paRecordStack
40371>>>>>>>>>
40371>>>>>>>>>    Procedure PushRecord Integer iTable
40374>>>>>>>>>        _trbfRecordBuffer strRB
40374>>>>>>>>>        _trbfRecordBuffer strRB
40374>>>>>>>>>        _trbfRecordBuffer[] aRecordStack
40374>>>>>>>>>        _trbfRecordBuffer[] aRecordStack
40375>>>>>>>>>
40375>>>>>>>>>        Move iTable to strRB.iTable
40376>>>>>>>>>        Move (GetRowID(iTable)) to strRB.rRowId
40377>>>>>>>>>
40377>>>>>>>>>        Get paRecordStack to aRecordStack
40378>>>>>>>>>        Move strRB to aRecordStack[SizeOfArray(aRecordStack)]
40379>>>>>>>>>        Set paRecordStack to aRecordStack
40380>>>>>>>>>    End_Procedure
40381>>>>>>>>>
40381>>>>>>>>>        Procedure _PopRecord Integer iTable Boolean bRestoreBuffer
40384>>>>>>>>>            _trbfRecordBuffer strRB
40384>>>>>>>>>            _trbfRecordBuffer strRB
40384>>>>>>>>>            _trbfRecordBuffer[] aRecordStack
40384>>>>>>>>>            _trbfRecordBuffer[] aRecordStack
40385>>>>>>>>>
40385>>>>>>>>>            Get paRecordStack to aRecordStack
40386>>>>>>>>>            Move (aRecordStack[SizeOfArray(aRecordStack)-1]) to strRB
40387>>>>>>>>>
40387>>>>>>>>>            If (strRB.iTable=iTable) Begin
40389>>>>>>>>>
40389>>>>>>>>>                Move (ResizeArray(aRecordStack,SizeOfArray(aRecordStack)-1)) to aRecordStack
40390>>>>>>>>>                Set paRecordStack to aRecordStack
40391>>>>>>>>>
40391>>>>>>>>>                If (bRestoreBuffer) Begin
40393>>>>>>>>>                    Clear iTable
40394>>>>>>>>>                    If (not(IsNullRowID(strRB.rRowId))) Begin
40396>>>>>>>>>                        If (FindByRowID(strRB.iTable,strRB.rRowId)) Begin
40398>>>>>>>>>                        End
40398>>>>>>>>>>
40398>>>>>>>>>                    End
40398>>>>>>>>>>
40398>>>>>>>>>                End
40398>>>>>>>>>>
40398>>>>>>>>>            End
40398>>>>>>>>>>
40398>>>>>>>>>            Else Begin
40399>>>>>>>>>                Error DFERR_PROGRAM "Un-balanced record buffer push/pop"
40400>>>>>>>>>>
40400>>>>>>>>>            End
40400>>>>>>>>>>
40400>>>>>>>>>        End_Procedure
40401>>>>>>>>>
40401>>>>>>>>>    Procedure PopRecord Integer iTable // iTable parameter is used to check for balanced use of record stack
40404>>>>>>>>>        Send _PopRecord iTable True
40405>>>>>>>>>    End_Procedure
40406>>>>>>>>>
40406>>>>>>>>>    Procedure DropRecord Integer iTable // iTable parameter is used to check for balanced use of record stack
40409>>>>>>>>>        Send _PopRecord iTable False
40410>>>>>>>>>    End_Procedure
40411>>>>>>>>>
40411>>>>>>>>>        Function _IsRecordBufferActive Integer iTable Returns Boolean
40414>>>>>>>>>            Integer iStatus
40414>>>>>>>>>            Get_Attribute DF_FILE_STATUS of iTable to iStatus
40417>>>>>>>>>            Function_Return (iStatus=DF_FILE_ACTIVE or iStatus=DF_FILE_ACTIVE_CHANGED)
40418>>>>>>>>>        End_Function
40419>>>>>>>>>
40419>>>>>>>>>    Function IsNullRecordBuffer Integer iTable Returns Boolean
40422>>>>>>>>>        Function_Return (not(_IsRecordBufferActive(Self,iTable)))
40423>>>>>>>>>    End_Function
40424>>>>>>>>>
40424>>>>>>>>>    Function RecordBufferColumnValues Integer iTable Returns String[]
40427>>>>>>>>>        Integer iColumn iColumns iColumnType
40427>>>>>>>>>        String[] aColumnValues
40428>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iColumns
40431>>>>>>>>>        For iColumn from 0 to iColumns
40437>>>>>>>>>>
40437>>>>>>>>>            Get_Attribute DF_FIELD_TYPE of iTable iColumn to iColumnType
40440>>>>>>>>>            If (iColumnType<>DF_OVERLAP) Begin
40442>>>>>>>>>                Get_Field_Value iTable iColumn to aColumnValues[iColumn]
40445>>>>>>>>>            End
40445>>>>>>>>>>
40445>>>>>>>>>            Else Begin
40446>>>>>>>>>                Move "" to aColumnValues[iColumn
40447>>>>>>>>>            End
40447>>>>>>>>>>
40447>>>>>>>>>        Loop
40448>>>>>>>>>>
40448>>>>>>>>>        Function_Return aColumnValues
40449>>>>>>>>>    End_Function
40450>>>>>>>>>
40450>>>>>>>>>End_Object
40451>>>>>>>>>
40451>>>>>>>
40451>>>>>>>Enum_List // Column value types
40451>>>>>>>    Define tqSTRING
40451>>>>>>>    Define tqNUMBER
40451>>>>>>>    Define tqTEXT
40451>>>>>>>    Define tqDATE
40451>>>>>>>    Define tqDATETIME
40451>>>>>>>End_Enum_List
40451>>>>>>>
40451>>>>>>>Enum_List // Filter comparison modes
40451>>>>>>>    Define tqLT
40451>>>>>>>    Define tqLE
40451>>>>>>>    Define tqEQ
40451>>>>>>>    Define tqGE
40451>>>>>>>    Define tqGT
40451>>>>>>>    Define tqNE
40451>>>>>>>    // These can never be used for index optimization:
40451>>>>>>>//    Define tqCONTAINS   // DO NOT USE
40451>>>>>>>//    Define tqIN         // DO NOT USE (use orlist instead)
40451>>>>>>>    Define tqMATCH      // When evaluated on the embedded database tqMATCH and tqUCMATCH may be
40451>>>>>>>    Define tqUCMATCH    // expensive. On SQL they are converted to 'like' predicates and they fly.
40451>>>>>>>    Define _tqComparisonMax   // Stop-marker
40451>>>>>>>End_Enum_List
40451>>>>>>>
40451>>>>>>>Struct tTQResultRow
40451>>>>>>>    RowID    riRowId
40451>>>>>>>    String   sSortValue
40451>>>>>>>    String[] aColumnValues
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>Struct tTQResultSet
40451>>>>>>>    Integer iTable
40451>>>>>>>    tTQResultRow[] aRecords
40451>>>>>>>    tTQResultRow[] aRecords
40451>>>>>>>    Integer _iCurrentRowPointer
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>Struct _tTQValueSource
40451>>>>>>>    // An actual value is derived like this:
40451>>>>>>>    //  If iTable<>0 then: get_field_value iTable iColumn
40451>>>>>>>    //  Else If (hFunction<>0) then: get hFunction of hObject iColumn // Column is passed to hFunction as argument
40451>>>>>>>    //  Else If aOrList has elements the value of the _iOrListPointer'th element in aOrList is assumed
40451>>>>>>>    //  Else: sConstant
40451>>>>>>>    Integer iTable
40451>>>>>>>    Integer iColumn
40451>>>>>>>
40451>>>>>>>    Integer hObject
40451>>>>>>>    Integer hFunction
40451>>>>>>>
40451>>>>>>>    Integer iType
40451>>>>>>>    Integer iLen
40451>>>>>>>    Integer iDecimals
40451>>>>>>>
40451>>>>>>>    String  sConstant
40451>>>>>>>
40451>>>>>>>    String _sValue
40451>>>>>>>
40451>>>>>>>    String[] aOrList
40451>>>>>>>    Integer _iOrListPointer
40451>>>>>>>
40451>>>>>>>    String  sSQLResultSetColumnName
40451>>>>>>>//    Integer iSQLResultSetColumnNumber // This is implicitly given by the position of the _tTQValueSource member in the aSelectedColumns array of a tTableQuery type variable.
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>Struct tTQFilterSegment
40451>>>>>>>    _tTQValueSource strLeftValue
40451>>>>>>>    _tTQValueSource strLeftValue
40451>>>>>>>    Integer iComp // tqEQ, tqLT, tgLE, tqMATCH etc...
40451>>>>>>>    tWildCardEvalSequence strMatchEvalSequence // If selection by wild card string matching this member is needed
40451>>>>>>>    tWildCardEvalSequence strMatchEvalSequence // If selection by wild card string matching this member is needed
40451>>>>>>>    _tTQValueSource strRightValue
40451>>>>>>>    _tTQValueSource strRightValue
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>Struct _tTQTableRelationSegment
40451>>>>>>>    Integer iSourceTable
40451>>>>>>>    Integer iSourceColumn
40451>>>>>>>    Integer iInnerJoinComp
40451>>>>>>>    Integer iTargetColumn
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>Struct tTQTableRelation
40451>>>>>>>    Integer iTargetTable                  // The table that is being related to
40451>>>>>>>    String sForceSQLTableName             // If represented in a select statement we can force its name by setting this
40451>>>>>>>    _tTQTableRelationSegment[] aSegments  // The columns being used for the relation. Note that these may stem from a number of different
40451>>>>>>>    _tTQTableRelationSegment[] aSegments  // The columns being used for the relation. Note that these may stem from a number of different
40451>>>>>>>                                          // child tables. Note also that if aSegments is empty the record of the iTargetTable table is
40451>>>>>>>                                          // constant for the duration of the query execution. But they are all in effect "outer left joins".
40451>>>>>>>    Integer _iEmbeddedIndex               // What embedded index should be used to find a record of this kind (the iTargetTable kind)
40451>>>>>>>    Boolean bFixed                        // A table is fixed if the record buffer is constant through the query.
40451>>>>>>>    Boolean bInnerJoin                    // If a relation is marked as "inner join" the SQL generated will do something I can't remember.
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>Struct tTQFilterExpression //
40451>>>>>>>    Number nExpense // Expected expense of evaluating this expression.
40451>>>>>>>    Boolean bNot // Applies to strOperand or aSubExpressions whichever is 'active'
40451>>>>>>>    tTQFilterSegment strOperand
40451>>>>>>>    tTQFilterSegment strOperand
40451>>>>>>>    tTQFilterExpression[] aSubExpressions // If this array has members then tTQFilterSegment is disregarded
40451>>>>>>>    tTQFilterExpression[] aSubExpressions // If this array has members then tTQFilterSegment is disregarded
40451>>>>>>>    Integer iAndOr // 0=leaf(nothing), 1=and, 2=or, 3=xOr
40451>>>>>>>    Boolean _bOpen
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>// a or b and c xor (d or not(e))
40451>>>>>>>Enum_List // Filter expression 'keys'
40451>>>>>>>    Define _tqKeyNULL
40451>>>>>>>    Define tqKeyAND
40451>>>>>>>    Define tqKeyOR
40451>>>>>>>    Define tqKeyNOT
40451>>>>>>>    Define tqKeyPARLEFT
40451>>>>>>>    Define tqKeyPARRIGHT
40451>>>>>>>End_Enum_List
40451>>>>>>>
40451>>>>>>>Struct tTQOrderBySegment
40451>>>>>>>    Boolean bDescending
40451>>>>>>>    Boolean bUppercase
40451>>>>>>>    _tTQValueSource strValueSource
40451>>>>>>>    _tTQValueSource strValueSource
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>Struct _tTQInnerJoinControlBlock
40451>>>>>>>    Boolean bEnabled // Inner join enabled
40451>>>>>>>    Boolean bInitialized // Inner join initialised
40451>>>>>>>    String[] aCurrentParentSortValues // Sort values of current parent record
40451>>>>>>>    Boolean bSkipNextFetch // First run in inner join
40451>>>>>>>    Boolean bEndOfResultSet
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>Struct tTQPrefetchCacheControl
40451>>>>>>>    Boolean bUseSettings
40451>>>>>>>    Integer iPrefetchRecordCount
40451>>>>>>>    Integer iPrefetchRecordTimeout
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>Struct tTSQueryControlBlock
40451>>>>>>>    Boolean bCompiled
40451>>>>>>>    Boolean bInitialized
40451>>>>>>>
40451>>>>>>>    // How much do we prefer to limit the number of finds performed against the
40451>>>>>>>    // database over not having to sort all the selected rows in an array?
40451>>>>>>>    //
40451>>>>>>>    // A value of 0.1 (its default value) indicates that we are willing to accept
40451>>>>>>>    // 10 times more finds to not have to prefetch the whole set. A value of 1
40451>>>>>>>    // would mean that we are not willing to perform any unnecessary finds and
40451>>>>>>>    // thus prefetching would only occur if absolutely necessary.
40451>>>>>>>    //
40451>>>>>>>    // (actually it might make sense to set it according to the computing power or the
40451>>>>>>>    // network speed of the client and the expected size of the result set)
40451>>>>>>>    //
40451>>>>>>>    // If you set it higher than 1 it will prefer prefetch indices for no good
40451>>>>>>>    // reason (so don't do that).
40451>>>>>>>
40451>>>>>>>    Number nPrefetchAvoidanceFactor // Default assigned by NewQuery is 0.1
40451>>>>>>>
40451>>>>>>>    Integer iFindCount
40451>>>>>>>    Integer iSelectCount
40451>>>>>>>
40451>>>>>>>    Boolean bFirstRecord
40451>>>>>>>
40451>>>>>>>    Boolean bBreakScan
40451>>>>>>>    String sLogTag
40451>>>>>>>
40451>>>>>>>    Integer iCursor
40451>>>>>>>
40451>>>>>>>    Boolean[] aRelatedRecords // True if the same index in the aTableRelations array has already been executed
40451>>>>>>>
40451>>>>>>>    Integer iQueryMethod // tqDataFlex, tqSQLPKG or tqMERTECHINC
40451>>>>>>>    tSQLStatementHandle strSQLStatementHandle
40451>>>>>>>    tSQLStatementHandle strSQLStatementHandle
40451>>>>>>>    Boolean bSQLTableIsAnsi
40451>>>>>>>    tTQPrefetchCacheControl strSQLCacheControl
40451>>>>>>>    tTQPrefetchCacheControl strSQLCacheControl
40451>>>>>>>    tTQPrefetchCacheControl _strPreviousSQLCacheControl // Used to push the cache settings and restore previous value upon loop exit
40451>>>>>>>    tTQPrefetchCacheControl _strPreviousSQLCacheControl // Used to push the cache settings and restore previous value upon loop exit
40451>>>>>>>
40451>>>>>>>    _tTQInnerJoinControlBlock strInnerJoinCB
40451>>>>>>>    _tTQInnerJoinControlBlock strInnerJoinCB
40451>>>>>>>
40451>>>>>>>    Boolean bFilterExpressionActive
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>Enum_List // Query methods
40451>>>>>>>    Define tqDATAFLEX
40451>>>>>>>    Define tqSQLPKG
40451>>>>>>>    Define tqMERTECHINC
40451>>>>>>>End_Enum_List
40451>>>>>>>
40451>>>>>>>Struct tTSQueryCompiled
40451>>>>>>>    Integer iIndex
40451>>>>>>>    Boolean bBackwards
40451>>>>>>>
40451>>>>>>>    Number nENR // Expected number of rows according to iIndex. If nENR is zero the index is fully specified
40451>>>>>>>
40451>>>>>>>    Boolean bPrefetch
40451>>>>>>>    Boolean bIndexSeedSharpeningEnabled
40451>>>>>>>    Integer _iLimit
40451>>>>>>>    Integer _iPushLimit
40451>>>>>>>    tTQFilterSegment[] aJumpInValues
40451>>>>>>>    tTQFilterSegment[] aJumpInValues
40451>>>>>>>    tTQFilterSegment[] aJumpOutValues
40451>>>>>>>    tTQFilterSegment[] aJumpOutValues
40451>>>>>>>    tTQFilterSegment[] aOtherConditions // Non optimized conditions
40451>>>>>>>    tTQFilterSegment[] aOtherConditions // Non optimized conditions
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>//> The supreme struct!
40451>>>>>>>Struct tTableQuery
40451>>>>>>>    Integer iTable
40451>>>>>>>
40451>>>>>>>    Boolean bNoESQL            //> If true: Do not use ESQL even if SQL table.
40451>>>>>>>    Boolean bForcePrefetch     //> If true: Force finding of all rows before FindRecord loop execution.
40451>>>>>>>    Integer iForceIndex        //> If you don't care what the query analyzer says, you may force the table scan to be performed by this index (-1 means no force)
40451>>>>>>>    Integer iLimit             //> Limits the amount of rows returned by the loop
40451>>>>>>>    String  sForceSQLTableName //> Use this table name when generating ESQL (over the default value from filelist.cfg)
40451>>>>>>>    String  sForceSQLStatement //> DANGER! Use this to completely overtake the SQL generated by TQ. It's your responsability then that the columns of the result set are in synch with what TQ expects (qua the result set specification).
40451>>>>>>>    // Select:
40451>>>>>>>    _tTQValueSource[]     aColumnSources //> If this array is empty TQ will by default activate the iTable buffer.
40451>>>>>>>    _tTQValueSource[]     aColumnSources //> If this array is empty TQ will by default activate the iTable buffer.
40451>>>>>>>    _tTQValueSource[]     aOutputColumns //> This array contains a copy of the items added to aColumnSources that are column specific. The order of the columns will be identical to the order in which they were added
40451>>>>>>>    _tTQValueSource[]     aOutputColumns //> This array contains a copy of the items added to aColumnSources that are column specific. The order of the columns will be identical to the order in which they were added
40451>>>>>>>    Boolean               _bOutputColumnsFixated 
40451>>>>>>>    Boolean               bRestoreRecordBuffersOnQueryCompletion
40451>>>>>>>    // Where:
40451>>>>>>>    tTQFilterSegment[] aFilters //> Segments are and'ed
40451>>>>>>>    tTQFilterSegment[] aFilters //> Segments are and'ed
40451>>>>>>>    // Where (for filterexpressions):
40451>>>>>>>    tTQFilterExpression[] aFilterExpressions //> are of course also and'ed if there are more of them
40451>>>>>>>    tTQFilterExpression[] aFilterExpressions //> are of course also and'ed if there are more of them
40451>>>>>>>    // Order by:
40451>>>>>>>    tTQOrderBySegment[]   aOrdering
40451>>>>>>>    tTQOrderBySegment[]   aOrdering
40451>>>>>>>    // House keeping:
40451>>>>>>>    tTSQueryCompiled      _strCompiled
40451>>>>>>>    tTSQueryCompiled      _strCompiled
40451>>>>>>>    tTSQueryControlBlock  _strControlBlock
40451>>>>>>>    tTSQueryControlBlock  _strControlBlock
40451>>>>>>>    tTQResultSet          strResultSet
40451>>>>>>>    tTQResultSet          strResultSet
40451>>>>>>>
40451>>>>>>>    tTQTableRelation[]    aTableRelations //> Defines relations to parent tables
40451>>>>>>>    tTQTableRelation[]    aTableRelations //> Defines relations to parent tables
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>Struct _tTQIndexRating
40451>>>>>>>    Integer iIndex
40451>>>>>>>    Number  nExpectedNumberRows // With the filters supplied, how many rows can we expect to find by this index.
40451>>>>>>>    Boolean bOutputAgree // Does the index agree with the output order specified?
40451>>>>>>>    Integer iKeyLevels
40451>>>>>>>    Integer iKeyLength // A short key length might rate better if everything else was equal.
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>Struct _tTQIndexAnalysis
40451>>>>>>>    Number[] aSegmentReductions
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>Struct tTQTableAnalysis
40451>>>>>>>    Boolean bInitialized
40451>>>>>>>    DateTime dtAnalysisDateTime
40451>>>>>>>    Number nNumberOfRecords
40451>>>>>>>    _tTQIndexAnalysis[] aIndices
40451>>>>>>>    _tTQIndexAnalysis[] aIndices
40451>>>>>>>    String sTimeToComplete
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>Struct tTQTableMeta
40451>>>>>>>    Integer   _iIsInitialized
40451>>>>>>>    Integer[] aIndices // Indices to scan
40451>>>>>>>End_Struct
40451>>>>>>>
40451>>>>>>>Global_Variable tTQTableAnalysis[]  _gTQaTableAnalysis
40451>>>>>>>Global_Variable tTQTableMeta[]      _gTQaTableMeta
40451>>>>>>>
40451>>>>>>>Global_Variable Integer _giTQLogState // 0=No logging, 1=Log when LogTag'ed, 2=Log always
40451>>>>>>>Global_Variable Integer[] _gaTQLogTables
40451>>>>>>>
40451>>>>>>>Procedure Set TableQuery_LogState Global Integer iState
40453>>>>>>>    Move iState to _giTQLogState
40454>>>>>>>End_Procedure
40455>>>>>>>
40455>>>>>>>Class cTableQuerySQL is a cObject // Generates an SQL statement
40456>>>>>>>    Procedure Construct_Object
40458>>>>>>>        Forward Send Construct_Object
40460>>>>>>>        Property String psCollation "Latin1_General_BIN" // Or maybe "SQL_Latin1_CP850_BIN"? Who knows?
40461>>>>>>>    End_Procedure
40462>>>>>>>
40462>>>>>>>        Function _SQL_ColumnName tTableQuery strQ Integer hoTQ Integer iTable Integer iColumn Returns String
40464>>>>>>>            String sValue
40464>>>>>>>            Get ColumnName of hoTQ strQ iTable iColumn True to sValue
40465>>>>>>>            Function_Return sValue
40466>>>>>>>        End_Function
40467>>>>>>>
40467>>>>>>>        Function _SQL_TableName tTableQuery strQ Integer hoTQ Integer iTable Returns String
40469>>>>>>>            String sValue
40469>>>>>>>            Get TableName of hoTQ strQ iTable to sValue
40470>>>>>>>            Move ("["+sValue+"]") to sValue
40471>>>>>>>            Function_Return sValue
40472>>>>>>>        End_Function
40473>>>>>>>
40473>>>>>>>        Function _SQL_SelectColumns tTableQuery strQ Integer hoTQ Returns String
40475>>>>>>>            Integer iMax iItem iTable iColumn
40475>>>>>>>            String sColumnList sColumnName sTableName
40475>>>>>>>            Move (SizeOfArray(strQ.aColumnSources)-1) to iMax
40476>>>>>>>            If (iMax>=0) Begin
40478>>>>>>>                For iItem from 0 to iMax
40484>>>>>>>>
40484>>>>>>>                    If (iItem<>0) Begin
40486>>>>>>>                        Move (sColumnList+",") to sColumnList
40487>>>>>>>                    End
40487>>>>>>>>
40487>>>>>>>                    Move strQ.aColumnSources[iItem].iTable to iTable
40488>>>>>>>                    Move strQ.aColumnSources[iItem].iColumn to iColumn
40489>>>>>>>
40489>>>>>>>                    If (iColumn<>0) Begin
40491>>>>>>>                        Get _SQL_ColumnName strQ hoTQ iTable iColumn to sColumnName
40492>>>>>>>                    End
40492>>>>>>>>
40492>>>>>>>                    Else Begin
40493>>>>>>>                        Get TableName of hoTQ strQ iTable to sTableName
40494>>>>>>>                        Move (sTableName+".*") to sColumnName
40495>>>>>>>                    End
40495>>>>>>>>
40495>>>>>>>                    Move (sColumnList+sColumnName) to sColumnList
40496>>>>>>>                Loop
40497>>>>>>>>
40497>>>>>>>            End
40497>>>>>>>>
40497>>>>>>>            Else Begin
40498>>>>>>>                Move "*" to sColumnList
40499>>>>>>>            End
40499>>>>>>>>
40499>>>>>>>            Function_Return sColumnList
40500>>>>>>>        End_Function
40501>>>>>>>
40501>>>>>>>            Procedure _SQL_OuterLeftJoin_AddSegments tTableQuery strQ Integer hoTQ String ByRef sFromTables Integer iRelateItem
40503>>>>>>>                Integer iItem iItemMax
40503>>>>>>>                String sColumnName sComp
40503>>>>>>>                tTQTableRelation strRelation
40503>>>>>>>                tTQTableRelation strRelation
40503>>>>>>>                Move strQ.aTableRelations[iRelateItem] to strRelation
40504>>>>>>>                Move (SizeOfArray(strRelation.aSegments)-1) to iItemMax
40505>>>>>>>                For iItem from 0 to iItemMax
40511>>>>>>>>
40511>>>>>>>                    If (iItem<>0) Begin
40513>>>>>>>                        Move (sFromTables+" AND") to sFromTables
40514>>>>>>>                    End
40514>>>>>>>>
40514>>>>>>>                    Get _SQL_ColumnName strQ hoTQ strRelation.aSegments[iItem].iSourceTable strRelation.aSegments[iItem].iSourceColumn to sColumnName
40515>>>>>>>                    Move (sFromTables*sColumnName) to sFromTables
40516>>>>>>>
40516>>>>>>>                    Get _SQL_WhereClauseComperator strRelation.aSegments[iItem].iInnerJoinComp False to sComp
40517>>>>>>>                    Move (sFromTables*sComp) to sFromTables
40518>>>>>>>
40518>>>>>>>                    Get _SQL_ColumnName strQ hoTQ strRelation.iTargetTable strRelation.aSegments[iItem].iTargetColumn to sColumnName
40519>>>>>>>                    Move (sFromTables*sColumnName) to sFromTables
40520>>>>>>>                Loop
40521>>>>>>>>
40521>>>>>>>            End_Procedure
40522>>>>>>>
40522>>>>>>>            //select f.foo
40522>>>>>>>            //     , b.bar
40522>>>>>>>            //     , q.qux
40522>>>>>>>            //  from footable as f
40522>>>>>>>            //left outer
40522>>>>>>>            //  join bartable as b
40522>>>>>>>            //    on f.id = b.fid
40522>>>>>>>            //left outer
40522>>>>>>>            //  join quxtable as q
40522>>>>>>>            //    on b.id = q.bid
40522>>>>>>>
40522>>>>>>>        Function _SQL_OuterLeftJoins tTableQuery strQ Integer hoTQ Returns String
40524>>>>>>>            Integer iItem iItemMax
40524>>>>>>>            String sFromTables sTableName
40524>>>>>>>            Get TableName of hoTQ strQ strQ.iTable to sFromTables
40525>>>>>>>
40525>>>>>>>            Move (SizeOfArray(strQ.aTableRelations)-1) to iItemMax
40526>>>>>>>            For iItem from 0 to iItemMax
40532>>>>>>>>
40532>>>>>>>                If (not(strQ.aTableRelations[iItem].bFixed)) Begin
40534>>>>>>>                    Get _SQL_TableName strQ hoTQ strQ.aTableRelations[iItem].iTargetTable to sTableName
40535>>>>>>>                    Move (sFromTables+" left outer join"*sTableName+" on (") to sFromTables
40536>>>>>>>                    Send _SQL_OuterLeftJoin_AddSegments strQ hoTQ (&sFromTables) iItem
40537>>>>>>>                    Move (sFromTables+")") to sFromTables
40538>>>>>>>                End
40538>>>>>>>>
40538>>>>>>>            Loop
40539>>>>>>>>
40539>>>>>>>            Function_Return sFromTables
40540>>>>>>>        End_Function
40541>>>>>>>
40541>>>>>>>        Function _SQL_InnerJoins tTableQuery strQ Integer hoTQ Returns String
40543>>>>>>>            Integer iItem iItemMax
40543>>>>>>>            String sFromTables sTableName
40543>>>>>>>
40543>>>>>>>            Move (SizeOfArray(strQ.aTableRelations)-1) to iItemMax
40544>>>>>>>            For iItem from 0 to iItemMax
40550>>>>>>>>
40550>>>>>>>                If (strQ.aTableRelations[iItem].bInnerJoin) Begin
40552>>>>>>>                    Get _SQL_TableName strQ hoTQ strQ.aTableRelations[iItem].iTargetTable to sTableName
40553>>>>>>>                    Move (sFromTables+" inner join"*sTableName+" on (") to sFromTables
40554>>>>>>>                    Send _SQL_OuterLeftJoin_AddSegments strQ hoTQ (&sFromTables) iItem
40555>>>>>>>                    Move (sFromTables+")") to sFromTables
40556>>>>>>>                End
40556>>>>>>>>
40556>>>>>>>            Loop
40557>>>>>>>>
40557>>>>>>>            Function_Return sFromTables
40558>>>>>>>        End_Function
40559>>>>>>>
40559>>>>>>>            Function _SQL_WhereClauseComperator Integer iComp Boolean bIn Returns String
40561>>>>>>>                If (bIn) Begin
40563>>>>>>>                    Function_Return " in "
40564>>>>>>>                End
40564>>>>>>>>
40564>>>>>>>                If (iComp=tqLT) Function_Return "<"
40567>>>>>>>                If (iComp=tqLE) Function_Return "<="
40570>>>>>>>                If (iComp=tqEQ) Function_Return "="
40573>>>>>>>                If (iComp=tqGE) Function_Return ">="
40576>>>>>>>                If (iComp=tqGT) Function_Return ">"
40579>>>>>>>                If (iComp=tqNE) Function_Return "<>"
40582>>>>>>>                If (iComp=tqMATCH) Function_Return " like " // This can't be guaranteed on SQL. or what?
40585>>>>>>>                If (iComp=tqUCMATCH) Function_Return " like "
40588>>>>>>>//                If (iComp=tqCONTAINS) Function_Return "contains"
40588>>>>>>>                Function_Return "error"
40589>>>>>>>            End_Function
40590>>>>>>>
40590>>>>>>>                Function EscapeStringConstant String sValue Returns String
40592>>>>>>>                    Function_Return (Replaces("'",sValue,"''")) // cross fingers
40593>>>>>>>                End_Function
40594>>>>>>>
40594>>>>>>>            Function _SQL_WhereClauseValue tTableQuery strQ Integer hoTQ Integer iComp _tTQValueSource strValue Returns String
40596>>>>>>>                Boolean bFixed bDoValue
40596>>>>>>>                Integer iMax iItem
40596>>>>>>>                String sValue sColumnName sSQLdate
40596>>>>>>>                If (iComp=tqEQ and SizeOfArray(strValue.aOrList)<>0) Begin // IN
40598>>>>>>>                    Move (SizeOfArray(strValue.aOrList)-1) to iMax
40599>>>>>>>                    Move "(" to sValue
40600>>>>>>>                    For iItem from 0 to iMax
40606>>>>>>>>
40606>>>>>>>
40606>>>>>>>                        If (iItem>0) Begin
40608>>>>>>>                            Move (sValue+",") to sValue
40609>>>>>>>                        End
40609>>>>>>>>
40609>>>>>>>
40609>>>>>>>                        If (strValue.iType=tqSTRING or strValue.iType=tqTEXT) Begin
40611>>>>>>>                            Move (sValue+"'"+EscapeStringConstant(Self,strValue.aOrList[iItem])+"'") to sValue
40612>>>>>>>                        End
40612>>>>>>>>
40612>>>>>>>                        Else If (strValue.iType=tqDATE or strValue.iType=tqDATETIME) Begin
40615>>>>>>>                            Get DFDateToSQLDate of strQ._strControlBlock.strSQLStatementHandle.hHandle (Date(strValue.aOrList[iItem])) to sSQLdate
40616>>>>>>>                            Move (sValue+"'"+sSQLdate+"'") to sValue
40617>>>>>>>                        End
40617>>>>>>>>
40617>>>>>>>                        Else Begin
40618>>>>>>>                            Move (sValue+strValue.aOrList[iItem]) to sValue
40619>>>>>>>                        End
40619>>>>>>>>
40619>>>>>>>                    Loop
40620>>>>>>>>
40620>>>>>>>                    Move (sValue+")") to sValue
40621>>>>>>>                End
40621>>>>>>>>
40621>>>>>>>                Else Begin
40622>>>>>>>                    Move True to bDoValue
40623>>>>>>>                    If (strValue.iTable<>0) Begin
40625>>>>>>>                        Get _IsTableFixed of hoTQ strQ strValue.iTable to bFixed
40626>>>>>>>                        If (not(bFixed)) Begin
40628>>>>>>>                            Get _SQL_ColumnName strQ hoTQ strValue.iTable strValue.iColumn to sColumnName
40629>>>>>>>                            Move sColumnName to sValue
40630>>>>>>>                            Move False to bDoValue
40631>>>>>>>                        End
40631>>>>>>>>
40631>>>>>>>                    End
40631>>>>>>>>
40631>>>>>>>                    If (bDoValue) Begin // Either it's a constant or it's a fixed table:
40633>>>>>>>                        Get _ValueSourceValue of hoTQ (&strQ) strValue to sValue
40634>>>>>>>
40634>>>>>>>                        If (iComp=tqMATCH or iComp=tqUCMATCH) Begin
40636>>>>>>>                            Move (Replaces("%",sValue,"\%")) to sValue // Escape all SQL wildcard patterns
40637>>>>>>>                            Move (Replaces("_",sValue,"\_")) to sValue // that happens to be in the string
40638>>>>>>>                            Move (Replaces("[",sValue,"\[")) to sValue // by chance.
40639>>>>>>>                            Move (Replaces("]",sValue,"\]")) to sValue
40640>>>>>>>                            Move (Replaces("*",sValue,"%")) to sValue  // Replace our own * and ? wildcards
40641>>>>>>>                            Move (Replaces("?",sValue,"_")) to sValue  // with their SQL counterparts.
40642>>>>>>>                            If (iComp=tqUCMATCH) Begin
40644>>>>>>>                                Move (Uppercase(sValue)) to sValue
40645>>>>>>>                            End
40645>>>>>>>>
40645>>>>>>>                        End
40645>>>>>>>>
40645>>>>>>>
40645>>>>>>>                        If (strValue.iType=tqSTRING or strValue.iType=tqTEXT) Begin
40647>>>>>>>                            Move ("'"+EscapeStringConstant(Self,sValue)+"'") to sValue
40648>>>>>>>                        End
40648>>>>>>>>
40648>>>>>>>                        Else If (strValue.iType=tqDATE or strValue.iType=tqDATETIME) Begin
40651>>>>>>>                            Get DFDateToSQLDate of strQ._strControlBlock.strSQLStatementHandle.hHandle (Date(sValue)) to sValue
40652>>>>>>>                            Move ("'"+sValue+"'") to sValue
40653>>>>>>>                        End
40653>>>>>>>>
40653>>>>>>>
40653>>>>>>>                        If (iComp=tqMATCH or iComp=tqUCMATCH) Begin
40655>>>>>>>                            Move (sValue*"ESCAPE '\'") to sValue // tell mssql that the pattern has been escaped with the "\" character.
40656>>>>>>>                        End
40656>>>>>>>>
40656>>>>>>>                    End
40656>>>>>>>>
40656>>>>>>>                End
40656>>>>>>>>
40656>>>>>>>                Function_Return sValue
40657>>>>>>>            End_Function
40658>>>>>>>
40658>>>>>>>            Function _SQL_WhereClauseSegment tTableQuery strQ tTQFilterSegment strSegment Integer hoTQ Returns String
40660>>>>>>>                Integer iTable iColumn
40660>>>>>>>                Boolean bIn
40660>>>>>>>                String sValue
40660>>>>>>>                Move strSegment.strLeftValue.iTable to iTable
40661>>>>>>>                Move strSegment.strLeftValue.iColumn to iColumn
40662>>>>>>>                Get _SQL_ColumnName strq hoTQ iTable iColumn to sValue
40663>>>>>>>
40663>>>>>>>                Move (SizeOfArray(strSegment.strRightValue.aOrList)<>0) to bIn
40664>>>>>>>                Move (sValue+_SQL_WhereClauseComperator(Self,strSegment.iComp,bIn)) to sValue
40665>>>>>>>
40665>>>>>>>                Move (sValue+_SQL_WhereClauseValue(Self,strQ,hoTQ,strSegment.iComp,strSegment.strRightValue)) to sValue
40666>>>>>>>                Function_Return sValue
40667>>>>>>>            End_Function
40668>>>>>>>
40668>>>>>>>            Function _SQL_WhereClauseExpressionSegment tTableQuery strQ tTQFilterExpression[] aSegments Integer hoTQ Returns String
40670>>>>>>>                Integer iItem iItemMax
40670>>>>>>>                String sValue
40670>>>>>>>                Move (SizeOfArray(aSegments)-1) to iItemMax
40671>>>>>>>                For iItem from 0 to iItemMax
40677>>>>>>>>
40677>>>>>>>                    If (iItem>0) Begin
40679>>>>>>>                        If (aSegments[iItem-1].iAndOr=tqKeyAND) Begin
40681>>>>>>>                            Move (sValue*"AND") to sValue
40682>>>>>>>                        End
40682>>>>>>>>
40682>>>>>>>                        Else If (aSegments[iItem-1].iAndOr=tqKeyOR) Begin
40685>>>>>>>                            Move (sValue*"OR") to sValue
40686>>>>>>>                        End
40686>>>>>>>>
40686>>>>>>>                        Else Begin
40687>>>>>>>                            Send OnError 738 "Illegal operator in where clause expression"
40688>>>>>>>                        End
40688>>>>>>>>
40688>>>>>>>                    End
40688>>>>>>>>
40688>>>>>>>                    If (aSegments[iItem].bNot) Begin
40690>>>>>>>                        Move (sValue*"NOT") to sValue
40691>>>>>>>                    End
40691>>>>>>>>
40691>>>>>>>                    If (SizeOfArray(aSegments[iItem].aSubExpressions)>0) Begin
40693>>>>>>>                        Move (sValue*_SQL_WhereClauseExpressionSegment(Self,strQ,aSegments[iItem].aSubExpressions,hoTQ)) to sValue
40694>>>>>>>                    End
40694>>>>>>>>
40694>>>>>>>                    Else Begin
40695>>>>>>>                        Move (sValue*_SQL_WhereClauseSegment(Self,strQ,aSegments[iItem].strOperand,hoTQ)) to sValue
40696>>>>>>>                    End
40696>>>>>>>>
40696>>>>>>>                Loop
40697>>>>>>>>
40697>>>>>>>                Function_Return ("("+Trim(sValue)+")")
40698>>>>>>>            End_Function
40699>>>>>>>
40699>>>>>>>        Function _SQL_WhereClause tTableQuery strQ Integer hoTQ Returns String
40701>>>>>>>            Integer iMax iItem
40701>>>>>>>            Boolean bAddAND
40701>>>>>>>            String sValue
40701>>>>>>>            Move (SizeOfArray(strQ.aFilters)-1) to iMax
40702>>>>>>>            For iItem from 0 to iMax
40708>>>>>>>>
40708>>>>>>>                If (iItem<>0) Begin
40710>>>>>>>                    Move (sValue*"and") to sValue
40711>>>>>>>                End
40711>>>>>>>>
40711>>>>>>>                Move (sValue*_SQL_WhereClauseSegment(Self,strQ,strQ.aFilters[iItem],hoTQ)) to sValue
40712>>>>>>>            Loop
40713>>>>>>>>
40713>>>>>>>            Move (iMax>=0) to bAddAND
40714>>>>>>>            Move (SizeOfArray(strQ.aFilterExpressions)-1) to iMax
40715>>>>>>>            For iItem from 0 to iMax
40721>>>>>>>>
40721>>>>>>>                If (iItem>0 or bAddAND) Begin
40723>>>>>>>                    Move (sValue*"and") to sValue
40724>>>>>>>                End
40724>>>>>>>>
40724>>>>>>>                Move (sValue*_SQL_WhereClauseExpressionSegment(Self,strQ,strQ.aFilterExpressions[iItem].aSubExpressions,hoTQ)) to sValue
40725>>>>>>>            Loop
40726>>>>>>>>
40726>>>>>>>            Function_Return sValue
40727>>>>>>>        End_Function
40728>>>>>>>
40728>>>>>>>        Function _SQL_OrderByClause tTableQuery strQ Integer hoTQ Returns String
40730>>>>>>>            Integer iItem iMax iTable iColumn
40730>>>>>>>            String sValue sColumnName
40730>>>>>>>            Move (SizeOfArray(strQ.aOrdering)-1) to iMax
40731>>>>>>>            For iItem from 0 to iMax
40737>>>>>>>>
40737>>>>>>>                If (iItem<>0) Begin
40739>>>>>>>                    Move (sValue+", ") to sValue
40740>>>>>>>                End
40740>>>>>>>>
40740>>>>>>>                Move strQ.aOrdering[iItem].strValueSource.iTable to iTable
40741>>>>>>>                Move strQ.aOrdering[iItem].strValueSource.iColumn to iColumn
40742>>>>>>>                Get _SQL_ColumnName strQ hoTQ iTable iColumn to sColumnName
40743>>>>>>>                Move (sValue+sColumnName) to sValue
40744>>>>>>>                If (strQ.aOrdering[iItem].strValueSource.iType=tqSTRING) Begin
40746>>>>>>>                    Move (sValue+" collate "+psCollation(Self)) to sValue
40747>>>>>>>                End
40747>>>>>>>>
40747>>>>>>>                If (strQ.aOrdering[iItem].bDescending) Begin
40749>>>>>>>                    Move (sValue*"DESC") to sValue
40750>>>>>>>                End
40750>>>>>>>>
40750>>>>>>>                // ToDo: uppercase ordering
40750>>>>>>>//                If (strQ.aOrdering[iItem].bUppercase) Begin
40750>>>>>>>//                    // Somethings wrong here. And it's not the 'lower' instead of 'upper'
40750>>>>>>>//                    Move (sValue*"lower("+sValue+")") to sValue
40750>>>>>>>//                End
40750>>>>>>>            Loop
40751>>>>>>>>
40751>>>>>>>            Function_Return sValue
40752>>>>>>>        End_Function
40753>>>>>>>
40753>>>>>>>    Function _SQLSelectStatement tTableQuery strQ Integer hoTQ Returns String
40755>>>>>>>        String sStatement
40755>>>>>>>
40755>>>>>>>        Move "select" to sStatement
40756>>>>>>>
40756>>>>>>>        If (strQ.iLimit>0) Begin
40758>>>>>>>            Move (sStatement*"top "+String(strQ.iLimit)) to sStatement
40759>>>>>>>        End
40759>>>>>>>>
40759>>>>>>>        If (strQ.iLimit<0) Begin
40761>>>>>>>            Move (sStatement*"bottom "+String(0-strQ.iLimit)) to sStatement
40762>>>>>>>        End
40762>>>>>>>>
40762>>>>>>>
40762>>>>>>>        Move (sStatement*_SQL_SelectColumns(Self,strQ,hoTQ)) to sStatement
40763>>>>>>>
40763>>>>>>>        Move (sStatement*" from") to sStatement
40764>>>>>>>
40764>>>>>>>        Move (sStatement*_SQL_OuterLeftJoins(Self,strQ,hoTQ)) to sStatement // related records
40765>>>>>>>
40765>>>>>>>        Move (sStatement*_SQL_InnerJoins(Self,strQ,hoTQ)) to sStatement // find child records for each parent
40766>>>>>>>
40766>>>>>>>        If (SizeOfArray(strQ.aFilters)<>0 or SizeOfArray(strQ.aFilterExpressions)<>0) Begin
40768>>>>>>>            Move (sStatement*" where") to sStatement
40769>>>>>>>            Move (sStatement*_SQL_WhereClause(Self,strQ,hoTQ)) to sStatement
40770>>>>>>>        End
40770>>>>>>>>
40770>>>>>>>        If (SizeOfArray(strQ.aOrdering)<>0) Begin
40772>>>>>>>            Move (sStatement*" order by") to sStatement
40773>>>>>>>            Move (sStatement*_SQL_OrderByClause(Self,strQ,hoTQ)) to sStatement
40774>>>>>>>        End
40774>>>>>>>>
40774>>>>>>>        Function_Return sStatement
40775>>>>>>>    End_Function
40776>>>>>>>
40776>>>>>>>    Function _SQLDeleteStatement tTableQuery strQ Integer hoTQ Returns String
40778>>>>>>>        String sStatement
40778>>>>>>>
40778>>>>>>>        Move "delete" to sStatement
40779>>>>>>>
40779>>>>>>>//        If (strQ.iLimit<>0) Begin
40779>>>>>>>//            Send OnError 742 "Limit not allowed on delete statement"
40779>>>>>>>//            Function_Return "" // Error
40779>>>>>>>//        End
40779>>>>>>>//        
40779>>>>>>>//        If (SizeOfArray(strQ.aColumnSources)>0) Begin
40779>>>>>>>//            Send OnError 743 "Result column not allowed on delete statement"
40779>>>>>>>//            Function_Return "" // Error
40779>>>>>>>//        End
40779>>>>>>>
40779>>>>>>>        Move (sStatement*" from") to sStatement
40780>>>>>>>
40780>>>>>>>        Move (sStatement*_SQL_OuterLeftJoins(Self,strQ,hoTQ)) to sStatement // related records
40781>>>>>>>
40781>>>>>>>        Move (sStatement*_SQL_InnerJoins(Self,strQ,hoTQ)) to sStatement // find child records for each parent
40782>>>>>>>
40782>>>>>>>        If (SizeOfArray(strQ.aFilters)<>0 or SizeOfArray(strQ.aFilterExpressions)<>0) Begin
40784>>>>>>>            Move (sStatement*" where") to sStatement
40785>>>>>>>            Move (sStatement*_SQL_WhereClause(Self,strQ,hoTQ)) to sStatement
40786>>>>>>>        End
40786>>>>>>>>
40786>>>>>>>
40786>>>>>>>//        If (SizeOfArray(strQ.aOrdering)>0) Begin
40786>>>>>>>//            Send OnError 744 "Ordering not allowed on delete statement"
40786>>>>>>>//            Function_Return "" // Error
40786>>>>>>>//        End
40786>>>>>>>
40786>>>>>>>        Function_Return sStatement
40787>>>>>>>    End_Function
40788>>>>>>>End_Class
40789>>>>>>>
40789>>>>>>>Class cTableQueryFunctions is a cObject
40790>>>>>>>
40790>>>>>>>    Procedure Construct_Object
40792>>>>>>>        Forward Send Construct_Object
40794>>>>>>>
40794>>>>>>>        Property Number _pnPrefetchAvoidanceFactor // Temporary property used by index rating sort algorithm
40795>>>>>>>
40795>>>>>>>        Object oSQLGeneratorMSSQLDRV is a cTableQuerySQL
40797>>>>>>>        End_Object
40798>>>>>>>
40798>>>>>>>        Property Handle phoSQLGeneratorMSSQLDRC (oSQLGeneratorMSSQLDRV(Self))
40799>>>>>>>    End_Procedure
40800>>>>>>>
40800>>>>>>>    Function Version Returns String
40802>>>>>>>// Function_Return "0.96" // 9-05-2012
40802>>>>>>>        // Fixed error in MSSQLDRV SQL generating when an ordering segment is both ASCII and descending
40802>>>>>>>        // Removed timing and track of current-record
40802>>>>>>>// Function_Return "0.97" // 10-05-2012
40802>>>>>>>        // Addded methods ResetResultSetColumns and ResetOrdering
40802>>>>>>>        // Fixed seeding error on backwards ASCII columns
40802>>>>>>>        // Bug in ResultColumnValue function fixed
40802>>>>>>>        // Bug in _FindFirstRecordAux function fixed (related to 'VFind GE')
40802>>>>>>>        // SQL handling of dates repaired
40802>>>>>>>        // Parent column filter bugfix. No longer ends up in jump-in/out filters by accident
40802>>>>>>>        // Fixed _ValidateQuery to correctly complain about over-constrain on parent table columns
40802>>>>>>>        // Public function SQLStatement renamed to SQLSelectStatement
40802>>>>>>>// Function_Return "0.98" // 29-11-2012
40802>>>>>>>        // SQL date handling is now also effective if column type is DF_DATETIME (may go wrong if value also has a time part)
40802>>>>>>>        // Implementation of private function _DeleteConstraint changed (old one still there for 15.1)
40802>>>>>>>        // Method DeleteRecords added (ignore, not tested)
40802>>>>>>>// Function_Return "0.99" // 04-04-2013
40802>>>>>>>        // Fixed bug in AddFilterTableColumn method.
40802>>>>>>>        // Comperators tqCONTAINS and tqIN have been removed.
40802>>>>>>>        // Filter evaluating for index seeding capacitance has been fixed. Until now filters on parent tables may have wronged the index selection process.
40802>>>>>>>        // Error handling changed. All errors are now declared as DFERR_PROGRAM. If cTableQueryFunctions is subclassed procedure OnError may be augmented to do otherwise.
40802>>>>>>>        // Function HasData was designed to check for data before the main finding loop was entered. It may now also meaningfully be called after the main loop to query if the loop had any data at all.
40802>>>>>>>        // Function FixedTables added. Returns an array of tables that are referenced as "fixed" during the execution of a query. So if I want to repeat the find loop of a particular tTableQuery variable at a later time, the record buffers of these fixed tables must be restored to that of the original query. Does this make sense?
40802>>>>>>>        // Similarly NotFixedTables has been added.
40802>>>>>>>        // Function Belongs added. Returns true if the record currently in the buffer of the query main table evaluates true against the filters of query variable passed.
40802>>>>>>>        // Procedure RestoreRecordBuffersOnQueryCompletion added. Use to have TQ restore all affected record buffers on find loop completion.
40802>>>>>>>// Function_Return "0.991" // 25-09-2013
40802>>>>>>>        Function_Return "0.992"
40803>>>>>>>    End_Function
40804>>>>>>>
40804>>>>>>>    Function NewQuery Integer iTable Returns tTableQuery
40806>>>>>>>        Integer iFilterTable iArg
40806>>>>>>>        tTableQuery strQuery
40806>>>>>>>        tTableQuery strQuery
40806>>>>>>>        Move iTable to strQuery.iTable
40807>>>>>>>        Move -1     to strQuery.iForceIndex
40808>>>>>>>        Move False  to strQuery.bForcePrefetch
40809>>>>>>>        Move False  to strQuery.bNoESQL
40810>>>>>>>        Move False  to strQuery.bRestoreRecordBuffersOnQueryCompletion
40811>>>>>>>        Move False  to strQuery._strControlBlock.bInitialized
40812>>>>>>>        Move False  to strQuery._strControlBlock.bCompiled
40813>>>>>>>        Move -1     to strQuery._strControlBlock.iQueryMethod
40814>>>>>>>        Move 0.1    to strQuery._strControlBlock.nPrefetchAvoidanceFactor
40815>>>>>>>        Move False  to strQuery._strControlBlock.strInnerJoinCB.bEnabled // (CB=Control Block)
40816>>>>>>>        Move False  to strQuery._strControlBlock.strInnerJoinCB.bInitialized
40817>>>>>>>        Move False  to strQuery._strControlBlock.bFilterExpressionActive
40818>>>>>>>        Move True   to strQuery._strCompiled.bIndexSeedSharpeningEnabled
40819>>>>>>>        Move False  to strQuery._strCompiled.bBackwards
40820>>>>>>>        Move -1     to strQuery._strCompiled.nENR
40821>>>>>>>        Move False  to strQuery._bOutputColumnsFixated
40822>>>>>>>        Send ReadTableDefinition of oOverlapColumnFunctions iTable // Make sure that oOverlapColumnFunctions knows about this table
40823>>>>>>>        If (num_arguments>1) Begin // For a while multiple parameters was allowed. Therefore this. Also for a while.
40825>>>>>>>            Error 343 "TQ: Illegal call to NewQuery"
40826>>>>>>>>
40826>>>>>>>        End
40826>>>>>>>>
40826>>>>>>>        Function_Return strQuery
40827>>>>>>>    End_Function
40828>>>>>>>    
40828>>>>>>>    Procedure OnError Integer iErrNo String sErrorText
40830>>>>>>>        Error DFERR_PROGRAM ("TQ-"+String(iErrNo)+": "+sErrorText)
40831>>>>>>>>
40831>>>>>>>    End_Procedure
40832>>>>>>>
40832>>>>>>>    //> If you have a 2 level scan (scanning orders, and order lines for each order) you can save execution time by creating
40832>>>>>>>    //> the sub-query only once and then call ReUse to reinitialise it.
40832>>>>>>>    //>
40832>>>>>>>    //> This is how you might go about it without the ReUse method:
40832>>>>>>>    //>
40832>>>>>>>    //>      Open Order
40832>>>>>>>    //>      Open OrderLin
40832>>>>>>>    //>      tTableQuery strOrderQuery strOrderlineQuery
40832>>>>>>>    //>
40832>>>>>>>    //>      Get NewQuery of oTQ Order.file_number to strOrderQuery
40832>>>>>>>    //>
40832>>>>>>>    //>      While (FindRecord(oTQ,&strOrderQuery))
40832>>>>>>>    //>          Get NewQuery of oTQ OrderLin.file_number to strOrderlineQuery // New query for each order
40832>>>>>>>    //>          Send AddFilterRelate of oTQ (&strOrderlineQuery) Order.file_number
40832>>>>>>>    //>          While (FindRecord(oTQ,&strOrderlineQuery))
40832>>>>>>>    //>          Loop
40832>>>>>>>    //>      Loop
40832>>>>>>>    //>
40832>>>>>>>    //> With the ReUse method you can skip the repeated "compilation" of the inner query:
40832>>>>>>>    //>
40832>>>>>>>    //>      Open Order
40832>>>>>>>    //>      Open OrderLin
40832>>>>>>>    //>      tTableQuery strOrderQuery strOrderlineQuery
40832>>>>>>>    //>      Get NewQuery of oTQ Order.file_number to strOrderQuery
40832>>>>>>>    //>      Get NewQuery of oTQ OrderLin.file_number to strOrderlineQuery
40832>>>>>>>    //>      Send AddFilterRelate of oTQ (&strOrderlineQuery) Order.file_number
40832>>>>>>>    //>
40832>>>>>>>    //>      While (FindRecord(oTQ,&strOrderQuery))
40832>>>>>>>    //>          Send ReUse of oTQ (&strOrderlineQuery)
40832>>>>>>>    //>          While (FindRecord(oTQ,&strOrderlineQuery))
40832>>>>>>>    //>          Loop
40832>>>>>>>    //>      Loop
40832>>>>>>>    //>
40832>>>>>>>    Procedure ReUse tTableQuery ByRef strQuery
40834>>>>>>>        Move False to strQuery._strControlBlock.bInitialized
40835>>>>>>>    End_Procedure
40836>>>>>>>
40836>>>>>>>    //> The scanning algorithm may transparantly to the FindRecord loop decide
40836>>>>>>>    //> to find all the rows in advance (if for example the desired output order
40836>>>>>>>    //> is incompatible with the optimum search order). But if you call ForcePrefind
40836>>>>>>>    //> you can force the algorithm to pre-find the rows regardless of whether it
40836>>>>>>>    //> is necessary (or not?).
40836>>>>>>>
40836>>>>>>>    //> This is relevant if editing indexed columns of the rows found during the
40836>>>>>>>    //> FindRecord loop.
40836>>>>>>>    //
40836>>>>>>>    //> ForcePrefetch has no relevance (but does no harm) when run on a SQL table because the
40836>>>>>>>    //> algorithm in this case generates an SQL statement via the driver. In this
40836>>>>>>>    //> mode way the rows are "pre-found" anyway.
40836>>>>>>>
40836>>>>>>>    Procedure ForcePrefetch tTableQuery ByRef strQuery // Records will be prefetched.
40838>>>>>>>        Move True to strQuery.bForcePrefetch
40839>>>>>>>    End_Procedure
40840>>>>>>>
40840>>>>>>>    //> Even if we are querying an SQL table we may have reasons to force TQ to use
40840>>>>>>>    //> the record oriented driver interface. This call does that:
40840>>>>>>>    //>
40840>>>>>>>    //>     Send ForcePrefetch of oTQ (&strQ)
40840>>>>>>>    //>
40840>>>>>>>    //> If in addition we also want to specify the cache parameters used by the
40840>>>>>>>    //> driver we can also specify prefetch count and cache timeout (for the
40840>>>>>>>    //> duration of the query:
40840>>>>>>>    //>
40840>>>>>>>    //>     Send ForcePrefetch of oTQ (&strQ) 1000 2000
40840>>>>>>>    //>
40840>>>>>>>    //> This sets the prefetch cache to 1000 records and cache timeout to 2 seconds
40840>>>>>>>    //> and this will most certaimly give you a boost compared to the default values
40840>>>>>>>    //> which are 10ms for both of them.
40840>>>>>>>
40840>>>>>>>    Procedure ForceNoESQL tTableQuery ByRef strQuery Integer iPrefetchSize Integer iCacheTimeoutMS // ESQL will not be applied
40842>>>>>>>        Move True to strQuery.bNoESQL
40843>>>>>>>        If  (num_arguments>1) Begin
40845>>>>>>>            Move True to strQuery._strControlBlock.strSQLCacheControl.bUseSettings
40846>>>>>>>            Move iPrefetchSize to strQuery._strControlBlock.strSQLCacheControl.iPrefetchRecordCount
40847>>>>>>>            If (num_arguments>2) Begin
40849>>>>>>>                Move iCacheTimeoutMS to strQuery._strControlBlock.strSQLCacheControl.iPrefetchRecordTimeout
40850>>>>>>>            End
40850>>>>>>>>
40850>>>>>>>            Else Begin
40851>>>>>>>                Move 0 to strQuery._strControlBlock.strSQLCacheControl.iPrefetchRecordTimeout
40852>>>>>>>            End
40852>>>>>>>>
40852>>>>>>>        End
40852>>>>>>>>
40852>>>>>>>        Else Begin
40853>>>>>>>            Move False to strQuery._strControlBlock.strSQLCacheControl.bUseSettings
40854>>>>>>>        End
40854>>>>>>>>
40854>>>>>>>    End_Procedure
40855>>>>>>>
40855>>>>>>>    //> Don't evaluate, just use iIndex I tell you. Ignored by ESQL
40855>>>>>>>    Procedure ForceIndex tTableQuery ByRef strQuery Integer iIndex 
40857>>>>>>>        Move iIndex to strQuery.iForceIndex
40858>>>>>>>    End_Procedure
40859>>>>>>>
40859>>>>>>>    //> Limit number of rows in the result set.
40859>>>>>>>    Procedure SetLimit tTableQuery ByRef strQuery Integer iLimit 
40861>>>>>>>        Move iLimit to strQuery.iLimit
40862>>>>>>>    End_Procedure
40863>>>>>>>
40863>>>>>>>//    Procedure SetExpectedNumberOfRecords tTableQuery ByRef strQuery Integer iResultSetSize // Just a thought
40863>>>>>>>//    End_Procedure
40863>>>>>>>
40863>>>>>>>    //> Use this table name when generating ESQL rather than the default one. Because I tell you to!
40863>>>>>>>    Procedure ForceSQLTableName tTableQuery ByRef strQuery String sSqlTableName 
40865>>>>>>>        Move sSqlTableName to strQuery.sForceSQLTableName
40866>>>>>>>    End_Procedure
40867>>>>>>>
40867>>>>>>>    //> DANGER! Completely overtakes the scene. Make sure to "select" the columns expected by TQ
40867>>>>>>>    Procedure ForceSQLStatement tTableQuery ByRef strQuery String sSQLStatement 
40869>>>>>>>        Move sSQLStatement to strQuery.sForceSQLStatement
40870>>>>>>>    End_Procedure
40871>>>>>>>
40871>>>>>>>    Procedure RestoreRecordBuffersOnQueryCompletion tTableQuery ByRef strQuery Boolean bState
40873>>>>>>>        Move bState to strQuery.bRestoreRecordBuffersOnQueryCompletion
40874>>>>>>>    End_Procedure
40875>>>>>>>
40875>>>>>>>    //> Use LogTag to distinguish between different FindRecord loops in the log. Or
40875>>>>>>>    //> between different situations in different runs of the same FindLoop. When this is set, TQ 
40875>>>>>>>    //> will create a record in an un-listed log table by the name of (LogTableName(oTQ,strQuery))
40875>>>>>>>    Procedure SetLogTag tTableQuery ByRef strQuery String sTag
40877>>>>>>>        Move sTag to strQuery._strControlBlock.sLogTag
40878>>>>>>>    End_Procedure
40879>>>>>>>
40879>>>>>>>    //> Call BreakScan to terminate the FindRecord loop on next iteration. Note that when (explicitly or implicitly) we have set
40879>>>>>>>    //> the bForcePrefetch attribute, this will not be effective until we enter the actual find-loop. Which in that case will be
40879>>>>>>>    //> after all the rows have been found.
40879>>>>>>>    Procedure BreakScan tTableQuery ByRef strQuery
40881>>>>>>>        Move True to strQuery._strControlBlock.bBreakScan
40882>>>>>>>    End_Procedure
40883>>>>>>>
40883>>>>>>>    //> After query execution this will return an (english) string: "So many selected rows in so many finds"
40883>>>>>>>    Function StatisticsString tTableQuery strQuery Returns String
40885>>>>>>>        Integer iFound iSelect
40885>>>>>>>        Move strQuery._strControlBlock.iFindCount to iFound
40886>>>>>>>        Move strQuery._strControlBlock.iSelectCount to iSelect
40887>>>>>>>        Function_Return (String(iSelect)+" selected rows (in "+String(iFound)+" finds)")
40888>>>>>>>    End_Function
40889>>>>>>>
40889>>>>>>>    //> Returns the number of milliseconds it takes to make an "empty" round-trip to the SQL server. It makes at least 4 server calls.
40889>>>>>>>    Function ZeroSelectTime Integer iTable Returns Number
40891>>>>>>>        tSystemTimeMS strStart strStop
40891>>>>>>>        tSystemTimeMS strStart strStop
40891>>>>>>>        tTableQuery strQuery
40891>>>>>>>        tTableQuery strQuery
40891>>>>>>>        Boolean bFound
40891>>>>>>>
40891>>>>>>>        Get NewQuery iTable to strQuery
40892>>>>>>>        Send ForceSQLStatement (&strQuery) "select 1"
40893>>>>>>>        Repeat
40893>>>>>>>>
40893>>>>>>>            Get FindRecord (&strQuery) to bFound
40894>>>>>>>        Until (not(bFound))
40896>>>>>>>
40896>>>>>>>        Send ReUse (&strQuery)
40897>>>>>>>        Get SystemTimeMilliSeconds of oDateFunctions to strStart // We time the second loop (in case the first loop had to set up a connection)
40898>>>>>>>        Repeat
40898>>>>>>>>
40898>>>>>>>            Get FindRecord (&strQuery) to bFound
40899>>>>>>>        Until (not(bFound))
40901>>>>>>>
40901>>>>>>>        Get SystemTimeMilliSeconds of oDateFunctions to strStop
40902>>>>>>>        Function_Return (SystemTimeMilliSecondsElapsed(oDateFunctions,strStart, strStop))
40903>>>>>>>    End_Function
40904>>>>>>>
40904>>>>>>>        //> Returns the table name of iTable as used (in SQL staments) in the strQuery context.
40904>>>>>>>        Function TableName tTableQuery strQuery Integer iTable Returns String
40906>>>>>>>            Integer iRelateItem
40906>>>>>>>            String sValue
40906>>>>>>>            If (iTable=strQuery.iTable) Begin
40908>>>>>>>                Move strQuery.sForceSQLTableName to sValue
40909>>>>>>>            End
40909>>>>>>>>
40909>>>>>>>            Else Begin
40910>>>>>>>                Get _FindTableRelation strQuery iTable to iRelateItem
40911>>>>>>>                If (iRelateItem>=0) Begin
40913>>>>>>>                    Move strQuery.aTableRelations[iRelateItem].sForceSQLTableName to sValue
40914>>>>>>>                End
40914>>>>>>>>
40914>>>>>>>            End
40914>>>>>>>>
40914>>>>>>>            If (sValue="") Begin
40916>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sValue
40919>>>>>>>            End
40919>>>>>>>>
40919>>>>>>>            If (sValue="") Begin
40921>>>>>>>                Send OnError 701 ("Table name could not be found for table "+String(iTable))
40922>>>>>>>            End
40922>>>>>>>>
40922>>>>>>>
40922>>>>>>>            Function_Return sValue
40923>>>>>>>        End_Function
40924>>>>>>>
40924>>>>>>>        //> Returns column name of iTable.iColumn as used (in SQL staments) in the strQuery context.
40924>>>>>>>        Function ColumnName tTableQuery strQuery Integer iTable Integer iColumn Boolean bIncludeTableName Returns String
40926>>>>>>>            String sColumnName sTableName
40926>>>>>>>            Get_Attribute DF_FIELD_NAME of iTable iColumn to sColumnName
40929>>>>>>>            If (sColumnName<>"") Begin
40931>>>>>>>                If (bIncludeTableName) Begin
40933>>>>>>>                    Get TableName strQuery iTable iColumn to sTableName
40934>>>>>>>                    Function_Return (sTableName+"."+sColumnName)
40935>>>>>>>                End
40935>>>>>>>>
40935>>>>>>>                Else Begin
40936>>>>>>>                    Function_Return sColumnName
40937>>>>>>>                End
40937>>>>>>>>
40937>>>>>>>            End
40937>>>>>>>>
40937>>>>>>>            Function_Return ""
40938>>>>>>>        End_Function
40939>>>>>>>
40939>>>>>>>        Function ComperatorID2String Integer iComp Returns String
40941>>>>>>>            If (iComp=tqLT) Function_Return "<"
40944>>>>>>>            If (iComp=tqLE) Function_Return "<="
40947>>>>>>>            If (iComp=tqEQ) Function_Return "="
40950>>>>>>>            If (iComp=tqGE) Function_Return ">="
40953>>>>>>>            If (iComp=tqGT) Function_Return ">"
40956>>>>>>>            If (iComp=tqNE) Function_Return "<>"
40959>>>>>>>//            If (iComp=tqIN) Function_Return "in"
40959>>>>>>>//            If (iComp=tqCONTAINS) Function_Return "contains"
40959>>>>>>>            If (iComp=tqMATCH) Function_Return "match"
40962>>>>>>>            If (iComp=tqUCMATCH) Function_Return "ucmatch"
40965>>>>>>>            Function_Return "error"
40966>>>>>>>        End_Function
40967>>>>>>>
40967>>>>>>>        Function ComperatorID2ComperatorString Integer iComp Returns String
40969>>>>>>>            If (iComp=tqLT) Function_Return "tqLT"
40972>>>>>>>            If (iComp=tqLE) Function_Return "tqLE"
40975>>>>>>>            If (iComp=tqEQ) Function_Return "tqEQ"
40978>>>>>>>            If (iComp=tqGE) Function_Return "tqGE"
40981>>>>>>>            If (iComp=tqGT) Function_Return "tqGT"
40984>>>>>>>            If (iComp=tqNE) Function_Return "tqNE"
40987>>>>>>>//            If (iComp=tqIN) Function_Return "tqIN"
40987>>>>>>>//            If (iComp=tqCONTAINS) Function_Return "tqCONTAINS"
40987>>>>>>>            If (iComp=tqMATCH) Function_Return "tqMATCH"
40990>>>>>>>            If (iComp=tqUCMATCH) Function_Return "tqUCMATCH"
40993>>>>>>>        End_Function
40994>>>>>>>
40994>>>>>>>        Function ComperatorString2ID String sComp Returns Integer
40996>>>>>>>            Integer iMax iItem
40996>>>>>>>            Move (_tqComparisonMax-1) to iMax
40997>>>>>>>            Move (Lowercase(sComp)) to sComp
40998>>>>>>>            For iItem from 0 to iMax
41004>>>>>>>>
41004>>>>>>>                If (sComp=Lowercase(ComperatorID2String(Self,iItem))) Begin
41006>>>>>>>                    Function_Return iItem
41007>>>>>>>                End
41007>>>>>>>>
41007>>>>>>>            Loop
41008>>>>>>>>
41008>>>>>>>            Function_Return -1 // not found
41009>>>>>>>        End_Function
41010>>>>>>>
41010>>>>>>>    Procedure AddOrderBy tTableQuery ByRef strQuery Integer iTable Integer iColumn Boolean bDescending Boolean bUppercase
41012>>>>>>>        Integer iCount iRelateItem
41012>>>>>>>        Move (SizeOfArray(strQuery.aOrdering)) to iCount
41013>>>>>>>        Move iTable to strQuery.aOrdering[iCount].strValueSource.iTable
41014>>>>>>>        Move iColumn to strQuery.aOrdering[iCount].strValueSource.iColumn
41015>>>>>>>        Get _ColumnType iTable iColumn to strQuery.aOrdering[iCount].strValueSource.iType
41016>>>>>>>        If (num_arguments>=4) Begin
41018>>>>>>>            Move bDescending to strQuery.aOrdering[iCount].bDescending
41019>>>>>>>        End
41019>>>>>>>>
41019>>>>>>>        Else Begin
41020>>>>>>>            Move False to strQuery.aOrdering[iCount].bDescending
41021>>>>>>>        End
41021>>>>>>>>
41021>>>>>>>        If (num_arguments>=5) Begin
41023>>>>>>>            Move bUppercase to strQuery.aOrdering[iCount].bUppercase
41024>>>>>>>        End
41024>>>>>>>>
41024>>>>>>>        Else Begin
41025>>>>>>>            Move False to strQuery.aOrdering[iCount].bUppercase
41026>>>>>>>        End
41026>>>>>>>>
41026>>>>>>>        If (iTable<>strQuery.iTable) Begin
41028>>>>>>>            // We will also check if this parent table is accessible via the known table relations:
41028>>>>>>>            Get _FindTableRelation strQuery iTable to iRelateItem
41029>>>>>>>            If (iRelateItem=-1) Begin
41031>>>>>>>                Send OnError 702 ("Unknown table relation to table "+String(iTable))
41032>>>>>>>            End
41032>>>>>>>>
41032>>>>>>>            Else Begin
41033>>>>>>>                // We're ordering by a parent table column which makes us have to prefetch the result:
41033>>>>>>>                Move True to strQuery.bForcePrefetch
41034>>>>>>>            End
41034>>>>>>>>
41034>>>>>>>        End
41034>>>>>>>>
41034>>>>>>>    End_Procedure
41035>>>>>>>
41035>>>>>>>    //> Delete all ordering information from the strQuery variable
41035>>>>>>>    Procedure ResetOrdering tTableQuery ByRef strQuery
41037>>>>>>>        // Check that the query is not already executing
41037>>>>>>>        If (strQuery._strControlBlock.bInitialized) Begin
41039>>>>>>>            Send OnError 740 "ResetOrdering called while query is executing"
41040>>>>>>>        End
41040>>>>>>>>
41040>>>>>>>        Else Begin
41041>>>>>>>            Move (ResizeArray(strQuery.aOrdering,0)) to strQuery.aOrdering
41042>>>>>>>        End
41042>>>>>>>>
41042>>>>>>>    End_Procedure
41043>>>>>>>    
41043>>>>>>>    Function _FindOrderBySegment tTableQuery strQuery Integer iTable Integer iColumn Returns Integer
41045>>>>>>>        Integer iItem iItemMax
41045>>>>>>>        Move (SizeOfArray(strQuery.aOrdering)-1) to iItemMax
41046>>>>>>>        For iItem from 0 to iItemMax
41052>>>>>>>>
41052>>>>>>>            If (iTable=strQuery.aOrdering[iItem].strValueSource.iTable and iColumn=strQuery.aOrdering[iItem].strValueSource.iColumn) Begin
41054>>>>>>>                Function_Return iItem
41055>>>>>>>            End
41055>>>>>>>>
41055>>>>>>>        Loop
41056>>>>>>>>
41056>>>>>>>        Function_Return -1 // Not found
41057>>>>>>>    End_Function
41058>>>>>>>
41058>>>>>>>    //> Shorthand for sending the AddOrdering a number of times to match the factual search order of a particular index. It's hard to explain why you'd do it, but I have.
41058>>>>>>>    Procedure SetOrderByToIndex tTableQuery ByRef strQuery Integer iIndex
41060>>>>>>>        tOCIndex strIndex
41060>>>>>>>        tOCIndex strIndex
41060>>>>>>>        Integer iSegment iSegments
41060>>>>>>>        Get IndexDefinition of oOverlapColumnFunctions strQuery.iTable iIndex to strIndex
41061>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
41062>>>>>>>        For iSegment from 0 to iSegments
41068>>>>>>>>
41068>>>>>>>            Send AddOrderBy (&strQuery) strQuery.iTable strIndex.aSegments[iSegment].iColumn strIndex.aSegments[iSegment].bDescending strIndex.aSegments[iSegment].bUppercase
41069>>>>>>>        Loop
41070>>>>>>>>
41070>>>>>>>    End_Procedure
41071>>>>>>>
41071>>>>>>>        Function _ColumnType Integer iTable Integer iColumn Returns Integer
41073>>>>>>>            Integer iVdfType
41073>>>>>>>            Get_Attribute DF_FIELD_TYPE of iTable iColumn to iVdfType
41076>>>>>>>            If (iVdfType=DF_ASCII) Function_Return tqSTRING
41079>>>>>>>            If (iVdfType=DF_OVERLAP) Function_Return tqSTRING
41082>>>>>>>            If (iVdfType=DF_BCD) Function_Return tqNUMBER
41085>>>>>>>            If (iVdfType=DF_DATE) Function_Return tqDATE
41088>>>>>>>            If (iVdfType=DF_DATETIME) Function_Return tqDATETIME
41091>>>>>>>            If (iVdfType=DF_TEXT) Function_Return tqTEXT
41094>>>>>>>            Function_Return -1
41095>>>>>>>        End_Function
41096>>>>>>>
41096>>>>>>>    Procedure AddFilter tTableQuery ByRef strQuery Integer iTable Integer iColumn Integer iComp String sConstant
41098>>>>>>>        Integer iConstraintIndex iRelateItem
41098>>>>>>>        tTQFilterSegment strSegment
41098>>>>>>>        tTQFilterSegment strSegment
41098>>>>>>>        
41098>>>>>>>        Move iTable to strSegment.strLeftValue.iTable
41099>>>>>>>        Move iColumn to strSegment.strLeftValue.iColumn
41100>>>>>>>        Get _ColumnType iTable iColumn to strSegment.strLeftValue.iType
41101>>>>>>>        Move iComp to strSegment.iComp
41102>>>>>>>        Move sConstant to strSegment.strRightValue.sConstant
41103>>>>>>>        Get _ColumnType iTable iColumn to strSegment.strRightValue.iType
41104>>>>>>>
41104>>>>>>>        If (iTable<>strQuery.iTable) Begin
41106>>>>>>>            // Check if this parent table is accessible via the known table relations:
41106>>>>>>>            Get _FindTableRelation strQuery iTable to iRelateItem
41107>>>>>>>            If (iRelateItem=-1) Begin
41109>>>>>>>                Send OnError 703 ("Unknown table relation to table "+String(iTable))
41110>>>>>>>            End
41110>>>>>>>>
41110>>>>>>>        End
41110>>>>>>>>
41110>>>>>>>        
41110>>>>>>>        If (strQuery._strControlBlock.bFilterExpressionActive) Begin
41112>>>>>>>            Send FilterExpressionAddOperand (&strQuery) strSegment
41113>>>>>>>        End
41113>>>>>>>>
41113>>>>>>>        Else Begin
41114>>>>>>>            Move (SizeOfArray(strQuery.aFilters)) to iConstraintIndex
41115>>>>>>>            Move strSegment to strQuery.aFilters[iConstraintIndex]
41116>>>>>>>        End
41116>>>>>>>>
41116>>>>>>>    End_Procedure
41117>>>>>>>
41117>>>>>>>    Procedure AddFilterOrList tTableQuery ByRef strQuery Integer iTable Integer iColumn String[] aOrList
41119>>>>>>>        Integer iConstraintIndex iRelateItem
41119>>>>>>>        tTQFilterSegment strSegment
41119>>>>>>>        tTQFilterSegment strSegment
41119>>>>>>>
41119>>>>>>>        Move iTable to strSegment.strLeftValue.iTable
41120>>>>>>>        Move iColumn to strSegment.strLeftValue.iColumn
41121>>>>>>>        Get _ColumnType iTable iColumn to strSegment.strLeftValue.iType
41122>>>>>>>        Move tqEQ to strSegment.iComp
41123>>>>>>>        Move aOrList to strSegment.strRightValue.aOrList
41124>>>>>>>        Move 0 to strSegment.strRightValue._iOrListPointer
41125>>>>>>>        Get _ColumnType iTable iColumn to strSegment.strRightValue.iType
41126>>>>>>>
41126>>>>>>>        If (iTable<>strQuery.iTable) Begin
41128>>>>>>>            // Check if this parent table is accessible via the known table relations:
41128>>>>>>>            Get _FindTableRelation strQuery iTable to iRelateItem
41129>>>>>>>            If (iRelateItem=-1) Begin
41131>>>>>>>                Send OnError 704 ("Unknown table relation to table "+String(iTable))
41132>>>>>>>            End
41132>>>>>>>>
41132>>>>>>>        End
41132>>>>>>>>
41132>>>>>>>        
41132>>>>>>>        If (strQuery._strControlBlock.bFilterExpressionActive) Begin
41134>>>>>>>            Send FilterExpressionAddOperand (&strQuery) strSegment
41135>>>>>>>        End
41135>>>>>>>>
41135>>>>>>>        Else Begin
41136>>>>>>>            Move (SizeOfArray(strQuery.aFilters)) to iConstraintIndex
41137>>>>>>>            Move strSegment to strQuery.aFilters[iConstraintIndex]
41138>>>>>>>        End
41138>>>>>>>>
41138>>>>>>>    End_Procedure
41139>>>>>>>    
41139>>>>>>>    Procedure AddFilterTableColumn tTableQuery ByRef strQuery Integer iTable Integer iColumn Integer iComp Integer iFilterTable Integer iFilterColumn
41141>>>>>>>        Integer iConstraintIndex iRelateItem
41141>>>>>>>        tTQFilterSegment strSegment
41141>>>>>>>        tTQFilterSegment strSegment
41141>>>>>>>
41141>>>>>>>        Move iTable to strSegment.strLeftValue.iTable
41142>>>>>>>        Move iColumn to strSegment.strLeftValue.iColumn
41143>>>>>>>        Get _ColumnType iTable iColumn to strSegment.strLeftValue.iType
41144>>>>>>>        Move iComp to strSegment.iComp
41145>>>>>>>        Move iFilterTable to strSegment.strRightValue.iTable
41146>>>>>>>        Move iFilterColumn to strSegment.strRightValue.iColumn
41147>>>>>>>        Get _ColumnType iFilterTable iFilterColumn to strSegment.strRightValue.iType
41148>>>>>>>
41148>>>>>>>        If (strSegment.strLeftValue.iTable<>strQuery.iTable) Begin
41150>>>>>>>            // Check if left hand table is accessible via the known table relations:
41150>>>>>>>            Get _FindTableRelation strQuery strSegment.strLeftValue.iTable to iRelateItem
41151>>>>>>>            If (iRelateItem=-1) Begin
41153>>>>>>>                Send OnError 705 ("Unknown table relation to table "+String(strSegment.strLeftValue.iTable))
41154>>>>>>>            End
41154>>>>>>>>
41154>>>>>>>        End
41154>>>>>>>>
41154>>>>>>>
41154>>>>>>>        If (strQuery._strControlBlock.bFilterExpressionActive) Begin
41156>>>>>>>            Send FilterExpressionAddOperand (&strQuery) strSegment
41157>>>>>>>        End
41157>>>>>>>>
41157>>>>>>>        Else Begin
41158>>>>>>>            Move (SizeOfArray(strQuery.aFilters)) to iConstraintIndex
41159>>>>>>>            Move strSegment to strQuery.aFilters[iConstraintIndex]
41160>>>>>>>        End
41160>>>>>>>>
41160>>>>>>>    End_Procedure
41161>>>>>>>    
41161>>>>>>>        Procedure _AddConstrainRelateSegments tTableQuery ByRef strQuery Integer iTable Integer[] aColumns Integer iRelTable Integer[] aRelColumns
41163>>>>>>>            Integer iColumns iItem
41163>>>>>>>            Move (SizeOfArray(aColumns)-1) to iColumns
41164>>>>>>>            If ((iColumns+1)<>SizeOfArray(aRelColumns)) Begin
41166>>>>>>>                Send OnError 706 "Number of segments do not match in AddFilterRelate method"
41167>>>>>>>            End
41167>>>>>>>>
41167>>>>>>>            For iItem from 0 to iColumns
41173>>>>>>>>
41173>>>>>>>                If (iItem<>0 and strQuery._strControlBlock.bFilterExpressionActive) Begin
41175>>>>>>>                    Send FilterPressKey (&strQuery) tqKeyAND // Put and between the segments
41176>>>>>>>                End
41176>>>>>>>>
41176>>>>>>>                Send AddFilterTableColumn (&strQuery) iTable aColumns[iItem] tqEQ iRelTable aRelColumns[iItem]
41177>>>>>>>            Loop
41178>>>>>>>>
41178>>>>>>>        End_Procedure
41179>>>>>>>
41179>>>>>>>    Procedure AddFilterRelate tTableQuery ByRef strQuery Integer iParentTable
41181>>>>>>>        Integer iTable iColumn iColumns iRelTable iRelColumn
41181>>>>>>>        Boolean bAnyColumnsAtAll
41181>>>>>>>        Send ReadTableDefinition of oOverlapColumnFunctions iParentTable
41182>>>>>>>        Move strQuery.iTable to iTable
41183>>>>>>>        Move False to bAnyColumnsAtAll
41184>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iColumns
41187>>>>>>>        For iColumn from 1 to iColumns
41193>>>>>>>>
41193>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of iTable iColumn to iRelTable
41196>>>>>>>            If (iRelTable=iParentTable) Begin
41198>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of iTable iColumn to iRelColumn
41201>>>>>>>                Send _AddConstrainRelateSegments (&strQuery) strQuery.iTable (TranslateOverlap(oOverlapColumnFunctions,iTable,iColumn)) iRelTable (TranslateOverlap(oOverlapColumnFunctions,iRelTable,iRelColumn))
41202>>>>>>>                Move True to bAnyColumnsAtAll
41203>>>>>>>            End
41203>>>>>>>>
41203>>>>>>>        Loop
41204>>>>>>>>
41204>>>>>>>        If (bAnyColumnsAtAll) Begin // If there were any segments relating we assume that the relation is good. If not we consider it an error of the table definitions.
41206>>>>>>>            // Tell the relationship handler that it should not worry about iParentTable. It is automatically and constantly related.
41206>>>>>>>            Send AddTableRelationFixedRecord (&strQuery) iParentTable 
41207>>>>>>>        End
41207>>>>>>>>
41207>>>>>>>        Else Begin
41208>>>>>>>            Send OnError 707 "Main query table does not relate to the parent table passed"
41209>>>>>>>        End
41209>>>>>>>>
41209>>>>>>>    End_Procedure
41210>>>>>>>
41210>>>>>>>    //> AddFilterRelateFixedRecord is equivalent to AddFilterRelate but it defines the
41210>>>>>>>    //> filter based on constant filters rather than dynamic "table column filters".
41210>>>>>>>    Procedure AddFilterRelateFixedRecord tTableQuery ByRef strQuery Integer iParentTable
41212>>>>>>>        Integer iTable iColumn iColumns iRelTable iRelColumn iIndex iMax
41212>>>>>>>        Integer[] aColumns aRelColumns
41214>>>>>>>        String sValue
41214>>>>>>>        Boolean bAnythingAtAll
41214>>>>>>>        Send ReadTableDefinition of oOverlapColumnFunctions iParentTable
41215>>>>>>>        Move strQuery.iTable to iTable
41216>>>>>>>        Move False to bAnythingAtAll
41217>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iColumns
41220>>>>>>>        For iColumn from 1 to iColumns
41226>>>>>>>>
41226>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of iTable iColumn to iRelTable
41229>>>>>>>            If (iRelTable=iParentTable) Begin
41231>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of iTable iColumn to iRelColumn
41234>>>>>>>                Get TranslateOverlap of oOverlapColumnFunctions iTable iColumn to aColumns
41235>>>>>>>                Get TranslateOverlap of oOverlapColumnFunctions iRelTable iRelColumn to aRelColumns
41236>>>>>>>                Move (SizeOfArray(aColumns)-1) to iMax
41237>>>>>>>                If ((iMax+1)=SizeOfArray(aRelColumns)) Begin
41239>>>>>>>                    Get_Field_Value iRelColumn aRelColumns[iIndex] to sValue
41242>>>>>>>                    Send AddFilter (&strQuery) iTable aColumns[iIndex] tqEQ sValue
41243>>>>>>>                    Move True to bAnythingAtAll
41244>>>>>>>                End
41244>>>>>>>>
41244>>>>>>>                Else Begin
41245>>>>>>>                    Send OnError 745 "Number of segments do not match in AddFilterRelateAsConstant method"
41246>>>>>>>                End
41246>>>>>>>>
41246>>>>>>>            End
41246>>>>>>>>
41246>>>>>>>        Loop
41247>>>>>>>>
41247>>>>>>>        If (not(bAnythingAtAll)) Begin // If there were any segments relating we assume that the relation is good. If not we consider it an error of the table definitions.
41249>>>>>>>            Send OnError 746 "Main query table does not relate to the parent table passed"
41250>>>>>>>        End
41250>>>>>>>>
41250>>>>>>>    End_Procedure
41251>>>>>>>  
41251>>>>>>>    Procedure FilterKeyPadOn tTableQuery ByRef strQuery
41253>>>>>>>        Integer iItem
41253>>>>>>>        If (strQuery._strControlBlock.bFilterExpressionActive) Begin
41255>>>>>>>            Send OnError 708 "Filter expression already active (keypad is already on)"
41256>>>>>>>        End
41256>>>>>>>>
41256>>>>>>>        Else Begin
41257>>>>>>>            Move (SizeOfArray(strQuery.aFilterExpressions)) to iItem
41258>>>>>>>            Move True to strQuery._strControlBlock.bFilterExpressionActive
41259>>>>>>>            Move False to strQuery.aFilterExpressions[iItem]._bOpen
41260>>>>>>>        End
41260>>>>>>>>
41260>>>>>>>    End_Procedure
41261>>>>>>>
41261>>>>>>>            Procedure _FilterExpressionAndOr tTQFilterExpression[] ByRef aSegments Integer iKey
41263>>>>>>>                Integer iItem
41263>>>>>>>                Move (SizeOfArray(aSegments)-1) to iItem
41264>>>>>>>                If (iItem>=0 and aSegments[iItem].iAndOr=_tqKeyNULL) Begin
41266>>>>>>>                    If (aSegments[iItem]._bOpen) Begin
41268>>>>>>>                        Send _FilterExpressionAndOr (&aSegments[iItem].aSubExpressions) iKey
41269>>>>>>>                    End
41269>>>>>>>>
41269>>>>>>>                    Else Begin
41270>>>>>>>                        Move iKey to aSegments[iItem].iAndOr
41271>>>>>>>                    End
41271>>>>>>>>
41271>>>>>>>                End
41271>>>>>>>>
41271>>>>>>>                Else Begin
41272>>>>>>>                    Send OnError 709 "Logical operator (AND/OR) not allowed"
41273>>>>>>>                End
41273>>>>>>>>
41273>>>>>>>            End_Procedure
41274>>>>>>>
41274>>>>>>>            Procedure _FilterExpressionNot tTQFilterExpression[] ByRef aSegments
41276>>>>>>>                Integer iItem
41276>>>>>>>                Move (SizeOfArray(aSegments)-1) to iItem
41277>>>>>>>                If (iItem>=0) Begin
41279>>>>>>>                    If (aSegments[iItem]._bOpen) Begin
41281>>>>>>>                        Send _FilterExpressionNot (&aSegments[iItem].aSubExpressions)
41282>>>>>>>                    End
41282>>>>>>>>
41282>>>>>>>                    Else Begin
41283>>>>>>>                        If (aSegments[iItem].iAndOr=_tqKeyNULL) Begin
41285>>>>>>>                            Move True to aSegments[iItem].bNot
41286>>>>>>>                        End
41286>>>>>>>>
41286>>>>>>>                        Else Begin
41287>>>>>>>                            Send OnError 710 "Logical operator (NOT) not allowed"
41288>>>>>>>                        End
41288>>>>>>>>
41288>>>>>>>                    End
41288>>>>>>>>
41288>>>>>>>                End
41288>>>>>>>>
41288>>>>>>>                Else Begin
41289>>>>>>>                    Send OnError 711 "Logical operator (NOT) not allowed"
41290>>>>>>>                End
41290>>>>>>>>
41290>>>>>>>            End_Procedure
41291>>>>>>>
41291>>>>>>>            Procedure _FilterExpressionLeftParenthesis tTQFilterExpression[] ByRef aSegments
41293>>>>>>>                Integer iItem
41293>>>>>>>                Move (SizeOfArray(aSegments)-1) to iItem
41294>>>>>>>                If (iItem>=0) Begin
41296>>>>>>>                    If (aSegments[iItem]._bOpen) Begin
41298>>>>>>>                        Send _FilterExpressionLeftParenthesis (&aSegments[iItem].aSubExpressions)
41299>>>>>>>                    End
41299>>>>>>>>
41299>>>>>>>                    Else Begin
41300>>>>>>>                        If (aSegments[iItem].iAndOr=_tqKeyNULL) Begin
41302>>>>>>>                            Move True to aSegments[iItem]._bOpen
41303>>>>>>>                        End
41303>>>>>>>>
41303>>>>>>>                        Else Begin
41304>>>>>>>                            Move True to aSegments[iItem+1]._bOpen
41305>>>>>>>                        End
41305>>>>>>>>
41305>>>>>>>                    End
41305>>>>>>>>
41305>>>>>>>                End
41305>>>>>>>>
41305>>>>>>>                Else Begin
41306>>>>>>>                    Send OnError 713 "'(' not allowed"
41307>>>>>>>                End
41307>>>>>>>>
41307>>>>>>>            End_Procedure
41308>>>>>>>
41308>>>>>>>            Procedure _FilterExpressionRightParenthesis tTQFilterExpression[] ByRef aSegments
41310>>>>>>>                Integer iItem
41310>>>>>>>                Move (SizeOfArray(aSegments)-1) to iItem
41311>>>>>>>                If (iItem>=0) Begin
41313>>>>>>>                    If (aSegments[iItem]._bOpen) Begin
41315>>>>>>>                        If (SizeOfArray(aSegments[iItem].aSubExpressions)=0 or not(aSegments[iItem].aSubExpressions[SizeOfArray(aSegments[iItem].aSubExpressions)-1]._bOpen)) Begin
41317>>>>>>>                            Move False to aSegments[iItem]._bOpen
41318>>>>>>>                        End
41318>>>>>>>>
41318>>>>>>>                        Else Begin
41319>>>>>>>                            Send _FilterExpressionRightParenthesis (&aSegments[iItem].aSubExpressions)
41320>>>>>>>                        End
41320>>>>>>>>
41320>>>>>>>                    End
41320>>>>>>>>
41320>>>>>>>                    Else Begin
41321>>>>>>>                        Send OnError 714 "')' not allowed"
41322>>>>>>>                    End
41322>>>>>>>>
41322>>>>>>>                End
41322>>>>>>>>
41322>>>>>>>                Else Begin
41323>>>>>>>                    Send OnError 715 "Empty sub-expression, ')' not allowed"
41324>>>>>>>                End
41324>>>>>>>>
41324>>>>>>>            End_Procedure
41325>>>>>>>
41325>>>>>>>        Procedure _FilterPressKey tTableQuery ByRef strQuery Integer iKey
41327>>>>>>>            Integer iActiveFilterExpression
41327>>>>>>>            If (strQuery._strControlBlock.bFilterExpressionActive) Begin
41329>>>>>>>                Move (SizeOfArray(strQuery.aFilterExpressions)-1) to iActiveFilterExpression
41330>>>>>>>                If (iKey=tqKeyAND or iKey=tqKeyOR) Begin
41332>>>>>>>                    Send _FilterExpressionAndOr (&strQuery.aFilterExpressions[iActiveFilterExpression].aSubExpressions) iKey
41333>>>>>>>                End
41333>>>>>>>>
41333>>>>>>>                Else If (iKey=tqKeyNOT) Begin
41336>>>>>>>                    Send _FilterExpressionNot (&strQuery.aFilterExpressions[iActiveFilterExpression].aSubExpressions)
41337>>>>>>>                End
41337>>>>>>>>
41337>>>>>>>                Else If (iKey=tqKeyPARLEFT or iKey=tqKeyPARRIGHT) Begin
41340>>>>>>>                    If (iKey=tqKeyPARLEFT) Begin
41342>>>>>>>                        Send _FilterExpressionLeftParenthesis (&strQuery.aFilterExpressions[iActiveFilterExpression].aSubExpressions)
41343>>>>>>>                    End
41343>>>>>>>>
41343>>>>>>>                    Else If (iKey=tqKeyPARRIGHT) Begin
41346>>>>>>>                        Send _FilterExpressionRightParenthesis (&strQuery.aFilterExpressions[iActiveFilterExpression].aSubExpressions)
41347>>>>>>>                    End
41347>>>>>>>>
41347>>>>>>>                End
41347>>>>>>>>
41347>>>>>>>                Else Begin
41348>>>>>>>                    Send OnError 716 "Unknown 'key' passed to FilterPressKey method"
41349>>>>>>>                End
41349>>>>>>>>
41349>>>>>>>            End
41349>>>>>>>>
41349>>>>>>>            Else Begin
41350>>>>>>>                Send OnError 717 "No active filter expression"
41351>>>>>>>            End
41351>>>>>>>>
41351>>>>>>>        End_Procedure
41352>>>>>>>
41352>>>>>>>    Procedure FilterPressKey tTableQuery ByRef strQuery Integer iKey
41354>>>>>>>        If (strQuery._strControlBlock.bFilterExpressionActive) Begin
41356>>>>>>>            Send _FilterPressKey (&strQuery) iKey
41357>>>>>>>        End
41357>>>>>>>>
41357>>>>>>>        Else Begin
41358>>>>>>>            Send OnError 718 "No active filter expression"
41359>>>>>>>        End
41359>>>>>>>>
41359>>>>>>>    End_Procedure
41360>>>>>>>
41360>>>>>>>        Procedure _FilterExpressionAddOperand tTableQuery ByRef strQuery tTQFilterExpression[] ByRef aFilterSegments tTQFilterSegment strConstrainSegment
41362>>>>>>>            Integer iItem
41362>>>>>>>//            Boolean bHasSubExp
41362>>>>>>>            Move (SizeOfArray(aFilterSegments)-1) to iItem
41363>>>>>>>            If (iItem>=0) Begin
41365>>>>>>>                If (aFilterSegments[iItem]._bOpen) Begin
41367>>>>>>>                    Send _FilterExpressionAddOperand (&strQuery) (&aFilterSegments[iItem].aSubExpressions) strConstrainSegment
41368>>>>>>>                End
41368>>>>>>>>
41368>>>>>>>                Else Begin
41369>>>>>>>//                    Move (SizeOfArray(aFilterSegments[iItem].aSubExpressions)>0) to bHasSubExp
41369>>>>>>>                    If (aFilterSegments[iItem].iAndOr=_tqKeyNULL) Begin // if operator has not been added
41371>>>>>>>                        Move strConstrainSegment to aFilterSegments[iItem].strOperand
41372>>>>>>>                    End
41372>>>>>>>>
41372>>>>>>>                    Else Begin // Operator has been added, well take the next segment
41373>>>>>>>                        Move strConstrainSegment to aFilterSegments[iItem+1].strOperand
41374>>>>>>>                    End
41374>>>>>>>>
41374>>>>>>>                End
41374>>>>>>>>
41374>>>>>>>            End
41374>>>>>>>>
41374>>>>>>>            Else Begin
41375>>>>>>>                Move strConstrainSegment to aFilterSegments[0].strOperand
41376>>>>>>>            End
41376>>>>>>>>
41376>>>>>>>        End_Procedure
41377>>>>>>>
41377>>>>>>>    Procedure FilterExpressionAddOperand tTableQuery ByRef strQuery tTQFilterSegment strFilterSegment
41379>>>>>>>        Integer iActiveFilterExpression
41379>>>>>>>        Move (SizeOfArray(strQuery.aFilterExpressions)-1) to iActiveFilterExpression
41380>>>>>>>        If (iActiveFilterExpression>=0) Begin
41382>>>>>>>            Send _FilterExpressionAddOperand (&strQuery) (&strQuery.aFilterExpressions[iActiveFilterExpression].aSubExpressions) strFilterSegment
41383>>>>>>>        End
41383>>>>>>>>
41383>>>>>>>        Else Begin
41384>>>>>>>            Send OnError 719 "No active expression filter"
41385>>>>>>>        End
41385>>>>>>>>
41385>>>>>>>    End_Procedure
41386>>>>>>>
41386>>>>>>>    Procedure FilterEnterOverAndOut tTableQuery ByRef strQuery
41388>>>>>>>        If (strQuery._strControlBlock.bFilterExpressionActive) Begin
41390>>>>>>>            Move False to strQuery._strControlBlock.bFilterExpressionActive
41391>>>>>>>        End
41391>>>>>>>>
41391>>>>>>>        Else Begin
41392>>>>>>>            Send OnError 720 "No active filter expression to close"
41393>>>>>>>        End
41393>>>>>>>>
41393>>>>>>>    End_Procedure
41394>>>>>>>
41394>>>>>>>        Function _ValidateQuery tTableQuery strQuery Returns Boolean
41396>>>>>>>            // Check that no more than 1 constraints is put on each column (allow for interval checking though)
41396>>>>>>>            Integer iConstrainMax iConstrainIndex iComp 
41396>>>>>>>            Integer iNewLoad iCurrentLoad iColumn
41396>>>>>>>            Integer iTable
41396>>>>>>>            Integer[][] aaConstrainLoads
41397>>>>>>>            Move (SizeOfArray(strQuery.aFilters)-1) to iConstrainMax
41398>>>>>>>            For iConstrainIndex from 0 to iConstrainMax
41404>>>>>>>>
41404>>>>>>>
41404>>>>>>>                Move strQuery.aFilters[iConstrainIndex].strLeftValue.iTable to iTable
41405>>>>>>>                
41405>>>>>>>                If (iTable>=SizeOfArray(aaConstrainLoads)) Begin
41407>>>>>>>                    Move 0 to aaConstrainLoads[iTable][0]
41408>>>>>>>                End
41408>>>>>>>>
41408>>>>>>>
41408>>>>>>>                // Check that no more than 1 constraints is put on each column (allow for interval checking though)
41408>>>>>>>                Move strQuery.aFilters[iConstrainIndex].iComp to iComp
41409>>>>>>>                If (iComp=tqGT or iComp=tqGE) Move 1 to iNewLoad      // 01
41412>>>>>>>                Else If (iComp=tqLT or iComp=tqLE) Move 2 to iNewLoad // 10
41416>>>>>>>                Else Move 3 to iNewLoad                               // 11
41418>>>>>>>
41418>>>>>>>                Move strQuery.aFilters[iConstrainIndex].strLeftValue.iColumn to iColumn
41419>>>>>>>                
41419>>>>>>>                If (iColumn>=SizeOfArray(aaConstrainLoads[iTable])) Begin
41421>>>>>>>                    Move 0 to iCurrentLoad
41422>>>>>>>                End
41422>>>>>>>>
41422>>>>>>>                Else Begin
41423>>>>>>>                    Move aaConstrainLoads[iTable][iColumn] to iCurrentLoad
41424>>>>>>>                End
41424>>>>>>>>
41424>>>>>>>                If (iNewLoad iand iCurrentLoad) Begin
41426>>>>>>>                    Send OnError 739 (Replace("#","Illegal filter. Column # is over-constrained",ColumnName(Self,strQuery,iTable,iColumn,True)))
41427>>>>>>>                    Function_Return False
41428>>>>>>>                End
41428>>>>>>>>
41428>>>>>>>                Move (iCurrentLoad+iNewLoad) to aaConstrainLoads[iTable][iColumn]
41429>>>>>>>
41429>>>>>>>                // ToDo: (maybe) Check that tables used for AddFilterRelate are not used as relate tables also.
41429>>>>>>>
41429>>>>>>>            Loop
41430>>>>>>>>
41430>>>>>>>            Function_Return True
41431>>>>>>>        End_Function
41432>>>>>>>
41432>>>>>>>        Function _IsTableFixed tTableQuery strQ Integer iTable Returns Boolean
41434>>>>>>>            Integer iRelateItem
41434>>>>>>>            If (iTable=strQ.iTable) Begin
41436>>>>>>>                Function_Return False // If it's the main table of the query it is definitely not fixed.
41437>>>>>>>            End
41437>>>>>>>>
41437>>>>>>>            Get _FindTableRelation strQ iTable to iRelateItem
41438>>>>>>>            If (iRelateItem<>-1) Begin
41440>>>>>>>                Function_Return strQ.aTableRelations[iRelateItem].bFixed
41441>>>>>>>            End
41441>>>>>>>>
41441>>>>>>>            Send OnError 735 ("Table not related: "+String(iTable))
41442>>>>>>>        End_Function
41443>>>>>>>
41443>>>>>>>        Function _ColumnRatings tTableQuery strQuery Returns Number[]
41445>>>>>>>            // Calculate an array of columns that can be used for jump-in /jump-out.
41445>>>>>>>            // If a column has a jump-in value or a jump-out value it is rated (apr) 0.5.
41445>>>>>>>            // If a column has both it is rated 2.0.
41445>>>>>>>            Integer iColumn
41445>>>>>>>            Integer iIndex iIndices
41445>>>>>>>            Integer iSegment iSegments
41445>>>>>>>            Integer iConstraint iConstraints
41445>>>>>>>            Integer iTable iComp
41445>>>>>>>
41445>>>>>>>            Number[] aColumnRatings
41446>>>>>>>            tOCTable strTable
41446>>>>>>>            tOCTable strTable
41446>>>>>>>
41446>>>>>>>            Move strQuery.iTable to iTable
41447>>>>>>>
41447>>>>>>>            Get TableDefinition of oOverlapColumnFunctions iTable to strTable
41448>>>>>>>
41448>>>>>>>            Move (SizeOfArray(strTable.aIndices)-1) to iIndices
41449>>>>>>>            Move (SizeOfArray(strQuery.aFilters)-1) to iConstraints
41450>>>>>>>            Move (ResizeArray(aColumnRatings,SizeOfArray(strTable.aColumns))) to aColumnRatings
41451>>>>>>>
41451>>>>>>>            For iIndex from 1 to iIndices
41457>>>>>>>>
41457>>>>>>>                Move (SizeOfArray(strTable.aIndices[iIndex].aSegments)-1) to iSegments
41458>>>>>>>
41458>>>>>>>                For iSegment from 0 to iSegments
41464>>>>>>>>
41464>>>>>>>                    Move strTable.aIndices[iIndex].aSegments[iSegment].iColumn to iColumn
41465>>>>>>>
41465>>>>>>>                    If (aColumnRatings[iColumn]=0) Begin // To avoid the same column getting added ratings because appearing in multiple indices
41467>>>>>>>
41467>>>>>>>                        For iConstraint from 0 to iConstraints
41473>>>>>>>>
41473>>>>>>>
41473>>>>>>>                            // Only evaluate filters that:
41473>>>>>>>                            //  1. (left side) filters on a column in the query main table
41473>>>>>>>                            //  2. (right side) does not filter on a column from a table that changes on each new main table record
41473>>>>>>>
41473>>>>>>>                            If ( strQuery.aFilters[iConstraint].strLeftValue.iTable=iTable and ;                                    ( strQuery.aFilters[iConstraint].strRightValue.iTable=0 or ;                                      _IsTableFixed(Self,strQuery,strQuery.aFilters[iConstraint].strRightValue.iTable) )) Begin
41475>>>>>>>
41475>>>>>>>                                Move strQuery.aFilters[iConstraint].iComp to iComp
41476>>>>>>>                                If (iColumn=strQuery.aFilters[iConstraint].strLeftValue.iColumn) Begin
41478>>>>>>>
41478>>>>>>>                                    If (iComp=tqEQ) Begin
41480>>>>>>>                                        Move 2 to aColumnRatings[iColumn]
41481>>>>>>>                                    End
41481>>>>>>>>
41481>>>>>>>                                    Else If (iComp=tqGE or iComp=tqGT) Begin
41484>>>>>>>                                        Move (aColumnRatings[iColumn]+0.49) to aColumnRatings[iColumn]
41485>>>>>>>                                    End
41485>>>>>>>>
41485>>>>>>>                                    Else If (iComp=tqLT or iComp=tqLE) Begin
41488>>>>>>>                                        Move (aColumnRatings[iColumn]+0.51) to aColumnRatings[iColumn]
41489>>>>>>>                                    End
41489>>>>>>>>
41489>>>>>>>                                    // Note: Using the values 0.49 and 0.51 is a trick to allow the consumer
41489>>>>>>>                                    //       of these data to determine whether the constraining operator
41489>>>>>>>                                    //       was Lx or Gx (or both). It means nothing to the final ranking
41489>>>>>>>                                    //       of the indices. They are both weighed by 0.5.
41489>>>>>>>                                End
41489>>>>>>>>
41489>>>>>>>                            End
41489>>>>>>>>
41489>>>>>>>                        Loop
41490>>>>>>>>
41490>>>>>>>                    End
41490>>>>>>>>
41490>>>>>>>                Loop
41491>>>>>>>>
41491>>>>>>>            Loop
41492>>>>>>>>
41492>>>>>>>
41492>>>>>>>            Function_Return aColumnRatings
41493>>>>>>>        End_Function
41494>>>>>>>
41494>>>>>>>            // If this returns true column iColumn is constrained to a fixed value. (If it is, the
41494>>>>>>>            // column may be discarded if appearing as a most-significant index segment)
41494>>>>>>>            Function _ColumnFixedByEqConstraint tTableQuery strQuery Integer iColumn Returns Boolean
41496>>>>>>>                Integer iConstraintIndex iConstraintMax
41496>>>>>>>                tTQFilterSegment strConstraint
41496>>>>>>>                tTQFilterSegment strConstraint
41496>>>>>>>
41496>>>>>>>                Move (SizeOfArray(strQuery.aFilters)-1) to iConstraintMax
41497>>>>>>>                For iConstraintIndex from 0 to iConstraintMax
41503>>>>>>>>
41503>>>>>>>                    Move strQuery.aFilters[iConstraintIndex] to strConstraint
41504>>>>>>>                    If (strConstraint.iComp=tqEQ and ;                        strConstraint.strLeftValue.iTable=strQuery.iTable and ;                        strConstraint.strLeftValue.iColumn=iColumn and ;                        SizeOfArray(strConstraint.strRightValue.aOrList)<2) Begin
41506>>>>>>>                        Function_Return True
41507>>>>>>>                    End
41507>>>>>>>>
41507>>>>>>>                Loop
41508>>>>>>>>
41508>>>>>>>                Function_Return False
41509>>>>>>>            End_Function
41510>>>>>>>
41510>>>>>>>            Function _IndexSegmentAgreement tTQOrderBySegment strOrderSegment Integer iTable tOCIndexSegment[] aIndexSegments Integer iIndexSegment Boolean bBackwards Boolean bEQ Returns Boolean
41512>>>>>>>                If (iIndexSegment<SizeOfArray(aIndexSegments)) Begin //If there is no more segments in the index then obviously we cant be in agreement
41514>>>>>>>                    If (strOrderSegment.strValueSource.iTable=iTable) Begin // If the required segment is of another table we're definately not in agreement
41516>>>>>>>                        If (strOrderSegment.strValueSource.iColumn=aIndexSegments[iIndexSegment].iColumn) Begin
41518>>>>>>>                            If (strOrderSegment.bUppercase=aIndexSegments[iIndexSegment].bUppercase) Begin
41520>>>>>>>                                If (bEQ) Begin // It doesn't matter if they don't match if we are under an EQ constraint
41522>>>>>>>                                    Function_Return True // So we just say: fine!
41523>>>>>>>                                End
41523>>>>>>>>
41523>>>>>>>                                // If we are not under an EQ constraint we have to consider the direction:
41523>>>>>>>                                If (bBackwards) Begin
41525>>>>>>>                                    If ((Integer(strOrderSegment.bDescending)+Integer(aIndexSegments[iIndexSegment].bDescending))=1) Begin // xor = if they are opposite
41527>>>>>>>                                        Function_Return True
41528>>>>>>>                                    End
41528>>>>>>>>
41528>>>>>>>                                End
41528>>>>>>>>
41528>>>>>>>                                Else Begin
41529>>>>>>>                                    If (strOrderSegment.bDescending=aIndexSegments[iIndexSegment].bDescending) Begin
41531>>>>>>>                                        Function_Return True
41532>>>>>>>                                    End
41532>>>>>>>>
41532>>>>>>>                                End
41532>>>>>>>>
41532>>>>>>>                            End
41532>>>>>>>>
41532>>>>>>>                        End
41532>>>>>>>>
41532>>>>>>>                    End
41532>>>>>>>>
41532>>>>>>>                End
41532>>>>>>>>
41532>>>>>>>                Function_Return False
41533>>>>>>>            End_Function
41534>>>>>>>            
41534>>>>>>>            // The index is trimmed in the sence that most-significant segments of the index are removed
41534>>>>>>>            // if they are bounded by an eq-constraint.
41534>>>>>>>            Function _TrimIndexSegments tTableQuery strQuery tOCIndexSegment[] aIndexSegments Returns tOCIndexSegment[]
41536>>>>>>>                Integer iSegments iSkipSegments
41536>>>>>>>                tOCIndexSegment[] aRemainingSegments
41536>>>>>>>                tOCIndexSegment[] aRemainingSegments
41537>>>>>>>                Move 0 to iSkipSegments
41538>>>>>>>                Move (SizeOfArray(aIndexSegments)-1) to iSegments
41539>>>>>>>                While (iSkipSegments<=iSegments and _ColumnFixedByEqConstraint(Self,strQuery,aIndexSegments[iSkipSegments].iColumn))
41543>>>>>>>                    Increment iSkipSegments
41544>>>>>>>                Loop
41545>>>>>>>>
41545>>>>>>>                If (SizeOfArray(aIndexSegments)>0) Begin
41547>>>>>>>                    Move (CopyArray(aIndexSegments,iSkipSegments,iSegments)) to aRemainingSegments
41548>>>>>>>                End
41548>>>>>>>>
41548>>>>>>>                Function_Return aRemainingSegments
41549>>>>>>>            End_Function
41550>>>>>>>            
41550>>>>>>>            Function _TrimOrderBySegments tTableQuery strQuery tTQOrderBySegment[] aOrderingBySegments Returns tTQOrderBySegment[]
41552>>>>>>>                Integer iTable
41552>>>>>>>                Integer iSegments iSkipSegments
41552>>>>>>>                tTQOrderBySegment[] aRemainingSegments
41552>>>>>>>                tTQOrderBySegment[] aRemainingSegments
41553>>>>>>>
41553>>>>>>>                Move strQuery.iTable to iTable
41554>>>>>>>                Move 0 to iSkipSegments
41555>>>>>>>                Move (SizeOfArray(aOrderingBySegments)-1) to iSegments
41556>>>>>>>                If (iSegments>=0) Begin
41558>>>>>>>                    While (iSkipSegments<=iSegments and aOrderingBySegments[iSkipSegments].strValueSource.iTable=iTable and _ColumnFixedByEqConstraint(Self,strQuery,aOrderingBySegments[iSkipSegments].strValueSource.iColumn))
41562>>>>>>>                        Increment iSkipSegments
41563>>>>>>>                    Loop
41564>>>>>>>>
41564>>>>>>>                    Move (CopyArray(aOrderingBySegments,iSkipSegments,iSegments)) to aRemainingSegments
41565>>>>>>>                End
41565>>>>>>>>
41565>>>>>>>                Function_Return aRemainingSegments
41566>>>>>>>            End_Function
41567>>>>>>>            
41567>>>>>>>        Function _IndexAgreement tTableQuery strQuery Integer iIndex Boolean bFinalDecision Returns Boolean
41569>>>>>>>            // Is the index in agreement with the specified output order?
41569>>>>>>>            // 
41569>>>>>>>            // For each segment in the desired output order it must be the case that it is a
41569>>>>>>>            // table column based segment and that either:
41569>>>>>>>            //  
41569>>>>>>>            //     1)   its value is fixed by a eq-constraint and all segments before it has been 
41569>>>>>>>            //          satisfied the same way (if the column happens to be the same as the
41569>>>>>>>            //          "next segment" in the index we're testing, then we must disregard that
41569>>>>>>>            //          segment from then on).
41569>>>>>>>            // or
41569>>>>>>>            //     2)   it is satisfied by the "next segment" in the index we're testing
41569>>>>>>>            //
41569>>>>>>>            tOCIndex              strIndex
41569>>>>>>>            tOCIndex              strIndex
41569>>>>>>>            tOCIndexSegment[]     aIndexSegments
41569>>>>>>>            tOCIndexSegment[]     aIndexSegments
41570>>>>>>>            tTQOrderBySegment[]   aOrderingSegments
41570>>>>>>>            tTQOrderBySegment[]   aOrderingSegments
41571>>>>>>>            _tTQValueSource       strValueSource
41571>>>>>>>            _tTQValueSource       strValueSource
41571>>>>>>>            
41571>>>>>>>            Boolean bOrderSegmentOK bIndexSegmentMatch
41571>>>>>>>            Boolean bBackwards bEq
41571>>>>>>>            Integer iIndexSegment iIndexSegments
41571>>>>>>>            Integer iOrderingSegment iOrderingSegments
41571>>>>>>>            Integer iConstraint
41571>>>>>>>            
41571>>>>>>>            If (strQuery._strCompiled.nENR=0) Begin // If index is fully specified all indices agree
41573>>>>>>>                Function_Return True
41574>>>>>>>            End
41574>>>>>>>>
41574>>>>>>>
41574>>>>>>>            If (bFinalDecision) Begin
41576>>>>>>>                Move strQuery._strCompiled.bBackwards to bBackwards
41577>>>>>>>            End
41577>>>>>>>>
41577>>>>>>>            Else Begin
41578>>>>>>>                If (iIndex>1000) Begin
41580>>>>>>>                    Move (iIndex-1000) to iIndex
41581>>>>>>>                    Move True to bBackwards
41582>>>>>>>                End
41582>>>>>>>>
41582>>>>>>>                Else Begin
41583>>>>>>>                    Move False to bBackwards
41584>>>>>>>                End
41584>>>>>>>>
41584>>>>>>>            End
41584>>>>>>>>
41584>>>>>>>            
41584>>>>>>>            Get IndexDefinition of oOverlapColumnFunctions strQuery.iTable iIndex to strIndex
41585>>>>>>>            
41585>>>>>>>            Get _TrimIndexSegments strQuery strIndex.aSegments to aIndexSegments
41586>>>>>>>            Get _TrimOrderBySegments strQuery strQuery.aOrdering to aOrderingSegments
41587>>>>>>>
41587>>>>>>>            Move (SizeOfArray(aIndexSegments)-1) to iIndexSegments
41588>>>>>>>            Move (SizeOfArray(aOrderingSegments)-1) to iOrderingSegments
41589>>>>>>>            
41589>>>>>>>            Move 0 to iIndexSegment
41590>>>>>>>            
41590>>>>>>>            For iOrderingSegment from 0 to iOrderingSegments
41596>>>>>>>>
41596>>>>>>>                Move False to bOrderSegmentOK
41597>>>>>>>                Move aOrderingSegments[iOrderingSegment].strValueSource to strValueSource
41598>>>>>>>                If (iOrderingSegment<=iIndexSegments and strValueSource.iTable=strQuery.iTable) Begin // If the order-segment is main-table-based
41600>>>>>>>                    
41600>>>>>>>                    Get _FindConstraintEQ strQuery.aFilters strQuery.iTable strValueSource.iColumn False to iConstraint
41601>>>>>>>                    Move (iConstraint<>-1) to bEq
41602>>>>>>>                    
41602>>>>>>>                    Get _IndexSegmentAgreement aOrderingSegments[iOrderingSegment] strQuery.iTable aIndexSegments iIndexSegment bBackwards bEq to bIndexSegmentMatch
41603>>>>>>>                    
41603>>>>>>>                    If (bIndexSegmentMatch) Begin
41605>>>>>>>                        Move True to bOrderSegmentOK
41606>>>>>>>                        Increment iIndexSegment
41607>>>>>>>                    End
41607>>>>>>>>
41607>>>>>>>                    Else Begin
41608>>>>>>>                        // If the segment is constrained by an EQ we are still in agreement
41608>>>>>>>                        If (_ColumnFixedByEqConstraint(Self,strQuery,strValueSource.iColumn)) Begin
41610>>>>>>>                            Move True to bOrderSegmentOK
41611>>>>>>>                        End
41611>>>>>>>>
41611>>>>>>>                    End
41611>>>>>>>>
41611>>>>>>>                End
41611>>>>>>>>
41611>>>>>>>
41611>>>>>>>                If (not(bOrderSegmentOK)) Begin
41613>>>>>>>                    Function_Return False
41614>>>>>>>                End
41614>>>>>>>>
41614>>>>>>>            Loop
41615>>>>>>>>
41615>>>>>>>            Function_Return True
41616>>>>>>>        End_Function
41617>>>>>>>
41617>>>>>>>        Function _IndexExpectedNumberRows tTableQuery strQuery Integer iIndex Number[] aColumnRatings _tTQIndexAnalysis strIndexA Returns Number
41619>>>>>>>            Boolean bAccept
41619>>>>>>>            Integer iTable iColumn
41619>>>>>>>            Integer iSegmentIndex iSegmentMax iPushIndex
41619>>>>>>>            Number nExpectedNumberRows 
41619>>>>>>>            tOCIndex strIndex
41619>>>>>>>            tOCIndex strIndex
41619>>>>>>>            Number nColumnRating
41619>>>>>>>            
41619>>>>>>>            If (iIndex>=1000) Begin
41621>>>>>>>                Move (iIndex-1000) to iIndex
41622>>>>>>>            End
41622>>>>>>>>
41622>>>>>>>
41622>>>>>>>            Move strQuery.iTable to iTable
41623>>>>>>>            Get_Attribute DF_FILE_RECORDS_USED of iTable to nExpectedNumberRows
41626>>>>>>>            Get IndexDefinition of oOverlapColumnFunctions iTable iIndex to strIndex
41627>>>>>>>            Move (SizeOfArray(strIndex.aSegments)) to iSegmentMax
41628>>>>>>>            
41628>>>>>>>            Move True to bAccept
41629>>>>>>>            Move 0 to iSegmentIndex
41630>>>>>>>            
41630>>>>>>>            While (bAccept and iSegmentIndex<iSegmentMax) // From l-to-r: get all consecutive EQ segments
41634>>>>>>>                Move strIndex.aSegments[iSegmentIndex].iColumn to iColumn
41635>>>>>>>                Move aColumnRatings[iColumn] to nColumnRating
41636>>>>>>>                Move (nColumnRating=2) to bAccept
41637>>>>>>>                If (bAccept) Begin
41639>>>>>>>                    Move (nExpectedNumberRows*strIndexA.aSegmentReductions[iSegmentIndex]) to nExpectedNumberRows
41640>>>>>>>                    Increment iSegmentIndex
41641>>>>>>>                End
41641>>>>>>>>
41641>>>>>>>            Loop
41642>>>>>>>>
41642>>>>>>>            
41642>>>>>>>            If (bAccept) Begin // Means that all segments have been provided eq constraints
41644>>>>>>>                Function_Return 0 // The best possible result    
41645>>>>>>>            End
41645>>>>>>>>
41645>>>>>>>            
41645>>>>>>>            Move iSegmentIndex to iPushIndex
41646>>>>>>>            Move True to bAccept
41647>>>>>>>            
41647>>>>>>>            While (bAccept and iSegmentIndex<iSegmentMax) // Continuing l-to-r: get all consecutive GE/GT segments
41651>>>>>>>                Move strIndex.aSegments[iSegmentIndex].iColumn to iColumn
41652>>>>>>>                Move aColumnRatings[iColumn] to nColumnRating
41653>>>>>>>                Move (nColumnRating>=1 or nColumnRating=0.49) to bAccept
41654>>>>>>>                If (bAccept) Begin
41656>>>>>>>                    Move (nExpectedNumberRows*0.5) to nExpectedNumberRows
41657>>>>>>>                    Increment iSegmentIndex
41658>>>>>>>                End
41658>>>>>>>>
41658>>>>>>>            Loop
41659>>>>>>>>
41659>>>>>>>
41659>>>>>>>            Move iPushIndex to iSegmentIndex
41660>>>>>>>            Move True to bAccept
41661>>>>>>>            
41661>>>>>>>            While (bAccept and iSegmentIndex<iSegmentMax) // Continuing l-to-r: get all consecutive LE/LT segments
41665>>>>>>>                Move strIndex.aSegments[iSegmentIndex].iColumn to iColumn
41666>>>>>>>                Move aColumnRatings[iColumn] to nColumnRating
41667>>>>>>>                Move (nColumnRating>=1 or nColumnRating=0.51) to bAccept
41668>>>>>>>                If (bAccept) Begin
41670>>>>>>>                    Move (nExpectedNumberRows*0.5) to nExpectedNumberRows
41671>>>>>>>                    Increment iSegmentIndex
41672>>>>>>>                End
41672>>>>>>>>
41672>>>>>>>            Loop
41673>>>>>>>>
41673>>>>>>>            Function_Return nExpectedNumberRows
41674>>>>>>>        End_Function
41675>>>>>>>
41675>>>>>>>        Function _IndexRating tTableQuery strQuery Integer iIndex Number[] aColumnRatings _tTQIndexAnalysis strIndexA Returns _tTQIndexRating
41677>>>>>>>            Integer iTable
41677>>>>>>>            _tTQIndexRating strRating
41677>>>>>>>            _tTQIndexRating strRating
41677>>>>>>>            Move strQuery.iTable to iTable
41678>>>>>>>            Move iIndex to strRating.iIndex
41679>>>>>>>            Get _IndexExpectedNumberRows strQuery iIndex aColumnRatings strIndexA to strRating.nExpectedNumberRows
41680>>>>>>>            If (strRating.nExpectedNumberRows=0) Begin
41682>>>>>>>                Move True to strRating.bOutputAgree
41683>>>>>>>            End
41683>>>>>>>>
41683>>>>>>>            Else Begin
41684>>>>>>>                Get _IndexAgreement strQuery iIndex False to strRating.bOutputAgree
41685>>>>>>>            End
41685>>>>>>>>
41685>>>>>>>            If (iIndex>=1000) Begin // find lt by index iIndex-1000
41687>>>>>>>                Move (iIndex-1000) to iIndex
41688>>>>>>>                Get_Attribute DF_INDEX_LEVELS of iTable iIndex 0 to strRating.iKeyLevels
41691>>>>>>>                Get_Attribute DF_INDEX_KEY_LENGTH of iTable iIndex 0 to strRating.iKeyLength
41694>>>>>>>                Move (strRating.iKeyLength+1) to strRating.iKeyLength // Always prefer find gt to find lt when all else is equal
41695>>>>>>>            End
41695>>>>>>>>
41695>>>>>>>            Else Begin
41696>>>>>>>                Get_Attribute DF_INDEX_LEVELS of iTable iIndex 0 to strRating.iKeyLevels
41699>>>>>>>                Get_Attribute DF_INDEX_KEY_LENGTH of iTable iIndex 0 to strRating.iKeyLength
41702>>>>>>>            End
41702>>>>>>>>
41702>>>>>>>
41702>>>>>>>            Function_Return strRating
41703>>>>>>>        End_Function
41704>>>>>>>
41704>>>>>>>        Function _IndexRatings tTableQuery strQuery Returns _tTQIndexRating[]
41706>>>>>>>            // Create an array of defined indices on the table and for each index assign a rating
41706>>>>>>>            // Sort the array of indices according to rating and pick the one with the highest one.
41706>>>>>>>            Integer iItem iMax 
41706>>>>>>>            Integer iIndex
41706>>>>>>>            Integer[] aIndices
41707>>>>>>>            Number[] aColumnRatings
41708>>>>>>>            tTQTableAnalysis strAnalysis
41708>>>>>>>            tTQTableAnalysis strAnalysis
41708>>>>>>>            _tTQIndexRating strRating
41708>>>>>>>            _tTQIndexRating strRating
41708>>>>>>>            _tTQIndexRating[] aIndexRatings
41708>>>>>>>            _tTQIndexRating[] aIndexRatings
41709>>>>>>>            
41709>>>>>>>            Get TableAnalysis strQuery.iTable to strAnalysis
41710>>>>>>>            
41710>>>>>>>            Get _ColumnRatings strQuery to aColumnRatings
41711>>>>>>>
41711>>>>>>>            Get TableIndices strQuery.iTable to aIndices // All on-line indices
41712>>>>>>>            
41712>>>>>>>            Move (SizeOfArray(aIndices)-1) to iMax
41713>>>>>>>            For iItem from 0 to iMax
41719>>>>>>>>
41719>>>>>>>                Move aIndices[iItem] to iIndex
41720>>>>>>>                Get _IndexRating strQuery iIndex aColumnRatings strAnalysis.aIndices[iIndex] to strRating
41721>>>>>>>                Move strRating to aIndexRatings[SizeOfArray(aIndexRatings)]
41722>>>>>>>                // Also check the reverse index:
41722>>>>>>>                Get _IndexRating strQuery (1000+iIndex) aColumnRatings strAnalysis.aIndices[iIndex] to strRating
41723>>>>>>>                Move strRating to aIndexRatings[SizeOfArray(aIndexRatings)]
41724>>>>>>>            Loop
41725>>>>>>>>
41725>>>>>>>            Function_Return aIndexRatings
41726>>>>>>>        End_Function
41727>>>>>>>
41727>>>>>>>        Function _LowestIndexNumber Integer iTable Returns Integer
41729>>>>>>>            Integer iIndex iIndexMax iSegments
41729>>>>>>>
41729>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iTable to iIndexMax
41732>>>>>>>            Move 1 to iIndex
41733>>>>>>>            While (iIndex<=iIndexMax)
41737>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iTable iIndex to iSegments
41740>>>>>>>                If (iSegments<>0) Begin
41742>>>>>>>                    Function_Return iIndex
41743>>>>>>>                End
41743>>>>>>>>
41743>>>>>>>            Loop
41744>>>>>>>>
41744>>>>>>>            
41744>>>>>>>            Function_Return 0 // None found
41745>>>>>>>        End_Function
41746>>>>>>>
41746>>>>>>>        Function _CompareIndexRating _tTQIndexRating strRatingLeft _tTQIndexRating strRatingRight Returns Integer
41748>>>>>>>            Number nFactorLeft nFactorRight
41748>>>>>>>            Number nPrefetchAvoidanceFactor
41748>>>>>>>        
41748>>>>>>>            Get _pnPrefetchAvoidanceFactor to nPrefetchAvoidanceFactor
41749>>>>>>>        
41749>>>>>>>            // This means that we accept an index in agreement with the output order if it is more
41749>>>>>>>            // than 10 times less efficient (assuming that nPrefetchAvoidanceFactor is 0.1 (which it is (by default)))
41749>>>>>>>            Move (If(strRatingLeft.bOutputAgree,nPrefetchAvoidanceFactor,1)) to nFactorLeft
41750>>>>>>>            Move (If(strRatingRight.bOutputAgree,nPrefetchAvoidanceFactor,1)) to nFactorRight
41751>>>>>>>            
41751>>>>>>>            Move (strRatingLeft.nExpectedNumberRows*nFactorLeft) to nFactorLeft
41752>>>>>>>            Move (strRatingRight.nExpectedNumberRows*nFactorRight) to nFactorRight
41753>>>>>>>
41753>>>>>>>            If (nFactorLeft > nFactorRight) Function_Return (GT) // Right is best
41756>>>>>>>            If (nFactorLeft < nFactorRight) Function_Return (LT) // Left is best
41759>>>>>>>            
41759>>>>>>>            If (strRatingLeft.iKeyLevels>strRatingRight.iKeyLevels) Function_Return (GT) // Right is best
41762>>>>>>>            If (strRatingLeft.iKeyLevels<strRatingRight.iKeyLevels) Function_Return (LT) // Left is best 
41765>>>>>>>            
41765>>>>>>>            If (strRatingLeft.iKeyLength>strRatingRight.iKeyLength) Function_Return (GT) // Right is best
41768>>>>>>>            If (strRatingLeft.iKeyLength<strRatingRight.iKeyLength) Function_Return (LT) // Left is best
41771>>>>>>>                                                                                  
41771>>>>>>>            Function_Return (EQ)
41772>>>>>>>        End_Function
41773>>>>>>>
41773>>>>>>>        Function _CalculateIndex tTableQuery ByRef strQuery Returns _tTQIndexRating[] 
41775>>>>>>>            Integer iIndex iIndexIndex
41775>>>>>>>            Number nENR
41775>>>>>>>            _tTQIndexRating[] aIndexRatings
41775>>>>>>>            _tTQIndexRating[] aIndexRatings
41776>>>>>>>            
41776>>>>>>>            Get _IndexRatings strQuery to aIndexRatings
41777>>>>>>>            Move (SizeOfArray(aIndexRatings)-1) to iIndexIndex
41778>>>>>>>            If (iIndexIndex>=0) Begin
41780>>>>>>>                If (strQuery.bForcePrefetch) Begin
41782>>>>>>>                    // If prefetch is forced anyway, we will not consider prefetch an "extra" cost.
41782>>>>>>>                    Set _pnPrefetchAvoidanceFactor to 1 
41783>>>>>>>                End
41783>>>>>>>>
41783>>>>>>>                Else Begin
41784>>>>>>>                    Set _pnPrefetchAvoidanceFactor to strQuery._strControlBlock.nPrefetchAvoidanceFactor
41785>>>>>>>                End
41785>>>>>>>>
41785>>>>>>>                Move (SortArray(aIndexRatings,Self,GET__CompareIndexRating)) to aIndexRatings
41786>>>>>>>                Move aIndexRatings[0].iIndex to iIndex
41787>>>>>>>                Move aIndexRatings[0].nExpectedNumberRows to nENR
41788>>>>>>>            End
41788>>>>>>>>
41788>>>>>>>            Else Begin
41789>>>>>>>                Move 0 to iIndex
41790>>>>>>>                Move -1 to nENR // No idea
41791>>>>>>>            End
41791>>>>>>>>
41791>>>>>>>
41791>>>>>>>            If (iIndex>=1000) Begin
41793>>>>>>>                Move (iIndex-1000) to iIndex
41794>>>>>>>                Move (not(strQuery._strCompiled.bBackwards)) to strQuery._strCompiled.bBackwards // Flip
41795>>>>>>>            End
41795>>>>>>>>
41795>>>>>>>            
41795>>>>>>>            Move iIndex to strQuery._strCompiled.iIndex
41796>>>>>>>            Move nENR to strQuery._strCompiled.nENR
41797>>>>>>>            
41797>>>>>>>            Function_Return aIndexRatings
41798>>>>>>>        End_Function
41799>>>>>>>        
41799>>>>>>>    Function IndexRatingText tTableQuery strQuery _tTQIndexRating[] aIndexRatings Returns String
41801>>>>>>>        Boolean bBackwards
41801>>>>>>>        Integer iItem iMax iTable iIndex
41801>>>>>>>        Number nRecCount nFactor
41801>>>>>>>        String sValue sIndex sTemp
41801>>>>>>>
41801>>>>>>>        Move strQuery.iTable to iTable
41802>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of iTable to nRecCount
41805>>>>>>>        
41805>>>>>>>        If (strQuery.bForcePrefetch) Begin
41807>>>>>>>            Move 1 to nFactor
41808>>>>>>>        End
41808>>>>>>>>
41808>>>>>>>        Else Begin
41809>>>>>>>            Move strQuery._strControlBlock.nPrefetchAvoidanceFactor to nFactor
41810>>>>>>>        End
41810>>>>>>>>
41810>>>>>>>        
41810>>>>>>>        If (strQuery.iForceIndex=-1) Begin
41812>>>>>>>            Move "Index Ratings\n\nRatings are based on expected number of rows (ENR). If the use of an index implies prefetching and sorting data then ENR is multiplied by # (but not shown).\n\nIndex ratings, best to worst (there is # rows in table #):\n" to sValue
41813>>>>>>>            Move (Replace("#",sValue,String(1.0/nFactor))) to sValue
41814>>>>>>>            Move (Replace("#",sValue,NumberToString(oStringFunctions,nRecCount,0))) to sValue
41815>>>>>>>            Move (Replace("#",sValue,TableName(Self,strQuery,iTable))) to sValue
41816>>>>>>>            Move (SizeOfArray(aIndexRatings)-1) to iMax
41817>>>>>>>            For iItem from 0 to iMax
41823>>>>>>>>
41823>>>>>>>                Move "Index ##: ENR=#, #, Levels/length=#/#" to sIndex
41824>>>>>>>                Move aIndexRatings[iItem].iIndex to iIndex
41825>>>>>>>                If (iIndex>1000) Begin
41827>>>>>>>                    Move (iIndex-1000) to iIndex
41828>>>>>>>                    Move True to bBackwards
41829>>>>>>>                End
41829>>>>>>>>
41829>>>>>>>                Else Begin
41830>>>>>>>                    Move False to bBackwards
41831>>>>>>>                End
41831>>>>>>>>
41831>>>>>>>                Move (Replace("#",sIndex,String(iIndex))) to sIndex
41832>>>>>>>                If (bBackwards) Begin
41834>>>>>>>                    Move (Replace("#",sIndex," (backwards)")) to sIndex
41835>>>>>>>                End
41835>>>>>>>>
41835>>>>>>>                Else Begin
41836>>>>>>>                    Move (Replace("#",sIndex,"")) to sIndex
41837>>>>>>>                End
41837>>>>>>>>
41837>>>>>>>                Move (Replace("#",sIndex,String(aIndexRatings[iItem].nExpectedNumberRows))) to sIndex
41838>>>>>>>                Move (If(aIndexRatings[iItem].bOutputAgree,"Ordering ok","Prefetch needed")) to sTemp
41839>>>>>>>                Move (Replace("#",sIndex,sTemp)) to sIndex
41840>>>>>>>                Move (Replace("#",sIndex,String(aIndexRatings[iItem].iKeyLevels))) to sIndex
41841>>>>>>>                Move (Replace("#",sIndex,String(aIndexRatings[iItem].iKeyLength))) to sIndex
41842>>>>>>>                Move (sValue+"\n"+sIndex) to sValue
41843>>>>>>>            Loop
41844>>>>>>>>
41844>>>>>>>        End
41844>>>>>>>>
41844>>>>>>>        Else Begin
41845>>>>>>>            Move "Indices have not been rated (index was forced)" to sValue
41846>>>>>>>        End
41846>>>>>>>>
41846>>>>>>>        Function_Return sValue
41847>>>>>>>    End_Function
41848>>>>>>>
41848>>>>>>>    Procedure OnIndexCalculated tTableQuery strQuery _tTQIndexRating[] aIndexRatings
41850>>>>>>>    End_Procedure
41851>>>>>>>
41851>>>>>>>                Function _FindConstraintEQ tTQFilterSegment[] aFilters Integer iTable Integer iColumn Boolean bOrListOnly Returns Integer
41853>>>>>>>                    Integer iConstraint iConstraints
41853>>>>>>>                    Move (SizeOfArray(aFilters)-1) to iConstraints
41854>>>>>>>                    For iConstraint from 0 to iConstraints
41860>>>>>>>>
41860>>>>>>>                        If (iTable=aFilters[iConstraint].strLeftValue.iTable and ;                            iColumn=aFilters[iConstraint].strLeftValue.iColumn and aFilters[iConstraint].iComp=tqEQ) Begin
41862>>>>>>>                            If (not(bOrListOnly) or SizeOfArray(aFilters[iConstraint].strRightValue.aOrList)>0) Begin
41864>>>>>>>                                Function_Return iConstraint
41865>>>>>>>                            End
41865>>>>>>>>
41865>>>>>>>                        End
41865>>>>>>>>
41865>>>>>>>                    Loop
41866>>>>>>>>
41866>>>>>>>                    Function_Return -1
41867>>>>>>>                End_Function
41868>>>>>>>
41868>>>>>>>                Procedure _AppendConstraint tTQFilterSegment[] ByRef aConstraint tTQFilterSegment strConstraint
41870>>>>>>>                    Integer iIndex
41870>>>>>>>                    Move (SizeOfArray(aConstraint)) to iIndex
41871>>>>>>>                    Move strConstraint to aConstraint[iIndex]
41872>>>>>>>                End_Procedure
41873>>>>>>>                
41873>>>>>>>                Procedure _DeleteConstraint tTQFilterSegment[] ByRef aFilters Integer iConstraint
41875>>>>>>>                    Move (RemoveFromArray(aFilters,iConstraint)) to aFilters
41876>>>>>>>                End_Procedure
41877>>>>>>>        
41877>>>>>>>        Procedure _CalculateJumpInOutConditionsStep01 tTableQuery ByRef strQuery Integer ByRef iSegment Integer iSegments tOCIndex strIndex
41879>>>>>>>            // 1: As long as we can consequetively provide EQ constraints on the segment, we copy the constraint to 
41879>>>>>>>            //    both the JumpInValues and JumpOutValues (and disregard that constraint from then on)
41879>>>>>>>            Integer iTable iIndex iColumn iConstraint
41879>>>>>>>            Boolean bCont
41879>>>>>>>            
41879>>>>>>>            Move strQuery.iTable to iTable
41880>>>>>>>            Move strQuery._strCompiled.iIndex to iIndex
41881>>>>>>>            
41881>>>>>>>            Move True to bCont
41882>>>>>>>
41882>>>>>>>            While (bCont and iSegment<=iSegments)
41886>>>>>>>                Move strIndex.aSegments[iSegment].iColumn to iColumn
41887>>>>>>>                Get _FindConstraintEQ strQuery.aFilters iTable iColumn False to iConstraint
41888>>>>>>>                Move (iConstraint<>-1) to bCont
41889>>>>>>>                If (bCont) Begin
41891>>>>>>>                    Send _AppendConstraint (&strQuery._strCompiled.aJumpInValues) strQuery.aFilters[iConstraint] 
41892>>>>>>>                    Send _AppendConstraint (&strQuery._strCompiled.aJumpOutValues) strQuery.aFilters[iConstraint]
41893>>>>>>>                    Send _DeleteConstraint (&strQuery.aFilters) iConstraint
41894>>>>>>>                    Increment iSegment
41895>>>>>>>                End
41895>>>>>>>>
41895>>>>>>>            Loop
41896>>>>>>>>
41896>>>>>>>        End_Procedure
41897>>>>>>>
41897>>>>>>>                Function _FindConstraintGEGT tTQFilterSegment[] aFilters Integer iTable Integer iColumn Boolean bAlsoEQ Returns Integer
41899>>>>>>>                    Integer iConstraint iConstraints iComp
41899>>>>>>>                    Move (SizeOfArray(aFilters)-1) to iConstraints
41900>>>>>>>                    For iConstraint from 0 to iConstraints
41906>>>>>>>>
41906>>>>>>>                        If (iTable=aFilters[iConstraint].strLeftValue.iTable and iColumn=aFilters[iConstraint].strLeftValue.iColumn) Begin
41908>>>>>>>                            Move aFilters[iConstraint].iComp to iComp
41909>>>>>>>                            If (iComp=tqGT or iComp=tqGE or (bAlsoEQ and iComp=tqEQ)) Begin
41911>>>>>>>                                Function_Return iConstraint
41912>>>>>>>                            End
41912>>>>>>>>
41912>>>>>>>                        End
41912>>>>>>>>
41912>>>>>>>                    Loop
41913>>>>>>>>
41913>>>>>>>                    Function_Return -1
41914>>>>>>>                End_Function
41915>>>>>>>                
41915>>>>>>>                Function _FindConstraintLELT tTQFilterSegment[] aFilters Integer iTable Integer iColumn Boolean bAlsoEQ Returns Integer
41917>>>>>>>                    Integer iConstraint iConstraints iComp
41917>>>>>>>                    Move (SizeOfArray(aFilters)-1) to iConstraints
41918>>>>>>>                    For iConstraint from 0 to iConstraints
41924>>>>>>>>
41924>>>>>>>                        If (iTable=aFilters[iConstraint].strLeftValue.iTable and iColumn=aFilters[iConstraint].strLeftValue.iColumn) Begin
41926>>>>>>>                            Move aFilters[iConstraint].iComp to iComp
41927>>>>>>>                            If (iComp=tqLT or iComp=tqLE or (bAlsoEQ and iComp=tqEQ)) Begin
41929>>>>>>>                                Function_Return iConstraint
41930>>>>>>>                            End
41930>>>>>>>>
41930>>>>>>>                        End
41930>>>>>>>>
41930>>>>>>>                    Loop
41931>>>>>>>>
41931>>>>>>>                    Function_Return -1
41932>>>>>>>                End_Function
41933>>>>>>>                
41933>>>>>>>        Procedure _CalculateJumpInOutConditionsStep02 tTableQuery ByRef strQuery Integer ByRef iJumpInSegment Integer ByRef iJumpOutSegment Integer iSegments tOCIndex strIndex
41935>>>>>>>            // 2. If we can then provide a LT,LE,GE,GT type constraint (for JumpInValues and JumpOutValues 
41935>>>>>>>            //    indepentdantly) we move the constraint to JumpInValues/JumpOutValues (and disregard that 
41935>>>>>>>            //    constraint from then on *unless* it's a jump-in constraint and the comperator is GT (or LT 
41935>>>>>>>            //    if it's a descending index segment))
41935>>>>>>>            Integer iTable iIndex iColumn iConstraint
41935>>>>>>>            Boolean bCont
41935>>>>>>>            
41935>>>>>>>            Move strQuery.iTable to iTable
41936>>>>>>>            Move strQuery._strCompiled.iIndex to iIndex
41937>>>>>>>            
41937>>>>>>>            // Jump in
41937>>>>>>>            If (iJumpInSegment<=iSegments) Begin
41939>>>>>>>                Move strIndex.aSegments[iJumpInSegment].iColumn to iColumn
41940>>>>>>>                If (strIndex.aSegments[iJumpInSegment].bDescending) Begin
41942>>>>>>>                    Get _FindConstraintLELT strQuery.aFilters iTable iColumn False to iConstraint
41943>>>>>>>                    If (iConstraint<>-1) Begin
41945>>>>>>>                        Send _AppendConstraint (&strQuery._strCompiled.aJumpInValues) strQuery.aFilters[iConstraint]
41946>>>>>>>                        If (strQuery.aFilters[iConstraint].iComp=tqLE) Begin
41948>>>>>>>                            Send _DeleteConstraint (&strQuery.aFilters) iConstraint
41949>>>>>>>                        End
41949>>>>>>>>
41949>>>>>>>                        Increment iJumpInSegment
41950>>>>>>>                    End
41950>>>>>>>>
41950>>>>>>>                    Else Begin
41951>>>>>>>                        Move -1 to iJumpInSegment
41952>>>>>>>                    End
41952>>>>>>>>
41952>>>>>>>                End
41952>>>>>>>>
41952>>>>>>>                Else Begin
41953>>>>>>>                    Get _FindConstraintGEGT strQuery.aFilters iTable iColumn False to iConstraint
41954>>>>>>>                    If (iConstraint<>-1) Begin
41956>>>>>>>                        Send _AppendConstraint (&strQuery._strCompiled.aJumpInValues) strQuery.aFilters[iConstraint] 
41957>>>>>>>                        If (strQuery.aFilters[iConstraint].iComp=tqGE) Begin
41959>>>>>>>                            Send _DeleteConstraint (&strQuery.aFilters) iConstraint
41960>>>>>>>                        End
41960>>>>>>>>
41960>>>>>>>                        Increment iJumpInSegment
41961>>>>>>>                    End
41961>>>>>>>>
41961>>>>>>>                    Else Begin
41962>>>>>>>                        Move -1 to iJumpInSegment
41963>>>>>>>                    End
41963>>>>>>>>
41963>>>>>>>                End
41963>>>>>>>>
41963>>>>>>>            End
41963>>>>>>>>
41963>>>>>>>            
41963>>>>>>>            // Jump out
41963>>>>>>>            If (iJumpOutSegment<=iSegments) Begin
41965>>>>>>>                Move strIndex.aSegments[iJumpOutSegment].iColumn to iColumn
41966>>>>>>>                If (strIndex.aSegments[iJumpOutSegment].bDescending) Begin
41968>>>>>>>                    Get _FindConstraintGEGT strQuery.aFilters iTable iColumn False to iConstraint
41969>>>>>>>                    If (iConstraint<>-1) Begin
41971>>>>>>>                        Send _AppendConstraint (&strQuery._strCompiled.aJumpOutValues) strQuery.aFilters[iConstraint] 
41972>>>>>>>                        Send _DeleteConstraint (&strQuery.aFilters) iConstraint
41973>>>>>>>                        Increment iJumpOutSegment
41974>>>>>>>                    End
41974>>>>>>>>
41974>>>>>>>                    Else Begin
41975>>>>>>>                        Move -1 to iJumpOutSegment
41976>>>>>>>                    End
41976>>>>>>>>
41976>>>>>>>                End
41976>>>>>>>>
41976>>>>>>>                Else Begin
41977>>>>>>>                    Get _FindConstraintLELT strQuery.aFilters iTable iColumn False to iConstraint
41978>>>>>>>                    If (iConstraint<>-1) Begin
41980>>>>>>>                        Send _AppendConstraint (&strQuery._strCompiled.aJumpOutValues) strQuery.aFilters[iConstraint] 
41981>>>>>>>                        Send _DeleteConstraint (&strQuery.aFilters) iConstraint
41982>>>>>>>                        Increment iJumpOutSegment
41983>>>>>>>                    End
41983>>>>>>>>
41983>>>>>>>                    Else Begin
41984>>>>>>>                        Move -1 to iJumpOutSegment
41985>>>>>>>                    End
41985>>>>>>>>
41985>>>>>>>                End
41985>>>>>>>>
41985>>>>>>>            End
41985>>>>>>>>
41985>>>>>>>        End_Procedure
41986>>>>>>>
41986>>>>>>>        Procedure _CalculateJumpInOutConditions tTableQuery ByRef strQuery
41988>>>>>>>            Integer iSegment iSegments iTable iIndex iTempIndex
41988>>>>>>>            Integer iJumpInSegment iJumpOutSegment
41988>>>>>>>            Boolean bBackwards 
41988>>>>>>>            tTQFilterSegment[] aBackupConstraints
41988>>>>>>>            tTQFilterSegment[] aBackupConstraints
41989>>>>>>>            tOCIndex strIndex
41989>>>>>>>            tOCIndex strIndex
41989>>>>>>>            
41989>>>>>>>            Move strQuery.iTable to iTable
41990>>>>>>>            Move strQuery._strCompiled.iIndex to iIndex
41991>>>>>>>            Move strQuery._strCompiled.bBackwards to bBackwards
41992>>>>>>>            Move strQuery.aFilters to aBackupConstraints
41993>>>>>>>            
41993>>>>>>>            // If the scan index is not compatible with the output index we are forced to 
41993>>>>>>>            // prefetch the record set in order to sort it before we "output" it:
41993>>>>>>>            If (not(_IndexAgreement(Self,strQuery,iIndex,True))) Begin
41995>>>>>>>
41995>>>>>>>                // If the index is the exact uppersite we still consider the index in agreement.
41995>>>>>>>                // Therefore we do not pass the information that the index is scanned backwards to 
41995>>>>>>>                // the _IndexAgreement function.
41995>>>>>>>                
41995>>>>>>>                Move True to strQuery._strCompiled.bPrefetch
41996>>>>>>>                Move strQuery._strCompiled._iLimit to strQuery._strCompiled._iPushLimit 
41997>>>>>>>
41997>>>>>>>                If (strQuery._strCompiled.bBackwards) Begin // set to the opposite of what was tested above _IndexAgreement call
41999>>>>>>>                    Move strQuery._strCompiled.iIndex to iTempIndex
42000>>>>>>>                End
42000>>>>>>>>
42000>>>>>>>                Else Begin
42001>>>>>>>                    Move (strQuery._strCompiled.iIndex+1000) to iTempIndex
42002>>>>>>>                End
42002>>>>>>>>
42002>>>>>>>
42002>>>>>>>                If (strQuery.iForceIndex=-1 and strQuery.iLimit<>0 and _IndexAgreement(Self,strQuery,iTempIndex,False)) Begin
42004>>>>>>>                    // If tail and negated index is ok then we do _not_ reset the limit.
42004>>>>>>>                End
42004>>>>>>>>
42004>>>>>>>                Else Begin
42005>>>>>>>                    Move 0 to strQuery._strCompiled._iLimit
42006>>>>>>>                End
42006>>>>>>>>
42006>>>>>>>                
42006>>>>>>>            End
42006>>>>>>>>
42006>>>>>>>            Else Begin
42007>>>>>>>                Move 0 to strQuery._strCompiled._iPushLimit
42008>>>>>>>            End
42008>>>>>>>>
42008>>>>>>>                
42008>>>>>>>            // Initialize:
42008>>>>>>>            Move (ResizeArray(strQuery._strCompiled.aJumpInValues,0)) to strQuery._strCompiled.aJumpInValues
42009>>>>>>>            Move (ResizeArray(strQuery._strCompiled.aJumpOutValues,0)) to strQuery._strCompiled.aJumpOutValues
42010>>>>>>>            Move (ResizeArray(strQuery._strCompiled.aOtherConditions,0)) to strQuery._strCompiled.aOtherConditions
42011>>>>>>>            
42011>>>>>>>            Get IndexDefinition of oOverlapColumnFunctions strQuery.iTable iIndex to strIndex
42012>>>>>>>            Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
42013>>>>>>>        
42013>>>>>>>            Move 0 to iSegment // Used to be 1
42014>>>>>>>             
42014>>>>>>>            // Calculating the JumpInValues:
42014>>>>>>>            //     Starting with the most significant segment we go through the segments of the iScanIndex
42014>>>>>>>            //        1. As long as we can consequetively provide EQ constraints on the segment, we copy the 
42014>>>>>>>            //           constraint to both the JumpInValues and JumpOutValues (and disregard that constraint 
42014>>>>>>>            //           from then on)
42014>>>>>>>                         Send _CalculateJumpInOutConditionsStep01 (&strQuery) (&iSegment) iSegments strIndex
42015>>>>>>>            //        2. If we can then provide a LT,LE,GE,GT type constraint (for JumpInValues and JumpOutValues 
42015>>>>>>>            //           respectively) we move the constraint to JumpInValues/JumpOutValues (and disregard that 
42015>>>>>>>            //           constraint from then on)
42015>>>>>>>                         Move iSegment to iJumpInSegment
42016>>>>>>>                         Move iSegment to iJumpOutSegment
42017>>>>>>>                         Send _CalculateJumpInOutConditionsStep02 (&strQuery) (&iJumpInSegment) (&iJumpOutSegment) iSegments strIndex
42018>>>>>>>            //        3. The constraints that are then left are copied to the aOtherConstraints array
42018>>>>>>>                         Move strQuery.aFilters to strQuery._strCompiled.aOtherConditions
42019>>>>>>>            Move aBackupConstraints to strQuery.aFilters 
42020>>>>>>>        End_Procedure
42021>>>>>>>
42021>>>>>>>                        Procedure _IncrementJumpInOutCondition _tTQValueSource ByRef stValue Integer ByRef bIncrement Integer ByRef bCarry
42023>>>>>>>                            Integer iMax
42023>>>>>>>                            Move (SizeOfArray(stValue.aOrList)-1) to iMax
42024>>>>>>>                            If (iMax>=0) Begin // If it's an or-list
42026>>>>>>>                                If (bIncrement or bCarry) Begin
42028>>>>>>>                                    Increment stValue._iOrListPointer
42029>>>>>>>                                    If (stValue._iOrListPointer>iMax) Begin
42031>>>>>>>                                        Move True to bCarry
42032>>>>>>>                                        Move 0 to stValue._iOrListPointer
42033>>>>>>>                                    End
42033>>>>>>>>
42033>>>>>>>                                    Else Begin
42034>>>>>>>                                        Move False to bCarry
42035>>>>>>>                                    End
42035>>>>>>>>
42035>>>>>>>                                    Move False to bIncrement
42036>>>>>>>                                End
42036>>>>>>>>
42036>>>>>>>                            End
42036>>>>>>>>
42036>>>>>>>                        End_Procedure
42037>>>>>>>                        
42037>>>>>>>                        Procedure _ResetOrListPointer _tTQValueSource ByRef stValue
42039>>>>>>>                            If (SizeOfArray(stValue.aOrList)>0) Begin
42041>>>>>>>                                Move 0 to stValue._iOrListPointer
42042>>>>>>>                            End
42042>>>>>>>>
42042>>>>>>>                        End_Procedure
42043>>>>>>>
42043>>>>>>>                Function _IncrementJumpInOutConditions tTableQuery ByRef strQuery Integer iJumpOutTriggerIndex Returns Boolean
42045>>>>>>>                    // This function increments jump-in/out pointers and returns false if pointers could not
42045>>>>>>>                    // be incremented. The pointers are into arrays of or-list values
42045>>>>>>>                    // Parameter iJumpOutTriggerIndex points to the constrain segment that triggered the jump-out
42045>>>>>>>                    // that in turn triggered the call of this function.
42045>>>>>>>                    // The or-list pointers to the left of (and including) iJumpOutTriggerIndex must be incremented
42045>>>>>>>                    // while the or-list pointers to the right must be reset.
42045>>>>>>>                    Integer iItem iMax iIndex
42045>>>>>>>                    Boolean bCarry bIncrement bSuccess bReturnFalse
42045>>>>>>>                    Move (SizeOfArray(strQuery._strCompiled.aJumpOutValues)-1) to iMax
42046>>>>>>>
42046>>>>>>>                    Move False to bReturnFalse
42047>>>>>>>
42047>>>>>>>                    If (iJumpOutTriggerIndex>=0) Begin
42049>>>>>>>                        // Increment pointers to the left
42049>>>>>>>                        Move False to bCarry
42050>>>>>>>                        Move True to bIncrement
42051>>>>>>>                        If (SizeOfArray(strQuery._strCompiled.aJumpOutValues)>0) Begin // Only of there are any jumpout values to increment upon
42053>>>>>>>                            For iItem from 0 to iJumpOutTriggerIndex
42059>>>>>>>>
42059>>>>>>>                                Move (iJumpOutTriggerIndex-iItem) to iIndex // Go throught it backwards (least significant first)
42060>>>>>>>                                Send _IncrementJumpInOutCondition (&strQuery._strCompiled.aJumpOutValues[iIndex].strRightValue) (&bIncrement) (&bCarry)
42061>>>>>>>                            Loop
42062>>>>>>>>
42062>>>>>>>                        End
42062>>>>>>>>
42062>>>>>>>                        Move (not(bCarry) and not(bIncrement)) to bSuccess
42063>>>>>>>                    End
42063>>>>>>>>
42063>>>>>>>                    Else Begin
42064>>>>>>>                        Move True to bSuccess
42065>>>>>>>                        Move True to bReturnFalse
42066>>>>>>>                    End
42066>>>>>>>>
42066>>>>>>>                    // Reset the or-lists to the lessor significant side of iJumpOutTriggerIndex
42066>>>>>>>                    If (bSuccess) Begin
42068>>>>>>>                        For iItem from (iJumpOutTriggerIndex+1) to iMax
42074>>>>>>>>
42074>>>>>>>                            Send _ResetOrListPointer (&strQuery._strCompiled.aJumpOutValues[iItem].strRightValue)
42075>>>>>>>                        Loop
42076>>>>>>>>
42076>>>>>>>                    End
42076>>>>>>>>
42076>>>>>>>
42076>>>>>>>                    If (bReturnFalse) Begin
42078>>>>>>>                        // The point is that no-way will we return true if nothing was actually incremented
42078>>>>>>>                        Function_Return False
42079>>>>>>>                    End
42079>>>>>>>>
42079>>>>>>>
42079>>>>>>>                    Function_Return bSuccess
42080>>>>>>>                End_Function
42081>>>>>>>
42081>>>>>>>                Procedure _SortVariantArray String[] ByRef aValues Integer iType Boolean bReverseArray
42083>>>>>>>                    Integer iMax iItem
42083>>>>>>>                    String[] aStringValues
42084>>>>>>>                    Number[] aNumberValues
42085>>>>>>>                    Date[] aDateValues
42086>>>>>>>                    DateTime[] aDateTimeValues
42087>>>>>>>
42087>>>>>>>                    Move (SizeOfArray(aValues)-1) to iMax
42088>>>>>>>                    If (iType=tqSTRING or iType=tqTEXT) Begin
42090>>>>>>>                        Move (SortArray(aValues)) to aValues
42091>>>>>>>                    End
42091>>>>>>>>
42091>>>>>>>                    Else If (iType=tqNUMBER) Begin
42094>>>>>>>                        For iItem from 0 to iMax
42100>>>>>>>>
42100>>>>>>>                            Move aValues[iItem] to aNumberValues[iItem]
42101>>>>>>>                        Loop
42102>>>>>>>>
42102>>>>>>>                        Move (SortArray(aNumberValues)) to aNumberValues
42103>>>>>>>                        For iItem from 0 to iMax
42109>>>>>>>>
42109>>>>>>>                            Move aNumberValues[iItem] to aValues[iItem]
42110>>>>>>>                        Loop
42111>>>>>>>>
42111>>>>>>>                    End
42111>>>>>>>>
42111>>>>>>>                    Else If (iType=tqDATE) Begin
42114>>>>>>>                        For iItem from 0 to iMax
42120>>>>>>>>
42120>>>>>>>                            Move aValues[iItem] to aDateValues[iItem]
42121>>>>>>>                        Loop
42122>>>>>>>>
42122>>>>>>>                        Move (SortArray(aDateValues)) to aDateValues
42123>>>>>>>                        For iItem from 0 to iMax
42129>>>>>>>>
42129>>>>>>>                            Move aDateValues[iItem] to aValues[iItem]
42130>>>>>>>                        Loop
42131>>>>>>>>
42131>>>>>>>                    End
42131>>>>>>>>
42131>>>>>>>                    Else If (iType=tqDATETIME) Begin
42134>>>>>>>                        For iItem from 0 to iMax
42140>>>>>>>>
42140>>>>>>>                            Move aValues[iItem] to aDateTimeValues[iItem]
42141>>>>>>>                        Loop
42142>>>>>>>>
42142>>>>>>>                        Move (SortArray(aDateTimeValues)) to aDateTimeValues
42143>>>>>>>                        For iItem from 0 to iMax
42149>>>>>>>>
42149>>>>>>>                            Move aDateTimeValues[iItem] to aValues[iItem]
42150>>>>>>>                        Loop
42151>>>>>>>>
42151>>>>>>>                    End
42151>>>>>>>>
42151>>>>>>>                    
42151>>>>>>>                    If (bReverseArray) Begin
42153>>>>>>>                        Move (ReverseArray(aValues)) to aValues
42154>>>>>>>                    End
42154>>>>>>>>
42154>>>>>>>                End_Procedure
42155>>>>>>>                
42155>>>>>>>                    Function _SortSegmentReversed tTableQuery strQ _tTQValueSource strLeftValue Returns Boolean
42157>>>>>>>                        Integer iItem iMax
42157>>>>>>>                        Move (SizeOfArray(strQ.aOrdering)-1) to iMax
42158>>>>>>>                        For iItem from 0 to iMax
42164>>>>>>>>
42164>>>>>>>                            If (strQ.aOrdering[iItem].strValueSource.iTable=strQ.iTable and ;                                strQ.iTable=strLeftValue.iTable and ;                                strQ.aOrdering[iItem].strValueSource.iColumn=strLeftValue.iColumn) Begin
42166>>>>>>>                                    Function_Return strQ.aOrdering[iItem].bDescending
42167>>>>>>>                            End
42167>>>>>>>>
42167>>>>>>>                        Loop
42168>>>>>>>>
42168>>>>>>>                    End_Function
42169>>>>>>>
42169>>>>>>>                Procedure _SortOrListValues tTableQuery ByRef strQ   
42171>>>>>>>                    // Sorting the OrList values serves two purposes:
42171>>>>>>>                    // 1: The rows will be found in the order specified by the scan index
42171>>>>>>>                    // 2: The mechanism that determines which OrList to "increment" will be confused
42171>>>>>>>                    //    if the OrList values do not appear in sequence (it's the break level
42171>>>>>>>                    //    computation that will go wrong)
42171>>>>>>>                    Boolean bReverseArray
42171>>>>>>>                    Integer iItem iMax
42171>>>>>>>                    Move (SizeOfArray(strQ._strCompiled.aJumpInValues)-1) to iMax
42172>>>>>>>                    For iItem from 0 to iMax
42178>>>>>>>>
42178>>>>>>>                        // Should we sort backwards?
42178>>>>>>>                        Get _SortSegmentReversed strQ strQ._strCompiled.aJumpInValues[iItem].strLeftValue to bReverseArray
42179>>>>>>>                        Send _SortVariantArray (&strQ._strCompiled.aJumpInValues[iItem].strRightValue.aOrList) strQ._strCompiled.aJumpInValues[iItem].strLeftValue.iType bReverseArray //(Integer(bReverseArray)+Integer(strQ._strCompiled.bBackwards)=1)
42180>>>>>>>                    Loop
42181>>>>>>>>
42181>>>>>>>                    Move (SizeOfArray(strQ._strCompiled.aJumpOutValues)-1) to iMax
42182>>>>>>>                    For iItem from 0 to iMax
42188>>>>>>>>
42188>>>>>>>                        // Should we sort backwards?
42188>>>>>>>                        Get _SortSegmentReversed strQ strQ._strCompiled.aJumpOutValues[iItem].strLeftValue to bReverseArray
42189>>>>>>>                        Send _SortVariantArray (&strQ._strCompiled.aJumpOutValues[iItem].strRightValue.aOrList) strQ._strCompiled.aJumpOutValues[iItem].strLeftValue.iType bReverseArray //(Integer(bReverseArray)+Integer(strQ._strCompiled.bBackwards)=1)
42190>>>>>>>                    Loop
42191>>>>>>>>
42191>>>>>>>                End_Procedure
42192>>>>>>>                
42192>>>>>>>                Function _CanFindIndexInRatings _tTQIndexRating[] aIndexRatings Integer iIndex Boolean ByRef bBackwards Number ByRef nENR Returns Boolean
42194>>>>>>>                    Integer iItem iMax
42194>>>>>>>                    Move (SizeOfArray(aIndexRatings)-1) to iMax
42195>>>>>>>                    For iItem from 0 to iMax
42201>>>>>>>>
42201>>>>>>>                        If (iIndex=aIndexRatings[iItem].iIndex or (iIndex+1000)=aIndexRatings[iItem].iIndex) Begin
42203>>>>>>>                            Move (aIndexRatings[iItem].iIndex>1000) to bBackwards
42204>>>>>>>                            Move aIndexRatings[iItem].nExpectedNumberRows to nENR
42205>>>>>>>                            Function_Return True
42206>>>>>>>                        End
42206>>>>>>>>
42206>>>>>>>                    Loop
42207>>>>>>>>
42207>>>>>>>                    Function_Return False
42208>>>>>>>                End_Function
42209>>>>>>>
42209>>>>>>>            Function SQLSelectStatement tTableQuery strQuery Returns String
42211>>>>>>>                Handle hoSQLGenerator
42211>>>>>>>                String sStatement
42211>>>>>>>                Send _TableRelateStatesReset (&strQuery)
42212>>>>>>>                If (strQuery.sForceSQLStatement<>"") Begin
42214>>>>>>>                    Function_Return strQuery.sForceSQLStatement
42215>>>>>>>                End
42215>>>>>>>>
42215>>>>>>>                Get phoSQLGeneratorMSSQLDRC to hoSQLGenerator
42216>>>>>>>                Get _SQLSelectStatement of hoSQLGenerator strQuery Self to sStatement
42217>>>>>>>                Function_Return sStatement
42218>>>>>>>            End_Function
42219>>>>>>>            
42219>>>>>>>            Function SQLDeleteStatement tTableQuery strQuery Returns String
42221>>>>>>>                Handle hoSQLGenerator
42221>>>>>>>                String sStatement
42221>>>>>>>                Send _TableRelateStatesReset (&strQuery)
42222>>>>>>>                Get phoSQLGeneratorMSSQLDRC to hoSQLGenerator
42223>>>>>>>                Get _SQLDeleteStatement of hoSQLGenerator strQuery Self to sStatement
42224>>>>>>>                Function_Return sStatement
42225>>>>>>>            End_Function
42226>>>>>>>
42226>>>>>>>                // Used by TableQueryStructureFunctions.pkg
42226>>>>>>>                Procedure _ReadParentSortValues tTableQuery ByRef strParentQuery tTableQuery ByRef strChildQuery
42228>>>>>>>                    Integer iItem iItemMax
42228>>>>>>>                    String sValue
42228>>>>>>>                    String[] aValues
42229>>>>>>>                    Move (SizeOfArray(strParentQuery.aOrdering)-1) to iItemMax
42230>>>>>>>                    For iItem from 0 to iItemMax
42236>>>>>>>>
42236>>>>>>>                        Get ResultColumnValue (&strParentQuery) strParentQuery.aOrdering[iItem].strValueSource.iTable strParentQuery.aOrdering[iItem].strValueSource.iColumn to sValue
42237>>>>>>>                        If (strParentQuery.aOrdering[iItem].bUppercase) Begin
42239>>>>>>>                            Move (Uppercase(sValue)) to sValue
42240>>>>>>>                        End
42240>>>>>>>>
42240>>>>>>>                        Move sValue to aValues[iItem]
42241>>>>>>>                    Loop
42242>>>>>>>>
42242>>>>>>>                    Move aValues to strChildQuery._strControlBlock.strInnerJoinCB.aCurrentParentSortValues
42243>>>>>>>                End_Procedure
42244>>>>>>>
42244>>>>>>>//            Global_Variable Integer _giSQLHandleCheckIndent
42244>>>>>>>//            Move 0 to _giSQLHandleCheckIndent
42244>>>>>>>//            Procedure ShowInit tSQLStatementHandle strStatement Integer iTable
42244>>>>>>>//                Showln (Repeat("    ",_giSQLHandleCheckIndent)) "Initialize using connection " (String(strStatement.strConnectionHandle.hHandle)) ". Statement handle is: " (String(strStatement.hHandle)) " (Table " (String(iTable)) ")"
42244>>>>>>>//                Increment _giSQLHandleCheckIndent
42244>>>>>>>//            End_Procedure
42244>>>>>>>//            Procedure ShowDeInit tSQLStatementHandle strStatement Integer iTable
42244>>>>>>>//                Decrement _giSQLHandleCheckIndent
42244>>>>>>>//                Showln (Repeat("    ",_giSQLHandleCheckIndent)) "Deinitialize using connection " (String(strStatement.strConnectionHandle.hHandle)) ". Statement handle is: " (String(strStatement.hHandle)) " (Table " (String(iTable)) ")"
42244>>>>>>>//            End_Procedure
42244>>>>>>>
42244>>>>>>>            Function _InitializeQuery tTableQuery ByRef strQuery Returns Boolean
42246>>>>>>>                Integer iTable iPrefetchCount iPrefetchTimeout
42246>>>>>>>                Integer iDecimalSeparator iDriverIndex
42246>>>>>>>                String sDriver sStatement
42246>>>>>>>                tSQLStatementHandle strStatement
42246>>>>>>>                tSQLStatementHandle strStatement
42246>>>>>>>                If (not(strQuery._strControlBlock.bInitialized)) Begin
42248>>>>>>>                    Move True to strQuery._strControlBlock.bInitialized
42249>>>>>>>                    
42249>>>>>>>                    If (strQuery.bRestoreRecordBuffersOnQueryCompletion) Begin
42251>>>>>>>                        Send _PushNoneFixedBuffers strQuery
42252>>>>>>>                    End
42252>>>>>>>>
42252>>>>>>>                    
42252>>>>>>>                    Move strQuery.iTable to iTable
42253>>>>>>>                    Get_Attribute DF_FILE_DRIVER of iTable to sDriver
42256>>>>>>>                    
42256>>>>>>>                    If (strQuery._strControlBlock.iQueryMethod=tqSQLPKG) Begin
42258>>>>>>>                        If (not(strQuery._strControlBlock.strInnerJoinCB.bEnabled) or not(strQuery._strControlBlock.strInnerJoinCB.bInitialized)) Begin
42260>>>>>>>                            
42260>>>>>>>                            If (OpenStatementOnTable(oSQLStatementHandles,strQuery.iTable,&strStatement)) Begin
42262>>>>>>>                                Move strStatement to strQuery._strControlBlock.strSQLStatementHandle
42263>>>>>>>
42263>>>>>>>                                Send _TableRelateStatesReset (&strQuery)
42264>>>>>>>                                Get SQLSelectStatement strQuery Self to sStatement
42265>>>>>>>                                Move (ToANSI(sStatement)) to sStatement
42266>>>>>>>                                Send SQLExecDirect of strStatement.hHandle sStatement
42267>>>>>>>                                Send SQLFetchActivatesBuffer of strStatement.hHandle strQuery.iTable True // True: DF_FILE_ACTIVATE will be true
42268>>>>>>>                                
42268>>>>>>>                                If (strQuery._strControlBlock.strInnerJoinCB.bEnabled) Begin
42270>>>>>>>                                    Move True to strQuery._strControlBlock.strInnerJoinCB.bInitialized
42271>>>>>>>                                    Move False to strQuery._strControlBlock.strInnerJoinCB.bSkipNextFetch
42272>>>>>>>                                    Move False to strQuery._strControlBlock.strInnerJoinCB.bEndOfResultSet
42273>>>>>>>                                End
42273>>>>>>>>
42273>>>>>>>    //                            Send ShowInit strStatement strQuery.iTable
42273>>>>>>>                            End
42273>>>>>>>>
42273>>>>>>>                            
42273>>>>>>>                        End
42273>>>>>>>>
42273>>>>>>>                    End
42273>>>>>>>>
42273>>>>>>>                    Else Begin
42274>>>>>>>                        If (sDriver<>"DATAFLEX") Begin // We're on an SQL backend 
42276>>>>>>>                            // This means that we have been 'forced' to use the record oriented 
42276>>>>>>>                            // interface but we are in fact an SQL table and therefore we might
42276>>>>>>>                            // might want to tamper with the prefetch cache settings:
42276>>>>>>>                            If (strQuery._strControlBlock.strSQLCacheControl.bUseSettings) Begin
42278>>>>>>>                                Move strQuery._strControlBlock.strSQLCacheControl.iPrefetchRecordCount to iPrefetchCount
42279>>>>>>>                                Move strQuery._strControlBlock.strSQLCacheControl.iPrefetchRecordTimeout to iPrefetchTimeout
42280>>>>>>>                                If (iPrefetchCount<>0) Begin
42282>>>>>>>                                    Get_Attribute DF_FILE_BLOCK_SIZE of iTable to strQuery._strControlBlock._strPreviousSQLCacheControl.iPrefetchRecordCount
42285>>>>>>>                                    Set_Attribute DF_FILE_BLOCK_SIZE of iTable to iPrefetchCount
42288>>>>>>>                                End
42288>>>>>>>>
42288>>>>>>>                                If (iPrefetchTimeout<>0) Begin
42290>>>>>>>                                    Get TableCacheTimeout of oTableDriverFunctions iTable to strQuery._strControlBlock._strPreviousSQLCacheControl.iPrefetchRecordTimeout
42291>>>>>>>                                    Set TableCacheTimeout of oTableDriverFunctions iTable to iPrefetchTimeout
42292>>>>>>>                                End
42292>>>>>>>>
42292>>>>>>>                            End
42292>>>>>>>>
42292>>>>>>>                        End
42292>>>>>>>>
42292>>>>>>>                    End
42292>>>>>>>>
42292>>>>>>>                End
42292>>>>>>>>
42292>>>>>>>                Function_Return (strQuery._strControlBlock.bInitialized)
42293>>>>>>>            End_Function
42294>>>>>>>            
42294>>>>>>>            Procedure _DeinitializeQuery tTableQuery ByRef strQuery
42296>>>>>>>                Integer iTable iPrefetchCount iPrefetchTimeout
42296>>>>>>>                String sDriver
42296>>>>>>>                If (strQuery._strControlBlock.iQueryMethod=tqSQLPKG) Begin
42298>>>>>>>                    If (not(strQuery._strControlBlock.strInnerJoinCB.bInitialized)) Begin // inner join => don't close the statement
42300>>>>>>>//                    Send ShowDeInit strQuery._strControlBlock.strSQLStatementHandle strQuery.iTable
42300>>>>>>>                        Send CloseStatement of oSQLStatementHandles strQuery._strControlBlock.strSQLStatementHandle
42301>>>>>>>                    End
42301>>>>>>>>
42301>>>>>>>                End
42301>>>>>>>>
42301>>>>>>>                Else Begin
42302>>>>>>>                    Move strQuery.iTable to iTable
42303>>>>>>>                    Get_Attribute DF_FILE_DRIVER of iTable to sDriver
42306>>>>>>>                    If (sDriver<>"DATAFLEX") Begin // We're on an SQL backend 
42308>>>>>>>                        // This means that we have been 'forced' to use the record oriented 
42308>>>>>>>                        // interface but we are in fact an SQL table and therefore we want
42308>>>>>>>                        // to restore the prefetch cache settings (if they were originally set):
42308>>>>>>>                        If (strQuery._strControlBlock.strSQLCacheControl.bUseSettings) Begin
42310>>>>>>>                            Move strQuery._strControlBlock.strSQLCacheControl.iPrefetchRecordCount to iPrefetchCount
42311>>>>>>>                            Move strQuery._strControlBlock.strSQLCacheControl.iPrefetchRecordTimeout to iPrefetchTimeout
42312>>>>>>>                            If (iPrefetchCount<>0) Begin // Only then did we change it in the first place
42314>>>>>>>                                // Reset prefetch setting
42314>>>>>>>                                Set_Attribute DF_FILE_BLOCK_SIZE of iTable to strQuery._strControlBlock._strPreviousSQLCacheControl.iPrefetchRecordCount
42317>>>>>>>                            End
42317>>>>>>>>
42317>>>>>>>                            If (iPrefetchTimeout<>0) Begin // Only then did we change it in the first place
42319>>>>>>>                                // Restore cache time out setting
42319>>>>>>>                                Set TableCacheTimeout of oTableDriverFunctions iTable to strQuery._strControlBlock._strPreviousSQLCacheControl.iPrefetchRecordTimeout
42320>>>>>>>                            End
42320>>>>>>>>
42320>>>>>>>                        End
42320>>>>>>>>
42320>>>>>>>                    End
42320>>>>>>>>
42320>>>>>>>                End
42320>>>>>>>>
42320>>>>>>>            End_Procedure
42321>>>>>>>
42321>>>>>>>                Function _QueryMethodSQL tTableQuery strQuery Returns Boolean
42323>>>>>>>                    String sDriver
42323>>>>>>>                    Integer iQueryMethod
42323>>>>>>>                    Move tqDATAFLEX to iQueryMethod 
42324>>>>>>>                    If (not(strQuery.bNoESQL)) Begin
42326>>>>>>>                        Get_Attribute DF_FILE_DRIVER of strQuery.iTable to sDriver
42329>>>>>>>                        If (sDriver="MSSQLDRV") Begin
42331>>>>>>>                            Move tqSQLPKG to iQueryMethod
42332>>>>>>>                        End
42332>>>>>>>>
42332>>>>>>>                    End
42332>>>>>>>>
42332>>>>>>>                    Function_Return (iQueryMethod<>tqDATAFLEX)
42333>>>>>>>                End_Function
42334>>>>>>>
42334>>>>>>>            Function _CompileQuery tTableQuery ByRef strQuery Returns Boolean
42336>>>>>>>                Boolean bBackwards
42336>>>>>>>                Boolean[] aSortDescending
42337>>>>>>>                Number nENR
42337>>>>>>>                Number[] aColumnRatings
42338>>>>>>>                String sDriver sFormat
42338>>>>>>>                _tTQIndexRating strRating
42338>>>>>>>                _tTQIndexRating strRating
42338>>>>>>>                _tTQIndexRating[] aIndexRatings
42338>>>>>>>                _tTQIndexRating[] aIndexRatings
42339>>>>>>>                tTQFilterSegment[] aTemp
42339>>>>>>>                tTQFilterSegment[] aTemp
42340>>>>>>>
42340>>>>>>>                If (not(strQuery._strControlBlock.bCompiled)) Begin                    
42342>>>>>>>                    If (_ValidateQuery(Self,strQuery)) Begin
42344>>>>>>>                        
42344>>>>>>>                        // Determine query method:
42344>>>>>>>                        Move tqDATAFLEX to strQuery._strControlBlock.iQueryMethod 
42345>>>>>>>                        If (not(strQuery.bNoESQL)) Begin
42347>>>>>>>                            Get_Attribute DF_FILE_DRIVER of strQuery.iTable to sDriver
42350>>>>>>>                            If (sDriver="MSSQLDRV") Begin
42352>>>>>>>                                Move tqSQLPKG to strQuery._strControlBlock.iQueryMethod
42353>>>>>>>                                Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of strQuery.iTable to sFormat
42356>>>>>>>                                Move (sFormat<>"OEM") to strQuery._strControlBlock.bSQLTableIsAnsi
42357>>>>>>>                            End
42357>>>>>>>>
42357>>>>>>>                        End
42357>>>>>>>>
42357>>>>>>>                        
42357>>>>>>>                        If (strQuery._strControlBlock.iQueryMethod=tqDATAFLEX) Begin
42359>>>>>>>                        
42359>>>>>>>                            Move False to strQuery._strCompiled.bBackwards
42360>>>>>>>                            
42360>>>>>>>                            Move strQuery.bForcePrefetch to strQuery._strCompiled.bPrefetch
42361>>>>>>>                
42361>>>>>>>                            Get _CalculateIndex (&strQuery) to aIndexRatings
42362>>>>>>>                            
42362>>>>>>>                            If (strQuery.iForceIndex<>-1) Begin
42364>>>>>>>                                If (_CanFindIndexInRatings(Self,aIndexRatings,strQuery.iForceIndex,&bBackwards,&nENR)) Begin
42366>>>>>>>                                    Move strQuery.iForceIndex to strQuery._strCompiled.iIndex
42367>>>>>>>                                    Move bBackwards to strQuery._strCompiled.bBackwards
42368>>>>>>>                                    Move nENR to strQuery._strCompiled.nENR
42369>>>>>>>                                End
42369>>>>>>>>
42369>>>>>>>                                Else Begin
42370>>>>>>>                                    Send OnError 721 "Illegal index forced"
42371>>>>>>>                                End
42371>>>>>>>>
42371>>>>>>>                            End
42371>>>>>>>>
42371>>>>>>>        
42371>>>>>>>                            If (strQuery.iLimit>=0) Begin
42373>>>>>>>                                Move strQuery.iLimit to strQuery._strCompiled._iLimit
42374>>>>>>>                            End
42374>>>>>>>>
42374>>>>>>>                            Else Begin 
42375>>>>>>>                                // If limit is -3 for example, we only want the 3 last rows of the 
42375>>>>>>>                                // set. In this case we instruct TableQuery to reverse the ordering 
42375>>>>>>>                                // and return the first three. Hokus pokus. (and then of course they
42375>>>>>>>                                // will be occurring in the wrong order). ((deal with that later))
42375>>>>>>>                                Move (-strQuery.iLimit) to strQuery._strCompiled._iLimit
42376>>>>>>>                                Move (not(strQuery._strCompiled.bBackwards)) to strQuery._strCompiled.bBackwards // reverse index search
42377>>>>>>>                            End
42377>>>>>>>>
42377>>>>>>>        
42377>>>>>>>                            Send OnIndexCalculated strQuery aIndexRatings
42378>>>>>>>        
42378>>>>>>>                            Send _CalculateJumpInOutConditions (&strQuery)
42379>>>>>>>        
42379>>>>>>>                            Send _SortOrListValues (&strQuery) // Make sure that values occur in the sequence they would be if occurring in an index
42380>>>>>>>                            
42380>>>>>>>                            If (strQuery._strCompiled.bBackwards) Begin // If backwards, we swap jump-in and jump-out conditions
42382>>>>>>>                                Move strQuery._strCompiled.aJumpInValues to aTemp
42383>>>>>>>                                Move strQuery._strCompiled.aJumpOutValues to strQuery._strCompiled.aJumpInValues
42384>>>>>>>                                Move aTemp to strQuery._strCompiled.aJumpOutValues
42385>>>>>>>                            End
42385>>>>>>>>
42385>>>>>>>                        End
42385>>>>>>>>
42385>>>>>>>
42385>>>>>>>                        Move True to strQuery._strControlBlock.bCompiled
42386>>>>>>>                    End
42386>>>>>>>>
42386>>>>>>>                    Move False to strQuery._strControlBlock.bInitialized
42387>>>>>>>                End
42387>>>>>>>>
42387>>>>>>>                Function_Return (strQuery._strControlBlock.bCompiled)
42388>>>>>>>            End_Function
42389>>>>>>>
42389>>>>>>>    //> This will analyse the query and calculate a query strategy. The strategy may be
42389>>>>>>>    //> inspected by inspecting the values of strQuery members
42389>>>>>>>    Function CompileQuery tTableQuery ByRef strQuery Returns Boolean
42391>>>>>>>        Move False to strQuery._strControlBlock.bCompiled
42392>>>>>>>        Function_Return (_CompileQuery(Self,&strQuery))
42393>>>>>>>    End_Function
42394>>>>>>>
42394>>>>>>>        Function _ValueSourceValue tTableQuery ByRef strQuery _tTQValueSource strValue Returns String
42396>>>>>>>            Integer iColumn
42396>>>>>>>            String sValue
42396>>>>>>>            If (strValue.iTable<>0) Begin
42398>>>>>>>                If (strValue.iTable<>strQuery.iTable) Begin // Only called when dataflex handling
42400>>>>>>>                    Send _RelateToTable (&strQuery) strValue.iTable
42401>>>>>>>                End
42401>>>>>>>>
42401>>>>>>>                Move strValue.iColumn to iColumn
42402>>>>>>>                If (iColumn=0) Begin
42404>>>>>>>                    Move (SerializeRowID(GetRowID(strValue.iTable))) to sValue
42405>>>>>>>                End
42405>>>>>>>>
42405>>>>>>>                Else Begin
42406>>>>>>>                    Get_Field_Value strValue.iTable iColumn to sValue
42409>>>>>>>                    Move (Rtrim(sValue)) to sValue
42410>>>>>>>                End
42410>>>>>>>>
42410>>>>>>>            End
42410>>>>>>>>
42410>>>>>>>            Else If (strValue.hFunction<>0) Begin
42413>>>>>>>                Get strValue.hFunction of strValue.hObject strValue.iColumn to sValue
42414>>>>>>>            End
42414>>>>>>>>
42414>>>>>>>            Else If (SizeOfArray(strValue.aOrList)>0) Begin
42417>>>>>>>                Move strValue.aOrList[strValue._iOrListPointer] to sValue
42418>>>>>>>            End
42418>>>>>>>>
42418>>>>>>>            Else Begin
42419>>>>>>>                Move strValue.sConstant to sValue
42420>>>>>>>            End
42420>>>>>>>>
42420>>>>>>>            If (strValue.iType=tqNUMBER and sValue="") Begin
42422>>>>>>>                Move "0" to sValue
42423>>>>>>>            End
42423>>>>>>>>
42423>>>>>>>            Function_Return sValue
42424>>>>>>>        End_Function
42425>>>>>>>
42425>>>>>>>            Function _ValueSourceScriptValueOrListFormat String[] aOrList Integer iType Returns String
42427>>>>>>>                Integer iItem iMax
42427>>>>>>>                Boolean bOk
42427>>>>>>>                String sValue
42427>>>>>>>                If (iType=tqSTRING or iType=tqTEXT) Begin
42429>>>>>>>                    Move (SizeOfArray(aOrList)-1) to iMax
42430>>>>>>>                    Move True to bOk
42431>>>>>>>                    For iItem from 0 to iMax
42437>>>>>>>>
42437>>>>>>>                        If (bOk) Begin
42439>>>>>>>                            Get AddQuotes of oStringFunctions (&aOrList[iItem]) "'" to bOk
42440>>>>>>>                        End
42440>>>>>>>>
42440>>>>>>>                    Loop
42441>>>>>>>>
42441>>>>>>>                    If (bOk) Begin
42443>>>>>>>                        Get JoinString aOrList "," 0 0 to sValue
42444>>>>>>>                        Move ("("+sValue+")") to sValue
42445>>>>>>>                    End
42445>>>>>>>>
42445>>>>>>>                    Else Begin
42446>>>>>>>                        Move "" to sValue // Signals an error
42447>>>>>>>                    End
42447>>>>>>>>
42447>>>>>>>                End
42447>>>>>>>>
42447>>>>>>>                Else Begin
42448>>>>>>>                    Get JoinString aOrList "," 0 0 to sValue
42449>>>>>>>                    Move ("("+sValue+")") to sValue
42450>>>>>>>                End
42450>>>>>>>>
42450>>>>>>>                Function_Return sValue
42451>>>>>>>            End_Function
42452>>>>>>>
42452>>>>>>>        Function _ValueSourceDisplayValue tTableQuery ByRef strQ _tTQValueSource strValue Returns String // Called by TQ test facility in VDFxray
42454>>>>>>>            Integer iMax iItem
42454>>>>>>>            String sValue
42454>>>>>>>            Move (SizeOfArray(strValue.aOrList)-1) to iMax
42455>>>>>>>            If (iMax>=0) Begin
42457>>>>>>>                For iItem from 0 to iMax
42463>>>>>>>>
42463>>>>>>>                    Move (sValue+strValue.aOrList[iItem]) to sValue
42464>>>>>>>                    If (iItem<>iMax) Begin
42466>>>>>>>                        Move (sValue+" ; ") to sValue
42467>>>>>>>                    End
42467>>>>>>>>
42467>>>>>>>                Loop
42468>>>>>>>>
42468>>>>>>>            End
42468>>>>>>>>
42468>>>>>>>            Else Begin
42469>>>>>>>                Get _ValueSourceValue (&strQ) strValue to sValue
42470>>>>>>>            End
42470>>>>>>>>
42470>>>>>>>            Function_Return sValue
42471>>>>>>>        End_Function
42472>>>>>>>            
42472>>>>>>>        Procedure _AssignConstraintValues tTableQuery ByRef strQuery tTQFilterSegment[] ByRef aFilters
42474>>>>>>>            Integer iMax iIndex
42474>>>>>>>            Move (SizeOfArray(aFilters)-1) to iMax
42475>>>>>>>            For iIndex from 0 to iMax
42481>>>>>>>>
42481>>>>>>>                // If it's a contraint by a table column value and if the table is not fixed we do not bother to assign 
42481>>>>>>>                // initial values. Instead we "calculate" them on each record.
42481>>>>>>>                If (aFilters[iIndex].strRightValue.iTable=0 or _IsTableFixed(Self,strQuery,aFilters[iIndex].strRightValue.iTable)) Begin
42483>>>>>>>                    Get _ValueSourceValue (&strQuery) aFilters[iIndex].strRightValue to aFilters[iIndex].strRightValue._sValue
42484>>>>>>>                    If (aFilters[iIndex].iComp=tqMATCH) Begin
42486>>>>>>>                        Get WildCardEvalSequence of oStringFunctions aFilters[iIndex].strRightValue._sValue to aFilters[iIndex].strMatchEvalSequence
42487>>>>>>>                    End
42487>>>>>>>>
42487>>>>>>>                    If (aFilters[iIndex].iComp=tqUCMATCH) Begin
42489>>>>>>>                        Get WildCardEvalSequence of oStringFunctions (Uppercase(aFilters[iIndex].strRightValue._sValue)) to aFilters[iIndex].strMatchEvalSequence
42490>>>>>>>                    End
42490>>>>>>>>
42490>>>>>>>                End
42490>>>>>>>>
42490>>>>>>>            Loop
42491>>>>>>>>
42491>>>>>>>        End_Procedure
42492>>>>>>>        
42492>>>>>>>            Procedure _AssignFilterExpressionValue tTableQuery ByRef strQuery tTQFilterExpression ByRef strFilterExpression
42494>>>>>>>                Integer iItem iItemMax
42494>>>>>>>
42494>>>>>>>                Get _ValueSourceValue (&strQuery) strFilterExpression.strOperand.strRightValue to strFilterExpression.strOperand.strRightValue._sValue
42495>>>>>>>                If (strFilterExpression.strOperand.iComp=tqMATCH) Begin
42497>>>>>>>                    Get WildCardEvalSequence of oStringFunctions strFilterExpression.strOperand.strRightValue._sValue to strFilterExpression.strOperand.strMatchEvalSequence
42498>>>>>>>                End
42498>>>>>>>>
42498>>>>>>>                If (strFilterExpression.strOperand.iComp=tqUCMATCH) Begin
42500>>>>>>>                    Get WildCardEvalSequence of oStringFunctions (Uppercase(strFilterExpression.strOperand.strRightValue._sValue)) to strFilterExpression.strOperand.strMatchEvalSequence
42501>>>>>>>                End
42501>>>>>>>>
42501>>>>>>>                 
42501>>>>>>>                Move (SizeOfArray(strFilterExpression.aSubExpressions)-1) to iItemMax
42502>>>>>>>                For iItem from 0 to iItemMax
42508>>>>>>>>
42508>>>>>>>                   Send _AssignFilterExpressionValue (&strQuery) (&strFilterExpression.aSubExpressions[iItem])
42509>>>>>>>                Loop
42510>>>>>>>>
42510>>>>>>>            End_Procedure
42511>>>>>>>            
42511>>>>>>>        Procedure _AssignFilterExpressionValues tTableQuery ByRef strQuery
42513>>>>>>>            Integer iItem iItemMax
42513>>>>>>>            tTQFilterExpression strFilterExpression
42513>>>>>>>            tTQFilterExpression strFilterExpression
42513>>>>>>>            Move (SizeOfArray(strQuery.aFilterExpressions)-1) to iItemMax
42514>>>>>>>            For iItem from 0 to iItemMax
42520>>>>>>>>
42520>>>>>>>                Send _AssignFilterExpressionValue (&strQuery) (&strQuery.aFilterExpressions[iItem])
42521>>>>>>>            Loop
42522>>>>>>>>
42522>>>>>>>        End_Procedure
42523>>>>>>>
42523>>>>>>>        Procedure _ReassignJumpInOutConstraintValues tTableQuery ByRef strQuery tTQFilterSegment[] ByRef aJumpInConstraints tTQFilterSegment[] ByRef aJumpOutConstraints
42525>>>>>>>            Integer iTable iColumn iJumpOutItem
42525>>>>>>>            _tTQValueSource stSource
42525>>>>>>>            _tTQValueSource stSource
42525>>>>>>>            String sValue
42525>>>>>>>            Integer iItem iMax
42525>>>>>>>            Move (SizeOfArray(aJumpOutConstraints)-1) to iMax
42526>>>>>>>            For iItem from 0 to iMax
42532>>>>>>>>
42532>>>>>>>                If (SizeOfArray(aJumpOutConstraints[iItem].strRightValue.aOrList)>0) Begin
42534>>>>>>>                    Move aJumpOutConstraints[iItem].strLeftValue.iTable to iTable
42535>>>>>>>                    Move aJumpOutConstraints[iItem].strLeftValue.iColumn to iColumn
42536>>>>>>>                    Move aJumpOutConstraints[iItem].strRightValue to stSource
42537>>>>>>>                    Get _ValueSourceValue (&strQuery) stSource to sValue
42538>>>>>>>                    Move sValue to aJumpOutConstraints[iItem].strRightValue._sValue
42539>>>>>>>                    Get _FindConstraintEQ aJumpInConstraints iTable iColumn True to iJumpOutItem
42540>>>>>>>                    If (iJumpOutItem>-1) Begin
42542>>>>>>>                        Move sValue to aJumpInConstraints[iJumpOutItem].strRightValue._sValue
42543>>>>>>>                    End
42543>>>>>>>>
42543>>>>>>>                    Else Begin
42544>>>>>>>                        Send OnError 722 "Unmatched jumpin or-list (should have been matched in jump-out constraints)"
42545>>>>>>>                    End
42545>>>>>>>>
42545>>>>>>>                End
42545>>>>>>>>
42545>>>>>>>            Loop
42546>>>>>>>>
42546>>>>>>>        End_Procedure
42547>>>>>>>
42547>>>>>>>                Function _SharpenJumpInValue String sValue Integer iTable Integer iColumn Boolean bDescending Returns String
42549>>>>>>>                    // NOTE: If the function does not succeed in sharpening the value, no harm
42549>>>>>>>                    // is done (other than some potentially unnescessary finds).
42549>>>>>>>                    Integer iType iLen iDecs
42549>>>>>>>                    Number nValue
42549>>>>>>>                    Date dValue
42549>>>>>>>                    DateTime dtValue
42549>>>>>>>                    
42549>>>>>>>                    Get_Attribute DF_FIELD_TYPE of iTable iColumn to iType
42552>>>>>>>                    Get_Attribute DF_FIELD_LENGTH of iTable iColumn to iLen
42555>>>>>>>                    Get_Attribute DF_FIELD_PRECISION of iTable iColumn to iDecs
42558>>>>>>>                    
42558>>>>>>>                    If (iType=DF_BCD) Begin 
42560>>>>>>>                        Move sValue to nValue
42561>>>>>>>                        // OBS! Here we need a check that we do not in- or decrement the value out of range
42561>>>>>>>                        If (bDescending) Begin 
42563>>>>>>>                            If (iDecs=0) Move (nValue-1) to nValue
42566>>>>>>>                            Else If (iDecs=2) Move (nValue-0.01) to nValue
42570>>>>>>>                            Else If (iDecs=4) Move (nValue-0.0001) to nValue
42574>>>>>>>                            Else If (iDecs=6) Move (nValue-0.000001) to nValue
42578>>>>>>>                            Else If (iDecs=8) Move (nValue-0.00000001) to nValue
42582>>>>>>>                        End
42582>>>>>>>>
42582>>>>>>>                        Else Begin
42583>>>>>>>                            If (iDecs=0) Move (nValue+1) to nValue
42586>>>>>>>                            Else If (iDecs=2) Move (nValue+0.01) to nValue
42590>>>>>>>                            Else If (iDecs=4) Move (nValue+0.0001) to nValue
42594>>>>>>>                            Else If (iDecs=6) Move (nValue+0.000001) to nValue
42598>>>>>>>                            Else If (iDecs=8) Move (nValue+0.00000001) to nValue
42602>>>>>>>                        End
42602>>>>>>>>
42602>>>>>>>                        Move nValue to sValue
42603>>>>>>>                    End
42603>>>>>>>>
42603>>>>>>>                    Else If (iType=DF_DATE) Begin
42606>>>>>>>                        Move sValue to dValue
42607>>>>>>>                        If (bDescending) Begin
42609>>>>>>>                            If (Integer(dValue>0)) Begin
42611>>>>>>>                                Get DateIncrement of oDateFunctions dValue DS_DAY -1 to dValue
42612>>>>>>>                            End
42612>>>>>>>>
42612>>>>>>>                        End
42612>>>>>>>>
42612>>>>>>>                        Else Begin
42613>>>>>>>                            If (dValue<LargestPossibleDate) Begin
42615>>>>>>>                                Get DateIncrement of oDateFunctions dValue DS_DAY 1 to dValue
42616>>>>>>>                            End
42616>>>>>>>>
42616>>>>>>>                        End
42616>>>>>>>>
42616>>>>>>>                        Move dValue to sValue
42617>>>>>>>                    End
42617>>>>>>>>
42617>>>>>>>                    Else If (iType=DF_DATETIME) Begin
42620>>>>>>>                        Move sValue to dtValue
42621>>>>>>>                        // OBS. Here we need a check that we do not in- or decrement the value out of range
42621>>>>>>>                        If (bDescending) Begin
42623>>>>>>>                            Get DateTimeIncrement of oDateFunctions dtValue DS_SECOND -1 to dValue
42624>>>>>>>                        End
42624>>>>>>>>
42624>>>>>>>                        Else Begin
42625>>>>>>>                            Get DateTimeIncrement of oDateFunctions dtValue DS_SECOND 1 to dValue
42626>>>>>>>                        End
42626>>>>>>>>
42626>>>>>>>                        Move dtValue to sValue
42627>>>>>>>                    End
42627>>>>>>>>
42627>>>>>>>                    Else If (iType=DF_ASCII) Begin
42630>>>>>>>                        // This involves knowing the collate sequence of the DB and this we
42630>>>>>>>                        // can only know that for sure if the driver is "DATAFLEX". (clue: Get CurrentCollateString of oVdfRuntimeFunctions)
42630>>>>>>>                    End
42630>>>>>>>>
42630>>>>>>>                    Function_Return sValue
42631>>>>>>>                End_Function
42632>>>>>>>
42632>>>>>>>        Procedure _SeedRecordBuffer tTableQuery strQ
42634>>>>>>>            Boolean bIndexSeedSharpeningEnabled bBackwards
42634>>>>>>>            Integer iMax iMax2 iIndex iTable iColumn
42634>>>>>>>            String sValue
42634>>>>>>>            tTQFilterSegment[] aFilters
42634>>>>>>>            tTQFilterSegment[] aFilters
42635>>>>>>>            tocIndex strIndex
42635>>>>>>>            tocIndex strIndex
42635>>>>>>>
42635>>>>>>>            Move strQ._strCompiled.bIndexSeedSharpeningEnabled to bIndexSeedSharpeningEnabled
42636>>>>>>>
42636>>>>>>>            Move strQ._strCompiled.aJumpInValues to aFilters
42637>>>>>>>
42637>>>>>>>            Move (SizeOfArray(aFilters)-1) to iMax
42638>>>>>>>            For iIndex from 0 to iMax
42644>>>>>>>>
42644>>>>>>>                Move aFilters[iIndex].strLeftValue.iTable to iTable
42645>>>>>>>                Move aFilters[iIndex].strLeftValue.iColumn to iColumn
42646>>>>>>>                Move aFilters[iIndex].strRightValue._sValue to sValue
42647>>>>>>>
42647>>>>>>>                If (bIndexSeedSharpeningEnabled) Begin
42649>>>>>>>                    If (aFilters[iIndex].iComp=tqLT) Begin // Attempt to sharpen jump-in value on descending segment
42651>>>>>>>                        Get _SharpenJumpInValue sValue iTable iColumn True to sValue
42652>>>>>>>                    End
42652>>>>>>>>
42652>>>>>>>                    Else If (aFilters[iIndex].iComp=tqGT) Begin // Attempt to sharpen jump-in value on ascending segment
42655>>>>>>>                        Get _SharpenJumpInValue sValue iTable iColumn False to sValue
42656>>>>>>>                    End
42656>>>>>>>>
42656>>>>>>>                End
42656>>>>>>>>
42656>>>>>>>
42656>>>>>>>                Set_Field_Value iTable iColumn to sValue
42659>>>>>>>            Loop
42660>>>>>>>>
42660>>>>>>>
42660>>>>>>>            Get IndexDefinition of oOverlapColumnFunctions strQ.iTable strQ._strCompiled.iIndex to strIndex
42661>>>>>>>            Move (SizeOfArray(strIndex.aSegments)-1) to iMax2
42662>>>>>>>            For iIndex from (iMax+1) to iMax2
42668>>>>>>>>
42668>>>>>>>                Move ((Integer(strQ._strCompiled.bBackwards)+Integer(strIndex.aSegments[iIndex].bDescending))=1) to bBackwards // xor
42669>>>>>>>                If (strIndex.aSegments[iIndex].iColumn>0 or bBackwards) Begin // Don't seed a negative recnum !!!!
42671>>>>>>>                    Send SeedMinValue of oIndexFunctions strQ.iTable strIndex.aSegments[iIndex].iColumn (bBackwards)
42672>>>>>>>                End
42672>>>>>>>>
42672>>>>>>>            Loop
42673>>>>>>>>
42673>>>>>>>        End_Procedure
42674>>>>>>>
42674>>>>>>>            Function _TestNumber Number nValueLeft Integer iComp Number nValueRight Returns Boolean
42676>>>>>>>                If (iComp=tqEQ) Function_Return (nValueLeft =  nValueRight)
42679>>>>>>>                If (iComp=tqLT) Function_Return (nValueLeft <  nValueRight)
42682>>>>>>>                If (iComp=tqLE) Function_Return (nValueLeft <= nValueRight)
42685>>>>>>>                If (iComp=tqGE) Function_Return (nValueLeft >= nValueRight)
42688>>>>>>>                If (iComp=tqGT) Function_Return (nValueLeft >  nValueRight)
42691>>>>>>>                If (iComp=tqNE) Function_Return (nValueLeft <> nValueRight)
42694>>>>>>>                Function_Return False
42695>>>>>>>            End_Function
42696>>>>>>>
42696>>>>>>>            Function _TestString String sValueLeft Integer iComp tWildCardEvalSequence strMatchSequence String sValueRight Returns Boolean
42698>>>>>>>                If (iComp=tqEQ) Function_Return (sValueLeft =  sValueRight)
42701>>>>>>>                If (iComp=tqLT) Function_Return (sValueLeft <  sValueRight)
42704>>>>>>>                If (iComp=tqLE) Function_Return (sValueLeft <= sValueRight)
42707>>>>>>>                If (iComp=tqGE) Function_Return (sValueLeft >= sValueRight)
42710>>>>>>>                If (iComp=tqGT) Function_Return (sValueLeft >  sValueRight)
42713>>>>>>>                If (iComp=tqNE) Function_Return (sValueLeft <> sValueRight)
42716>>>>>>>//                If (iComp=tqCONTAINS) Function_Return (sValueLeft contains sValueRight)
42716>>>>>>>//                If (iComp=tqIN) Begin
42716>>>>>>>//                    If sValueLeft in sValueRight Begin
42716>>>>>>>//                        Function_Return True
42716>>>>>>>//                    End
42716>>>>>>>//                End
42716>>>>>>>                If (iComp=tqMATCH) Begin
42718>>>>>>>                    Function_Return (WildCardMatch(oStringFunctions,sValueLeft,strMatchSequence))
42719>>>>>>>                End
42719>>>>>>>>
42719>>>>>>>                If (iComp=tqUCMATCH) Begin
42721>>>>>>>                    Function_Return (WildCardMatch(oStringFunctions,Uppercase(sValueLeft),strMatchSequence))
42722>>>>>>>                End
42722>>>>>>>>
42722>>>>>>>                Function_Return False
42723>>>>>>>            End_Function
42724>>>>>>>
42724>>>>>>>            Function _TestText String sValueLeft Integer iComp tWildCardEvalSequence stMatchSequence String sValueRight Returns Boolean
42726>>>>>>>                Function_Return (_TestString(Self,sValueLeft,iComp,stMatchSequence,sValueRight))
42727>>>>>>>            End_Function
42728>>>>>>>        
42728>>>>>>>            Function _TestDate Date dValueLeft Integer iComp Date dValueRight Returns Boolean
42730>>>>>>>                If (iComp=tqEQ) Function_Return (dValueLeft =  dValueRight)
42733>>>>>>>                If (iComp=tqLT) Function_Return (dValueLeft <  dValueRight)
42736>>>>>>>                If (iComp=tqLE) Function_Return (dValueLeft <= dValueRight)
42739>>>>>>>                If (iComp=tqGE) Function_Return (dValueLeft >= dValueRight)
42742>>>>>>>                If (iComp=tqGT) Function_Return (dValueLeft >  dValueRight)
42745>>>>>>>                If (iComp=tqNE) Function_Return (dValueLeft <> dValueRight)
42748>>>>>>>                Function_Return False
42749>>>>>>>            End_Function
42750>>>>>>>        
42750>>>>>>>            Function _TestDateTime DateTime dtValueLeft Integer iComp DateTime dtValueRight Returns Boolean
42752>>>>>>>                If (iComp=tqEQ) Function_Return (dtValueLeft =  dtValueRight)
42755>>>>>>>                If (iComp=tqLT) Function_Return (dtValueLeft <  dtValueRight)
42758>>>>>>>                If (iComp=tqLE) Function_Return (dtValueLeft <= dtValueRight)
42761>>>>>>>                If (iComp=tqGE) Function_Return (dtValueLeft >= dtValueRight)
42764>>>>>>>                If (iComp=tqGT) Function_Return (dtValueLeft >  dtValueRight)
42767>>>>>>>                If (iComp=tqNE) Function_Return (dtValueLeft <> dtValueRight)
42770>>>>>>>                Function_Return False
42771>>>>>>>            End_Function
42772>>>>>>>            
42772>>>>>>>            Function _EvaluateFilter tTableQuery ByRef strQuery tTQFilterSegment strFilter Boolean bOrlistAllItems Returns Boolean
42774>>>>>>>                Integer iType iOrListMax iOrListIndex
42774>>>>>>>                Boolean bEval bFoundInOrList
42774>>>>>>>                String sLeftValue sRightValue
42774>>>>>>>
42774>>>>>>>                Get _ValueSourceValue (&strQuery) strFilter.strLeftValue to sLeftValue
42775>>>>>>>                Move strFilter.strLeftValue.iType to iType
42776>>>>>>>                
42776>>>>>>>                Move (SizeOfArray(strFilter.strRightValue.aOrList)-1) to iOrListMax
42777>>>>>>>                If (bOrlistAllItems and iOrListMax>=0) Begin
42779>>>>>>>                    Move False to bFoundInOrList
42780>>>>>>>                    For iOrListIndex from 0 to iOrListMax
42786>>>>>>>>
42786>>>>>>>                        If (not(bFoundInOrList)) Begin
42788>>>>>>>                            If (iType=tqSTRING)        Get _TestString   sLeftValue strFilter.iComp strFilter.strMatchEvalSequence strFilter.strRightValue.aOrList[iOrListIndex] to bFoundInOrList
42791>>>>>>>                            Else If (iType=tqNUMBER)   Get _TestNumber   sLeftValue strFilter.iComp strFilter.strRightValue.aOrList[iOrListIndex] to bFoundInOrList
42795>>>>>>>                            Else If (iType=tqTEXT)     Get _TestText     sLeftValue strFilter.iComp strFilter.strMatchEvalSequence strFilter.strRightValue.aOrList[iOrListIndex] to bFoundInOrList
42799>>>>>>>                            Else If (iType=tqDATE)     Get _TestDate     sLeftValue strFilter.iComp strFilter.strRightValue.aOrList[iOrListIndex] to bFoundInOrList
42803>>>>>>>                            Else If (iType=tqDATETIME) Get _TestDateTime sLeftValue strFilter.iComp strFilter.strRightValue.aOrList[iOrListIndex] to bFoundInOrList
42807>>>>>>>                        End
42807>>>>>>>>
42807>>>>>>>                    Loop
42808>>>>>>>>
42808>>>>>>>                    Move bFoundInOrList to bEval
42809>>>>>>>                End
42809>>>>>>>>
42809>>>>>>>                Else Begin
42810>>>>>>>                    If (strFilter.strRightValue.iTable<>0 and not(_IsTableFixed(Self,strQuery,strFilter.strRightValue.iTable))) Begin
42812>>>>>>>                        Get _ValueSourceValue (&strQuery) strFilter.strRightValue to sRightValue
42813>>>>>>>                        If (strFilter.iComp=tqMATCH or strFilter.iComp=tqUCMATCH) Begin
42815>>>>>>>                            Get WildCardEvalSequence of oStringFunctions sRightValue to strFilter.strMatchEvalSequence
42816>>>>>>>                        End
42816>>>>>>>>
42816>>>>>>>                    end
42816>>>>>>>>
42816>>>>>>>                    Else Begin
42817>>>>>>>                        Move strFilter.strRightValue._sValue to sRightValue
42818>>>>>>>                    End
42818>>>>>>>>
42818>>>>>>>                    If (iType=tqSTRING)        Get _TestString   sLeftValue strFilter.iComp strFilter.strMatchEvalSequence sRightValue to bEval
42821>>>>>>>                    Else If (iType=tqNUMBER)   Get _TestNumber   sLeftValue strFilter.iComp sRightValue to bEval
42825>>>>>>>                    Else If (iType=tqTEXT)     Get _TestText     sLeftValue strFilter.iComp strFilter.strMatchEvalSequence sRightValue to bEval
42829>>>>>>>                    Else If (iType=tqDATE)     Get _TestDate     sLeftValue strFilter.iComp sRightValue to bEval
42833>>>>>>>                    Else If (iType=tqDATETIME) Get _TestDateTime sLeftValue strFilter.iComp sRightValue to bEval
42837>>>>>>>                End
42837>>>>>>>>
42837>>>>>>>                Function_Return bEval
42838>>>>>>>            End_Function
42839>>>>>>>            
42839>>>>>>>        Function _EvaluateConstraints tTableQuery ByRef strQuery tTQFilterSegment[] aFilters Boolean bOrlistAllItems Integer ByRef iFailedConstrainIndex Returns Boolean
42841>>>>>>>            Integer iMax iIndex 
42841>>>>>>>            Boolean bEval 
42841>>>>>>>            Move (SizeOfArray(aFilters)-1) to iMax
42842>>>>>>>            
42842>>>>>>>            For iIndex from 0 to iMax
42848>>>>>>>>
42848>>>>>>>                Get _EvaluateFilter (&strQuery) aFilters[iIndex] bOrlistAllItems to bEval
42849>>>>>>>                If (not(bEval)) Begin
42851>>>>>>>                    Move iIndex to iFailedConstrainIndex
42852>>>>>>>                    Function_Return False
42853>>>>>>>                End
42853>>>>>>>>
42853>>>>>>>            Loop
42854>>>>>>>>
42854>>>>>>>
42854>>>>>>>            Move -1 to iFailedConstrainIndex // Nothing failed
42855>>>>>>>            Function_Return True
42856>>>>>>>        End_Function
42857>>>>>>>    
42857>>>>>>>                Function _EvaluateFilterExpression tTableQuery ByRef strQuery tTQFilterExpression[] aExpressions Returns Boolean
42859>>>>>>>                    Integer iItem iItemMax
42859>>>>>>>                    Boolean bRvalDetermined bEvalResult bAtomExpression
42859>>>>>>>                    Move False to bRvalDetermined
42860>>>>>>>                    Move (SizeOfArray(aExpressions)-1) to iItemMax
42861>>>>>>>                    Move 0 to iItem
42862>>>>>>>                    While (iItem<=iItemMax)
42866>>>>>>>                        
42866>>>>>>>                        If (iItem>0 and ((bEvalResult and aExpressions[iItem-1].iAndOr=tqKeyOR) or ;                                    (not(bEvalResult) and aExpressions[iItem-1].iAndOr=tqKeyAND))) Begin
42868>>>>>>>                            // Do nothing! Evaluating the current item will not change the overall value
42868>>>>>>>                        End
42868>>>>>>>>
42868>>>>>>>                        Else Begin
42869>>>>>>>                        
42869>>>>>>>                            If (SizeOfArray(aExpressions[iItem].aSubExpressions)>0) Begin
42871>>>>>>>                                Get _EvaluateFilterExpression (&strQuery) aExpressions[iItem].aSubExpressions to bAtomExpression
42872>>>>>>>                            End
42872>>>>>>>>
42872>>>>>>>                            Else Begin
42873>>>>>>>                                Get _EvaluateFilter (&strQuery) aExpressions[iItem].strOperand True to bAtomExpression
42874>>>>>>>                            End
42874>>>>>>>>
42874>>>>>>>                            If (aExpressions[iItem].bNot) Begin
42876>>>>>>>                                Move (not(bAtomExpression)) to bAtomExpression
42877>>>>>>>                            End
42877>>>>>>>>
42877>>>>>>>                            
42877>>>>>>>                            If (iItem=0) Begin
42879>>>>>>>                                Move bAtomExpression to bEvalResult
42880>>>>>>>                            End
42880>>>>>>>>
42880>>>>>>>                            Else Begin
42881>>>>>>>                                If (aExpressions[iitem-1].iAndOr=tqKeyAND) Begin
42883>>>>>>>                                    Move (bEvalResult and bAtomExpression) to bEvalResult
42884>>>>>>>                                End
42884>>>>>>>>
42884>>>>>>>                                Else If (aExpressions[iitem-1].iAndOr=tqKeyOR) Begin
42887>>>>>>>                                    Move (bEvalResult or bAtomExpression) to bEvalResult
42888>>>>>>>                                End
42888>>>>>>>>
42888>>>>>>>                                Else Begin
42889>>>>>>>                                    Send OnError 723 "Unknown operator (should be AND or OR)"
42890>>>>>>>                                End
42890>>>>>>>>
42890>>>>>>>                            End
42890>>>>>>>>
42890>>>>>>>                        End
42890>>>>>>>>
42890>>>>>>>                        Increment iItem
42891>>>>>>>                    Loop
42892>>>>>>>>
42892>>>>>>>
42892>>>>>>>                    //    If (not(bRvalDetermined)) Begin
42892>>>>>>>                    //        Error 724 "Expression could not evaluate"
42892>>>>>>>                    //    End
42892>>>>>>>
42892>>>>>>>                    Function_Return bEvalResult
42893>>>>>>>                End_Function
42894>>>>>>>
42894>>>>>>>        Function _EvaluateFilterExpressions tTableQuery ByRef strQuery Returns Boolean
42896>>>>>>>            Boolean bEvalResult
42896>>>>>>>            Integer iItem iItemMax
42896>>>>>>>            Move True to bEvalResult
42897>>>>>>>            Move (SizeOfArray(strQuery.aFilterExpressions)-1) to iItemMax
42898>>>>>>>            Move 0 to iItem
42899>>>>>>>            While (bEvalResult and iItem<=iItemMax)
42903>>>>>>>                Get _EvaluateFilterExpression (&strQuery) strQuery.aFilterExpressions[iItem].aSubExpressions to bEvalResult
42904>>>>>>>                Increment iItem
42905>>>>>>>            Loop
42906>>>>>>>>
42906>>>>>>>            Function_Return bEvalResult
42907>>>>>>>        End_Function
42908>>>>>>>        
42908>>>>>>>    //> The function returns true if the record currently in
42908>>>>>>>    //> the buffer of the query main table evaluates true
42908>>>>>>>    //> against the filters of strQuery.
42908>>>>>>>    Function Belongs tTableQuery strQuery Returns Boolean
42910>>>>>>>        Boolean bBelongs
42910>>>>>>>        Integer iGrb
42910>>>>>>>        // New record! Indicate that related buffers have to be reconsidered 
42910>>>>>>>        // and found if needed:
42910>>>>>>>        Send _TableRelateStatesReset (&strQuery)
42911>>>>>>>        // Evaluate against all filters added to the query:
42911>>>>>>>        Get _EvaluateConstraints (&strQuery) strQuery.aFilters True (&iGrb) to bBelongs
42912>>>>>>>        Function_Return bBelongs
42913>>>>>>>    End_Function
42914>>>>>>>
42914>>>>>>>//    Procedure ExecuteQuery tTableQuery ByRef strQuery
42914>>>>>>>//        Boolean bFound
42914>>>>>>>//        Move True to strQuery.bForcePrefetch
42914>>>>>>>//        If (_CompileQuery(Self,&strQuery)) Begin
42914>>>>>>>//            If (_InitializeQuery(Self,&strQuery)) Begin
42914>>>>>>>//                // When bForcePrefetch is true finding the record will populate the
42914>>>>>>>//                // result array inside strQuery:
42914>>>>>>>//                Get FindRecord (&strQuery) to bFound // and that's all we need
42914>>>>>>>//                Get SystemTimeMilliSeconds of oDateFunctions to strQuery._strControlBlock.strStopTime
42914>>>>>>>//            End
42914>>>>>>>//        End
42914>>>>>>>//    End_Procedure
42914>>>>>>>
42914>>>>>>>    Procedure PurgeResultSet tTableQuery ByRef strQuery
42916>>>>>>>        Move strQuery.iTable to strQuery.strResultSet.iTable
42917>>>>>>>        Move (ResizeArray(strQuery.strResultSet.aRecords,0)) to strQuery.strResultSet.aRecords
42918>>>>>>>        Move -1 to strQuery.strResultSet._iCurrentRowPointer
42919>>>>>>>    End_Procedure
42920>>>>>>>
42920>>>>>>>
42920>>>>>>>                Procedure _ResultSetAddCurrentRecord tTableQuery ByRef strQuery
42922>>>>>>>                    Integer iRow iSegment iMax iColumn
42922>>>>>>>                    Integer iTable
42922>>>>>>>                    String sValue sSortValue
42922>>>>>>>                    tocIndexSegment stSegment
42922>>>>>>>                    tocIndexSegment stSegment
42922>>>>>>>
42922>>>>>>>                    // Row ID
42922>>>>>>>                    Move (SizeOfArray(strQuery.strResultSet.aRecords)) to iRow
42923>>>>>>>                    Move (GetRowID(strQuery.iTable)) to strQuery.strResultSet.aRecords[iRow].riRowId
42924>>>>>>>
42924>>>>>>>                    // Calculate sort value
42924>>>>>>>                    Move "" to sSortValue
42925>>>>>>>                    Move (SizeOfArray(strQuery.aOrdering)-1) to iMax
42926>>>>>>>                    For iSegment from 0 to iMax
42932>>>>>>>>
42932>>>>>>>                        Move strQuery.aOrdering[iSegment].strValueSource.iTable to iTable
42933>>>>>>>                        Move strQuery.aOrdering[iSegment].strValueSource.iColumn to stSegment.iColumn
42934>>>>>>>                        Move strQuery.aOrdering[iSegment].bDescending to stSegment.bDescending
42935>>>>>>>                        Move strQuery.aOrdering[iSegment].bUppercase to stSegment.bUppercase
42936>>>>>>>                        If (iTable<>strQuery.iTable) Begin
42938>>>>>>>                            Send _RelateToTable (&strQuery) iTable
42939>>>>>>>                        End
42939>>>>>>>>
42939>>>>>>>                        Get IndexSegmentSortValue of oIndexFunctions iTable stSegment to sValue
42940>>>>>>>                        Move (sSortValue+sValue) to sSortValue
42941>>>>>>>                    Loop
42942>>>>>>>>
42942>>>>>>>                    Move sSortValue to strQuery.strResultSet.aRecords[iRow].sSortValue
42943>>>>>>>
42943>>>>>>>                    // Read selected column values
42943>>>>>>>                    Move (SizeOfArray(strQuery.aColumnSources)-1) to iMax
42944>>>>>>>                    For iColumn from 0 to iMax
42950>>>>>>>>
42950>>>>>>>                        Get _ValueSourceValue (&strQuery) strQuery.aColumnSources[iColumn] to strQuery.strResultSet.aRecords[iRow].aColumnValues[iColumn]
42951>>>>>>>                    Loop
42952>>>>>>>>
42952>>>>>>>                End_Procedure
42953>>>>>>>
42953>>>>>>>                    Function _ResultSetRecordsCompare tTQResultRow stVal1 tTQResultRow stVal2 Returns Integer
42955>>>>>>>                        If (stVal1.sSortValue<stVal2.sSortValue) Function_Return (LT)
42958>>>>>>>                        If (stVal1.sSortValue>stVal2.sSortValue) Function_Return (GT)
42961>>>>>>>                        Function_Return (EQ)
42962>>>>>>>                    End_Function
42963>>>>>>>
42963>>>>>>>                Procedure _ResultSetSort tTableQuery ByRef strQuery
42965>>>>>>>                    If (SizeOfArray(strQuery.aOrdering)>0) Begin
42967>>>>>>>                        Move (SortArray(strQuery.strResultSet.aRecords,Self,GET__ResultSetRecordsCompare)) to strQuery.strResultSet.aRecords
42968>>>>>>>                    End
42968>>>>>>>>
42968>>>>>>>                End_Procedure
42969>>>>>>>
42969>>>>>>>                Procedure _ResultSetActivateCurrentRecord tTableQuery ByRef strQuery
42971>>>>>>>                    Boolean bFound
42971>>>>>>>                    Integer iTable
42971>>>>>>>                    RowID riRowID
42971>>>>>>>                    Move strQuery.iTable to iTable
42972>>>>>>>                    Move strQuery.strResultSet.aRecords[strQuery.strResultSet._iCurrentRowPointer].riRowId to riRowID
42973>>>>>>>                    Move (FindByRowID(iTable,riRowID)) to bFound
42974>>>>>>>                    Send _TableRelateStatesReset (&strQuery)
42975>>>>>>>                    If (bFound) Begin
42977>>>>>>>                        Send _RelateMainRecord (&strQuery)
42978>>>>>>>                    End
42978>>>>>>>>
42978>>>>>>>                    Else Begin
42979>>>>>>>                        Send OnError 725 "Result set record not found"
42980>>>>>>>                    End
42980>>>>>>>>
42980>>>>>>>                End_Procedure
42981>>>>>>>
42981>>>>>>>            Function _FindFirstRecordAux tTableQuery ByRef strQuery Integer ByRef iFailedConstrainIndex Returns Boolean
42983>>>>>>>                Boolean bFound bEval
42983>>>>>>>                Integer iTable iIndex iJunk
42983>>>>>>>
42983>>>>>>>                Move strQuery.iTable to iTable
42984>>>>>>>                Move strQuery._strCompiled.iIndex to iIndex
42985>>>>>>>                Clear iTable
42986>>>>>>>
42986>>>>>>>                Send _TableRelateStatesReset (&strQuery) // Reset information about what related records have already been found
42987>>>>>>>                Send _SeedRecordBuffer strQuery
42988>>>>>>>
42988>>>>>>>                If (strQuery._strCompiled.bBackwards) Begin
42990>>>>>>>                    Vfind iTable iIndex LE
42992>>>>>>>                End
42992>>>>>>>>
42992>>>>>>>                Else Begin
42993>>>>>>>                    Vfind iTable iIndex GE
42995>>>>>>>                    If (Found) Begin // Problem and fix pointed out by Russell McDougall
42997>>>>>>>                        // From the on-line help:
42997>>>>>>>
42997>>>>>>>                        // "A Find GE always finds a record unless the table is empty. A find GE after
42997>>>>>>>                        // the last record in the table will still return the last record. It always sets
42997>>>>>>>                        // the Predefined Indicators Found to True and FindErr to False). Note that this
42997>>>>>>>                        // behavior is different than for LE. A Find LE before the first record in the table
42997>>>>>>>                        // will not return a record, and will set the predefined indicators Found to False
42997>>>>>>>                        // and FindErr to True."
42997>>>>>>>
42997>>>>>>>                        // This feature of the find and vfind commands forces us to check
42997>>>>>>>                        // that the record found is not a record that it really shouldn't have found in the
42997>>>>>>>                        // first place:
42997>>>>>>>
42997>>>>>>>                        Get _EvaluateConstraints (&strQuery) strQuery._strCompiled.aJumpInValues False (&iFailedConstrainIndex) to bEval
42998>>>>>>>                        Move bEval to Found
42999>>>>>>>                    End
42999>>>>>>>>
42999>>>>>>>                End
42999>>>>>>>>
42999>>>>>>>                Move (Found) to bFound
43000>>>>>>>
43000>>>>>>>                Increment strQuery._strControlBlock.iFindCount
43001>>>>>>>                If (bFound) Begin
43003>>>>>>>                    Repeat
43003>>>>>>>>
43003>>>>>>>                        // Jump out?
43003>>>>>>>                        Get _EvaluateConstraints (&strQuery) strQuery._strCompiled.aJumpOutValues False (&iFailedConstrainIndex) to bEval
43004>>>>>>>                        If (not(bEval)) Begin // If jump-out criteria does not evaluate: jump out
43006>>>>>>>                            Function_Return False
43007>>>>>>>                        End
43007>>>>>>>>
43007>>>>>>>                        // Evaluate 'other' criteria
43007>>>>>>>                        Get _EvaluateConstraints (&strQuery) strQuery._strCompiled.aOtherConditions True (&iJunk) to bEval
43008>>>>>>>                        If (bEval) Begin // Evaluate filter expressions
43010>>>>>>>                            Get _EvaluateFilterExpressions (&strQuery) to bEval
43011>>>>>>>                        End
43011>>>>>>>>
43011>>>>>>>                        If (not(bEval)) Begin
43013>>>>>>>                            If (strQuery._strCompiled.bBackwards) Begin
43015>>>>>>>                                Vfind iTable iIndex LT
43017>>>>>>>                            End
43017>>>>>>>>
43017>>>>>>>                            Else Begin
43018>>>>>>>                                Vfind iTable iIndex GT
43020>>>>>>>                            End
43020>>>>>>>>
43020>>>>>>>                            Move (Found) to bFound
43021>>>>>>>                            Increment strQuery._strControlBlock.iFindCount
43022>>>>>>>                            Send _TableRelateStatesReset (&strQuery)
43023>>>>>>>                            If (not(bFound)) Begin // end of table
43025>>>>>>>                                Move (SizeOfArray(strQuery._strCompiled.aJumpOutValues)-1) to iFailedConstrainIndex
43026>>>>>>>                                Function_Return False
43027>>>>>>>                            End
43027>>>>>>>>
43027>>>>>>>                        End
43027>>>>>>>>
43027>>>>>>>                    Until (bEval)
43029>>>>>>>                End
43029>>>>>>>>
43029>>>>>>>
43029>>>>>>>//                Move (GetRowID(iTable)) to strQuery._strControlBlock.rCurrentRecord
43029>>>>>>>                If (bFound) Begin
43031>>>>>>>                    Increment strQuery._strControlBlock.iSelectCount
43032>>>>>>>                End
43032>>>>>>>>
43032>>>>>>>                Function_Return bFound
43033>>>>>>>            End_Function // _FindFirstRecordAux
43034>>>>>>>            
43034>>>>>>>            Procedure _SQLBindResultTables tTableQuery ByRef strQuery
43036>>>>>>>                Integer iItem iItemMax
43036>>>>>>>                Move (SizeOfArray(strQuery.aColumnSources)-1) to iItemMax
43037>>>>>>>
43037>>>>>>>                If (iItemMax>=0) Begin
43039>>>>>>>                    For iItem from 0 to iItemMax
43045>>>>>>>>
43045>>>>>>>                        If (strQuery.aColumnSources[iItem].iColumn=0) Begin
43047>>>>>>>                             Send SQLBindFile of strQuery._strControlBlock.strSQLStatementHandle.hHandle strQuery.aColumnSources[iItem].iTable
43048>>>>>>>                        End
43048>>>>>>>>
43048>>>>>>>                    Loop
43049>>>>>>>>
43049>>>>>>>                End
43049>>>>>>>>
43049>>>>>>>                Else Begin
43050>>>>>>>                    Send SQLBindFile of strQuery._strControlBlock.strSQLStatementHandle.hHandle strQuery.iTable
43051>>>>>>>                End
43051>>>>>>>>
43051>>>>>>>            End_Procedure
43052>>>>>>>
43052>>>>>>>                    Function _SQLCheckAgainstParentRecord_CompareSortingSegmentValues String sValue1 String sValue2 Integer iType Returns Integer
43054>>>>>>>                        Date dValue1 dValue2
43054>>>>>>>                        DateTime dtValue1 dtValue2
43054>>>>>>>                        Number nValue1 nValue2
43054>>>>>>>                        If (iType=tqNUMBER) Begin
43056>>>>>>>                            Move sValue1 to nValue1
43057>>>>>>>                            Move sValue2 to nValue2
43058>>>>>>>                            If (nValue1>nValue2) Function_Return tqGT
43061>>>>>>>                            If (nValue1<nValue2) Function_Return tqLT
43064>>>>>>>                        End
43064>>>>>>>>
43064>>>>>>>                        Else If (iType=tqDATE) Begin
43067>>>>>>>                            Move sValue1 to dValue1
43068>>>>>>>                            Move sValue2 to dValue2
43069>>>>>>>                            If (dValue1>dValue2) Function_Return tqGT
43072>>>>>>>                            If (dValue1<dValue2) Function_Return tqLT
43075>>>>>>>                        End
43075>>>>>>>>
43075>>>>>>>                        Else If (iType=tqDATETIME) Begin
43078>>>>>>>                            Move sValue1 to dtValue1
43079>>>>>>>                            Move sValue2 to dtValue2
43080>>>>>>>                            If (dtValue1>dtValue2) Function_Return tqGT
43083>>>>>>>                            If (dtValue1<dtValue2) Function_Return tqLT
43086>>>>>>>                        End
43086>>>>>>>>
43086>>>>>>>                        Else If (iType=tqSTRING) Begin
43089>>>>>>>                            If (sValue1>sValue2) Function_Return tqGT
43092>>>>>>>                            If (sValue1<sValue2) Function_Return tqLT
43095>>>>>>>                        End
43095>>>>>>>>
43095>>>>>>>                        Else Begin
43096>>>>>>>                            Send OnError 726 ("Unknown column type ("+String(iType))
43097>>>>>>>                        End
43097>>>>>>>>
43097>>>>>>>                        Function_Return tqEQ
43098>>>>>>>                    End_Function
43099>>>>>>>            
43099>>>>>>>                Function _SQLCheckAgainstParentRecord tTableQuery ByRef strQuery Boolean ByRef bCatchUpWithParent Returns Boolean
43101>>>>>>>                    Integer iItem iItemMax iCompareResult
43101>>>>>>>                    String sValue1 sValue2
43101>>>>>>>                    Move (SizeOfArray(strQuery._strControlBlock.strInnerJoinCB.aCurrentParentSortValues)-1) to iItemMax
43102>>>>>>>                    For iItem from 0 to iItemMax
43108>>>>>>>>
43108>>>>>>>                        Move strQuery._strControlBlock.strInnerJoinCB.aCurrentParentSortValues[iItem] to sValue1
43109>>>>>>>                        Get ResultColumnValue (&strQuery) strQuery.aOrdering[iItem].strValueSource.iTable strQuery.aOrdering[iItem].strValueSource.iColumn to sValue2
43110>>>>>>>                        If (strQuery.aOrdering[iItem].bUppercase) Begin
43112>>>>>>>                           // Move (Uppercase(sValue1)) to sValue1 // This has already been uppercased by the parent record collection mechanism (procedure _ReadParentSortValues)
43112>>>>>>>                            Move (Uppercase(sValue2)) to sValue2
43113>>>>>>>                        End
43113>>>>>>>>
43113>>>>>>>                        Get _SQLCheckAgainstParentRecord_CompareSortingSegmentValues sValue1 sValue2 strQuery.aOrdering[iItem].strValueSource.iType to iCompareResult
43114>>>>>>>                        If (strQuery.aOrdering[iItem].bDescending) Begin
43116>>>>>>>                            Move (If(iCompareResult=tqGT,tqLT,tqGT)) to iCompareResult
43117>>>>>>>                        End
43117>>>>>>>>
43117>>>>>>>                        If (iCompareResult=tqGT) Begin // Parent is greater => child query must catch up
43119>>>>>>>                            Move True to bCatchUpWithParent
43120>>>>>>>                            Function_Return False
43121>>>>>>>                        End
43121>>>>>>>>
43121>>>>>>>                        Else If (iCompareResult=tqLT) Begin // Child is greater which means we must fake a end-of-result set
43124>>>>>>>                            Move False to bCatchUpWithParent
43125>>>>>>>                            Function_Return False
43126>>>>>>>                        End
43126>>>>>>>>
43126>>>>>>>                    Loop
43127>>>>>>>>
43127>>>>>>>                    Move False to bCatchUpWithParent
43128>>>>>>>                    Function_Return True
43129>>>>>>>                End_Function
43130>>>>>>>            
43130>>>>>>>            Function _SQLFindNextRecord tTableQuery ByRef strQuery Returns Boolean
43132>>>>>>>                Integer iFetchResult iItem iItemMax
43132>>>>>>>                Boolean bFound bSelect bInnerJoin bCatchUpWithParent bBelongsToCurrentParent
43132>>>>>>>
43132>>>>>>>
43132>>>>>>>                Move (SizeOfArray(strQuery._strControlBlock.strInnerJoinCB.aCurrentParentSortValues)-1) to iItemMax
43133>>>>>>>                Move (iItemMax>=0) to bInnerJoin // We are an inner join and should be prepared to fake a 'record not found'
43134>>>>>>>
43134>>>>>>>                If (bInnerJoin) Begin
43136>>>>>>>
43136>>>>>>>                    If (strQuery._strControlBlock.strInnerJoinCB.bEndOfResultSet) Begin
43138>>>>>>>                        Function_Return False
43139>>>>>>>                    End
43139>>>>>>>>
43139>>>>>>>
43139>>>>>>>                    Repeat
43139>>>>>>>>
43139>>>>>>>                        If (strQuery._strControlBlock.strInnerJoinCB.bSkipNextFetch) Begin
43141>>>>>>>                            Move False to strQuery._strControlBlock.strInnerJoinCB.bSkipNextFetch
43142>>>>>>>                            Move True to bFound
43143>>>>>>>                        End
43143>>>>>>>>
43143>>>>>>>                        Else Begin
43144>>>>>>>                            Get SQLFetch of strQuery._strControlBlock.strSQLStatementHandle.hHandle to iFetchResult
43145>>>>>>>                            Move (iFetchResult<>0) to bFound
43146>>>>>>>                            Increment strQuery._strControlBlock.iFindCount
43147>>>>>>>                        End
43147>>>>>>>>
43147>>>>>>>                        If (bFound) Begin
43149>>>>>>>                            Send _TableRelateStatesReset (&strQuery)
43150>>>>>>>                            Send _SQLBindResultTables (&strQuery)
43151>>>>>>>                            Get _SQLCheckAgainstParentRecord (&strQuery) (&bCatchUpWithParent) to bBelongsToCurrentParent
43152>>>>>>>                            If (bBelongsToCurrentParent) Begin
43154>>>>>>>                                Move True to bSelect
43155>>>>>>>                            End
43155>>>>>>>>
43155>>>>>>>                            Else Begin
43156>>>>>>>                                If (not(bCatchUpWithParent)) Begin
43158>>>>>>>                                    Move True to strQuery._strControlBlock.strInnerJoinCB.bSkipNextFetch
43159>>>>>>>                                End
43159>>>>>>>>
43159>>>>>>>                            End
43159>>>>>>>>
43159>>>>>>>                        End
43159>>>>>>>>
43159>>>>>>>                        Else Begin
43160>>>>>>>                            Move True to strQuery._strControlBlock.strInnerJoinCB.bEndOfResultSet
43161>>>>>>>                        End
43161>>>>>>>>
43161>>>>>>>                    Until (not(bFound) or bSelect or not(bCatchUpWithParent))
43163>>>>>>>
43163>>>>>>>                    If (bSelect) Begin
43165>>>>>>>                        Increment strQuery._strControlBlock.iSelectCount
43166>>>>>>>                        Function_Return True
43167>>>>>>>                    End
43167>>>>>>>>
43167>>>>>>>
43167>>>>>>>                End
43167>>>>>>>>
43167>>>>>>>                Else Begin
43168>>>>>>>
43168>>>>>>>                    Get SQLFetch of strQuery._strControlBlock.strSQLStatementHandle.hHandle to iFetchResult
43169>>>>>>>                    Move (iFetchResult<>0) to bFound
43170>>>>>>>                    If (bFound) Begin
43172>>>>>>>                        Send _SQLBindResultTables (&strQuery)
43173>>>>>>>                        Increment strQuery._strControlBlock.iSelectCount
43174>>>>>>>                    End
43174>>>>>>>>
43174>>>>>>>                    Increment strQuery._strControlBlock.iFindCount
43175>>>>>>>
43175>>>>>>>                    Function_Return bFound
43176>>>>>>>                End
43176>>>>>>>>
43176>>>>>>>                Function_Return False
43177>>>>>>>            End_Function
43178>>>>>>>
43178>>>>>>>        Register_Function FindRecord tTableQuery ByRef strQuery Returns Boolean
43178>>>>>>>
43178>>>>>>>        Function _FindFirstRecord tTableQuery ByRef strQuery Returns Boolean
43180>>>>>>>            Boolean bFound bIncremented bTmp
43180>>>>>>>            Integer iLastIndex iSize iTable
43180>>>>>>>            Integer iFailedConstrainIndex
43180>>>>>>>            Integer iLogState iFetchResult
43180>>>>>>>
43180>>>>>>>            Move 0 to strQuery._strControlBlock.iFindCount
43181>>>>>>>            Move 0 to strQuery._strControlBlock.iSelectCount
43182>>>>>>>            Move False to strQuery._strControlBlock.bBreakScan
43183>>>>>>>            Send PurgeResultSet (&strQuery) // Zero the result set
43184>>>>>>>
43184>>>>>>>            If (strQuery._strControlBlock.iQueryMethod=tqSQLPKG) Begin
43186>>>>>>>                Get _SQLFindNextRecord (&strQuery) to bFound
43187>>>>>>>            End
43187>>>>>>>>
43187>>>>>>>            Else Begin
43188>>>>>>>
43188>>>>>>>                // Makes the procedure reset all OrList pointers. Return value not used:
43188>>>>>>>                Get _IncrementJumpInOutConditions (&strQuery) -1 to bFound
43189>>>>>>>                Move strQuery.iTable to iTable
43190>>>>>>>                Clear iTable //
43191>>>>>>>                Send _TableRelateStatesReset (&strQuery)
43192>>>>>>>                Send _AssignConstraintValues (&strQuery) (&strQuery._strCompiled.aJumpInValues)
43193>>>>>>>                Send _AssignConstraintValues (&strQuery) (&strQuery._strCompiled.aJumpOutValues)
43194>>>>>>>                Send _AssignConstraintValues (&strQuery) (&strQuery._strCompiled.aOtherConditions)
43195>>>>>>>                Send _AssignFilterExpressionValues (&strQuery)
43196>>>>>>>
43196>>>>>>>                If (strQuery._strCompiled.bPrefetch) Begin
43198>>>>>>>                    Move False to strQuery._strCompiled.bPrefetch // Temporarily set bPrefetch to false
43199>>>>>>>
43199>>>>>>>                    Send ReUse (&strQuery) // resets strQuery.blabla.bInitialized
43200>>>>>>>                    Move strQuery.bForcePrefetch to bTmp
43201>>>>>>>
43201>>>>>>>                    // Here comes a dirty trick to avoid FindRecord deleting
43201>>>>>>>                    // the ResultArray of the strQuery variable on completion. The
43201>>>>>>>                    // default behavior is to reset the resultset on completion if
43201>>>>>>>                    // prefetch was not forced. It's dirty because I am fooling
43201>>>>>>>                    // FindRecord into not re-compiling the report. Here it goes:
43201>>>>>>>                    Move True to strQuery.bForcePrefetch
43202>>>>>>>                    Move _giTQLogState to iLogState
43203>>>>>>>                    Move 0 to _giTQLogState // Do not log the "inner" loop
43204>>>>>>>
43204>>>>>>>                    While (FindRecord(Self,&strQuery))
43208>>>>>>>                        Send _ResultSetAddCurrentRecord (&strQuery)
43209>>>>>>>                    Loop
43210>>>>>>>>
43210>>>>>>>                    Move bTmp to strQuery.bForcePrefetch
43211>>>>>>>                    Move iLogState to _giTQLogState // Restore log-state
43212>>>>>>>
43212>>>>>>>                    Send _ResultSetSort (&strQuery)
43213>>>>>>>
43213>>>>>>>                    Move False to strQuery._strControlBlock.bBreakScan // Cancel effect of possible break imposed by limit
43214>>>>>>>                    Move True to strQuery._strCompiled.bPrefetch // Restore bPrefetch
43215>>>>>>>                    If (strQuery._strCompiled._iPushLimit<>0) Begin
43217>>>>>>>
43217>>>>>>>                        If (SizeOfArray(strQuery.strResultSet.aRecords)>Abs(strQuery._strCompiled._iPushLimit)) Begin
43219>>>>>>>                            // If the record set is greater than our limit we'll have to prune it.
43219>>>>>>>                            If (strQuery.iLimit>0) Begin // We're supposed to return the head
43221>>>>>>>                                Move (ResizeArray(strQuery.strResultSet.aRecords,strQuery._strCompiled._iPushLimit)) to strQuery.strResultSet.aRecords
43222>>>>>>>                            End
43222>>>>>>>>
43222>>>>>>>                            Else Begin // We're supposed to take the tail
43223>>>>>>>                                Move (SizeOfArray(strQuery.strResultSet.aRecords)-1) to iLastIndex
43224>>>>>>>                                Move strQuery._strCompiled._iPushLimit to iSize
43225>>>>>>>                                Move (CopyArray(strQuery.strResultSet.aRecords,iLastIndex-iSize+1,iLastIndex)) to strQuery.strResultSet.aRecords
43226>>>>>>>                            End
43226>>>>>>>>
43226>>>>>>>                            Move (SizeOfArray(strQuery.strResultSet.aRecords)) to strQuery._strControlBlock.iSelectCount
43227>>>>>>>                        End
43227>>>>>>>>
43227>>>>>>>
43227>>>>>>>                        If (SizeOfArray(strQuery.strResultSet.aRecords)>strQuery._strCompiled._iPushLimit) Begin
43229>>>>>>>                            Move (ResizeArray(strQuery.strResultSet.aRecords,strQuery._strCompiled._iPushLimit)) to strQuery.strResultSet.aRecords
43230>>>>>>>                            Move (SizeOfArray(strQuery.strResultSet.aRecords)) to strQuery._strControlBlock.iSelectCount
43231>>>>>>>                        End
43231>>>>>>>>
43231>>>>>>>                        Move strQuery._strCompiled._iPushLimit to strQuery._strCompiled._iLimit
43232>>>>>>>                        Move 0 to strQuery._strCompiled._iPushLimit
43233>>>>>>>                    End
43233>>>>>>>>
43233>>>>>>>                    Move (SizeOfArray(strQuery.strResultSet.aRecords)>0) to bFound
43234>>>>>>>                    If (bFound) Begin
43236>>>>>>>                        Move 0 to strQuery.strResultSet._iCurrentRowPointer
43237>>>>>>>                        Send _ResultSetActivateCurrentRecord (&strQuery)
43238>>>>>>>                    End
43238>>>>>>>>
43238>>>>>>>                End
43238>>>>>>>>
43238>>>>>>>                Else Begin
43239>>>>>>>                    Repeat
43239>>>>>>>>
43239>>>>>>>                        Get _FindFirstRecordAux (&strQuery) (&iFailedConstrainIndex) to bFound
43240>>>>>>>                        If (not(bFound)) Begin
43242>>>>>>>                            Get _IncrementJumpInOutConditions (&strQuery) iFailedConstrainIndex to bIncremented
43243>>>>>>>                            If (bIncremented) Begin
43245>>>>>>>                                Send _ReassignJumpInOutConstraintValues (&strQuery) (&strQuery._strCompiled.aJumpInValues) (&strQuery._strCompiled.aJumpOutValues)
43246>>>>>>>                            End
43246>>>>>>>>
43246>>>>>>>                        End
43246>>>>>>>>
43246>>>>>>>                    Until (bFound or not(bIncremented))
43248>>>>>>>                End
43248>>>>>>>>
43248>>>>>>>            End
43248>>>>>>>>
43248>>>>>>>
43248>>>>>>>            Function_Return bFound
43249>>>>>>>        End_Function // _FindFirstRecord
43250>>>>>>>
43250>>>>>>>            Function _FindNextRecordAux tTableQuery ByRef strQuery Integer ByRef iFailedConstrainIndex Returns Boolean
43252>>>>>>>                Integer iTable iIndex iJunk
43252>>>>>>>                Boolean bFound bEval
43252>>>>>>>
43252>>>>>>>                Move strQuery.iTable to iTable
43253>>>>>>>                Move strQuery._strCompiled.iIndex to iIndex
43254>>>>>>>                If (strQuery._strCompiled.bBackwards) Begin
43256>>>>>>>                    Vfind iTable iIndex LT
43258>>>>>>>                End
43258>>>>>>>>
43258>>>>>>>                Else Begin
43259>>>>>>>                    Vfind iTable iIndex GT
43261>>>>>>>                End
43261>>>>>>>>
43261>>>>>>>                Move (Found) to bFound
43262>>>>>>>                Increment strQuery._strControlBlock.iFindCount
43263>>>>>>>                Send _TableRelateStatesReset (&strQuery)
43264>>>>>>>                If (bFound) Begin
43266>>>>>>>                    Repeat
43266>>>>>>>>
43266>>>>>>>                        // Jump out?
43266>>>>>>>                        Get _EvaluateConstraints (&strQuery) strQuery._strCompiled.aJumpOutValues False (&iFailedConstrainIndex) to bEval
43267>>>>>>>                        If (not(bEval)) Begin // If jump-out criteria does not evaluate: jump out
43269>>>>>>>                            Function_Return False
43270>>>>>>>                        End
43270>>>>>>>>
43270>>>>>>>                        // Evaluate 'other' criteria
43270>>>>>>>                        Get _EvaluateConstraints (&strQuery) strQuery._strCompiled.aOtherConditions True (&iJunk) to bEval
43271>>>>>>>                        If (bEval) Begin // Evaluate filter expressions
43273>>>>>>>                            Get _EvaluateFilterExpressions (&strQuery) to bEval
43274>>>>>>>                        End
43274>>>>>>>>
43274>>>>>>>                        If (not(bEval)) Begin
43276>>>>>>>                            If (strQuery._strCompiled.bBackwards) Begin
43278>>>>>>>                                Vfind iTable iIndex LT
43280>>>>>>>                            End
43280>>>>>>>>
43280>>>>>>>                            Else Begin
43281>>>>>>>                                Vfind iTable iIndex GT
43283>>>>>>>                            End
43283>>>>>>>>
43283>>>>>>>                            Increment strQuery._strControlBlock.iFindCount
43284>>>>>>>                            Move (Found) to bFound
43285>>>>>>>                            Send _TableRelateStatesReset (&strQuery)
43286>>>>>>>                            If (not(bFound)) Begin // end of table
43288>>>>>>>                                Move (SizeOfArray(strQuery._strCompiled.aJumpOutValues)-1) to iFailedConstrainIndex
43289>>>>>>>                                Function_Return False
43290>>>>>>>                            End
43290>>>>>>>>
43290>>>>>>>                        End
43290>>>>>>>>
43290>>>>>>>                    Until (bEval)
43292>>>>>>>                End
43292>>>>>>>>
43292>>>>>>>
43292>>>>>>>                If (bFound) Begin
43294>>>>>>>                    Increment strQuery._strControlBlock.iSelectCount
43295>>>>>>>                End
43295>>>>>>>>
43295>>>>>>>
43295>>>>>>>                Function_Return bFound
43296>>>>>>>            End_Function
43297>>>>>>>
43297>>>>>>>        Function _FindNextRecord tTableQuery ByRef strQuery Returns Boolean
43299>>>>>>>            Boolean bFound bIncremented
43299>>>>>>>            Integer iFailedConstrainIndex iFetchResult
43299>>>>>>>
43299>>>>>>>            If (strQuery._strControlBlock.bBreakScan) Begin
43301>>>>>>>                Move False to bFound
43302>>>>>>>            End
43302>>>>>>>>
43302>>>>>>>            Else Begin
43303>>>>>>>
43303>>>>>>>                If (strQuery._strControlBlock.iQueryMethod=tqSQLPKG) Begin
43305>>>>>>>                    Get _SQLFindNextRecord (&strQuery) to bFound
43306>>>>>>>                End
43306>>>>>>>>
43306>>>>>>>                Else Begin
43307>>>>>>>                    If (strQuery._strCompiled.bPrefetch) Begin
43309>>>>>>>                        Move ((strQuery.strResultSet._iCurrentRowPointer+1)<SizeOfArray(strQuery.strResultSet.aRecords)) to bFound
43310>>>>>>>                        If (bFound) Begin
43312>>>>>>>                            Increment strQuery.strResultSet._iCurrentRowPointer
43313>>>>>>>                            Send _ResultSetActivateCurrentRecord (&strQuery)
43314>>>>>>>                        End
43314>>>>>>>>
43314>>>>>>>                    End
43314>>>>>>>>
43314>>>>>>>                    Else Begin
43315>>>>>>>                        Get _FindNextRecordAux (&strQuery) (&iFailedConstrainIndex) to bFound
43316>>>>>>>
43316>>>>>>>                        Repeat
43316>>>>>>>>
43316>>>>>>>                            If (not(bFound)) Begin
43318>>>>>>>                                Get _IncrementJumpInOutConditions (&strQuery) iFailedConstrainIndex to bIncremented
43319>>>>>>>                                If (bIncremented) Begin
43321>>>>>>>                                    Send _ReassignJumpInOutConstraintValues (&strQuery) (&strQuery._strCompiled.aJumpInValues) (&strQuery._strCompiled.aJumpOutValues)
43322>>>>>>>                                    Get _FindFirstRecordAux (&strQuery) (&iFailedConstrainIndex) to bFound
43323>>>>>>>                                End
43323>>>>>>>>
43323>>>>>>>                            End
43323>>>>>>>>
43323>>>>>>>                        Until (bFound or not(bIncremented))
43325>>>>>>>                    End
43325>>>>>>>>
43325>>>>>>>                End
43325>>>>>>>>
43325>>>>>>>            End
43325>>>>>>>>
43325>>>>>>>
43325>>>>>>>            Function_Return bFound
43326>>>>>>>        End_Function
43327>>>>>>>
43327>>>>>>>// *** TableRelation functions *** TableRelation functions *** TableRelation functions *** TableRelation functions *** TableRelation functions ***
43327>>>>>>>
43327>>>>>>>        Function _ColumnSourceFind tTableQuery strQ Integer iTable Integer iColumn Returns Integer
43329>>>>>>>            Integer iItem iMax
43329>>>>>>>            Move (SizeOfArray(strQ.aColumnSources)-1) to iMax
43330>>>>>>>            For iItem from 0 to iMax
43336>>>>>>>>
43336>>>>>>>                If (strQ.aColumnSources[iItem].iTable=iTable) Begin
43338>>>>>>>                    If (strQ.aColumnSources[iItem].iColumn=iColumn or strQ.aColumnSources[iItem].iColumn=0) Begin
43340>>>>>>>                        Function_Return iItem
43341>>>>>>>                    End
43341>>>>>>>>
43341>>>>>>>                End
43341>>>>>>>>
43341>>>>>>>            Loop
43342>>>>>>>>
43342>>>>>>>            Function_Return -1 // not found
43343>>>>>>>        End_Function
43344>>>>>>>
43344>>>>>>>        //> Internal function used to find the index for the relation recip for tabel iTable.
43344>>>>>>>        Function _FindTableRelation tTableQuery strQ Integer iTable Returns Integer
43346>>>>>>>            Integer iItem iMax
43346>>>>>>>            Move (SizeOfArray(strQ.aTableRelations)-1) to iMax
43347>>>>>>>            For iItem from 0 to iMax
43353>>>>>>>>
43353>>>>>>>                If (strQ.aTableRelations[iItem].iTargetTable=iTable) Begin
43355>>>>>>>                    Function_Return iItem
43356>>>>>>>                End
43356>>>>>>>>
43356>>>>>>>            Loop
43357>>>>>>>>
43357>>>>>>>            Function_Return -1 // not found
43358>>>>>>>        End_Function
43359>>>>>>>
43359>>>>>>>        // If bFixed is true it means that the parent record is fixed for the duration of the query. In turn, that means
43359>>>>>>>        // that the relation mechanism will not find records in that table (iTargetTable).
43359>>>>>>>        Procedure _AddTableRelation tTableQuery ByRef strQ Integer iTargetTable Boolean bFixed
43361>>>>>>>            Integer iItem
43361>>>>>>>            Get _FindTableRelation strQ iTargetTable to iItem
43362>>>>>>>            If (iItem=-1) Begin
43364>>>>>>>                Move (SizeOfArray(strQ.aTableRelations)) to iItem
43365>>>>>>>                Move iTargetTable to strQ.aTableRelations[iItem].iTargetTable
43366>>>>>>>                Move -1 to strQ.aTableRelations[iItem]._iEmbeddedIndex
43367>>>>>>>                Move bFixed to strQ.aTableRelations[iItem].bFixed
43368>>>>>>>            End
43368>>>>>>>>
43368>>>>>>>            Else Begin
43369>>>>>>>                If (bFixed) Begin // If it's already there then bFixed=true wins.
43371>>>>>>>                    Move bFixed to strQ.aTableRelations[iItem].bFixed
43372>>>>>>>                End
43372>>>>>>>>
43372>>>>>>>            End
43372>>>>>>>>
43372>>>>>>>        End_Procedure
43373>>>>>>>
43373>>>>>>>            Function _CompareTableRelationSegments _tTQTableRelationSegment strValue1 _tTQTableRelationSegment strValue2 Returns Integer
43375>>>>>>>                Number nValue1 nValue2
43375>>>>>>>                Move (strValue1.iInnerJoinComp*10000+strValue1.iSourceColumn*10000+strValue1.iSourceTable*10000+strValue1.iTargetColumn) to nValue1
43376>>>>>>>                Move (strValue2.iInnerJoinComp*10000+strValue2.iSourceColumn*10000+strValue2.iSourceTable*10000+strValue2.iTargetColumn) to nValue2
43377>>>>>>>                If (nValue1<nValue2) Function_Return (LT)
43380>>>>>>>                Else If (nValue1>nValue2) Function_Return (GT)
43384>>>>>>>                Function_Return (EQ)
43385>>>>>>>            End_Function
43386>>>>>>>
43386>>>>>>>        Function _TableRelationsAreSegmentArraysIdentical _tTQTableRelationSegment[] aSegments1 _tTQTableRelationSegment[] aSegments2 Returns Boolean
43388>>>>>>>            Integer iItem iItemMax1 iItemMax2
43388>>>>>>>            Move (SizeOfArray(aSegments1)-1) to iItemMax1
43389>>>>>>>            Move (SizeOfArray(aSegments2)-1) to iItemMax2
43390>>>>>>>            If (iItemMax1<>iItemMax2) Begin
43392>>>>>>>                Function_Return False
43393>>>>>>>            End
43393>>>>>>>>
43393>>>>>>>            // The arrays are not ordered so to tell if they are identical they need to be sorted first.
43393>>>>>>>            Move (SortArray(aSegments1,Self,GET__CompareTableRelationSegments)) to aSegments1
43394>>>>>>>            Move (SortArray(aSegments2,Self,GET__CompareTableRelationSegments)) to aSegments2
43395>>>>>>>            For iItem from 0 to iItemMax1
43401>>>>>>>>
43401>>>>>>>                If (_CompareTableRelationSegments(Self,aSegments1[iItem],aSegments2[iItem])<>EQ) Begin
43403>>>>>>>                    Function_Return False
43404>>>>>>>                End
43404>>>>>>>>
43404>>>>>>>            Loop
43405>>>>>>>>
43405>>>>>>>        End_Function
43406>>>>>>>
43406>>>>>>>        Function _TableRelationsAreIdentical tTQTableRelation strRel1 tTQTableRelation strRel2 Returns Boolean
43408>>>>>>>            If (strRel1.iTargetTable<>strRel2.iTargetTable or strRel1.bFixed<>strRel2.bFixed) Begin
43410>>>>>>>                Function_Return False
43411>>>>>>>            End
43411>>>>>>>>
43411>>>>>>>            If (not(_TableRelationsAreSegmentArraysIdentical(Self,strRel1.aSegments,strRel2.aSegments))) Begin
43413>>>>>>>                Function_Return False
43414>>>>>>>            End
43414>>>>>>>>
43414>>>>>>>            Function_Return True
43415>>>>>>>        End_Function
43416>>>>>>>
43416>>>>>>>        Function _AddTableRelationB2B tTableQuery ByRef strQ tTQTableRelation strRelation Returns Boolean
43418>>>>>>>            Integer iItem
43418>>>>>>>            Get _FindTableRelation strQ strRelation.iTargetTable to iItem
43419>>>>>>>            If (iItem=-1) Begin
43421>>>>>>>                Move strRelation to strQ.aTableRelations[SizeOfArray(strQ.aTableRelations)]
43422>>>>>>>            End
43422>>>>>>>>
43422>>>>>>>            Else Begin
43423>>>>>>>                If (not(_TableRelationsAreIdentical(Self,strRelation,strQ.aTableRelations[iItem]))) Begin
43425>>>>>>>                    Send OnError 727 "Table takes on more than one role"
43426>>>>>>>                    Function_Return False
43427>>>>>>>                End
43427>>>>>>>>
43427>>>>>>>            End
43427>>>>>>>>
43427>>>>>>>            Function_Return True
43428>>>>>>>        End_Function
43429>>>>>>>
43429>>>>>>>    Procedure AddTableRelation tTableQuery ByRef strQ Integer iTargetTable
43431>>>>>>>        Send _AddTableRelation (&strQ) iTargetTable False
43432>>>>>>>    End_Procedure
43433>>>>>>>
43433>>>>>>>    // This is called from the AddFilterRelate procedure.
43433>>>>>>>    Procedure AddTableRelationFixedRecord tTableQuery ByRef strQ Integer iTargetTable
43435>>>>>>>        Send _AddTableRelation (&strQ) iTargetTable True
43436>>>>>>>    End_Procedure
43437>>>>>>>
43437>>>>>>>    Procedure _AddTableRelationSegment tTableQuery ByRef strQ Integer iSourceTable Integer iSourceColumn Integer iComp Integer iTargetTable Integer iTargetColumn
43439>>>>>>>        Integer iItem
43439>>>>>>>        tTQTableRelation strRelatation
43439>>>>>>>        tTQTableRelation strRelatation
43439>>>>>>>        _tTQTableRelationSegment strSegment
43439>>>>>>>        _tTQTableRelationSegment strSegment
43439>>>>>>>        Get _FindTableRelation strQ iTargetTable to iItem
43440>>>>>>>        If (iItem>=0) Begin
43442>>>>>>>
43442>>>>>>>            // Check that iSourceTable is already available in the .aRelations member. If not: error!
43442>>>>>>>            If (iSourceTable=strQ.iTable or _FindTableRelation(Self,strQ,iSourceTable)<>-1) Begin
43444>>>>>>>                Move strQ.aTableRelations[iItem] to strRelatation
43445>>>>>>>                Move iSourceTable to strSegment.iSourceTable
43446>>>>>>>                Move iComp to strSegment.iInnerJoinComp
43447>>>>>>>                Move iSourceColumn to strSegment.iSourceColumn
43448>>>>>>>                Move iTargetColumn to strSegment.iTargetColumn
43449>>>>>>>                Move strSegment to strRelatation.aSegments[SizeOfArray(strRelatation.aSegments)]
43450>>>>>>>                Move strRelatation to strQ.aTableRelations[iItem]
43451>>>>>>>            End
43451>>>>>>>>
43451>>>>>>>            Else Begin
43452>>>>>>>                Send OnError 728 ("No relation has been set up for table "+String(iSourceTable))
43453>>>>>>>            End
43453>>>>>>>>
43453>>>>>>>        End
43453>>>>>>>>
43453>>>>>>>        Else Begin
43454>>>>>>>            Send OnError 729 ("No relation has been set up for table "+String(iTargetTable))
43455>>>>>>>        End
43455>>>>>>>>
43455>>>>>>>    End_Procedure
43456>>>>>>>
43456>>>>>>>    Procedure AddTableRelationSegment tTableQuery ByRef strQ Integer iSourceTable Integer iSourceColumn Integer iTargetTable Integer iTargetColumn
43458>>>>>>>        Send _AddTableRelationSegment (&strQ) iSourceTable iSourceColumn tqEQ iTargetTable iTargetColumn
43459>>>>>>>    End_Procedure
43460>>>>>>>
43460>>>>>>>    Procedure _AddTableRelationInnerJoinSegment tTableQuery ByRef strQ Integer iSourceTable Integer iSourceColumn Integer iComp Integer iTargetTable Integer iTargetColumn
43462>>>>>>>        Send _AddTableRelationSegment (&strQ) iSourceTable iSourceColumn iComp iTargetTable iTargetColumn
43463>>>>>>>    End_Procedure
43464>>>>>>>
43464>>>>>>>    //> Use this method over the AddTableRelation ditto to register a table relation by its generic relation
43464>>>>>>>    Procedure _AddTableRelationAuto tTableQuery ByRef strQ Integer iSourceTable Integer iTargetTable Boolean bFixed
43466>>>>>>>        Integer iItem iMax iRelateItem
43466>>>>>>>        Integer[] aSourceColumns aTargetColumns
43468>>>>>>>
43468>>>>>>>        Get _FindTableRelation strQ iTargetTable to iRelateItem
43469>>>>>>>        If (iRelateItem=-1) Begin
43471>>>>>>>            If (TableColumnsRelatingBetweenTables(oOverlapColumnFunctions,iSourceTable,iTargetTable,&aSourceColumns,&aTargetColumns)) Begin
43473>>>>>>>                Send AddTableRelation (&strQ) iTargetTable
43474>>>>>>>                Move (SizeOfArray(aSourceColumns)-1) to iMax
43475>>>>>>>                For iItem from 0 to iMax
43481>>>>>>>>
43481>>>>>>>                    Send AddTableRelationSegment (&strQ) iSourceTable aSourceColumns[iItem] iTargetTable aTargetColumns[iItem]
43482>>>>>>>                Loop
43483>>>>>>>>
43483>>>>>>>            End
43483>>>>>>>>
43483>>>>>>>            Else Begin
43484>>>>>>>                Send OnError 730 ("Tables do not relate ("+String(iSourceTable)+"->"+String(iTargetTable)+")")
43485>>>>>>>            End
43485>>>>>>>>
43485>>>>>>>        End
43485>>>>>>>>
43485>>>>>>>        Else Begin // If a relation is already there:
43486>>>>>>>// ToDo:    // Here we need to check if the current segment array is empty.
43486>>>>>>>            // If it is, we add the relation segments
43486>>>>>>>            // If it's not, we should check that it is currently set
43486>>>>>>>            // to the "plain df relation" and give an Error if it's not.
43486>>>>>>>        End
43486>>>>>>>>
43486>>>>>>>    End_Procedure
43487>>>>>>>
43487>>>>>>>    Procedure AddTableRelationAuto tTableQuery ByRef strQ Integer iSourceTable Integer iTargetTable
43489>>>>>>>        Send _AddTableRelationAuto (&strQ) iSourceTable iTargetTable False
43490>>>>>>>    End_Procedure
43491>>>>>>>
43491>>>>>>>    Procedure AddTableRelationAutoFixed tTableQuery ByRef strQ Integer iSourceTable Integer iTargetTable
43493>>>>>>>        Send _AddTableRelationAuto (&strQ) iSourceTable iTargetTable True
43494>>>>>>>    End_Procedure
43495>>>>>>>
43495>>>>>>>        Function _TableRelationAlreadyOK tTableQuery ByRef strQ tTQTableRelation strRelation Returns Boolean
43497>>>>>>>            Integer iSegment iSegmentMax
43497>>>>>>>            String sSourceValue sTargetValue
43497>>>>>>>
43497>>>>>>>            If (not(strRelation.bFixed)) Begin
43499>>>>>>>                Move (SizeOfArray(strRelation.aSegments)-1) to iSegmentMax
43500>>>>>>>                For iSegment from 0 to iSegmentMax
43506>>>>>>>>
43506>>>>>>>                    Get ResultColumnValue (&strQ) strRelation.aSegments[iSegment].iSourceTable strRelation.aSegments[iSegment].iSourceColumn to sSourceValue
43507>>>>>>>                    Get_Field_Value strRelation.iTargetTable strRelation.aSegments[iSegment].iTargetColumn to sTargetValue
43510>>>>>>>                    If (sSourceValue<>sTargetValue) Begin
43512>>>>>>>                        Function_Return (False)
43513>>>>>>>                    End
43513>>>>>>>>
43513>>>>>>>                Loop
43514>>>>>>>>
43514>>>>>>>            End
43514>>>>>>>>
43514>>>>>>>            Function_Return (True)
43515>>>>>>>        End_Function
43516>>>>>>>
43516>>>>>>>        Function _SQLNumericToDFNumeric Integer iTable String sValue Returns String
43518>>>>>>>            Integer iDriverDS iRuntimeDS iDriverIndex
43518>>>>>>>            String sDriver
43518>>>>>>>
43518>>>>>>>            Get_Attribute DF_FILE_DRIVER of iTable to sDriver
43521>>>>>>>            Get DriverIndex of oTableDriverFunctions sDriver to iDriverIndex
43522>>>>>>>            Get_Attribute DF_DRIVER_DRIVER_DECIMAL_SEPARATOR of iDriverIndex to iDriverDS
43525>>>>>>>
43525>>>>>>>            Get_Attribute DF_DECIMAL_SEPARATOR to iRuntimeDS
43528>>>>>>>
43528>>>>>>>            If (iRuntimeDS<>iDriverDS) Begin
43530>>>>>>>                Move (Replaces(Character(iDriverDS),sValue,Character(iRuntimeDS))) to sValue
43531>>>>>>>            End
43531>>>>>>>>
43531>>>>>>>
43531>>>>>>>            If (Left(sValue,1)=Character(iRuntimeDS)) Begin
43533>>>>>>>                Move ("0"+sValue) to sValue
43534>>>>>>>            End
43534>>>>>>>>
43534>>>>>>>
43534>>>>>>>            Function_Return sValue
43535>>>>>>>        End_Function
43536>>>>>>>
43536>>>>>>>    Function ResultColumnValue tTableQuery ByRef strQ Integer iTable Integer iColumn Returns String
43538>>>>>>>        Integer iRelateItem iColumnSourceItem iType
43538>>>>>>>        Integer iDriverDecimalPlaces iDecimalPlaces
43538>>>>>>>        String sValue
43538>>>>>>>        If (strQ._strControlBlock.iQueryMethod=tqDATAFLEX) Begin
43540>>>>>>>            Send _RelateToTable (&strQ) iTable
43541>>>>>>>            If (iColumn=0) Begin
43543>>>>>>>                Move (SerializeRowID(GetRowID(iTable))) to sValue
43544>>>>>>>            End
43544>>>>>>>>
43544>>>>>>>            Else Begin
43545>>>>>>>                Get_Field_Value iTable iColumn to sValue
43548>>>>>>>                Move (Rtrim(sValue)) to sValue
43549>>>>>>>            End
43549>>>>>>>>
43549>>>>>>>        End
43549>>>>>>>>
43549>>>>>>>        Else Begin
43550>>>>>>>            If (SizeOfArray(strQ.aColumnSources)=0) Begin
43552>>>>>>>                If (iTable=strQ.iTable) Begin
43554>>>>>>>                    Get_Field_Value iTable iColumn to sValue
43557>>>>>>>                    Move (Rtrim(sValue)) to sValue
43558>>>>>>>                End
43558>>>>>>>>
43558>>>>>>>                Else Begin
43559>>>>>>>                    Send OnError 731 "Column not part of result set."
43560>>>>>>>                End
43560>>>>>>>>
43560>>>>>>>            End
43560>>>>>>>>
43560>>>>>>>            Else Begin
43561>>>>>>>                Get _ColumnSourceFind strQ iTable iColumn to iColumnSourceItem
43562>>>>>>>                If (iColumnSourceItem<>-1) Begin
43564>>>>>>>                    If (strQ.aColumnSources[iColumnSourceItem].iColumn=0) Begin
43566>>>>>>>                        Get_Field_Value iTable iColumn to sValue
43569>>>>>>>                        Move (Rtrim(sValue)) to sValue
43570>>>>>>>                    End
43570>>>>>>>>
43570>>>>>>>                    Else Begin
43571>>>>>>>                        // 
43571>>>>>>>                        Get SQLColumnValue of strQ._strControlBlock.strSQLStatementHandle.hHandle (iColumnSourceItem+1) to sValue
43572>>>>>>>                        Move strQ.aColumnSources[iColumnSourceItem].iType to iType
43573>>>>>>>                        If (iType=tqDATE) Begin
43575>>>>>>>                            Get SQLDateToDFDate of strQ._strControlBlock.strSQLStatementHandle.hHandle sValue to sValue
43576>>>>>>>                        End
43576>>>>>>>>
43576>>>>>>>                        Else If (iType=tqNUMBER) Begin
43579>>>>>>>                            Get _SQLNumericToDFNumeric iTable sValue to sValue
43580>>>>>>>                        End
43580>>>>>>>>
43580>>>>>>>                        Else If (iType=tqSTRING or iType=tqTEXT) Begin
43583>>>>>>>                            If (strQ._strControlBlock.bSQLTableIsAnsi) Begin
43585>>>>>>>                                Move (ToOEM(sValue)) to sValue
43586>>>>>>>                            End
43586>>>>>>>>
43586>>>>>>>                            Move (Rtrim(sValue)) to sValue
43587>>>>>>>                        End
43587>>>>>>>>
43587>>>>>>>                    End
43587>>>>>>>>
43587>>>>>>>                End
43587>>>>>>>>
43587>>>>>>>                Else Begin
43588>>>>>>>                    Send OnError 732 "Unknown result column"
43589>>>>>>>                End
43589>>>>>>>>
43589>>>>>>>            End
43589>>>>>>>>
43589>>>>>>>        End
43589>>>>>>>>
43589>>>>>>>        Function_Return sValue
43590>>>>>>>    End_Function
43591>>>>>>>
43591>>>>>>>    Function ResultColumnValues tTableQuery ByRef strQ Boolean bIncludeRowIDs Returns String[]
43593>>>>>>>        Boolean bDone
43593>>>>>>>        Integer iItem iMax iTable iColumn 
43593>>>>>>>        String[] aValues
43594>>>>>>>        Move (SizeOfArray(strQ.aColumnSources)-1) to iMax
43595>>>>>>>        Move 0 to iItem
43596>>>>>>>        Move False to bDone
43597>>>>>>>        While (not(bDone) and iItem<=iMax)
43601>>>>>>>            If (not(bIncludeRowIDs)) Begin
43603>>>>>>>                Move (strQ.aColumnSources[iItem].iColumn=0) to bDone // The ones that are Table.* are excluded
43604>>>>>>>            End
43604>>>>>>>>
43604>>>>>>>            If (not(bDone)) Begin
43606>>>>>>>                Get ResultColumnValue (&strQ) strQ.aColumnSources[iItem].iTable strQ.aColumnSources[iItem].iColumn to aValues[iItem]
43607>>>>>>>            End
43607>>>>>>>>
43607>>>>>>>            Increment iItem
43608>>>>>>>        Loop
43609>>>>>>>>
43609>>>>>>>        Function_Return aValues
43610>>>>>>>    End_Function
43611>>>>>>>    
43611>>>>>>>    Function OutputColumnValues tTableQuery ByRef strQ Boolean bIncludeRowIDs Returns String[]
43613>>>>>>>        Boolean bDone
43613>>>>>>>        Integer iItem iMax iTable iColumn 
43613>>>>>>>        String[] aValues
43614>>>>>>>        Move (SizeOfArray(strQ.aOutputColumns)-1) to iMax
43615>>>>>>>        Move 0 to iItem
43616>>>>>>>        Move False to bDone
43617>>>>>>>        While (not(bDone) and iItem<=iMax)
43621>>>>>>>            If (not(bIncludeRowIDs)) Begin
43623>>>>>>>                Move (strQ.aOutputColumns[iItem].iColumn=0) to bDone // The ones that are Table.* are excluded
43624>>>>>>>            End
43624>>>>>>>>
43624>>>>>>>            If (not(bDone)) Begin
43626>>>>>>>                Get ResultColumnValue (&strQ) strQ.aOutputColumns[iItem].iTable strQ.aOutputColumns[iItem].iColumn to aValues[iItem]
43627>>>>>>>            End
43627>>>>>>>>
43627>>>>>>>            Increment iItem
43628>>>>>>>        Loop
43629>>>>>>>>
43629>>>>>>>        Function_Return aValues
43630>>>>>>>    End_Function
43631>>>>>>>
43631>>>>>>>
43631>>>>>>>            Function __RelateSegmentsToColumns _tTQTableRelationSegment[] aSegments Returns Integer[]
43633>>>>>>>                Integer iItem iMax
43633>>>>>>>                Integer[] aColumns
43634>>>>>>>                Move (SizeOfArray(aSegments)-1) to iMax
43635>>>>>>>                For iItem from 0 to iMax
43641>>>>>>>>
43641>>>>>>>                    Move aSegments[iItem].iTargetColumn to aColumns[iItem]
43642>>>>>>>                Loop
43643>>>>>>>>
43643>>>>>>>                Function_Return aColumns
43644>>>>>>>            End_Function
43645>>>>>>>
43645>>>>>>>        Procedure _RelateTablePerform tTableQuery ByRef strQ Integer iRelateItem // Is only called when i embedded mode
43647>>>>>>>            Integer iMax iItem iIndex
43647>>>>>>>            Integer iSourceTable iSourceColumn iTargetTable iTargetColumn
43647>>>>>>>            String sValue
43647>>>>>>>            Integer[] aColumns
43648>>>>>>>            tTQTableRelation strRelation
43648>>>>>>>            tTQTableRelation strRelation
43648>>>>>>>
43648>>>>>>>            Move strQ.aTableRelations[iRelateItem] to strRelation
43649>>>>>>>
43649>>>>>>>            If (not(strRelation.bFixed)) Begin // If fixed we will just accept the record that is there.
43651>>>>>>>                Move (SizeOfArray(strRelation.aSegments)-1) to iMax
43652>>>>>>>
43652>>>>>>>                Move strRelation.iTargetTable to iTargetTable
43653>>>>>>>                Clear iTargetTable
43654>>>>>>>                For iItem from 0 to iMax
43660>>>>>>>>
43660>>>>>>>                    Move strRelation.aSegments[iItem].iSourceTable to iSourceTable
43661>>>>>>>                    Move strRelation.aSegments[iItem].iSourceColumn to iSourceColumn
43662>>>>>>>                    Move strRelation.aSegments[iItem].iTargetColumn to iTargetColumn
43663>>>>>>>                    Get ResultColumnValue (&strQ) iSourceTable iSourceColumn to sValue
43664>>>>>>>                    Set_Field_Value iTargetTable iTargetColumn to sValue
43667>>>>>>>                Loop
43668>>>>>>>>
43668>>>>>>>                If (strRelation._iEmbeddedIndex=-1) Begin
43670>>>>>>>                    Get __RelateSegmentsToColumns strRelation.aSegments to aColumns
43671>>>>>>>                    Get FindEQIndex of oIndexFunctions iTargetTable aColumns to iIndex
43672>>>>>>>                    If (iIndex=-1) Begin
43674>>>>>>>                        Send OnError 733 ("Can't identify record in related table "+String(iTargetTable))
43675>>>>>>>                    End
43675>>>>>>>>
43675>>>>>>>                    Move iIndex to strRelation._iEmbeddedIndex
43676>>>>>>>                    Move strRelation to strQ.aTableRelations[iRelateItem]
43677>>>>>>>                End
43677>>>>>>>>
43677>>>>>>>                Else Begin
43678>>>>>>>                    Move strRelation._iEmbeddedIndex to iIndex
43679>>>>>>>                End
43679>>>>>>>>
43679>>>>>>>
43679>>>>>>>                Vfind iTargetTable iIndex EQ
43681>>>>>>>                If (not(Found)) Begin
43683>>>>>>>                    Clear iTargetTable
43684>>>>>>>                End
43684>>>>>>>>
43684>>>>>>>            End
43684>>>>>>>>
43684>>>>>>>        End_Procedure
43685>>>>>>>
43685>>>>>>>    Procedure _RelateToTable tTableQuery ByRef strQ Integer iTable // This is only called for embedded type queries (from the ResultColumnValue function)
43687>>>>>>>        Integer iRelateItem
43687>>>>>>>        Boolean bTableRelated
43687>>>>>>>        tTQTableRelation strRelation
43687>>>>>>>        tTQTableRelation strRelation
43687>>>>>>>        If (iTable<>strQ.iTable) Begin // If iTable is not the main table of the query
43689>>>>>>>
43689>>>>>>>            Get _FindTableRelation strQ iTable to iRelateItem
43690>>>>>>>            If (iRelateItem<>-1) Begin
43692>>>>>>>
43692>>>>>>>                Move strQ._strControlBlock.aRelatedRecords[iRelateItem] to bTableRelated
43693>>>>>>>                If (not(bTableRelated)) Begin //
43695>>>>>>>
43695>>>>>>>                    Move strQ.aTableRelations[iRelateItem] to strRelation
43696>>>>>>>                    If (not(strRelation.bFixed)) Begin // If no items we will just accept the current record
43698>>>>>>>
43698>>>>>>>                        If (IsNullRowID(GetRowID(strQ.iTable))) Begin
43700>>>>>>>                            Clear iTable
43701>>>>>>>                        End
43701>>>>>>>>
43701>>>>>>>                        Else Begin
43702>>>>>>>
43702>>>>>>>                            If (not(_TableRelationAlreadyOK(Self,&strQ,strRelation))) Begin // If not already good by chance.
43704>>>>>>>                                // It could already be OK by chance in which case it will not perform a relate. If the parent
43704>>>>>>>                                // record is the same as for the previous child record. Or if it has been "fixated" by an
43704>>>>>>>                                // outer loop in which case it would be constant. It is the responsability of the
43704>>>>>>>                                // programmer to ensure that tables do have to take on double roles.
43704>>>>>>>                                Send _RelateTablePerform (&strQ) iRelateItem
43705>>>>>>>                            End
43705>>>>>>>>
43705>>>>>>>
43705>>>>>>>                        End
43705>>>>>>>>
43705>>>>>>>                    End
43705>>>>>>>>
43705>>>>>>>
43705>>>>>>>                    Move True to strQ._strControlBlock.aRelatedRecords[iRelateItem] // update TableRelateState to "performed"
43706>>>>>>>                End
43706>>>>>>>>
43706>>>>>>>            End
43706>>>>>>>>
43706>>>>>>>            Else Begin
43707>>>>>>>                Send OnError 734 "Table not related"
43708>>>>>>>            End
43708>>>>>>>>
43708>>>>>>>        End
43708>>>>>>>>
43708>>>>>>>    End_Procedure
43709>>>>>>>
43709>>>>>>>    // This is called in preparation for a new record to indicate the related buffers have
43709>>>>>>>    // to be reconsidered and rectified if needed.
43709>>>>>>>    Procedure _TableRelateStatesReset tTableQuery ByRef strQ
43711>>>>>>>        Boolean[] abEmpty
43712>>>>>>>        Move abEmpty to strQ._strControlBlock.aRelatedRecords
43713>>>>>>>        Move (ResizeArray(strQ._strControlBlock.aRelatedRecords,SizeOfArray(strQ.aTableRelations),False)) to strQ._strControlBlock.aRelatedRecords
43714>>>>>>>    End_Procedure
43715>>>>>>>
43715>>>>>>>        Function __CompareColumnSource _tTQValueSource strValue1 _tTQValueSource strValue2 Returns Integer
43717>>>>>>>            Boolean bCompleteRecord1 bCompleteRecord2
43717>>>>>>>            Move (strValue1.iColumn=0) to bCompleteRecord1
43718>>>>>>>            Move (strValue2.iColumn=0) to bCompleteRecord2
43719>>>>>>>            If (bCompleteRecord1=bCompleteRecord2) Begin
43721>>>>>>>                Function_Return (EQ)
43722>>>>>>>            End
43722>>>>>>>>
43722>>>>>>>            If (bCompleteRecord1) Begin
43724>>>>>>>                Function_Return (GT)
43725>>>>>>>            End
43725>>>>>>>>
43725>>>>>>>            Else Begin
43726>>>>>>>                Function_Return (LT)
43727>>>>>>>            End
43727>>>>>>>>
43727>>>>>>>        End_Function
43728>>>>>>>
43728>>>>>>>    //> Add table column to the result set.
43728>>>>>>>    Procedure AddResultColumn tTableQuery ByRef strQ Integer iTable Integer iColumn Boolean bRejectIfAlreadyThere
43730>>>>>>>        Integer iColumnSourceItem
43730>>>>>>>        Boolean _bRejectIfAlreadyThere
43730>>>>>>>        
43730>>>>>>>        If (num_arguments>=4) Begin
43732>>>>>>>            Move bRejectIfAlreadyThere to _bRejectIfAlreadyThere
43733>>>>>>>        End
43733>>>>>>>>
43733>>>>>>>        Else Begin
43734>>>>>>>            Move False to _bRejectIfAlreadyThere
43735>>>>>>>        End
43735>>>>>>>>
43735>>>>>>>        
43735>>>>>>>        If (_bRejectIfAlreadyThere) Begin
43737>>>>>>>            Get _ColumnSourceFind strQ iTable iColumn to iColumnSourceItem
43738>>>>>>>            If (iColumnSourceItem>=0) Begin
43740>>>>>>>                Procedure_Return // The column is already there => skip it
43741>>>>>>>            End
43741>>>>>>>>
43741>>>>>>>        End
43741>>>>>>>>
43741>>>>>>>        
43741>>>>>>>        If (iTable=strQ.iTable or _FindTableRelation(Self,strQ,iTable)<>-1) Begin // We accept only ourselves or one of our related.
43743>>>>>>>            Move (SizeOfArray(strQ.aColumnSources)) to iColumnSourceItem
43744>>>>>>>            Move iTable to strQ.aColumnSources[iColumnSourceItem].iTable
43745>>>>>>>            Move iColumn to strQ.aColumnSources[iColumnSourceItem].iColumn
43746>>>>>>>            Get _ColumnType iTable iColumn to strQ.aColumnSources[iColumnSourceItem].iType
43747>>>>>>>            If (not(strQ._bOutputColumnsFixated)) Begin
43749>>>>>>>                Move strQ.aColumnSources[iColumnSourceItem] to strQ.aOutputColumns[SizeOfArray(strQ.aOutputColumns)]
43750>>>>>>>            End
43750>>>>>>>>
43750>>>>>>>            Move (SortArray(strQ.aColumnSources,Self,GET___CompareColumnSource)) to strQ.aColumnSources
43751>>>>>>>        End
43751>>>>>>>>
43751>>>>>>>        Else Begin
43752>>>>>>>            Send OnError 736 ("Unknown table in result set ("+String(iTable)+")")
43753>>>>>>>        End
43753>>>>>>>>
43753>>>>>>>    End_Procedure
43754>>>>>>>    
43754>>>>>>>    Procedure FixateOutputColumns tTableQuery ByRef strQ
43756>>>>>>>        Move True to strQ._bOutputColumnsFixated
43757>>>>>>>    End_Procedure
43758>>>>>>>    
43758>>>>>>>    Procedure AddResultTable tTableQuery ByRef strQ Integer iTable
43760>>>>>>>        Send AddResultColumn (&strQ) iTable 0
43761>>>>>>>    End_Procedure
43762>>>>>>>
43762>>>>>>>    Procedure ResetResultSetColumns tTableQuery ByRef strQuery
43764>>>>>>>        // Check that the query is not already executing
43764>>>>>>>        If (strQuery._strControlBlock.bInitialized) Begin
43766>>>>>>>            Send OnError 741 "ResetResultSetColumns called while query is executing"
43767>>>>>>>        End
43767>>>>>>>>
43767>>>>>>>        Else Begin
43768>>>>>>>            Move (ResizeArray(strQuery.aColumnSources,0)) to strQuery.aColumnSources
43769>>>>>>>            Move (ResizeArray(strQuery.aOutputColumns,0)) to strQuery.aOutputColumns
43770>>>>>>>        End
43770>>>>>>>>
43770>>>>>>>    End_Procedure
43771>>>>>>>
43771>>>>>>>    Function _IsColumnIncludedInResultSet tTableQuery strQ Integer iTable Integer iColumn Returns Boolean
43773>>>>>>>        Integer iItem iItemMax
43773>>>>>>>        Move (SizeOfArray(strQ.aColumnSources)-1) to iItemMax
43774>>>>>>>        If (strQ.iTable=iTable and iItemMax=-1) Begin
43776>>>>>>>            Function_Return True //
43777>>>>>>>        End
43777>>>>>>>>
43777>>>>>>>        For iItem from 0 to iItemMax
43783>>>>>>>>
43783>>>>>>>            If (iTable=strQ.aColumnSources[iItem].iTable) Begin
43785>>>>>>>                If (iColumn=strQ.aColumnSources[iItem].iColumn or strQ.aColumnSources[iItem].iColumn=0) Begin
43787>>>>>>>                    Function_Return True
43788>>>>>>>                End
43788>>>>>>>>
43788>>>>>>>            End
43788>>>>>>>>
43788>>>>>>>        Loop
43789>>>>>>>>
43789>>>>>>>        Function_Return False
43790>>>>>>>    End_Function
43791>>>>>>>
43791>>>>>>>// *** End of TableRelation functions *** End of TableRelation functions *** End of TableRelation functions *** End of TableRelation functions *** End of TableRelation functions ***
43791>>>>>>>
43791>>>>>>>
43791>>>>>>>        // If iTable has a name in filelist.cfg we use that, other wise
43791>>>>>>>        // we try the SQL table name.
43791>>>>>>>        Function LogTableName tTableQuery strQuery Returns String
43793>>>>>>>            Integer iTable
43793>>>>>>>            String sTableName
43793>>>>>>>            Move strQuery.iTable to iTable
43794>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sTableName
43797>>>>>>>            If (sTableName="") Begin
43799>>>>>>>                Move strQuery.sForceSQLTableName to sTableName
43800>>>>>>>            End
43800>>>>>>>>
43800>>>>>>>            If (sTableName<>"") Begin
43802>>>>>>>                Move (sTableName+"_tqlog.dat") to sTableName
43803>>>>>>>            End
43803>>>>>>>>
43803>>>>>>>            Function_Return sTableName
43804>>>>>>>        End_Function
43805>>>>>>>
43805>>>>>>>        Function LogTableNameFullPath tTableQuery strQuery Returns String
43807>>>>>>>            String sFolder sTablePath
43807>>>>>>>            Get VdfFolderPath of oFileFunctions VDF_FILELIST to sFolder
43808>>>>>>>            Get AppendPath of oFileFunctions sFolder "tq-logdata" to sFolder
43809>>>>>>>            Get AppendPath of oFileFunctions sFolder (LogTableName(Self,strQuery)) to sTablePath
43810>>>>>>>            Function_Return sTablePath
43811>>>>>>>        End_Function
43812>>>>>>>
43812>>>>>>>        Function LogTableCreate tTableQuery strQuery Returns Boolean
43814>>>>>>>            tTempTableDefinition strTable
43814>>>>>>>            tTempTableDefinition strTable
43814>>>>>>>
43814>>>>>>>            Get EmptyTempTableDefinition of oTemporaryTablesFunctions to strTable
43815>>>>>>>
43815>>>>>>>            Move 20000 to strTable.iMaxRecords // Max number of logs
43816>>>>>>>            Get LogTableName strQuery to strTable.sFileName
43817>>>>>>>            Move "" to strTable.sFolder // blank means it goes in the data folder
43818>>>>>>>            Move "tq-logdata" to strTable.sSubFolder // means it goes in a subfolder of the data folder called "tq-logdata"
43819>>>>>>>
43819>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "DateTime"         DF_ASCII    23 0  // field no 1
43820>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "ExecTime"         DF_BCD       8 0  // field no 2
43821>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "LogTag"           DF_ASCII    20 0  // field no 3
43822>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "User"             DF_ASCII    20 0  // field no 4
43823>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "Application"      DF_ASCII    20 0  // field no 5
43824>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "SessionStart"     DF_ASCII    23 0  // field no 6
43825>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "FullTableScan"    DF_BCD       2 0  // field no 7
43826>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "RecordsFound"     DF_BCD      10 0  // field no 8
43827>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "RecordsSelected"  DF_BCD      10 0  // field no 9
43828>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "UnusedFilters"    DF_BCD       4 0  // field no 10
43829>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "Index"            DF_BCD       4 0  // field no 11
43830>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "IndexForced"      DF_BCD       2 0  // field no 12
43831>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "PrefetchForced"   DF_BCD       2 0  // field no 13
43832>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "Limit"            DF_BCD       6 0  // field no 14
43833>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "ScanComplete"     DF_BCD       2 0  // field no 15
43834>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "TQserialised"     DF_BINARY 2040 0  // field no 16
43835>>>>>>>            Move True to strTable.bCompression
43836>>>>>>>            
43836>>>>>>>            If (CreateTable(oTemporaryTablesFunctions,strTable,True)) Begin
43838>>>>>>>//                Showln "LogTableCreate Success"
43838>>>>>>>                Function_Return True
43839>>>>>>>            End
43839>>>>>>>>
43839>>>>>>>            Else Begin
43840>>>>>>>//                Showln "LogTableCreate Failure"
43840>>>>>>>            End
43840>>>>>>>>
43840>>>>>>>            Function_Return False
43841>>>>>>>        End_Function
43842>>>>>>>        
43842>>>>>>>        Function OpenLogTable tTableQuery strQuery Returns Integer 
43844>>>>>>>            Integer iLogTable
43844>>>>>>>            String sLogTableName
43844>>>>>>>            Move 0 to iLogTable
43845>>>>>>>            Get LogTableNameFullPath strQuery to sLogTableName
43846>>>>>>>            // We do not expect the log file to have an entry in filelist.cfg 
43846>>>>>>>            // so we open it "as".
43846>>>>>>>            If (sLogTableName<>"") Begin
43848>>>>>>>                Get OpenTableAsAutoHandle of oTableAccessFunctions sLogTableName DF_SHARE 0 to iLogTable
43849>>>>>>>                If (iLogTable=0) Begin // If the table isn't there, we create it
43851>>>>>>>                    If (LogTableCreate(Self,strQuery)) Begin
43853>>>>>>>                        Get OpenTableAsAutoHandle of oTableAccessFunctions sLogTableName DF_SHARE 0 to iLogTable
43854>>>>>>>                    End
43854>>>>>>>>
43854>>>>>>>                End
43854>>>>>>>>
43854>>>>>>>            End
43854>>>>>>>>
43854>>>>>>>            Else Begin
43855>>>>>>>                // No error! (I changed my mind)
43855>>>>>>>                // Error xxx ("Table name for log file could not be calculated (table: "+String(strQuery.iTable)+")")
43855>>>>>>>            End
43855>>>>>>>>
43855>>>>>>>            Function_Return iLogTable
43856>>>>>>>        End_Function
43857>>>>>>>        
43857>>>>>>>        Function LogTableHandle tTableQuery strQuery Returns Integer 
43859>>>>>>>            Integer iLogTable
43859>>>>>>>            Move 0 to iLogTable
43860>>>>>>>            If (strQuery.iTable<SizeOfArray(_gaTQLogTables)) Begin
43862>>>>>>>                Move _gaTQLogTables[strQuery.iTable] to iLogTable
43863>>>>>>>            End
43863>>>>>>>>
43863>>>>>>>            If (iLogTable=0) Begin
43865>>>>>>>                // Attempt to open log table
43865>>>>>>>                Get OpenLogTable strQuery to iLogTable
43866>>>>>>>                If (iLogTable=0) Move -1 to iLogTable
43869>>>>>>>                Move iLogTable to _gaTQLogTables[strQuery.iTable]
43870>>>>>>>            End
43870>>>>>>>>
43870>>>>>>>            Function_Return iLogTable
43871>>>>>>>        End_Function
43872>>>>>>>        
43872>>>>>>>        Function TableQueryUser Returns String
43874>>>>>>>            Function_Return (NetworkUserName(oWindowsInfo))
43875>>>>>>>        End_Function
43876>>>>>>>        
43876>>>>>>>//                Procedure _LogAppend String sValue String[] ByRef aValues
43876>>>>>>>//                    Send StringPush of oStackFunctions sValue (&aValues)
43876>>>>>>>//                End_Procedure
43876>>>>>>>//                
43876>>>>>>>//                Procedure _LogAppendValueSource _tTQValueSource strValue String[] ByRef aValues
43876>>>>>>>//                    Integer iItem iMax
43876>>>>>>>//                    Send _LogAppend strValue.iTable    (&aValues)
43876>>>>>>>//                    Send _LogAppend strValue.iColumn   (&aValues)
43876>>>>>>>//                    Send _LogAppend strValue.iType     (&aValues)
43876>>>>>>>//                    Send _LogAppend strValue.iLen      (&aValues)
43876>>>>>>>//                    Send _LogAppend strValue.iDecimals (&aValues)
43876>>>>>>>//                    Send _LogAppend strValue.sConstant (&aValues)
43876>>>>>>>//                    Send _LogAppend strValue.sSQLResultSetColumnName (&aValues)
43876>>>>>>>//                    Move (SizeOfArray(strValue.aOrList)-1) to iMax
43876>>>>>>>//                    Send _LogAppend iMax               (&aValues)
43876>>>>>>>//                    For iItem from 0 to iMax
43876>>>>>>>//                        Send _LogAppend strValue.aOrList[iItem] (&aValues)
43876>>>>>>>//                    Loop
43876>>>>>>>//                End_Procedure
43876>>>>>>>//                
43876>>>>>>>//            Procedure _LogAppendFilter tTQFilterSegment strFilter String[] ByRef aValues
43876>>>>>>>//                Send _LogAppendValueSource strFilter.strLeftValue  (&aValues)
43876>>>>>>>//                Send _LogAppend strFilter.iComp                    (&aValues)
43876>>>>>>>//                Send _LogAppendValueSource strFilter.strRightValue (&aValues)
43876>>>>>>>//            End_Procedure
43876>>>>>>>//
43876>>>>>>>//            Procedure _LogAppendOrderSegment tTQOrderBySegment strSegment String[] ByRef aValues
43876>>>>>>>//                Send _LogAppend strSegment.bDescending                (&aValues)
43876>>>>>>>//                Send _LogAppend strSegment.bUppercase                 (&aValues)
43876>>>>>>>//                Send _LogAppendValueSource strSegment.strValueSource  (&aValues)
43876>>>>>>>//            End_Procedure
43876>>>>>>>
43876>>>>>>>    //> Returns an array of tables that are referenced as constants during the execution of a query.
43876>>>>>>>    //> So if you want to repeat the find loop of a particular tTableQuery variable, the record 
43876>>>>>>>    //> buffers of fixed tables must be restored to that of the original query. Does this make sense?
43876>>>>>>>    Function _FixedTables tTableQuery strQuery Boolean bFixed Returns Integer[]
43878>>>>>>>        Integer iMax iIndex
43878>>>>>>>        Integer[] aTables
43879>>>>>>>        Move (SizeOfArray(strQuery.aTableRelations)-1) to iMax
43880>>>>>>>        For iIndex from 0 to iMax
43886>>>>>>>>
43886>>>>>>>            If (strQuery.aTableRelations[iIndex].bFixed=bFixed) Begin
43888>>>>>>>                If (IntegerAddToSet(oStackFunctions,&aTables,strQuery.aTableRelations[iIndex].iTargetTable)) Begin
43890>>>>>>>                    // Do nothing
43890>>>>>>>                End
43890>>>>>>>>
43890>>>>>>>            End
43890>>>>>>>>
43890>>>>>>>        Loop
43891>>>>>>>>
43891>>>>>>>        Function_Return aTables
43892>>>>>>>    End_Function
43893>>>>>>>
43893>>>>>>>    Function FixedTables tTableQuery strQuery Returns Integer[]
43895>>>>>>>        Function_Return (_FixedTables(Self,strQuery,True))
43896>>>>>>>    End_Function
43897>>>>>>>    
43897>>>>>>>    Function NotFixedTables tTableQuery strQuery Returns Integer[]
43899>>>>>>>        Boolean bGrb
43899>>>>>>>        Integer[] aTables
43900>>>>>>>        Get _FixedTables strQuery False to aTables
43901>>>>>>>        Get IntegerAddToSet of oStackFunctions (&aTables) strQuery.iTable to bGrb
43902>>>>>>>        Function_Return aTables
43903>>>>>>>    End_Function
43904>>>>>>>    
43904>>>>>>>    Function FixedTablesRowIDs tTableQuery strQuery Returns RowID[]
43906>>>>>>>        Integer iItem iMax
43906>>>>>>>        Integer[] aFixedTables
43907>>>>>>>        RowID[] aRowIDs
43908>>>>>>>        Get FixedTables strQuery to aFixedTables
43909>>>>>>>        Move (SizeOfArray(aFixedTables)-1) to iItem
43910>>>>>>>        For iItem from 0 to iMax
43916>>>>>>>>
43916>>>>>>>            Move (GetRowID(aFixedTables[iItem])) to aRowIDs[iItem]
43917>>>>>>>        Loop
43918>>>>>>>>
43918>>>>>>>        Function_Return aRowIDs
43919>>>>>>>    End_Function
43920>>>>>>>    
43920>>>>>>>    Function FixedTablesRowIDs_Serialized tTableQuery strQuery Returns String[]
43922>>>>>>>        Integer iItem iMax
43922>>>>>>>        Integer[] aFixedTables
43923>>>>>>>        String[] aRowIDs
43924>>>>>>>        Get FixedTables strQuery to aFixedTables
43925>>>>>>>        Move (SizeOfArray(aFixedTables)-1) to iItem
43926>>>>>>>        For iItem from 0 to iMax
43932>>>>>>>>
43932>>>>>>>            Move (SerializeRowID(GetRowID(aFixedTables[iItem]))) to aRowIDs[iItem]
43933>>>>>>>        Loop
43934>>>>>>>>
43934>>>>>>>        Function_Return aRowIDs
43935>>>>>>>    End_Function
43936>>>>>>>    
43936>>>>>>>    Function FixedTablesRestore tTableQuery strQuery RowID[] aRowIDs Returns Boolean
43938>>>>>>>        Boolean bFound
43938>>>>>>>        RowID riRow
43938>>>>>>>        Integer iItem iMax
43938>>>>>>>        Integer[] aFixedTables
43939>>>>>>>        Get FixedTables strQuery to aFixedTables
43940>>>>>>>        Move (SizeOfArray(aFixedTables)-1) to iMax
43941>>>>>>>        For iItem from 0 to iMax
43947>>>>>>>>
43947>>>>>>>            Move aRowIDs[iItem] to riRow
43948>>>>>>>            If (IsNullRowID(riRow)) Begin
43950>>>>>>>                Clear aFixedTables[iItem]
43951>>>>>>>            End
43951>>>>>>>>
43951>>>>>>>            Else Begin
43952>>>>>>>                Move (FindByRowID(aFixedTables[iItem],aRowIDs[iItem])) to bFound
43953>>>>>>>                If (not(bFound)) Begin
43955>>>>>>>                    Function_Return False
43956>>>>>>>                End
43956>>>>>>>>
43956>>>>>>>            End
43956>>>>>>>>
43956>>>>>>>        Loop
43957>>>>>>>>
43957>>>>>>>        Function_Return True
43958>>>>>>>    End_Function
43959>>>>>>>
43959>>>>>>>    Function FixedTablesRestore_Serialized tTableQuery strQuery String[] asRowIDs Returns Boolean
43961>>>>>>>        Integer iItem iMax
43961>>>>>>>        RowID[] ariRowIDs
43962>>>>>>>        Move (SizeOfArray(asRowIDs)-1) to iMax
43963>>>>>>>        For iItem from 0 to iMax
43969>>>>>>>>
43969>>>>>>>            Move (DeserializeRowID(asRowIDs[iItem])) to ariRowIDs[iItem]
43970>>>>>>>        Loop
43971>>>>>>>>
43971>>>>>>>        Function_Return (FixedTablesRestore(Self,strQuery,ariRowIDs))
43972>>>>>>>    End_Function
43973>>>>>>>
43973>>>>>>>    Procedure _PushNoneFixedBuffers tTableQuery strQuery
43975>>>>>>>        Integer iItem iMax iTable
43975>>>>>>>        Integer[] aTables
43976>>>>>>>        Get NotFixedTables strQuery to aTables
43977>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
43978>>>>>>>        For iItem from 0 to iMax
43984>>>>>>>>
43984>>>>>>>            Move aTables[iItem] to iTable
43985>>>>>>>            Send PushRecord of oRecordBufferFunctions iTable
43986>>>>>>>        Loop
43987>>>>>>>>
43987>>>>>>>    End_Procedure
43988>>>>>>>    Procedure _PopNoneFixedBuffers tTableQuery strQuery
43990>>>>>>>        Integer iItem iMax iTable
43990>>>>>>>        Integer[] aTables
43991>>>>>>>        Get NotFixedTables strQuery to aTables
43992>>>>>>>        Move (ReverseArray(aTables)) to aTables
43993>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
43994>>>>>>>        For iItem from 0 to iMax
44000>>>>>>>>
44000>>>>>>>            Move aTables[iItem] to iTable
44001>>>>>>>            Send PopRecord of oRecordBufferFunctions iTable
44002>>>>>>>        Loop
44003>>>>>>>>
44003>>>>>>>    End_Procedure
44004>>>>>>>    
44004>>>>>>>    
44004>>>>>>>    Function TableQueryToString tTableQuery strQuery Returns String
44006>>>>>>>        String sTQ
44006>>>>>>>        Get VariantToString of oStructFunctions strQuery to sTQ
44007>>>>>>>        Function_Return sTQ
44008>>>>>>>    End_Function
44009>>>>>>>    
44009>>>>>>>    Function StringToTableQuery String sTQ Returns tTableQuery
44011>>>>>>>        tTableQuery strQuery
44011>>>>>>>        tTableQuery strQuery
44011>>>>>>>        tValueTree strValueTree
44011>>>>>>>        tValueTree strValueTree
44011>>>>>>>        Get StringToValueTree of oStructFunctions sTQ to strValueTree
44012>>>>>>>        ValueTreeDeserializeParameter strValueTree to strQuery
44013>>>>>>>        Function_Return strQuery
44014>>>>>>>    End_Function
44015>>>>>>>        
44015>>>>>>>    Function TableQuerySerializedForLog tTableQuery strQuery Returns String
44017>>>>>>>        String sTQ
44017>>>>>>>        Get TableQueryToString strQuery to sTQ
44018>>>>>>>        Function_Return ("V1.0,"+sTQ)
44019>>>>>>>    End_Function
44020>>>>>>>        
44020>>>>>>>            Function _NextValueInArray String[] aValues Integer ByRef iPos Returns String
44022>>>>>>>                String sValue
44022>>>>>>>                Move aValues[iPos] to sValue
44023>>>>>>>                Increment iPos
44024>>>>>>>                Function_Return sValue
44025>>>>>>>            End_Function
44026>>>>>>>        
44026>>>>>>>                Function _LogReadValueSource String[] aValues Integer ByRef iPos Returns _tTQValueSource
44028>>>>>>>                    _tTQValueSource strValue
44028>>>>>>>                    _tTQValueSource strValue
44028>>>>>>>                    Integer iItem iMax
44028>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strValue.iTable   
44029>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strValue.iColumn  
44030>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strValue.iType    
44031>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strValue.iLen     
44032>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strValue.iDecimals
44033>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strValue.sConstant
44034>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strValue.sSQLResultSetColumnName
44035>>>>>>>                    Get _NextValueInArray aValues (&iPos) to iMax
44036>>>>>>>                    For iItem from 0 to iMax
44042>>>>>>>>
44042>>>>>>>                        Get _NextValueInArray aValues (&iPos) to strValue.aOrList[iItem]
44043>>>>>>>                    Loop
44044>>>>>>>>
44044>>>>>>>                    Function_Return strValue
44045>>>>>>>                End_Function
44046>>>>>>>
44046>>>>>>>            Function _LogReadFilter String[] aValues Integer ByRef iPos Returns tTQFilterSegment
44048>>>>>>>                tTQFilterSegment strFilter
44048>>>>>>>                tTQFilterSegment strFilter
44048>>>>>>>                Get _LogReadValueSource aValues (&iPos) to strFilter.strLeftValue
44049>>>>>>>                Get _NextValueInArray aValues (&iPos) to strFilter.iComp
44050>>>>>>>                Get _LogReadValueSource aValues (&iPos) to strFilter.strRightValue
44051>>>>>>>            End_Function
44052>>>>>>>            
44052>>>>>>>            Function _LogReadOrderingSegment String[] aValues Integer ByRef iPos Returns tTQOrderBySegment
44054>>>>>>>                tTQOrderBySegment strSegment
44054>>>>>>>                tTQOrderBySegment strSegment
44054>>>>>>>                Get _NextValueInArray aValues (&iPos) to strSegment.bDescending
44055>>>>>>>                Get _NextValueInArray aValues (&iPos) to strSegment.bUppercase
44056>>>>>>>                Get _LogReadValueSource aValues (&iPos) to strSegment.strValueSource
44057>>>>>>>            End_Function
44058>>>>>>>        
44058>>>>>>>        Function TableQueryDeserializedFromLog String sValue Returns tTableQuery
44060>>>>>>>            Integer iPos iItem iMax
44060>>>>>>>            tTableQuery strQuery 
44060>>>>>>>            tTableQuery strQuery 
44060>>>>>>>            tTQFilterSegment strFilter
44060>>>>>>>            tTQFilterSegment strFilter
44060>>>>>>>            tTQOrderBySegment strSegment
44060>>>>>>>            tTQOrderBySegment strSegment
44060>>>>>>>            String[] aValues
44061>>>>>>>            Send SplitString of oStringFunctions sValue (Character(10)) False False (&aValues)
44062>>>>>>>            If (SizeOfArray(aValues)>1) Begin
44064>>>>>>>                Move 1 to iPos
44065>>>>>>>                If (aValues[0]="V1.0") Begin
44067>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strQuery.iTable
44068>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strQuery.bNoESQL
44069>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strQuery.bForcePrefetch
44070>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strQuery.iForceIndex   
44071>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strQuery.iLimit        
44072>>>>>>>                    // Filters:
44072>>>>>>>                    Get _NextValueInArray aValues (&iPos) to iMax
44073>>>>>>>                    For iItem from 0 to iMax
44079>>>>>>>>
44079>>>>>>>                        Get _LogReadFilter aValues (&iPos) to strFilter
44080>>>>>>>                        Move strFilter to strQuery.aFilters[iItem]    
44081>>>>>>>                    Loop
44082>>>>>>>>
44082>>>>>>>                    // Ordering:
44082>>>>>>>                    Get _NextValueInArray aValues (&iPos) to iMax
44083>>>>>>>                    For iItem from 0 to iMax
44089>>>>>>>>
44089>>>>>>>                        Get _LogReadOrderingSegment aValues (&iPos) to strSegment
44090>>>>>>>                        Move strSegment to strQuery.aOrdering[iItem]    
44091>>>>>>>                    Loop
44092>>>>>>>>
44092>>>>>>>                End
44092>>>>>>>>
44092>>>>>>>            End
44092>>>>>>>>
44092>>>>>>>            Function_Return strQuery
44093>>>>>>>        End_Function
44094>>>>>>>
44094>>>>>>>    Procedure OnLogStatus tTableQuery strQuery
44096>>>>>>>        Boolean bVal
44096>>>>>>>        Integer iLogTable iSize iValue
44096>>>>>>>        String sModule sValue
44096>>>>>>>        Get LogTableHandle strQuery to iLogTable
44097>>>>>>>        If (iLogTable>0) Begin
44099>>>>>>>            Clear iLogTable
44100>>>>>>>
44100>>>>>>>            Get SystemTimeToString23 of oDateFunctions (SystemTimeMilliSeconds(oDateFunctions)) to sValue
44101>>>>>>>            Set_Field_Value iLogTable 1 to sValue
44104>>>>>>>            Set_Field_Value iLogTable 3 to strQuery._strControlBlock.sLogTag
44107>>>>>>>            Get TableQueryUser to sValue
44108>>>>>>>            Set_Field_Value iLogTable 4 to sValue  // (TableQueryUser(Self))
44111>>>>>>>            Get Module_Name to sModule
44112>>>>>>>            Set_Field_Value iLogTable 5 to sModule
44115>>>>>>>            Get ModuleStartTime of oDateFunctions to sValue
44116>>>>>>>            Set_Field_Value iLogTable 6 to sValue
44119>>>>>>>            Move (SizeOfArray(strQuery._strCompiled.aJumpInValues)=0 and SizeOfArray(strQuery._strCompiled.aJumpOutValues)=0 and strQuery.iLimit=0) to bVal
44120>>>>>>>            Set_Field_Value iLogTable 7 to bVal // Full table scan
44123>>>>>>>            Set_Field_Value iLogTable 8 to strQuery._strControlBlock.iFindCount
44126>>>>>>>            Set_Field_Value iLogTable 9 to strQuery._strControlBlock.iSelectCount
44129>>>>>>>            Move (SizeOfArray(strQuery._strCompiled.aOtherConditions)) to iSize
44130>>>>>>>            Set_Field_Value iLogTable 10 to iSize // Unused filters
44133>>>>>>>            Set_Field_Value iLogTable 11 to strQuery._strCompiled.iIndex
44136>>>>>>>            Move (strQuery.iForceIndex<>-1) to iValue
44137>>>>>>>            Set_Field_Value iLogTable 12 to iValue
44140>>>>>>>            Set_Field_Value iLogTable 13 to strQuery.bForcePrefetch
44143>>>>>>>            Set_Field_Value iLogTable 14 to strQuery.iLimit
44146>>>>>>>            Set_Field_Value iLogTable 15 to (not(strQuery._strControlBlock.bBreakScan))
44149>>>>>>>            Get TableQuerySerializedForLog strQuery to sValue
44150>>>>>>>            Set_Field_Value iLogTable 16 to sValue
44153>>>>>>>            
44153>>>>>>>            SaveRecord iLogTable
44154>>>>>>>        End
44154>>>>>>>>
44154>>>>>>>    End_Procedure
44155>>>>>>>        
44155>>>>>>>    Procedure OnComplete tTableQuery strQuery
44157>>>>>>>    End_Procedure
44158>>>>>>>    
44158>>>>>>>        Procedure _RelateMainRecord tTableQuery ByRef strQuery
44160>>>>>>>            Integer iItem iItemMax
44160>>>>>>>            Move (SizeOfArray(strQuery.aColumnSources)-1) to iItemMax
44161>>>>>>>            For iItem from 0 to iItemMax
44167>>>>>>>>
44167>>>>>>>                Send _RelateToTable (&strQuery) strQuery.aColumnSources[iItem].iTable
44168>>>>>>>            Loop
44169>>>>>>>>
44169>>>>>>>        End_Procedure
44170>>>>>>>
44170>>>>>>>    Function FindRecord tTableQuery ByRef strQuery Returns Boolean
44172>>>>>>>        Boolean bFound bInitialize
44172>>>>>>>
44172>>>>>>>        Move False to bInitialize
44173>>>>>>>
44173>>>>>>>        If (strQuery._strControlBlock.bCompiled) Begin
44175>>>>>>>            If (not(strQuery._strControlBlock.bInitialized)) Begin
44177>>>>>>>                Move True to bInitialize // Initialize!
44178>>>>>>>            End
44178>>>>>>>>
44178>>>>>>>        End
44178>>>>>>>>
44178>>>>>>>        Else Begin
44179>>>>>>>            Get _CompileQuery (&strQuery) to bInitialize // If it compiles we will initialize it
44180>>>>>>>        End
44180>>>>>>>>
44180>>>>>>>
44180>>>>>>>        If (bInitialize) Begin
44182>>>>>>>            If (_InitializeQuery(Self,&strQuery)) Begin
44184>>>>>>>                Move True to strQuery._strControlBlock.bInitialized
44185>>>>>>>                Get _FindFirstRecord (&strQuery) to bFound
44186>>>>>>>            End
44186>>>>>>>>
44186>>>>>>>            Else Begin
44187>>>>>>>                Move False to bFound
44188>>>>>>>            End
44188>>>>>>>>
44188>>>>>>>            Move True to strQuery._strControlBlock.bFirstRecord
44189>>>>>>>        End
44189>>>>>>>>
44189>>>>>>>        Else Begin
44190>>>>>>>            // This is the mechanism that enforces iLimit. However, if the record set is pre-fetched
44190>>>>>>>            // this has already been taken care of.
44190>>>>>>>            if (strQuery._strCompiled._iLimit<>0) Begin
44192>>>>>>>                If (not(strQuery._strCompiled.bPrefetch) and ;                    strQuery._strControlBlock.iSelectCount>=strQuery._strCompiled._iLimit) Begin
44194>>>>>>>                    Move True to strQuery._strControlBlock.bBreakScan
44195>>>>>>>                End
44195>>>>>>>>
44195>>>>>>>            End
44195>>>>>>>>
44195>>>>>>>
44195>>>>>>>            Get _FindNextRecord (&strQuery) to bFound
44196>>>>>>>            Move False to strQuery._strControlBlock.bFirstRecord
44197>>>>>>>        End
44197>>>>>>>>
44197>>>>>>>
44197>>>>>>>        If (bFound) Begin
44199>>>>>>>            If (strQuery._strControlBlock.iQueryMethod=tqDATAFLEX) Begin
44201>>>>>>>                // If we are in embedded mode we must find all parent related records specified by the aSelectedColumns member.
44201>>>>>>>                Send _RelateMainRecord (&strQuery)
44202>>>>>>>            End
44202>>>>>>>>
44202>>>>>>>            Else Begin
44203>>>>>>>                // If we are in ESQL mode we expect the fetch-record mechnism to have already done this
44203>>>>>>>            End
44203>>>>>>>>
44203>>>>>>>        End
44203>>>>>>>>
44203>>>>>>>        Else Begin
44204>>>>>>>            If (not(strQuery.bForcePrefetch)) Begin
44206>>>>>>>                Send PurgeResultSet (&strQuery) // if we didn't ask for it we'll get rid of it here (if it's there at all)
44207>>>>>>>            End
44207>>>>>>>>
44207>>>>>>>            If (_giTQLogState=2 or ( _giTQLogState=1 and strQuery._strControlBlock.sLogTag<>"")) Begin
44209>>>>>>>                Send OnLogStatus strQuery
44210>>>>>>>            End
44210>>>>>>>>
44210>>>>>>>            Send _DeinitializeQuery (&strQuery) // Get rid of SQL handles (if emploid)
44211>>>>>>>            Send OnComplete strQuery
44212>>>>>>>            If (strQuery.bRestoreRecordBuffersOnQueryCompletion) Begin
44214>>>>>>>                Send _PopNoneFixedBuffers strQuery // restore buffers of tables that were possibly changed by the query
44215>>>>>>>            End
44215>>>>>>>>
44215>>>>>>>            // This is where we _*ALWAYS*_ exit the FindRecord loop
44215>>>>>>>        End
44215>>>>>>>>
44215>>>>>>>
44215>>>>>>>        Function_Return bFound
44216>>>>>>>    End_Function
44217>>>>>>>
44217>>>>>>>    Function IsFirstRecord tTableQuery strQuery Returns Boolean
44219>>>>>>>        Function_Return strQuery._strControlBlock.bFirstRecord
44220>>>>>>>    End_Function
44221>>>>>>>    
44221>>>>>>>    //> Returns the current row number of the result set.
44221>>>>>>>    Function ResultRowNumber tTableQuery strQuery Returns Integer
44223>>>>>>>        If (strQuery._strCompiled.bPrefetch) Begin
44225>>>>>>>            Function_Return (strQuery.strResultSet._iCurrentRowPointer+1)
44226>>>>>>>        End
44226>>>>>>>>
44226>>>>>>>        Function_Return strQuery._strControlBlock.iFindCount
44227>>>>>>>    End_Function
44228>>>>>>>
44228>>>>>>>    Function HasData tTableQuery strQuery Returns Boolean
44230>>>>>>>        Boolean bHasData
44230>>>>>>>        tTQOrderBySegment[] aEmpty
44230>>>>>>>        tTQOrderBySegment[] aEmpty
44231>>>>>>>        If (strQuery._strControlBlock.bInitialized) Begin
44233>>>>>>>            // If the query has already been initialized the function will return whether or 
44233>>>>>>>            // not any records have been selected yet (this would only ever be relevant to a
44233>>>>>>>            // person subclassing the cTableQuery class). More relevant is the fact that this
44233>>>>>>>            // means that you can query HasData after loop completion and get to know if the 
44233>>>>>>>            // loop was ever executed.
44233>>>>>>>            Function_Return (strQuery._strControlBlock.iSelectCount<>0)
44234>>>>>>>        End
44234>>>>>>>>
44234>>>>>>>        Else Begin
44235>>>>>>>            // If the loop hasn't yet been initialized we will produce the simplest
44235>>>>>>>            // possible query to find out if the loop will have any data.
44235>>>>>>>            Move False to strQuery.bForcePrefetch // Prefetch would be stupid
44236>>>>>>>            Move aEmpty to strQuery.aOrdering // Do not dictate the ordering
44237>>>>>>>            Move 1 to strQuery.iLimit // This will prevent the complete set being built.
44238>>>>>>>            Move -1 to strQuery.iForceIndex // Do not force any particular index
44239>>>>>>>            
44239>>>>>>>            // Dilemma! If there are no non-optimizable filters then it's faster to not use
44239>>>>>>>            //          ESQL. But then I have to compile the query before executing the loop.
44239>>>>>>>            //          I just haven't gotten around to that yet.
44239>>>>>>>            // Move True to strQuery.bNoESQL // (do not use ESQL)
44239>>>>>>>            
44239>>>>>>>            Move False to bHasData
44240>>>>>>>            While (FindRecord(Self,&strQuery))
44244>>>>>>>                Move True to bHasData
44245>>>>>>>            Loop
44246>>>>>>>>
44246>>>>>>>        End
44246>>>>>>>>
44246>>>>>>>        Function_Return bHasData
44247>>>>>>>    End_Function
44248>>>>>>>    
44248>>>>>>>    Function QueryToRowIdArray tTableQuery ByRef strQuery Returns RowID[]
44250>>>>>>>        Integer iTable iCount
44250>>>>>>>        RowID[] aRecords
44251>>>>>>>        Move strQuery.iTable to iTable
44252>>>>>>>        Move 0 to iCount
44253>>>>>>>        While (FindRecord(Self,&strQuery))
44257>>>>>>>            Move (GetRowID(iTable)) to aRecords[iCount]
44258>>>>>>>            Increment iCount
44259>>>>>>>        Loop
44260>>>>>>>>
44260>>>>>>>        Function_Return aRecords    
44261>>>>>>>    End_Function
44262>>>>>>>    
44262>>>>>>>    Function DeleteRecords tTableQuery strQuery Returns Boolean
44264>>>>>>>        Integer iTable
44264>>>>>>>        String sStatement
44264>>>>>>>        tSQLStatementHandle strStatement
44264>>>>>>>        tSQLStatementHandle strStatement
44264>>>>>>>        
44264>>>>>>>        If (strQuery.iLimit<>0) Begin
44266>>>>>>>            Send OnError 742 "Limit not allowed on delete statement"
44267>>>>>>>        End
44267>>>>>>>>
44267>>>>>>>        Else Begin
44268>>>>>>>
44268>>>>>>>            Send ResetOrdering (&strQuery)               // Ordering irrelevant!
44269>>>>>>>            Send ResetResultSetColumns (&strQuery)       // Resultset irrelevant!
44270>>>>>>>            
44270>>>>>>>            If (_QueryMethodSQL(Self,strQuery)) Begin // ESQL
44272>>>>>>>
44272>>>>>>>                If (OpenStatementOnTable(oSQLStatementHandles,strQuery.iTable,&strStatement)) Begin
44274>>>>>>>
44274>>>>>>>                    Move strStatement to strQuery._strControlBlock.strSQLStatementHandle // Is used during the generating of the SQL statement.
44275>>>>>>>
44275>>>>>>>                    Send _TableRelateStatesReset (&strQuery)
44276>>>>>>>                    Get SQLDeleteStatement strQuery Self to sStatement
44277>>>>>>>                    Move (ToANSI(sStatement)) to sStatement
44278>>>>>>>                    If (sStatement<>"") Begin
44280>>>>>>>                        Send SQLExecDirect of strStatement.hHandle sStatement
44281>>>>>>>                    End
44281>>>>>>>>
44281>>>>>>>                    Send CloseStatement of oSQLStatementHandles strStatement
44282>>>>>>>                    
44282>>>>>>>                End
44282>>>>>>>>
44282>>>>>>>            End
44282>>>>>>>>
44282>>>>>>>            Else Begin
44283>>>>>>>                Move strQuery.iTable to iTable
44284>>>>>>>                While (FindRecord(Self,&strQuery))
44288>>>>>>>                    Delete iTable
44289>>>>>>>                Loop
44290>>>>>>>>
44290>>>>>>>            End
44290>>>>>>>>
44290>>>>>>>        End
44290>>>>>>>>
44290>>>>>>>        Function_Return False
44291>>>>>>>    End_Function
44292>>>>>>>
44292>>>>>>>
44292>>>>>>>        Function _TableRootNameStripDriver String sRootName Returns String
44294>>>>>>>            Integer iPos
44294>>>>>>>            Move (Pos(":",sRootName)) to iPos
44295>>>>>>>            If (iPos>2) Begin
44297>>>>>>>                Move (Remove(sRootName,1,iPos)) to sRootName
44298>>>>>>>            End
44298>>>>>>>>
44298>>>>>>>            Function_Return sRootName
44299>>>>>>>        End_Function
44300>>>>>>>
44300>>>>>>>        Function _TableAnalysisFileName Integer iTable Returns String
44302>>>>>>>            String sFolder sTableName
44302>>>>>>>            Get VdfFolderPath of oFileFunctions VDF_FILELIST to sFolder
44303>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of iTable to sTableName
44306>>>>>>>            Get _TableRootNameStripDriver sTableName to sTableName
44307>>>>>>>            Get PathStripType of oFileFunctions sTableName to sTableName
44308>>>>>>>            Get AppendPath of oFileFunctions sFolder (sTableName+".tq") to sTableName
44309>>>>>>>            Function_Return sTableName
44310>>>>>>>        End_Function
44311>>>>>>>
44311>>>>>>>            Function _TableAnalysisReadIndex Integer iChannel Returns _tTQIndexAnalysis
44313>>>>>>>                Integer iItem iMax
44313>>>>>>>                _tTQIndexAnalysis strIndexA
44313>>>>>>>                _tTQIndexAnalysis strIndexA
44313>>>>>>>                Readln iMax
44314>>>>>>>                For iItem from 0 to iMax
44320>>>>>>>>
44320>>>>>>>                    Get Readln of oFileFunctions iChannel to strIndexA.aSegmentReductions[iItem]
44321>>>>>>>                Loop
44322>>>>>>>>
44322>>>>>>>                Function_Return strIndexA
44323>>>>>>>            End_Function
44324>>>>>>>        
44324>>>>>>>        Function TableAnalysisRead Integer iTable tTQTableAnalysis ByRef strA Returns Boolean
44326>>>>>>>            Integer iChannel iItem iMax
44326>>>>>>>            String sFile
44326>>>>>>>            tTQTableAnalysis strEmpty
44326>>>>>>>            tTQTableAnalysis strEmpty
44326>>>>>>>            Move strEmpty to strA
44327>>>>>>>            Get _TableAnalysisFileName iTable to sFile
44328>>>>>>>            Get DirectInput of oFileFunctions sFile to iChannel
44329>>>>>>>            If (iChannel>=0) Begin
44331>>>>>>>                If (Readln(oFileFunctions,iChannel)="VER 1.0") Begin
44333>>>>>>>                    Get StringToDateTime of oDateFunctions (Readln(oFileFunctions,iChannel)) DF_DATE_MILITARY to strA.dtAnalysisDateTime
44334>>>>>>>                    Readln channel iChannel strA.nNumberOfRecords
44336>>>>>>>                    Readln strA.sTimeToComplete
44337>>>>>>>                    Readln iMax
44338>>>>>>>                    For iItem from 0 to iMax
44344>>>>>>>>
44344>>>>>>>                        Get _TableAnalysisReadIndex iChannel to strA.aIndices[iItem]
44345>>>>>>>                    Loop
44346>>>>>>>>
44346>>>>>>>                    Send CloseInput of oFileFunctions iChannel
44347>>>>>>>                    Function_Return True
44348>>>>>>>                End
44348>>>>>>>>
44348>>>>>>>                Else Begin
44349>>>>>>>                    Send OnError 737 ("TQ cache file not recognized ("+sFile+")")
44350>>>>>>>                End
44350>>>>>>>>
44350>>>>>>>                Send CloseInput of oFileFunctions iChannel
44351>>>>>>>            End
44351>>>>>>>>
44351>>>>>>>            Function_Return False
44352>>>>>>>        End_Function
44353>>>>>>>        
44353>>>>>>>        Procedure _TableAnalysisSaveIndex Integer iChannel _tTQIndexAnalysis strIndexA
44355>>>>>>>            Integer iMax iItem
44355>>>>>>>            Move (SizeOfArray(strIndexA.aSegmentReductions)-1) to iMax
44356>>>>>>>            Writeln channel iChannel iMax
44359>>>>>>>            For iItem from 0 to iMax
44365>>>>>>>>
44365>>>>>>>                Writeln strIndexA.aSegmentReductions[iItem]
44367>>>>>>>            Loop
44368>>>>>>>>
44368>>>>>>>        End_Procedure
44369>>>>>>>        
44369>>>>>>>    Function TableAnalysisSave Integer iTable tTQTableAnalysis strA Returns Boolean
44371>>>>>>>        Integer iChannel iItem iMax
44371>>>>>>>        String sFile
44371>>>>>>>        Get _TableAnalysisFileName iTable to sFile
44372>>>>>>>        Get DirectOutput of oFileFunctions sFile to iChannel
44373>>>>>>>        If (iChannel>=0) Begin
44375>>>>>>>            Writeln channel iChannel "VER 1.0"
44378>>>>>>>            Writeln (DateTimeToString(oDateFunctions,strA.dtAnalysisDateTime,DF_DATE_MILITARY,True,"-"))
44380>>>>>>>            Writeln strA.nNumberOfRecords
44382>>>>>>>            Writeln strA.sTimeToComplete
44384>>>>>>>            Move (SizeOfArray(strA.aIndices)-1) to iMax
44385>>>>>>>            Writeln iMax
44387>>>>>>>            For iItem from 0 to iMax
44393>>>>>>>>
44393>>>>>>>                Send _TableAnalysisSaveIndex iChannel strA.aIndices[iItem]
44394>>>>>>>            Loop
44395>>>>>>>>
44395>>>>>>>            Send CloseOutput of oFileFunctions iChannel
44396>>>>>>>            Function_Return True
44397>>>>>>>        End
44397>>>>>>>>
44397>>>>>>>        Function_Return False
44398>>>>>>>    End_Function
44399>>>>>>>    
44399>>>>>>>        Function _TableAnalysisDefault Integer iTable Returns tTQTableAnalysis
44401>>>>>>>            Integer iIndex iItem iMax 
44401>>>>>>>            Integer iSegment iSegments
44401>>>>>>>            Integer[] aIndices
44402>>>>>>>            Number nRecordCount nFactor
44402>>>>>>>            tocIndex strIndex
44402>>>>>>>            tocIndex strIndex
44402>>>>>>>            tTQTableAnalysis strA
44402>>>>>>>            tTQTableAnalysis strA
44402>>>>>>>
44402>>>>>>>            Get IndexSet of oIndexFunctions iTable 3 to aIndices // 3 means all online indices
44403>>>>>>>            Get_Attribute DF_FILE_RECORDS_USED of iTable 0 0 to nRecordCount
44406>>>>>>>            
44406>>>>>>>            Move (SizeOfArray(aIndices)-1) to iMax
44407>>>>>>>            For iItem from 0 to iMax
44413>>>>>>>>
44413>>>>>>>                Move aIndices[iItem] to iIndex
44414>>>>>>>                Get IndexDefinition of oOverlapColumnFunctions iTable iIndex to strIndex
44415>>>>>>>                Move (SizeOfArray(strIndex.aSegments)) to iSegments
44416>>>>>>>                
44416>>>>>>>                Move (nRecordCount^(1.0/iSegments)) to nFactor
44417>>>>>>>                Move (1.0/nFactor) to nFactor
44418>>>>>>>                
44418>>>>>>>                Decrement iSegments
44419>>>>>>>                For iSegment from 0 to iSegments
44425>>>>>>>>
44425>>>>>>>                    Move nFactor to strA.aIndices[iIndex].aSegmentReductions[iSegment]
44426>>>>>>>                Loop
44427>>>>>>>>
44427>>>>>>>            Loop
44428>>>>>>>>
44428>>>>>>>            Function_Return strA 
44429>>>>>>>        End_Function
44430>>>>>>>    
44430>>>>>>>    //> The TableAnalysis returns a struct that contains information that helps the index analyzer
44430>>>>>>>    //> to make informed guesses about which index seeds the best. VDFxray can be used to generate
44430>>>>>>>    //> a small text file for each table with this information. If this is the case then function
44430>>>>>>>    //> TableAnalysis will read that file and return the by now much mentioned information. And if not 
44430>>>>>>>    //> the best possible guess is calculated and returned. Actually, in addition to being returned
44430>>>>>>>    //> by the function it is also copied to a global cache so subsequent calls will take no time. 
44430>>>>>>>    Function TableAnalysis Integer iTable Returns tTQTableAnalysis
44432>>>>>>>        tTQTableAnalysis strA
44432>>>>>>>        tTQTableAnalysis strA
44432>>>>>>>        
44432>>>>>>>        Move False to strA.bInitialized
44433>>>>>>>        If (SizeOfArray(_gTQaTableAnalysis)>iTable and _gTQaTableAnalysis[iTable].bInitialized) Begin
44435>>>>>>>            Move _gTQaTableAnalysis[iTable] to strA
44436>>>>>>>        End
44436>>>>>>>>
44436>>>>>>>        Else Begin
44437>>>>>>>            If (not(TableAnalysisRead(Self,iTable,&strA))) Begin
44439>>>>>>>                Get _TableAnalysisDefault iTable to strA // Calculate one    
44440>>>>>>>            End
44440>>>>>>>>
44440>>>>>>>            Move True to strA.bInitialized
44441>>>>>>>            Move strA to _gTQaTableAnalysis[iTable]
44442>>>>>>>        End
44442>>>>>>>>
44442>>>>>>>        Function_Return strA
44443>>>>>>>    End_Function
44444>>>>>>>    
44444>>>>>>>    //> Information about configuration of indices for a table. A caching mechanism makes sure that
44444>>>>>>>    //> this configuration is not read on subsequent calls to the function.
44444>>>>>>>    Function TableMeta Integer iTable Returns tTQTableMeta
44446>>>>>>>        tTQTableMeta strM
44446>>>>>>>        tTQTableMeta strM
44446>>>>>>>        Move 0 to strM._iIsInitialized
44447>>>>>>>                                                
44447>>>>>>>        If (SizeOfArray(_gTQaTableMeta)>iTable and _gTQaTableMeta[iTable]._iIsInitialized<>0) Begin
44449>>>>>>>            Move _gTQaTableMeta[iTable] to strM
44450>>>>>>>        End
44450>>>>>>>>
44450>>>>>>>        Else Begin
44451>>>>>>>            Get IndexSet of oIndexFunctions iTable 3 to strM.aIndices // 3 means all on-line indices
44452>>>>>>>            Move 1 to strM._iIsInitialized
44453>>>>>>>            Move strM to _gTQaTableMeta[iTable]
44454>>>>>>>        End
44454>>>>>>>>
44454>>>>>>>        
44454>>>>>>>        Function_Return strM
44455>>>>>>>    End_Function
44456>>>>>>>    
44456>>>>>>>    Function TableIndices Integer iTable Returns Integer[]
44458>>>>>>>        tTQTableMeta strM
44458>>>>>>>        tTQTableMeta strM
44458>>>>>>>        Get TableMeta iTable to strM
44459>>>>>>>        Function_Return strM.aIndices
44460>>>>>>>    End_Function
44461>>>>>>>
44461>>>>>>>    //> This majesticly named procedure clears all cached values and closes
44461>>>>>>>    //> any log tables that might have been opened.
44461>>>>>>>    Procedure ClearTableQueryMetaDataGlobalArraysAndCloseLogFiles
44463>>>>>>>        Integer iItem iMax iLogTable
44463>>>>>>>        Move (SizeOfArray(_gaTQLogTables)-1) to iMax
44464>>>>>>>        For iItem from 0 to iMax
44470>>>>>>>>
44470>>>>>>>            Move _gaTQLogTables[iItem] to iLogTable
44471>>>>>>>            If (iLogTable>0) Begin
44473>>>>>>>                Send CloseTable of oTableAccessFunctions iLogTable
44474>>>>>>>            End
44474>>>>>>>>
44474>>>>>>>        Loop
44475>>>>>>>>
44475>>>>>>>        Move (ResizeArray(_gTQaTableMeta,0)) to _gTQaTableMeta
44476>>>>>>>        Move (ResizeArray(_gTQaTableAnalysis,0)) to _gTQaTableAnalysis
44477>>>>>>>        Move (ResizeArray(_gaTQLogTables,0)) to _gaTQLogTables
44478>>>>>>>    End_Procedure
44479>>>>>>>
44479>>>>>>>End_Class // cTableQueryFunctions
44480>>>>>>>
44480>>>>>>>
44480>>>>>>>Global_Variable Integer oTQ // Holder of the global singleton object.
44480>>>>>>>
44480>>>>>>>Object _oTQ is a cTableQueryFunctions
44482>>>>>>>    Move Self to oTQ
44483>>>>>>>    // Is called by VDFXray when new WS is selected (TableQuery.pkg is used by VDFXray)
44483>>>>>>>    Procedure OnNewFilelistSelected
44486>>>>>>>        Send ClearTableQueryMetaDataGlobalArraysAndCloseLogFiles  
44487>>>>>>>    End_Procedure
44488>>>>>>>End_Object
44489>>>>>>>
44489>>>>>>>
44489>>>>>>>Class cTableQueryAnalyzer is a cObject
44490>>>>>>>        Function _BreakLevel String[] aNewValues String[] aOldValues Returns Integer
44492>>>>>>>            Integer iMax iItem
44492>>>>>>>            Move (SizeOfArray(aNewValues)-1) to iMax
44493>>>>>>>            For iItem from 0 to iMax
44499>>>>>>>>
44499>>>>>>>                If (aNewValues[iItem]<>aOldValues[iItem]) Begin
44501>>>>>>>                    Function_Return iItem
44502>>>>>>>                End
44502>>>>>>>>
44502>>>>>>>            Loop
44503>>>>>>>>
44503>>>>>>>            Function_Return -1 // no break
44504>>>>>>>        End_Function
44505>>>>>>>
44505>>>>>>>        Procedure _IncrementBreakCounter Integer[] ByRef aBreakCounters Integer iLevel
44507>>>>>>>            Integer iMax iItem
44507>>>>>>>            If (iLevel>=0) Begin
44509>>>>>>>                Move (SizeOfArray(aBreakCounters)-1) to iMax
44510>>>>>>>                For iItem from 0 to iMax
44516>>>>>>>>
44516>>>>>>>                    If (iItem>=iLevel) Begin
44518>>>>>>>                        Move (aBreakCounters[iItem]+1) to aBreakCounters[iItem]
44519>>>>>>>                    End
44519>>>>>>>>
44519>>>>>>>                Loop
44520>>>>>>>>
44520>>>>>>>            End
44520>>>>>>>>
44520>>>>>>>        End_Procedure
44521>>>>>>>
44521>>>>>>>        Procedure _AnalyseTableIndexAux _tTQIndexAnalysis ByRef strIndexA Integer iTable Integer iIndex Integer[] aBreakCounters
44523>>>>>>>            Integer iMax iItem
44523>>>>>>>            Number nFactor
44523>>>>>>>            Move (ResizeArray(strIndexA.aSegmentReductions,0)) to strIndexA.aSegmentReductions
44524>>>>>>>            Move (SizeOfArray(aBreakCounters)-1) to iMax
44525>>>>>>>            For iItem from 0 to iMax
44531>>>>>>>>
44531>>>>>>>                If (iItem=0) Begin
44533>>>>>>>                    Move (1.0/aBreakCounters[iItem]) to nFactor
44534>>>>>>>                End
44534>>>>>>>>
44534>>>>>>>                Else Begin // 211 644 2200 11331 => 1/211, 211/644, 644/2200, 2200/11331
44535>>>>>>>                    Move (Number(aBreakCounters[iItem-1])/aBreakCounters[iItem]) to nFactor
44536>>>>>>>                End
44536>>>>>>>>
44536>>>>>>>                Move nFactor to strIndexA.aSegmentReductions[iItem]
44537>>>>>>>            Loop
44538>>>>>>>>
44538>>>>>>>        End_Procedure
44539>>>>>>>    
44539>>>>>>>    Procedure _AnalyseTableIndex _tTQIndexAnalysis ByRef strIndexA Integer iTable Integer iIndex
44541>>>>>>>        Integer iCount iLevel iMax
44541>>>>>>>        String[] aNewValues aOldValues
44543>>>>>>>        Integer[] aBreakCounters
44544>>>>>>>        tocIndex strIndex
44544>>>>>>>        tocIndex strIndex
44544>>>>>>>        _tTQIndexAnalysis strEmpty
44544>>>>>>>        _tTQIndexAnalysis strEmpty
44544>>>>>>>        tTableQuery strQ
44544>>>>>>>        tTableQuery strQ
44544>>>>>>>        
44544>>>>>>>        Get IndexDefinition of oOverlapColumnFunctions iTable iIndex to strIndex
44545>>>>>>>        
44545>>>>>>>        Move 0 to iCount
44546>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of iTable to iMax
44549>>>>>>>
44549>>>>>>>        Get NewQuery of oTQ iTable to strQ
44550>>>>>>>        Send SetOrderByToIndex of oTQ (&strQ) iIndex
44551>>>>>>>        
44551>>>>>>>        While (FindRecord(oTQ,&strQ))
44555>>>>>>>            Increment iCount
44556>>>>>>>            
44556>>>>>>>            Get IndexSegmentValueArray of oIndexFunctions iTable iIndex to aNewValues
44557>>>>>>>            If (iCount=1) Begin
44559>>>>>>>                Move (ResizeArray(aBreakCounters,SizeOfArray(aNewValues))) to aBreakCounters
44560>>>>>>>                Move aNewValues to aOldValues // No break on the first one
44561>>>>>>>            End
44561>>>>>>>>
44561>>>>>>>
44561>>>>>>>            If (((iCount/5000)*5000)=iCount) Begin
44563>>>>>>>                Send OnAnalyseIndexProgress iTable iCount iMax
44564>>>>>>>            End
44564>>>>>>>>
44564>>>>>>>
44564>>>>>>>            Get _BreakLevel aNewValues aOldValues to iLevel
44565>>>>>>>            If (iLevel>=0) Begin
44567>>>>>>>                Send _IncrementBreakCounter (&aBreakCounters) iLevel
44568>>>>>>>            End
44568>>>>>>>>
44568>>>>>>>
44568>>>>>>>            Move aNewValues to aOldValues
44569>>>>>>>        Loop
44570>>>>>>>>
44570>>>>>>>
44570>>>>>>>        Send OnAnalyseIndexProgress iTable iCount iCount
44571>>>>>>>
44571>>>>>>>        If (iCount<>0) Begin
44573>>>>>>>            Send _IncrementBreakCounter (&aBreakCounters) 0
44574>>>>>>>        End
44574>>>>>>>>
44574>>>>>>>
44574>>>>>>>        Move strEmpty to strIndexA
44575>>>>>>>        Send _AnalyseTableIndexAux (&strIndexA) iTable iIndex aBreakCounters
44576>>>>>>>    End_Procedure
44577>>>>>>>
44577>>>>>>>    Procedure OnAnalyseTableIndex Integer iTable Integer iIndex Integer iIndexIndex Integer IndexCount
44579>>>>>>>    End_Procedure
44580>>>>>>>
44580>>>>>>>    Procedure OnAnalyseTable Integer iTable Integer iIndexCount
44582>>>>>>>    End_Procedure
44583>>>>>>>
44583>>>>>>>    Procedure OnAnalyseIndexProgress Integer iTable Integer iCount Integer iMax
44585>>>>>>>    End_Procedure
44586>>>>>>>
44586>>>>>>>    Procedure AnalyzeTable tTQTableAnalysis ByRef strTableA Integer iTable
44588>>>>>>>        Integer iItem iMax iIndex
44588>>>>>>>        Integer[] aIndices
44589>>>>>>>        Number nElapsed nRecords
44589>>>>>>>        tSystemTimeMS strStart strStop
44589>>>>>>>        tSystemTimeMS strStart strStop
44589>>>>>>>        tTQTableAnalysis strEmptyTable
44589>>>>>>>        tTQTableAnalysis strEmptyTable
44589>>>>>>>        _tTQIndexAnalysis strIndexA
44589>>>>>>>        _tTQIndexAnalysis strIndexA
44589>>>>>>>        Move strEmptyTable to strTableA
44590>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of iTable to nRecords
44593>>>>>>>
44593>>>>>>>        If (nRecords>100) Begin
44595>>>>>>>            Get SystemTimeMilliSeconds of oDateFunctions to strStart
44596>>>>>>>
44596>>>>>>>            Get_Attribute DF_FILE_RECORDS_USED of iTable to strTableA.nNumberOfRecords
44599>>>>>>>            Get IndexSet of oIndexFunctions iTable 3 to aIndices // All on-line indices
44600>>>>>>>            Move (SizeOfArray(aIndices)-1) to iMax
44601>>>>>>>
44601>>>>>>>            Send OnAnalyseTable iTable (iMax+1)
44602>>>>>>>
44602>>>>>>>            For iItem from 0 to iMax
44608>>>>>>>>
44608>>>>>>>                Move aIndices[iItem] to iIndex
44609>>>>>>>                Send OnAnalyseTableIndex iTable iIndex iItem (iMax+1)
44610>>>>>>>                Send _AnalyseTableIndex (&strIndexA) iTable iIndex
44611>>>>>>>                Move strIndexA to strTableA.aIndices[iIndex]
44612>>>>>>>            Loop
44613>>>>>>>>
44613>>>>>>>            Send OnAnalyseTableIndex iTable iIndex (iMax+1) (iMax+1)
44614>>>>>>>            Get SystemTimeMilliSeconds of oDateFunctions to strStop
44615>>>>>>>            Get SystemTimeMilliSecondsElapsed of oDateFunctions strStart strStop to nElapsed
44616>>>>>>>            Get MilliSecondsToTimeString of oDateFunctions nElapsed to strTableA.sTimeToComplete
44617>>>>>>>
44617>>>>>>>            Get SystemDateTime of oDateFunctions to strTableA.dtAnalysisDateTime
44618>>>>>>>        End
44618>>>>>>>>
44618>>>>>>>    End_Procedure
44619>>>>>>>
44619>>>>>>>    Procedure DeleteAnalysis Integer[] aTables
44621>>>>>>>        Integer iItem iMax iFailure
44621>>>>>>>        String sFile
44621>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
44622>>>>>>>        For iItem from 0 to iMax
44628>>>>>>>>
44628>>>>>>>            Get _TableAnalysisFileName of oTQ aTables[iItem] to sFile
44629>>>>>>>            If (FileExists(oFileFunctions,sFile)=1) Begin
44631>>>>>>>                Get DeleteFileNew of oFileFunctions sFile True to iFailure
44632>>>>>>>            End
44632>>>>>>>>
44632>>>>>>>        Loop
44633>>>>>>>>
44633>>>>>>>    End_Procedure
44634>>>>>>>
44634>>>>>>>End_Class
44635>>>>>>>
44635>>>>>>>Class cTableQueryTester is a cObject
44636>>>>>>>    // Based on a tTableQuery value strQ, TestSuite will return
44636>>>>>>>    // an array of all queries that should return the same resultset.
44636>>>>>>>    Function TestSuite tTableQuery strQ Returns tTableQuery[]
44638>>>>>>>        Integer iForcePrefetch iItem iMax
44638>>>>>>>        tTableQuery[] aQueries
44638>>>>>>>        tTableQuery[] aQueries
44639>>>>>>>        Integer[] aIndices
44640>>>>>>>        Send ReUse of oTQ (&strQ)
44641>>>>>>>        Move False to strQ._strControlBlock.bCompiled
44642>>>>>>>        Get TableIndices of oTQ strQ.iTable to aIndices
44643>>>>>>>        Move (SizeOfArray(aIndices)-1) to iMax
44644>>>>>>>        For iForcePrefetch from 0 to 1
44650>>>>>>>>
44650>>>>>>>            Move (iForcePrefetch=1) to strQ.bForcePrefetch
44651>>>>>>>            For iItem from 0 to iMax
44657>>>>>>>>
44657>>>>>>>                Send ForceIndex of oTQ (&strQ) aIndices[iItem]
44658>>>>>>>                Move strQ to aQueries[SizeOfArray(aQueries)]
44659>>>>>>>            Loop
44660>>>>>>>>
44660>>>>>>>        Loop
44661>>>>>>>>
44661>>>>>>>        Function_Return aQueries
44662>>>>>>>    End_Function
44663>>>>>>>
44663>>>>>>>        Function CompareRowID RowID ri1 RowID ri2 Returns Integer
44665>>>>>>>            If (IsSameRowID(ri1,ri2)) Function_Return (EQ)
44668>>>>>>>            Function_Return (GT)
44669>>>>>>>        End_Function
44670>>>>>>>
44670>>>>>>>        Function ResultSetsIdentical RowID[] aResult1 RowID[] aResult2 Returns Boolean
44672>>>>>>>            Integer iMax iItem iItem2
44672>>>>>>>            Move (SizeOfArray(aResult1)-1) to iMax
44673>>>>>>>            If (iMax=(SizeOfArray(aResult2)-1)) Begin
44675>>>>>>>                For iItem from 0 to iMax
44681>>>>>>>>
44681>>>>>>>                    Move (SearchArray(aResult1[iItem],aResult2,Self,GET_CompareRowID)) to iItem2
44682>>>>>>>                    If (iItem2=-1) Begin
44684>>>>>>>                        Function_Return False
44685>>>>>>>                    End
44685>>>>>>>>
44685>>>>>>>                Loop
44686>>>>>>>>
44686>>>>>>>                Function_Return True
44687>>>>>>>            End
44687>>>>>>>>
44687>>>>>>>            Function_Return False
44688>>>>>>>        End_Function
44689>>>>>>>
44689>>>>>>>        Procedure OnNotIdentical tTableQuery strQ1 tTableQuery strQ2
44691>>>>>>>        End_Procedure
44692>>>>>>>
44692>>>>>>>    Function RunSuite tTableQuery[] ByRef aQueries Returns RowID[][]
44694>>>>>>>        Integer iItem iMax
44694>>>>>>>        Boolean bIdentical
44694>>>>>>>        RowID[] aResult
44695>>>>>>>        RowID[][] aMatrix // An array of result-arrays
44696>>>>>>>        Move (SizeOfArray(aQueries)-1) to iMax
44697>>>>>>>        For iItem from 0 to iMax
44703>>>>>>>>
44703>>>>>>>            Get QueryToRowIdArray of oTQ (&aQueries[iItem]) to aResult
44704>>>>>>>            Move aResult to aMatrix[iItem]
44705>>>>>>>        Loop
44706>>>>>>>>
44706>>>>>>>        Function_Return aMatrix
44707>>>>>>>    End_Function
44708>>>>>>>End_Class // cTableQueryTester
44709>>>>>>>//
44709>>>>>>>//
44709>>>>>>>//
44709>>>>>>>//
44709>>>>>>>//Struct tTQTestBedInput
44709>>>>>>>//    tTableQuery      strPQ
44709>>>>>>>//    tTableQuery      strCQ
44709>>>>>>>//    tTQTableRelation strRel
44709>>>>>>>//    String sName // Is used as part of a file name
44709>>>>>>>//    Boolean bNoESQL
44709>>>>>>>//    Boolean bRubQueries
44709>>>>>>>//End_Struct
44709>>>>>>>//
44709>>>>>>>//Struct tTQTestBedRowID
44709>>>>>>>//    String sRowID
44709>>>>>>>//    String[] aColumnSourceValues
44709>>>>>>>//    tTQTestBedRowID[] aChildRowIDs
44709>>>>>>>//End_Struct
44709>>>>>>>//
44709>>>>>>>//Struct tTQTestBedOutput
44709>>>>>>>//    tTQTestBedInput strInput
44709>>>>>>>//    tTQTestBedRowID[] aResultRowIDs
44709>>>>>>>//    Number nExecMs
44709>>>>>>>//End_Struct
44709>>>>>>>//
44709>>>>>>>//Class cTableQueryTestBed is a cObject
44709>>>>>>>//    Function RunTest tTQTestBedInput strIn Returns tTQTestBedOutput
44709>>>>>>>//        Integer iChildResultIndex iParentResultIndex iParentMaxColumn iChildMaxColumn iItem
44709>>>>>>>//        tTQTestBedOutput strOut
44709>>>>>>>//        _tTQValueSource strValueSource
44709>>>>>>>//
44709>>>>>>>//        Move strIn.bNoESQL to strIn.strPQ.bNoESQL
44709>>>>>>>//
44709>>>>>>>//        Move strIn to strOut.strInput
44709>>>>>>>//        Move 0 to iParentResultIndex
44709>>>>>>>//
44709>>>>>>>//        Move (SizeOfArray(strIn.strPQ.aColumnSources)-1) to iParentMaxColumn
44709>>>>>>>//        Move (SizeOfArray(strIn.strCQ.aColumnSources)-1) to iChildMaxColumn
44709>>>>>>>//
44709>>>>>>>//        While (FindRecord(oTQ,&strIn.strPQ))
44709>>>>>>>//            Move (SerializeRowID(FileRowId(strIn.strPQ.iTable))) to strOut.aResultRowIDs[iParentResultIndex].sRowID
44709>>>>>>>//            For iItem from 0 to iParentMaxColumn
44709>>>>>>>//                Move strIn.strPQ.aColumnSources[iItem] to strValueSource
44709>>>>>>>//                Get ResultColumnValue of oTQ (&strIn.strPQ) strValueSource.iTable strValueSource.iColumn to strOut.aResultRowIDs[iParentResultIndex].aColumnSourceValues[iItem]
44709>>>>>>>//            Loop
44709>>>>>>>//
44709>>>>>>>//            Move 0 to iChildResultIndex
44709>>>>>>>//            While (FindRecord(oTQ,&strIn.strCQ))
44709>>>>>>>//                Move (SerializeRowID(FileRowId(strIn.strCQ.iTable))) to strOut.aResultRowIDs[iParentResultIndex].aChildRowIDs[iChildResultIndex].sRowID
44709>>>>>>>//                For iItem from 0 to iChildMaxColumn
44709>>>>>>>//                    Move strIn.strCQ.aColumnSources[iItem] to strValueSource
44709>>>>>>>//                    Get ResultColumnValue of oTQ (&strIn.strCQ) strValueSource.iTable strValueSource.iColumn to strOut.aResultRowIDs[iParentResultIndex].aChildRowIDs[iChildResultIndex].aColumnSourceValues[iItem]
44709>>>>>>>//                Loop
44709>>>>>>>//                Increment iChildResultIndex
44709>>>>>>>//            Loop
44709>>>>>>>//            Increment iParentResultIndex
44709>>>>>>>//        Loop
44709>>>>>>>//
44709>>>>>>>//        Get SystemTimeMilliSecondsElapsed of oDateFunctions strIn.strPQ._strControlBlock.strStartTime strIn.strPQ._strControlBlock.strStopTime to strOut.nExecMs
44709>>>>>>>//
44709>>>>>>>//        Function_Return strOut
44709>>>>>>>//    End_Function
44709>>>>>>>//
44709>>>>>>>//    Procedure AddAutoRelation tTQTestBedInput ByRef strIn
44709>>>>>>>//        Send AddTableRelationAutoFixed of oTQ (&strIn.strCQ) strIn.strCQ.iTable strIn.strPQ.iTable
44709>>>>>>>//    End_Procedure
44709>>>>>>>//End_Class
44709>>>>>>>
44709>>>>>Use XmlBuilder.pkg
Including file: XmlBuilder.pkg    (C:\Projects\WebQuery\StureApsPublicLib\AppSrc\XmlBuilder.pkg)
44709>>>>>>>//> The cXmlBuilder class may be used for adding elements to an XML DOM tree in a way that relieves
44709>>>>>>>//> you of having to deal with a myriad of handle type variables in your code and the house keeping
44709>>>>>>>//> of destroying all the element objects again.
44709>>>>>>>//>
44709>>>>>>>//> As an alternative it may be used to write directly to a sequential file without building
44709>>>>>>>//> a DOM object in memory. It is a question of which method you use for initiating the
44709>>>>>>>//> XML builing:
44709>>>>>>>//>
44709>>>>>>>//>    send XmlToDOM iNode // Add to XML DOM object
44709>>>>>>>//>
44709>>>>>>>//>    send XmlToChannel iChannel // Write to sequential channel
44709>>>>>>>//>
44709>>>>>>>//>    send XmlToWebApp // Send output directly to the WebApp output stream.
44709>>>>>>>//>
44709>>>>>>>//>
44709>>>>>>>//> <tip legend="Writing XHTML code">
44709>>>>>>>//> If used in the sequential file output mode, all output is written by the write method. I use this
44709>>>>>>>//> when I write XTHML directly from within a WebApp application because I can augment just one
44709>>>>>>>//> method and have it write to the WebApp output stream..
44709>>>>>>>//> </tip>
44709>>>>>>>//>
44709>>>>>>>//> This piece of code:
44709>>>>>>>//> <pkgdoc:code>
44709>>>>>>>//> Use FileFunctions.pkg // Define oFileFunctions object
44709>>>>>>>//>
44709>>>>>>>//> Object oTestBuilder is a cXmlBuilder
44709>>>>>>>//>
44709>>>>>>>//>   Procedure DoTest
44709>>>>>>>//>     Integer iChannel
44709>>>>>>>//>     Get DirectOutput of oFileFunctions "test.xml" to iChannel
44709>>>>>>>//>     If (iChannel>=0) begin
44709>>>>>>>//>       // Manually write this line:
44709>>>>>>>//>       Write channel iChannel '<?xml version="1.0" encoding="iso-8859-1"?>'
44709>>>>>>>//>       Send XmlToChannel iChannel //
44709>>>>>>>//>       Send AddOpenElement "response"
44709>>>>>>>//>            Send AddAttribute "xmlns:service" "http://www.sture.dk/2012/service/"
44709>>>>>>>//>       Send AddOpenElement   "function"
44709>>>>>>>//>            Send AddAttribute "name" "login"
44709>>>>>>>//>       Send AddOpenElement     "result"
44709>>>>>>>//>       Send AddOpenElement       "fieldset"
44709>>>>>>>//>       Send AddElement       "legend" "Login"
44709>>>>>>>//>       Send AddElement       "span" "UserName"
44709>>>>>>>//>       Send AddOpenElement         "span"
44709>>>>>>>//>            Send AddElement         "input" ""
44709>>>>>>>//>            Send AddAttribute "type" "text"
44709>>>>>>>//>       Send CloseElement            // "span"
44709>>>>>>>//>       Send AddElement       "span" "Password"
44709>>>>>>>//>       Send AddOpenElement         "span"
44709>>>>>>>//>            Send AddElement         "input" ""
44709>>>>>>>//>            Send AddAttribute  "type" "password"
44709>>>>>>>//>       Send CloseElement            // span
44709>>>>>>>//>       Send CloseElement          // fieldset
44709>>>>>>>//>       Send CloseElement        // result
44709>>>>>>>//>       Send CloseElement      // function
44709>>>>>>>//>       Send CloseElement    // response
44709>>>>>>>//>       Send EndXml
44709>>>>>>>//>       Send CloseOutput of oFileFunctions iChannel
44709>>>>>>>//>     End
44709>>>>>>>//>   End_procedure
44709>>>>>>>//>
44709>>>>>>>//>   Send DoTest
44709>>>>>>>//>
44709>>>>>>>//> End_Object
44709>>>>>>>//> </pkgdoc:code>
44709>>>>>>>//>
44709>>>>>>>//> will write this to a file called test.xml:
44709>>>>>>>//>
44709>>>>>>>//> <pkgdoc:code>
44709>>>>>>>//> <?xml version="1.0" encoding="iso-8859-1"?>
44709>>>>>>>//> <response xmlns:service="http://www.sture.dk/2004/service/">
44709>>>>>>>//>   <function name="login">
44709>>>>>>>//>     <result>
44709>>>>>>>//>       <fieldset>
44709>>>>>>>//>         <legend>Login</legend>
44709>>>>>>>//>         <span>Username</span>
44709>>>>>>>//>         <span><input type="text" /></span>
44709>>>>>>>//>         <span>Password</span>
44709>>>>>>>//>         <span><input type="password" /></span>
44709>>>>>>>//>       </fieldset>>
44709>>>>>>>//>     </result>
44709>>>>>>>//>   </function>
44709>>>>>>>//> </response>
44709>>>>>>>//> </pkgdoc:code>
44709>>>>>>>//>
44709>>>>>>>//> (line feeds and indentation has been added for readability)
44709>>>>>>>//>
44709>>>>>>>//> <pkgdoc:note>
44709>>>>>>>//> This class is not able to handle mixed-content elements except by the use of the
44709>>>>>>>//> pbProtectValueData property.
44709>>>>>>>//> </pkgdoc:note>
44709>>>>>>>//>
44709>>>>>>>//> pkgdoc.end
44709>>>>>>>
44709>>>>>>>
44709>>>>>>>
44709>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
44709>>>>>>>Use FleXML.pkg // DAW interface package for FLEXML.DLL
44709>>>>>>>
44709>>>>>>>Use StackFunctions.pkg // Define oStackFunctions object
44709>>>>>>>Use DateFunctions.pkg // Define oDateFunctions object
44709>>>>>>>
44709>>>>>>>Global_Variable String[] _gaXmlBuildToString // Array for collecting XML as one string
44709>>>>>>>Global_Variable Integer  _giXmlBuildToString
44709>>>>>>>Global_Variable Boolean  _gbXmlBuildToString
44709>>>>>>>Move False to _gbXmlBuildToString // Not in use
44710>>>>>>>
44710>>>>>>>Enum_List // XML modes
44710>>>>>>>    Define XM_DOM // Build DOM
44710>>>>>>>    Define XM_SEQ // Write to sequential channel
44710>>>>>>>    Define XM_WEB // Write to WebApp output stream
44710>>>>>>>    Define XM_STR // Build XML string
44710>>>>>>>    Define XM_DWR // Delete calls to write
44710>>>>>>>End_Enum_List
44710>>>>>>>
44710>>>>>>>Class cXmlBuilder is a cObject
44711>>>>>>>    Procedure Construct_Object
44713>>>>>>>        Forward Send Construct_Object
44715>>>>>>>        Property Integer piOutputMode       //  XM_DOM, XM_SEQ, XM_WEB or XM_STR
44716>>>>>>>
44716>>>>>>>        Property Integer _channel       //
44717>>>>>>>        Property Handle  _CurrentNode   // While building DOM trees this property holds the "current node"
44718>>>>>>>        Property Boolean _ClosedElement // Has AddElement been called after the most recent FlushBuffers?
44719>>>>>>>        Property String  _WriteBuffer   // Used for building the attributes string while writing to sequential file
44720>>>>>>>        Property Boolean _OpenElement   // While writing to sequential files this property indicates that the last element added was an open one
44721>>>>>>>
44721>>>>>>>        Property Handle[] paNodes           // Node stack
44722>>>>>>>        Property String[] paElements        // Element stack
44723>>>>>>>        Property Integer[] paCDATAs         // CDATA? stack
44724>>>>>>>        
44724>>>>>>>        Property Boolean   pbTagSelfClosingEnabled True
44725>>>>>>>        
44725>>>>>>>        //> This property has been introduced because the textarea element in (X)HTML is not allowed to be closed
44725>>>>>>>        //> in this way "<textarea />" when it's empty. Totally not understandable! But it must be written as
44725>>>>>>>        //> "<textarea></textarea>".
44725>>>>>>>        Property Integer pbTextAreaException  False
44726>>>>>>>        //> This property has been introduced because the script element in (X)HTML is not allowed to be closed
44726>>>>>>>        //> in this way "<script />" when it's empty. Must be written as "<script></script>". IE 6 problem
44726>>>>>>>        Property Integer pbScriptException    False
44727>>>>>>>        //> The pbProtectValueData property controls whether <, > and & characters written to the XML as data
44727>>>>>>>        //> is HTML encoded ("&lt;", "&gt;" and "&amp;") or not. Its default value is to do this encoding (true).
44727>>>>>>>        //> The reason for (temporarily) setting it to false when generating XHTML code is making it able to handle
44727>>>>>>>        //> when the data itself represents XHTML code. In this case it is not OK to encode these characters.
44727>>>>>>>        Property Integer pbProtectValueData   True
44728>>>>>>>    
44728>>>>>>>        Property String[] _paAttr
44729>>>>>>>        Property String[] _paAttrValue
44730>>>>>>>    End_Procedure
44731>>>>>>>
44731>>>>>>>    //> If XML is not being added to DOM all output will be sent to this procedure.
44731>>>>>>>    Procedure Write String sValue
44733>>>>>>>        Integer iMode
44733>>>>>>>        String[] aOutput
44734>>>>>>>        Get piOutputMode to iMode
44735>>>>>>>        
44735>>>>>>>        If (iMode=XM_SEQ) Begin
44737>>>>>>>            Write channel (_channel(Self)) sValue
44739>>>>>>>        End
44739>>>>>>>>
44739>>>>>>>        Else If (iMode=XM_WEB) Begin
44742>>>>>>>              Send OutputString to ghInetSession sValue
44743>>>>>>>        End
44743>>>>>>>>
44743>>>>>>>        Else If (iMode=XM_STR) Begin
44746>>>>>>>            Move sValue to _gaXmlBuildToString[_giXmlBuildToString]
44747>>>>>>>            Increment _giXmlBuildToString
44748>>>>>>>        End
44748>>>>>>>>
44748>>>>>>>        Else If (iMode=XM_DWR) Begin
44751>>>>>>>            Delegate Send Write sValue // Somebody outside will handle it
44753>>>>>>>        End
44753>>>>>>>>
44753>>>>>>>    End_Procedure
44754>>>>>>>
44754>>>>>>>    Procedure Stream String sValue // Not for DOM building!
44756>>>>>>>        If (piOutputMode(Self)<>XM_DOM) Begin
44758>>>>>>>            Send FlushBuffer
44759>>>>>>>            Send Write sValue
44760>>>>>>>        End
44760>>>>>>>>
44760>>>>>>>        Else Begin
44761>>>>>>>            Error 312 "XmlBuilder: Illegal invocation of Stream method"
44762>>>>>>>>
44762>>>>>>>        End
44762>>>>>>>>
44762>>>>>>>    End_Procedure
44763>>>>>>>
44763>>>>>>>                Procedure PushNode Handle hValue // Private
44765>>>>>>>                    Handle[] aNodes
44766>>>>>>>                    Get paNodes to aNodes
44767>>>>>>>                    Send HandlePush of oStackFunctions hValue (&aNodes)
44768>>>>>>>                    Set paNodes to aNodes
44769>>>>>>>                End_Procedure
44770>>>>>>>
44770>>>>>>>                Function PopNode Returns Handle // Private
44772>>>>>>>                    Handle hValue
44772>>>>>>>                    Handle[] aNodes
44773>>>>>>>                    Get paNodes to aNodes
44774>>>>>>>                    Get HandlePop of oStackFunctions (&aNodes) to hValue
44775>>>>>>>                    Set paNodes to aNodes
44776>>>>>>>                    Function_Return hValue
44777>>>>>>>                End_Function
44778>>>>>>>
44778>>>>>>>                Procedure PushString String sValue // Private
44780>>>>>>>                    String[] aElements
44781>>>>>>>                    Get paElements to aElements
44782>>>>>>>                    Send StringPush of oStackFunctions sValue (&aElements)
44783>>>>>>>                    Set paElements to aElements
44784>>>>>>>                End_Procedure
44785>>>>>>>                
44785>>>>>>>                Function PopString Returns String // Private
44787>>>>>>>                    String sValue
44787>>>>>>>                    String[] aElements
44788>>>>>>>                    Get paElements to aElements
44789>>>>>>>                    Get StringPop of oStackFunctions (&aElements) to sValue
44790>>>>>>>                    Set paElements to aElements
44791>>>>>>>                    Function_Return sValue
44792>>>>>>>                End_Function
44793>>>>>>>
44793>>>>>>>                Procedure PushInteger Integer iValue // Private
44795>>>>>>>                    Integer[] aCDATAs
44796>>>>>>>                    Get paCDATAs to aCDATAs
44797>>>>>>>                    Send IntegerPush of oStackFunctions iValue (&aCDATAs)
44798>>>>>>>                    Set paCDATAs to aCDATAs
44799>>>>>>>                End_Procedure
44800>>>>>>>
44800>>>>>>>                Function PopInteger Returns Integer // Private
44802>>>>>>>                    Integer iValue
44802>>>>>>>                    Integer[] aCDATAs
44803>>>>>>>                    Get paCDATAs to aCDATAs
44804>>>>>>>                    Get IntegerPop of oStackFunctions (&aCDATAs) to iValue
44805>>>>>>>                    Set paCDATAs to aCDATAs
44806>>>>>>>                    Function_Return iValue
44807>>>>>>>                End_Function
44808>>>>>>>    
44808>>>>>>>                Procedure FlushBuffer // Private
44810>>>>>>>                    Boolean bException
44810>>>>>>>                    Boolean bCDATA
44810>>>>>>>                    String sBuffer sValue sElement
44810>>>>>>>                    If (piOutputMode(Self)=XM_DOM) Begin
44812>>>>>>>                        If (_ClosedElement(Self)) Begin
44814>>>>>>>                            Send destroy of (_CurrentNode(Self))
44815>>>>>>>                            Set _CurrentNode to (PopNode(Self))
44816>>>>>>>                            Set _ClosedElement to False
44817>>>>>>>                        End
44817>>>>>>>>
44817>>>>>>>                    End
44817>>>>>>>>
44817>>>>>>>                    Else Begin
44818>>>>>>>                        Get _WriteBuffer to sBuffer
44819>>>>>>>                        If (sBuffer<>"") Begin // If there's anything in the buffer
44821>>>>>>>                            If (_Openelement(Self)) Begin
44823>>>>>>>                                Send Write (sBuffer+">") // If we're writing an opening tag
44824>>>>>>>                            End
44824>>>>>>>>
44824>>>>>>>                            Else Begin // We're dealing with writing a data element (including a closing tag)
44825>>>>>>>                                Get PopInteger to bCDATA
44826>>>>>>>                                Get PopString to sElement
44827>>>>>>>                                Get PopString to sValue
44828>>>>>>>                                If (sValue="" and pbTagSelfClosingEnabled(Self) and ;                                     ((Lowercase(sElement)<>"textarea" or pbTextAreaException(Self)=0) and ;                                      (Lowercase(sElement)<>"script" or pbScriptException(Self)=0) )) Begin
44830>>>>>>>                                    Send Write (sBuffer+" />") // If no value, we're writing the shorthand open-close tag.
44831>>>>>>>                                End
44831>>>>>>>>
44831>>>>>>>                                Else Begin
44832>>>>>>>                                    If bCDATA Begin
44834>>>>>>>                                        Send Write (sBuffer+"><![CDATA["+sValue+"]]></"+sElement+">")
44835>>>>>>>                                    End
44835>>>>>>>>
44835>>>>>>>                                    Else Begin
44836>>>>>>>                                        If (pbProtectValueData(Self)) Begin
44838>>>>>>>                                            Move (replaces("&",sValue,"&amp;")) to sValue
44839>>>>>>>                                            Move (replaces("<",sValue,"&lt;")) to sValue
44840>>>>>>>                                            Move (replaces(">",sValue,"&gt;")) to sValue
44841>>>>>>>                                        End
44841>>>>>>>>
44841>>>>>>>                                        Send Write (sBuffer+">"+sValue+"</"+sElement+">")
44842>>>>>>>                                    End
44842>>>>>>>>
44842>>>>>>>                                End
44842>>>>>>>>
44842>>>>>>>                            End
44842>>>>>>>>
44842>>>>>>>                            Set _WriteBuffer to ""
44843>>>>>>>                        End
44843>>>>>>>>
44843>>>>>>>
44843>>>>>>>                    End
44843>>>>>>>>
44843>>>>>>>                End_Procedure
44844>>>>>>>                
44844>>>>>>>    //> Send this to initiate the process of adding to XML a DOM node.
44844>>>>>>>    Procedure XmlToDOM Integer iNode
44846>>>>>>>        Integer[] aNodes
44847>>>>>>>        Set piOutputMode to XM_DOM
44848>>>>>>>        Set _CurrentNode to iNode
44849>>>>>>>        Set paNodes to aNodes // Reset paNodes
44850>>>>>>>        Set _ClosedElement to False
44851>>>>>>>    End_Procedure
44852>>>>>>>
44852>>>>>>>    //> Send this to initiate the process of writing XML to a sequential channel.
44852>>>>>>>    Procedure XmlToChannel Integer iChannel
44854>>>>>>>        Set piOutputMode to XM_SEQ
44855>>>>>>>        Set _channel to iChannel
44856>>>>>>>        Set _WriteBuffer to ""
44857>>>>>>>    End_Procedure
44858>>>>>>>
44858>>>>>>>    //> Only use this from within an WebApp.
44858>>>>>>>    Procedure XmlToWebApp
44860>>>>>>>        Set piOutputMode to XM_WEB
44861>>>>>>>        Set _WriteBuffer to ""
44862>>>>>>>    End_Procedure
44863>>>>>>>
44863>>>>>>>  //> If you want the XML to be returned as a string you should use this method to initate the process.
44863>>>>>>>    Procedure XmlToString
44865>>>>>>>        String[] aValues
44866>>>>>>>        If (not(_gbXmlBuildToString)) Begin
44868>>>>>>>            Set piOutputMode to XM_STR
44869>>>>>>>            Set _WriteBuffer to ""
44870>>>>>>>            Move aValues to _gaXmlBuildToString
44871>>>>>>>            Move 0 to _giXmlBuildToString
44872>>>>>>>            Move True to _gbXmlBuildToString
44873>>>>>>>        End
44873>>>>>>>>
44873>>>>>>>        Else Begin
44874>>>>>>>            Error DFERR_PROGRAM "XmlBuilder can only build one string at a time (XmlBuilder.pkg)"
44875>>>>>>>>
44875>>>>>>>        End
44875>>>>>>>>
44875>>>>>>>    End_Procedure
44876>>>>>>>    
44876>>>>>>>    Procedure XmlToDelegatedWrite
44878>>>>>>>        Set piOutputMode to XM_DWR
44879>>>>>>>        Set _WriteBuffer to ""
44880>>>>>>>    End_Procedure
44881>>>>>>>    
44881>>>>>>>        Procedure _AddPreadvisedAttributes
44883>>>>>>>            Integer iIndex iMax
44883>>>>>>>            String[] aAttr aAttrValue
44885>>>>>>>            Get _paAttr to aAttr
44886>>>>>>>            Move (SizeOfArray(aAttr)-1) to iMax
44887>>>>>>>            If (iMax>=0) Begin
44889>>>>>>>                Get _paAttrValue to aAttrValue
44890>>>>>>>                For iIndex from 0 to iMax
44896>>>>>>>>
44896>>>>>>>                   Send AddAttribute aAttr[iIndex] aAttrValue[iIndex]
44897>>>>>>>                Loop
44898>>>>>>>>
44898>>>>>>>                Move (ResizeArray(aAttr,0)) to aAttr
44899>>>>>>>                Set _paAttr to aAttr
44900>>>>>>>                Set _paAttrValue to aAttr
44901>>>>>>>            End
44901>>>>>>>>
44901>>>>>>>        End_Procedure
44902>>>>>>>
44902>>>>>>>    //> Adds an element that contains other elements. The element must ultimately be closed by sending the CloseElement message.
44902>>>>>>>    Procedure AddOpenElement String sElement
44904>>>>>>>        Handle hParent hChild
44904>>>>>>>        if (piOutputMode(self)=XM_DOM) Begin
44906>>>>>>>            Send FlushBuffer
44907>>>>>>>            Get _CurrentNode to hParent
44908>>>>>>>            Get AddElement of hParent sElement "" to hChild
44909>>>>>>>            Send PushNode hParent
44910>>>>>>>            Set _CurrentNode to hChild
44911>>>>>>>        End
44911>>>>>>>>
44911>>>>>>>        Else Begin
44912>>>>>>>            Send FlushBuffer
44913>>>>>>>            Set _WriteBuffer to ("<"+sElement)
44914>>>>>>>            Send PushString sElement
44915>>>>>>>            Set _OpenElement to True
44916>>>>>>>        End
44916>>>>>>>>
44916>>>>>>>        Send _AddPreadvisedAttributes
44917>>>>>>>    End_Procedure
44918>>>>>>>    
44918>>>>>>>    //> Adds a data element (an element with no children)
44918>>>>>>>    Procedure AddElement String sElement String sValue
44920>>>>>>>        Handle hParent hChild
44920>>>>>>>        if (piOutputMode(self)=XM_DOM) Begin
44922>>>>>>>            Send FlushBuffer
44923>>>>>>>            Get _CurrentNode to hParent
44924>>>>>>>            Get AddElement of hParent sElement sValue to hChild
44925>>>>>>>            Send PushNode hParent
44926>>>>>>>            Set _CurrentNode to hChild
44927>>>>>>>            Set _ClosedElement to True
44928>>>>>>>        End
44928>>>>>>>>
44928>>>>>>>        Else Begin
44929>>>>>>>            Send FlushBuffer
44930>>>>>>>            Set _WriteBuffer to ("<"+sElement)
44931>>>>>>>            Send PushString sValue
44932>>>>>>>            Send PushString sElement
44933>>>>>>>            Send PushInteger 0 // not CDATA
44934>>>>>>>            Set _OpenElement to False
44935>>>>>>>        End
44935>>>>>>>>
44935>>>>>>>        Send _AddPreadvisedAttributes
44936>>>>>>>    End_Procedure
44937>>>>>>>
44937>>>>>>>    //> Same as AddElement but marks up the data in sValue as CDATA
44937>>>>>>>    Procedure AddCDATAElement String sElement String sValue
44939>>>>>>>        Handle hParent hChild
44939>>>>>>>        if (piOutputMode(self)=XM_DOM) Begin
44941>>>>>>>            Send FlushBuffer
44942>>>>>>>            Get _CurrentNode to hParent
44943>>>>>>>            Get AddElement of hParent sElement "" to hChild
44944>>>>>>>            Send AddCDataSection of hChild sValue
44945>>>>>>>            Send PushNode hParent
44946>>>>>>>            Set _CurrentNode to hChild
44947>>>>>>>            Set _ClosedElement to True
44948>>>>>>>        End
44948>>>>>>>>
44948>>>>>>>        Else Begin
44949>>>>>>>            Send FlushBuffer
44950>>>>>>>            Set _WriteBuffer to ("<"+sElement)
44951>>>>>>>            Send PushString sValue
44952>>>>>>>            Send PushString sElement
44953>>>>>>>            Send PushInteger 1 // CDATA
44954>>>>>>>            Set _OpenElement to False
44955>>>>>>>        End
44955>>>>>>>>
44955>>>>>>>    End_Procedure
44956>>>>>>>
44956>>>>>>>    //> Same as AddElement but formats the number with "." as decimal separator
44956>>>>>>>    Procedure AddNumberElement String sElement Number nValue
44958>>>>>>>        Send AddElement sElement (replace(",",String(nValue),"."))
44959>>>>>>>    End_Procedure
44960>>>>>>>
44960>>>>>>>    //> Same as AddElement but formats the date according to ISO 8601 (YYYY-MM-DD)
44960>>>>>>>    Procedure AddDateElement String sElement Date dValue                                                      
44962>>>>>>>        Send AddElement sElement (DateToString(oDateFunctions,dValue,DF_DATE_MILITARY,True,"-")) // International Standard ISO 8601
44963>>>>>>>    End_Procedure
44964>>>>>>>
44964>>>>>>>    //> Close an element previously added by the AddOpenElement method
44964>>>>>>>    Procedure CloseElement
44966>>>>>>>        String sElement
44966>>>>>>>        if (piOutputMode(self)=XM_DOM) Begin
44968>>>>>>>            Send FlushBuffer
44969>>>>>>>            Send destroy of (_CurrentNode(Self))
44970>>>>>>>            Set _CurrentNode to (PopNode(Self))
44971>>>>>>>        End
44971>>>>>>>>
44971>>>>>>>        Else Begin
44972>>>>>>>            Send FlushBuffer
44973>>>>>>>            Get PopString to sElement
44974>>>>>>>            Send Write ("</"+sElement+">")
44975>>>>>>>        End
44975>>>>>>>>
44975>>>>>>>    End_Procedure
44976>>>>>>>
44976>>>>>>>    //> Add an attribute to the element that was most recently added (whether it is an open or a closed element)
44976>>>>>>>    Procedure AddAttribute String sAttr String sValue
44978>>>>>>>        String sBuffer
44978>>>>>>>        If (piOutputMode(Self)=XM_DOM) Begin
44980>>>>>>>            Send AddAttribute of (_CurrentNode(Self)) sAttr sValue
44981>>>>>>>        End
44981>>>>>>>>
44981>>>>>>>        Else Begin
44982>>>>>>>            Get _WriteBuffer to sBuffer
44983>>>>>>>            Move (sBuffer+" ") to sBuffer
44984>>>>>>>            Move (sBuffer+sAttr) to sBuffer
44985>>>>>>>            Move (sBuffer+"=") to sBuffer
44986>>>>>>>            Move (sBuffer+'"') to sBuffer
44987>>>>>>>            Move (sBuffer+sValue) to sBuffer
44988>>>>>>>            Move (sBuffer+'"') to sBuffer
44989>>>>>>>            Set _WriteBuffer to sBuffer
44990>>>>>>>//            Set _WriteBuffer to (sBuffer+' '+sAttr+'="'+sValue+'"')
44990>>>>>>>        End
44990>>>>>>>>
44990>>>>>>>    End_Procedure
44991>>>>>>>
44991>>>>>>>    //> Adding attributes with this message will attach them to the next
44991>>>>>>>    //> element being added.
44991>>>>>>>    Procedure AddAttributeToNextElement String sAttr String sValue
44993>>>>>>>        Integer iIndex
44993>>>>>>>        String[] aAttr aAttrValue
44995>>>>>>>        Get _paAttr to aAttr
44996>>>>>>>        Get _paAttrValue to aAttrValue
44997>>>>>>>        Move (SizeOfArray(aAttr)) to iIndex
44998>>>>>>>        Move sAttr to aAttr[iIndex]
44999>>>>>>>        Move sValue to aAttrValue[iIndex]
45000>>>>>>>        Set _paAttr to aAttr
45001>>>>>>>        Set _paAttrValue to aAttrValue
45002>>>>>>>    End_Procedure
45003>>>>>>>
45003>>>>>>>    //> Send this to conclude the process of building the XML sequence.
45003>>>>>>>    Procedure EndXml
45005>>>>>>>        String[] aEmpty
45006>>>>>>>        Send FlushBuffer
45007>>>>>>>        Set _paAttr to aEmpty
45008>>>>>>>        Set _paAttrValue to aEmpty
45009>>>>>>>        If (piOutputMode(Self)=XM_STR) Begin
45011>>>>>>>            Move False to _gbXmlBuildToString // Means that a new string can be built
45012>>>>>>>        End
45012>>>>>>>>
45012>>>>>>>    End_Procedure
45013>>>>>>>
45013>>>>>>>    //> If the XML building was initiated by the XmlToString message you can use this function to retrieve the value. Calling this
45013>>>>>>>    //> function resets the content of the internal array.
45013>>>>>>>    Function XmlStringValue Returns String
45015>>>>>>>        String sRval
45015>>>>>>>        Integer iItm iMax
45015>>>>>>>        Send FlushBuffer
45016>>>>>>>        Move (SizeOfArray(_gaXmlBuildToString)-1) to iMax
45017>>>>>>>        Move "" to sRval
45018>>>>>>>        For iItm from 0 to iMax
45024>>>>>>>>
45024>>>>>>>            Move (sRval+_gaXmlBuildToString[iItm]) to sRval
45025>>>>>>>        Loop
45026>>>>>>>>
45026>>>>>>>        Move (ResizeArray(_gaXmlBuildToString,0)) to _gaXmlBuildToString // You can only get its value once.
45027>>>>>>>        Function_Return sRval
45028>>>>>>>    End_Function
45029>>>>>>>
45029>>>>>>>    Function XmlStringValueLength Returns Integer
45031>>>>>>>        Integer iLength iIndex iMax
45031>>>>>>>        Move (SizeOfArray(_gaXmlBuildToString)-1) to iMax
45032>>>>>>>        Move 0 to iLength
45033>>>>>>>        For iIndex from 0 to iMax
45039>>>>>>>>
45039>>>>>>>            Move (iLength+Length(_gaXmlBuildToString[iIndex])) to iLength
45040>>>>>>>        Loop
45041>>>>>>>>
45041>>>>>>>        Function_Return iLength
45042>>>>>>>    End_Function
45043>>>>>>>End_Class // cXmlBuilder
45044>>>>>>>
45044>>>>>>>Class cXmlBuilderProxyMixin is a Mixin
45045>>>>>>>    Procedure Define_cXmlBuilderProxyMixin Integer hXmlBuilder
45047>>>>>>>        Property Integer phXMLBuilder
45048>>>>>>>    End_Procedure
45049>>>>>>>
45049>>>>>>>    Procedure Write String sValue
45051>>>>>>>        Send Write of (phXMLBuilder(Self)) sValue
45052>>>>>>>    End_Procedure
45053>>>>>>>
45053>>>>>>>    Procedure Stream String sValue // Only for DOM building
45055>>>>>>>        Send Stream of (phXMLBuilder(Self)) sValue
45056>>>>>>>    End_Procedure
45057>>>>>>>
45057>>>>>>>    Procedure XmlToDOM Integer iNode //> Send this to initiate the process of adding to XML a DOM node.
45059>>>>>>>        Send XmlToDOM of (phXMLBuilder(Self)) iNode
45060>>>>>>>    End_Procedure
45061>>>>>>>
45061>>>>>>>    Procedure XmlToChannel Integer iChannel //> Send this to initiate the process of writing XML to a sequential channel.
45063>>>>>>>        Send XmlToChannel of (phXMLBuilder(Self)) iChannel
45064>>>>>>>    End_Procedure
45065>>>>>>>
45065>>>>>>>    Procedure XmlToWebApp //> Only use this from within an WebApp.
45067>>>>>>>        Send XmlToWebApp of (phXMLBuilder(Self))
45068>>>>>>>    End_Procedure
45069>>>>>>>
45069>>>>>>>    Procedure XmlToString //> If you want the XML to be returned as a string you should use this method to initate the process.
45071>>>>>>>        Send XmlToString of (phXMLBuilder(Self))
45072>>>>>>>    End_Procedure
45073>>>>>>>
45073>>>>>>>    Procedure XmlToDelegatedWrite //> If you want the encapsulating object to handle the Write method.
45075>>>>>>>        Send XmlToDelegatedWrite of (phXMLBuilder(Self))
45076>>>>>>>    End_Procedure
45077>>>>>>>
45077>>>>>>>    Procedure AddOpenElement String sElement //> Adds an element that contains other elements. The element must ultimately be closed by sending the CloseElement message.
45079>>>>>>>        Send AddOpenElement of (phXMLBuilder(Self)) sElement
45080>>>>>>>    End_Procedure
45081>>>>>>>
45081>>>>>>>    Procedure AddElement String sElement String sValue //> Adds a data element (an element with no children)
45083>>>>>>>        Send AddElement of (phXMLBuilder(Self)) sElement sValue
45084>>>>>>>    End_Procedure
45085>>>>>>>
45085>>>>>>>    Procedure AddCDATAElement String sElement String sValue //> Same as AddElement but marks up the data in sValue as CDATA
45087>>>>>>>        Send AddCDATAElement of (phXMLBuilder(Self)) sElement sValue
45088>>>>>>>    End_Procedure
45089>>>>>>>
45089>>>>>>>    Procedure AddNumberElement String sElement Number nValue //> Same as AddElement but formats the number with "." as decimal separator
45091>>>>>>>        Send AddNumberElement of (phXMLBuilder(Self)) sElement nValue
45092>>>>>>>    End_Procedure
45093>>>>>>>
45093>>>>>>>    Procedure AddDateElement String sElement Date dValue //> Same as AddElement but formats the date according to ISO 8601 (YYYY-MM-DD)
45095>>>>>>>        Send AddDateElement of (phXMLBuilder(Self)) sElement dValue
45096>>>>>>>    End_Procedure
45097>>>>>>>
45097>>>>>>>    Procedure CloseElement //> Close an element previously added by the AddOpenElement method
45099>>>>>>>        Send CloseElement of (phXMLBuilder(Self))
45100>>>>>>>    End_Procedure
45101>>>>>>>
45101>>>>>>>    Procedure AddAttribute String sAttr String sValue //> Add an attribute to the element that was most recently added (whether it is an open or a closed element)
45103>>>>>>>        Send AddAttribute of (phXMLBuilder(Self)) sAttr sValue
45104>>>>>>>    End_Procedure
45105>>>>>>>
45105>>>>>>>    Procedure AddAttributeToNextElement String sAttr String sValue //> Adding attributes with this message will attach them to the next element being added.
45107>>>>>>>        Send AddAttributeToNextElement of (phXMLBuilder(Self)) sAttr sValue
45108>>>>>>>    End_Procedure
45109>>>>>>>
45109>>>>>>>    Procedure EndXml //> Send this to conclude the process of building the XML sequence.
45111>>>>>>>        Send EndXml of (phXMLBuilder(Self))
45112>>>>>>>    End_Procedure
45113>>>>>>>
45113>>>>>>>    Function XmlStringValue Returns String //> If the XML building was initiated by the XmlToString message you can use this function to retrieve the value. Calling this function resets the content of the internal array.
45115>>>>>>>        Function_Return (XmlStringValue(phXMLBuilder(Self)))
45116>>>>>>>    End_Function
45117>>>>>>>    
45117>>>>>>>    Function XmlStringValueLength Returns Integer
45119>>>>>>>        Function_Return (XmlStringValueLength(phXMLBuilder(Self)))
45120>>>>>>>    End_Function
45121>>>>>>>End_Class
45122>>>>>
45122>>>>>Use wqSelectionOperators.wo
Including file: wqSelectionOperators.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\wqSelectionOperators.wo)
45122>>>>>>>Use cWebModalDialog
45122>>>>>>>Use cWebPanel.pkg
45122>>>>>>>Use cWebButton.pkg
45122>>>>>>>Use cWebForm.pkg
45122>>>>>>>Use cWebList.pkg
45122>>>>>>>Use cWebColumn.pkg
45122>>>>>>>
45122>>>>>>>Enum_List
45122>>>>>>>    Define C_wqEQ for 0
45122>>>>>>>    Define C_wqLT
45122>>>>>>>    Define C_wqLE
45122>>>>>>>    Define C_wqGR
45122>>>>>>>    Define C_wqGT
45122>>>>>>>    Define C_wqNE
45122>>>>>>>    Define C_wqIN
45122>>>>>>>    Define C_wqCIN
45122>>>>>>>    Define C_wqBT
45122>>>>>>>    Define C_wqCBT
45122>>>>>>>    Define C_wqINL
45122>>>>>>>    Define C_wqEndSelOps
45122>>>>>>>End_Enum_List
45122>>>>>>>
45122>>>>>>>Struct wqSelType
45122>>>>>>>    String  sCode
45122>>>>>>>    String  sDesc
45122>>>>>>>End_Struct  // wqSelType
45122>>>>>>>
45122>>>>>>>Object oWqSelectionTypes is a cObject
45124>>>>>>>    Property wqSelType[] paSelTypes
45126>>>>>>>    
45126>>>>>>>    Procedure LoadTypes
45129>>>>>>>        wqSelType[] aTypes
45129>>>>>>>        wqSelType[] aTypes
45130>>>>>>>        Integer i
45130>>>>>>>        
45130>>>>>>>        For i from 0 to (C_wqEndSelOps - 1)
45136>>>>>>>>
45136>>>>>>>            If (i =  0) Move "="                        to aTypes[i].sCode
45139>>>>>>>            If (i =  1) Move "<"                        to aTypes[i].sCode
45142>>>>>>>            If (i =  2) Move "<="                       to aTypes[i].sCode
45145>>>>>>>            If (i =  3) Move ">="                       to aTypes[i].sCode
45148>>>>>>>            If (i =  4) Move ">"                        to aTypes[i].sCode
45151>>>>>>>            If (i =  5) Move "<>"                       to aTypes[i].sCode
45154>>>>>>>            If (i =  6) Move "IN"                       to aTypes[i].sCode
45157>>>>>>>            If (i =  7) Move "CIN"                      to aTypes[i].sCode
45160>>>>>>>            If (i =  8) Move "x-y"                      to aTypes[i].sCode
45163>>>>>>>            If (i =  9) Move "CBT"                      to aTypes[i].sCode
45166>>>>>>>            If (i = 10) Move "in list"                  to aTypes[i].sCode
45169>>>>>>>            If (i =  0) Move "Equal to"                 to aTypes[i].sDesc
45172>>>>>>>            If (i =  1) Move "Less than"                to aTypes[i].sDesc
45175>>>>>>>            If (i =  2) Move "Less than or equal to"    to aTypes[i].sDesc
45178>>>>>>>            If (i =  3) Move "Greater than or equal to" to aTypes[i].sDesc
45181>>>>>>>            If (i =  4) Move "Greater than"             to aTypes[i].sDesc
45184>>>>>>>            If (i =  5) Move "Not equal to"             to aTypes[i].sDesc
45187>>>>>>>            If (i =  6) Move "String includes"          to aTypes[i].sDesc
45190>>>>>>>            If (i =  7) Move "String does not include"  to aTypes[i].sDesc
45193>>>>>>>            If (i =  8) Move "Between"                  to aTypes[i].sDesc
45196>>>>>>>            If (i =  9) Move "Outside interval"         to aTypes[i].sDesc
45199>>>>>>>            If (i = 10) Move "in list"                  to aTypes[i].sDesc
45202>>>>>>>        Loop
45203>>>>>>>>
45203>>>>>>>        
45203>>>>>>>        Set paSelTypes to aTypes
45204>>>>>>>    End_Procedure  // LoadTypes
45205>>>>>>>    
45205>>>>>>>    Function SelCode Integer i Returns String
45208>>>>>>>        wqSelType[] aTypes
45208>>>>>>>        wqSelType[] aTypes
45209>>>>>>>        
45209>>>>>>>        If (i => C_wqEndSelOps) Function_Return ""
45212>>>>>>>        
45212>>>>>>>        Get paSelTypes to aTypes
45213>>>>>>>        Function_Return aTypes[i].sCode
45214>>>>>>>    End_Function  // SelCode
45215>>>>>>>    
45215>>>>>>>    Function SelDesc Integer i Returns String
45218>>>>>>>        wqSelType[] aTypes
45218>>>>>>>        wqSelType[] aTypes
45219>>>>>>>        
45219>>>>>>>        If (i => C_wqEndSelOps) Function_Return ""
45222>>>>>>>        
45222>>>>>>>        Get paSelTypes to aTypes
45223>>>>>>>        Function_Return aTypes[i].sDesc
45224>>>>>>>    End_Function  // SelDesc
45225>>>>>>>    
45225>>>>>>>    Function SelDescFromType String sType Returns String
45228>>>>>>>        Integer i
45228>>>>>>>        wqSelType[] aTypes
45228>>>>>>>        wqSelType[] aTypes
45229>>>>>>>        
45229>>>>>>>        Get paSelTypes to aTypes
45230>>>>>>>        
45230>>>>>>>        For i from 0 to (SizeOfArray(aTypes) - 1)
45236>>>>>>>>
45236>>>>>>>            If (sType = aTypes[i].sCode) Function_Return aTypes[i].sDesc
45239>>>>>>>        Loop
45240>>>>>>>>
45240>>>>>>>
45240>>>>>>>        Function_Return ""        
45241>>>>>>>    End_Function  // SelDescFromType
45242>>>>>>>
45242>>>>>>>    Send LoadTypes    
45243>>>>>>>End_Object  // oWqSelectionTypes
45244>>>>>>>
45244>>>>>>>Object oWqSelectionOperators is a cWebModalDialog
45246>>>>>>>    Property Integer wpiOperation
45250>>>>>>>    
45250>>>>>>>    Set psCaption           to "Chose selection operator"
45251>>>>>>>    Set piMinWidth          to 240
45252>>>>>>>    Set piMinHeight         to 410
45253>>>>>>>    Set pbResizable         to False
45254>>>>>>>    Set pbServerOnSubmit    to True    // enable the OnSubmit event
45255>>>>>>>    
45255>>>>>>>    Object oSelOpsMain is a cWebPanel
45257>>>>>>>        Set piColumnCount to 1
45258>>>>>>>        
45258>>>>>>>        Object oOpsList is a cWebList
45260>>>>>>>            Set piColumnSpan     to 0
45261>>>>>>>            Set pbFillHeight     to True
45262>>>>>>>            Set pbDataAware      to False
45263>>>>>>>            Set pbColumnSortable to False
45264>>>>>>>            
45264>>>>>>>            Object oOperatorsCol is a cWebColumn
45266>>>>>>>                Set psCaption to "Selection Operators"
45267>>>>>>>            End_Object
45268>>>>>>>            
45268>>>>>>>            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
45271>>>>>>>                Integer i
45271>>>>>>>                Handle  hoST
45271>>>>>>>                
45271>>>>>>>                Forward Send OnManualLoadData (&aTheRows) (&sCurrentRowID)
45273>>>>>>>                Move (oWqSelectionTypes(Self)) to hoST
45274>>>>>>>                
45274>>>>>>>                For i from 0 to (C_wqEndSelOps - 1)
45280>>>>>>>>
45280>>>>>>>                    Move i                                                  to aTheRows[i].aValues[0]
45281>>>>>>>                    Move (SelDesc(hoST, i) * "(" + SelCode(hoST, i) + ")")  to aTheRows[i].aValues[1]
45282>>>>>>>                Loop
45283>>>>>>>>
45283>>>>>>>                
45283>>>>>>>            End_Procedure  // OnManualLoadData
45284>>>>>>>            
45284>>>>>>>            Procedure OnLoad
45287>>>>>>>                Send GridRefresh
45288>>>>>>>            End_Procedure  // OnLoad
45289>>>>>>>            
45289>>>>>>>        End_Object  // OpsList
45290>>>>>>>        
45290>>>>>>>    End_Object 
45291>>>>>>>    
45291>>>>>>>    Object oSelOpsBottom is a cWebPanel
45293>>>>>>>        Set piColumnCount to 3
45294>>>>>>>        Set peRegion to prBottom
45295>>>>>>>
45295>>>>>>>        Object oSelOpsOkBtn is a cWebButton
45297>>>>>>>            Set psCaption to C_$OK
45298>>>>>>>            Set piColumnSpan to 1
45299>>>>>>>            Set piColumnIndex to 1
45300>>>>>>>
45300>>>>>>>            Procedure OnClick
45303>>>>>>>                Send Ok
45304>>>>>>>            End_Procedure
45305>>>>>>>        End_Object 
45306>>>>>>>
45306>>>>>>>        Object oSelOpsCancelBtn is a cWebButton
45308>>>>>>>            Set psCaption to C_$Cancel
45309>>>>>>>            Set piColumnSpan to 1
45310>>>>>>>            Set piColumnIndex to 2
45311>>>>>>>
45311>>>>>>>            Procedure OnClick
45314>>>>>>>                Send Cancel
45315>>>>>>>            End_Procedure
45316>>>>>>>            
45316>>>>>>>        End_Object 
45317>>>>>>>        
45317>>>>>>>    End_Object 
45318>>>>>>>
45318>>>>>>>    Procedure OnSubmit
45321>>>>>>>        Send Ok
45322>>>>>>>    End_Procedure
45323>>>>>>>    
45323>>>>>>>    Procedure DoPopup Handle hoObj Integer eOp
45326>>>>>>>        WebSet wpiOperation to eOp
45327>>>>>>>        
45327>>>>>>>        Send Popup hoObj
45328>>>>>>>    End_Procedure  // DoPopup 
45329>>>>>>>    
45329>>>>>>>    Function SelectedOperator Returns Integer
45332>>>>>>>        Integer iOp
45332>>>>>>>        
45332>>>>>>>        WebGet psCurrentRowID of oOpsList to iOp
45333>>>>>>>        Function_Return iOp
45334>>>>>>>    End_Function  // SelectedOperator
45335>>>>>>>    
45335>>>>>>>    Function Operation Returns Integer
45338>>>>>>>        Integer eOp
45338>>>>>>>        
45338>>>>>>>        WebGet wpiOperation to eOp
45339>>>>>>>        Function_Return eOp
45340>>>>>>>    End_Function  // Operation
45341>>>>>>>    
45341>>>>>>>End_Object  // oWqSelectionOperators
45342>>>>>Use cWqExprParser.pkg
Including file: cWqExprParser.pkg    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\cWqExprParser.pkg)
45342>>>>>>>Use cExpressionParser.pkg
45342>>>>>>>
45342>>>>>>>Class cWqExprParser is a cExpressionParser
45343>>>>>>>
45343>>>>>>>    // Overridden _fAnd and _fOr to allow for booleans - Sture will probably fix soon
45343>>>>>>>    Function _fAnd tXPValue[] aParameters Returns tXPValue
45345>>>>>>>        tXPValue strRval strParameter1 strParameter2
45345>>>>>>>        tXPValue strRval strParameter1 strParameter2
45345>>>>>>>        Number nVal1 nVal2
45345>>>>>>>        Move aParameters[0] to strParameter1
45346>>>>>>>        Move aParameters[1] to strParameter2
45347>>>>>>>        If ((strParameter1.iValueType=XP_Integer or strParameter1.iValueType=XP_Numeric) and (strParameter2.iValueType=XP_Integer or strParameter2.iValueType=XP_Numeric)) Begin
45349>>>>>>>            Move XP_Boolean to strRval.iValueType
45350>>>>>>>            Move strParameter1.sValue to nVal1
45351>>>>>>>            Move strParameter2.sValue to nVal2
45352>>>>>>>            Move (nVal1<>0 and nVal2<>0) to strRval.sValue
45353>>>>>>>        End
45353>>>>>>>>
45353>>>>>>>        Else Begin
45354>>>>>>>            Move XP_Error to strRval.iValueType
45355>>>>>>>            Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'and'"
45356>>>>>>>>
45356>>>>>>>        End
45356>>>>>>>>
45356>>>>>>>        Function_Return strRval
45357>>>>>>>    End_Function
45358>>>>>>>    
45358>>>>>>>    Function _fOr tXPValue[] aParameters Returns tXPValue
45360>>>>>>>        tXPValue strRval strParameter1 strParameter2
45360>>>>>>>        tXPValue strRval strParameter1 strParameter2
45360>>>>>>>        Number nVal1 nVal2
45360>>>>>>>        Move aParameters[0] to strParameter1
45361>>>>>>>        Move aParameters[1] to strParameter2
45362>>>>>>>        If ((strParameter1.iValueType=XP_Integer or strParameter1.iValueType=XP_Numeric) and (strParameter2.iValueType=XP_Integer or strParameter2.iValueType=XP_Numeric)) Begin
45364>>>>>>>            Move XP_Boolean to strRval.iValueType
45365>>>>>>>            Move strParameter1.sValue to nVal1
45366>>>>>>>            Move strParameter2.sValue to nVal2
45367>>>>>>>            Move (nVal1<>0 or nVal2<>0) to strRval.sValue
45368>>>>>>>        End
45368>>>>>>>>
45368>>>>>>>        Else Begin
45369>>>>>>>            Move XP_Error to strRval.iValueType
45370>>>>>>>            Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'or'"
45371>>>>>>>>
45371>>>>>>>        End
45371>>>>>>>>
45371>>>>>>>        Function_Return strRval
45372>>>>>>>    End_Function
45373>>>>>>>    // End overrides
45373>>>>>>>    
45373>>>>>>>    Function _fInteger tXPValue[] aParameters Returns tXPValue
45375>>>>>>>        tXPValue strRval
45375>>>>>>>        tXPValue strRval
45375>>>>>>>        
45375>>>>>>>        Move (Integer(aParameters[0].sValue)) to strRval.sValue
45376>>>>>>>        Move XP_Integer                       to strRval.iValueType
45377>>>>>>>        Function_Return strRval
45378>>>>>>>    End_Function
45379>>>>>>>
45379>>>>>>>    Function _fString tXPValue[] aParameters Returns tXPValue
45381>>>>>>>        tXPValue strRval
45381>>>>>>>        tXPValue strRval
45381>>>>>>>        
45381>>>>>>>        Move (String(aParameters[0].sValue)) to strRval.sValue
45382>>>>>>>        Move XP_String                       to strRval.iValueType
45383>>>>>>>        Function_Return strRval
45384>>>>>>>    End_Function
45385>>>>>>>
45385>>>>>>>    Function _fNumber tXPValue[] aParameters Returns tXPValue
45387>>>>>>>        tXPValue strRval
45387>>>>>>>        tXPValue strRval
45387>>>>>>>        
45387>>>>>>>        Move (Number(aParameters[0].sValue)) to strRval.sValue
45388>>>>>>>        Move XP_Numeric                      to strRval.iValueType
45389>>>>>>>        Function_Return strRval
45390>>>>>>>    End_Function
45391>>>>>>>
45391>>>>>>>    Function _fDate tXPValue[] aParameters Returns tXPValue
45393>>>>>>>        tXPValue strRval
45393>>>>>>>        tXPValue strRval
45393>>>>>>>        
45393>>>>>>>        Move (Date(aParameters[0].sValue)) to strRval.sValue
45394>>>>>>>        Move XP_Date                       to strRval.iValueType
45395>>>>>>>        Function_Return strRval
45396>>>>>>>    End_Function
45397>>>>>>>    
45397>>>>>>>    Function _fConcat tXPValue[] aParameters Returns tXPValue
45399>>>>>>>        tXPValue strRval
45399>>>>>>>        tXPValue strRval
45399>>>>>>>        
45399>>>>>>>        Move (String(aParameters[0].sValue) + String(aParameters[1].sValue)) to strRval.sValue
45400>>>>>>>        Move XP_String to strRval.iValueType
45401>>>>>>>        Function_Return strRval
45402>>>>>>>    End_Function
45403>>>>>>>    
45403>>>>>>>    Function _fAmp tXPValue[] aParameters Returns tXPValue
45405>>>>>>>        tXPValue tRet
45405>>>>>>>        tXPValue tRet
45405>>>>>>>        
45405>>>>>>>        Move (String(aParameters[0].sValue) + String(aParameters[1].sValue)) to tRet.sValue
45406>>>>>>>        Move XP_String to tRet.iValueType
45407>>>>>>>        
45407>>>>>>>        Function_Return tRet
45408>>>>>>>    End_Function
45409>>>>>>>    
45409>>>>>>>    Function _fDateAsTextEU tXPValue[] aParameters Returns tXPValue
45411>>>>>>>        tXPValue tRetVal
45411>>>>>>>        tXPValue tRetVal
45411>>>>>>>        
45411>>>>>>>        Get DateToText of oDateFunctions aParameters[0].sValue "#D #MN #Y4" to tRetVal.sValue
45412>>>>>>>        Move XP_String to tRetVal.iValueType
45413>>>>>>>        Function_Return tRetVal
45414>>>>>>>    End_Function
45415>>>>>>>    
45415>>>>>>>    Function _fDateAsTextUS tXPValue[] aParameters Returns tXPValue
45417>>>>>>>        tXPValue tRetVal
45417>>>>>>>        tXPValue tRetVal
45417>>>>>>>        
45417>>>>>>>        Get DateToText of oDateFunctions aParameters[0].sValue "#MN #D #Y4" to tRetVal.sValue
45418>>>>>>>        Move XP_String to tRetVal.iValueType
45419>>>>>>>        Function_Return tRetVal
45420>>>>>>>    End_Function
45421>>>>>>>    
45421>>>>>>>    Function _fDateFormatText tXPValue[] aParameters Returns tXPValue
45423>>>>>>>        tXPValue tRetVal
45423>>>>>>>        tXPValue tRetVal
45423>>>>>>>        
45423>>>>>>>        Get DateToText of oDateFunctions aParameters[0].sValue aParameters[1].sValue to tRetVal.sValue
45424>>>>>>>        Move XP_String to tRetVal.iValueType
45425>>>>>>>        Function_Return tRetVal
45426>>>>>>>    End_Function
45427>>>>>>>    
45427>>>>>>>    Function _fFirstDayInMonth tXPValue[] aParameters Returns tXPValue
45429>>>>>>>        tXPValue tRetVal
45429>>>>>>>        tXPValue tRetVal
45429>>>>>>>        Date     dDate
45429>>>>>>>        
45429>>>>>>>        Move aParameters[0].sValue        to dDate
45430>>>>>>>        Move (Date(DateSetDay(dDate, 1))) to tRetVal.sValue
45431>>>>>>>        Move XP_Date                      to tRetVal.iValueType
45432>>>>>>>        Function_Return tRetVal
45433>>>>>>>    End_Function
45434>>>>>>>    
45434>>>>>>>    // ToDo: Ensure that all WebQuery functions are defined and working
45434>>>>>>>    
45434>>>>>>>    // Augmented OnDefineFunctions to add in the extras we want.
45434>>>>>>>    // Take them (and any implementations above) out as and when they
45434>>>>>>>    // become available in Sture's cExpressionParser
45434>>>>>>>    Procedure OnDefineFunctions tXPGrammar ByRef strGrammar 
45436>>>>>>>        Forward Send OnDefineFunctions (&strGrammar)
45438>>>>>>>        
45438>>>>>>>        Send DefineFunction (&strGrammar) "DateAsTextEU"      1 XP_Date    (RefFunc(_fDateAsTextEU))
45439>>>>>>>        Send DefineFunction (&strGrammar) "DateAsTextUS"      1 XP_Date    (RefFunc(_fDateAsTextUS))
45440>>>>>>>        Send DefineFunction (&strGrammar) "DateFormatText"  2 XP_Date    (RefFunc(_fDateFormatText))
45441>>>>>>>        Send DefineFunction (&strGrammar) "Integer"         1 XP_Integer (RefFunc(_fInteger))
45442>>>>>>>        Send DefineFunction (&strGrammar) "String"          1 XP_String  (RefFunc(_fString))
45443>>>>>>>        Send DefineFunction (&strGrammar) "Number"          1 XP_Numeric (RefFunc(_fNumber))
45444>>>>>>>        Send DefineFunction (&strGrammar) "Date"            1 XP_Date    (RefFunc(_fDate))
45445>>>>>>>        Send DefineFunction (&strGrammar) "Concat"          2 XP_String  (RefFunc(_fConcat))
45446>>>>>>>//        Send DefineFunction (&strGrammar) "DateIncrement"   3 XP_Date    (RefFunc(_fDateIncrement))
45446>>>>>>>        Send DefineFunction (&strGrammar) "FirstDayInMonth" 1 XP_Date    (RefFunc(_fFirstDayInMonth))
45447>>>>>>>//        Send DefineFunction (&strGrammar) "If_Int"          3 XP_Boolean (RefFunc(_fIf_Int))
45447>>>>>>>//        Send DefineFunction (&strGrammar) "If_Num"          3 XP_Boolean (RefFunc(_fIf_Num))
45447>>>>>>>//        Send DefineFunction (&strGrammar) "If_Str"          3 XP_Boolean (RefFunc(_fIf_Str))
45447>>>>>>>//        Send DefineFunction (&strGrammar) "If_Dat"          3 XP_Boolean (RefFunc(_fIf_Dat))
45447>>>>>>>    End_Procedure
45448>>>>>>>    
45448>>>>>>>    Procedure OnDefineOperators tXPGrammar byref strGrammar
45450>>>>>>>        Forward Send OnDefineOperators (&strGrammar)
45452>>>>>>>        
45452>>>>>>>        Send DefineOperator (&strGrammar) "&" 2 0 0 (RefFunc(_fAmp))
45453>>>>>>>    End_Procedure
45454>>>>>>>
45454>>>>>>>End_Class
45455>>>>>
45455>>>>>Struct wqDir
45455>>>>>    Boolean bDir
45455>>>>>    String  sName
45455>>>>>End_Struct
45455>>>>>
45455>>>>>Struct wqTableInfo
45455>>>>>    Integer iNum
45455>>>>>    String  sDispName
45455>>>>>    String  sDFName
45455>>>>>    String  sRootName
45455>>>>>End_Struct
45455>>>>>
45455>>>>>Global_Variable Handle ghoWebQry
45455>>>>>Global_Variable Handle ghoWQF
45455>>>>>
45455>>>>>Enum_List
45455>>>>>    Define C_wqAppendRow for 0
45455>>>>>    Define C_wqInsertRow
45455>>>>>    Define C_wqDeleteRow
45455>>>>>    Define C_wqAddExpression
45455>>>>>    Define C_wqInsertExpression 
45455>>>>>    Define C_wqEditExpression
45455>>>>>    Define C_wqSelectExpr
45455>>>>>    Define C_wqAssembleSave
45455>>>>>    Define C_wqAssembleRun
45455>>>>>    Define C_wqMoveRowUp
45455>>>>>    Define C_wqMoveRowDown
45455>>>>>    Define C_wqNoOp
45455>>>>>    Define C_wqSaveData
45455>>>>>    Define C_wqGetIndexInfo
45455>>>>>End_Enum_List
45455>>>>>
45455>>>>>Enum_List
45455>>>>>    Define C_wqModalWin for 0
45455>>>>>    Define C_wqNewTab
45455>>>>>    Define C_wqNewWin
45455>>>>>    Define C_wqDownload
45455>>>>>End_Enum_List
45455>>>>>
45455>>>>>Enum_List
45455>>>>>    Define C_wqViewOutput
45455>>>>>    Define C_wqDownloadOutput
45455>>>>>End_Enum_List
45455>>>>>
45455>>>>>Enum_List
45455>>>>>    Define C_wqOutputHtml
45455>>>>>    Define C_wqOutputText
45455>>>>>    Define C_wqOutputCSV
45455>>>>>    Define C_wqOutputXML
45455>>>>>End_Enum_List
45455>>>>>
45455>>>>>Struct wqPrintField
45455>>>>>    Boolean bCalc
45455>>>>>    Integer iTable
45455>>>>>    Integer iColumn
45455>>>>>    String  sUserName
45455>>>>>    Boolean bSum
45455>>>>>    Boolean bCR
45455>>>>>    String  sExpression
45455>>>>>    String  sLongLabel
45455>>>>>    Integer iWidth
45455>>>>>    Integer iType
45455>>>>>    Integer iDecimals
45455>>>>>End_Struct
45455>>>>>
45455>>>>>Struct wqTableDetail
45455>>>>>    Integer  iTabNum
45455>>>>>    String   sName
45455>>>>>    String[] asFieldNames
45455>>>>>End_Struct
45455>>>>>
45455>>>>>Struct wqSelections
45455>>>>>    Integer iTable
45455>>>>>    Integer iColumn
45455>>>>>    String  sUserName
45455>>>>>    String  sType
45455>>>>>    String  sValue
45455>>>>>    Integer iType
45455>>>>>End_Struct
45455>>>>>
45455>>>>>Struct wqSelsForTQ
45455>>>>>    wqSelections Selection
45455>>>>>    wqSelections Selection
45455>>>>>    Boolean  bUseTQ
45455>>>>>    Boolean  bInList
45455>>>>>    String   sStartR
45455>>>>>    String   sEndR
45455>>>>>    String[] aList
45455>>>>>End_Struct
45455>>>>>
45455>>>>>Struct wqIndexSeg
45455>>>>>    Integer iTable
45455>>>>>    Integer iField
45455>>>>>    Boolean bBreak
45455>>>>>    Boolean bUC
45455>>>>>    Boolean bDesc
45455>>>>>    String  sName
45455>>>>>End_Struct
45455>>>>>
45455>>>>>Struct wqWebQuery
45455>>>>>    String  sTitle
45455>>>>>    Handle  hMainTable
45455>>>>>    String  sSelectExpression
45455>>>>>    wqPrintField[] aPrintFields
45455>>>>>    wqPrintField[] aPrintFields
45455>>>>>    wqSelections[] aSelections
45455>>>>>    wqSelections[] aSelections
45455>>>>>    wqIndexSeg[]   aSegments
45455>>>>>    wqIndexSeg[]   aSegments
45455>>>>>    Integer iIndex
45455>>>>>    Integer iSearchOrd
45455>>>>>    String  sTextBefore
45455>>>>>    String  sTextAfter
45455>>>>>    String  sTypeface
45455>>>>>    String  sFontSize
45455>>>>>    String  sTextColour
45455>>>>>    String  sBGColour
45455>>>>>    Boolean bHighlightAlt
45455>>>>>    String  sHighlightColour
45455>>>>>    Boolean bPrintSels
45455>>>>>    Boolean bTotalsOnly
45455>>>>>    Boolean bPrintCount
45455>>>>>    Integer iDestination
45455>>>>>    Integer iOutputFormat
45455>>>>>    Boolean bColHeads
45455>>>>>    Boolean bGeneratedLine
45455>>>>>    Boolean bUseSQL
45455>>>>>End_Struct
45455>>>>>
45455>>>>>Struct wqColour
45455>>>>>    Integer iRed
45455>>>>>    Integer iGreen
45455>>>>>    Integer iBlue
45455>>>>>End_Struct
45455>>>>>
45455>>>>>Struct wqBreakpoint
45455>>>>>    Integer iTable
45455>>>>>    Integer iColumn
45455>>>>>    String  sName
45455>>>>>    String  sPrevValue
45455>>>>>End_Struct
45455>>>>>
45455>>>>>Struct wqPrintColumn
45455>>>>>    String   sName
45455>>>>>    Integer  iTable
45455>>>>>    Integer  iColumn
45455>>>>>    Integer  iType
45455>>>>>    Integer  iWidth
45455>>>>>    Integer  iDecimals
45455>>>>>    Integer  iPrintWidth
45455>>>>>    String   sExpr
45455>>>>>    Boolean  bCR
45455>>>>>    Boolean  bCalc
45455>>>>>    String   sCurVal
45455>>>>>    Boolean  bSum
45455>>>>>    Number[] anSum
45455>>>>>End_Struct
45455>>>>>
45455>>>>>Struct wqPrintRowPart
45455>>>>>    wqPrintColumn[] aColumns
45455>>>>>    wqPrintColumn[] aColumns
45455>>>>>End_Struct
45455>>>>>
45455>>>>>Struct wqPrintRowLayout
45455>>>>>    wqPrintRowPart[] aParts
45455>>>>>    wqPrintRowPart[] aParts
45455>>>>>    Integer iMaxCols
45455>>>>>    Integer iCount
45455>>>>>End_Struct
45455>>>>>
45455>>>>>Struct wqTableField
45455>>>>>    Handle  hTable
45455>>>>>    Integer iField
45455>>>>>End_Struct
45455>>>>>
45455>>>>>Define C_wqValidXmlChars   for "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_"
45455>>>>>Define C_wqInvalidDirChars for '/\?%*:|"<>'
45455>>>>>Define C_wqPublicDir       for "\Public"
45455>>>>>
45455>>>>>Register_Function phLoggedInFunc   Returns Boolean
45455>>>>>Register_Function phUserNameFunc   Returns String
45455>>>>>Register_Function pbAllowRawOutput Returns Boolean
45455>>>>>
45455>>>>>Object oWqExprPar is a cWqExprParser
45457>>>>>End_Object
45458>>>>>
45458>>>>>Object oWqXml is a cXmlBuilder
45460>>>>>End_Object
45461>>>>>
45461>>>>>Class cWebQueryFunctions is a cObject
45462>>>>>    
45462>>>>>    Procedure Construct_Object
45464>>>>>        Forward Send Construct_Object
45466>>>>>        
45466>>>>>        Property Handle[]       pahExcludedTables
45467>>>>>        Property wqTableField[] patExcludedFields
45468>>>>>        Property Integer        piChannel
45469>>>>>    End_Procedure
45470>>>>>    
45470>>>>>    Function StrAddQuotes String sVal Returns String
45472>>>>>        Function_Return ('"' + Trim(sVal) + '"')
45473>>>>>    End_Function
45474>>>>>    
45474>>>>>    Function StrDelQuotes String sVal Returns String
45476>>>>>        If (Left(sVal, 1) = '"')  Move (Right(sVal, (Length(sVal) - 1)))    to sVal
45479>>>>>        If (Right(sVal, 1) = '"') Move  (Left(sVal,  (Length(sVal) - 1)))   to sVal
45482>>>>>        Function_Return sVal
45483>>>>>    End_Function
45484>>>>>    
45484>>>>>    Function XmlTag String sName Returns String
45486>>>>>        Integer i iLen
45486>>>>>        
45486>>>>>        Move (Trim(sName))   to sName
45487>>>>>        Move (Length(sName)) to iLen
45488>>>>>        
45488>>>>>        For i from 1 to iLen
45494>>>>>>
45494>>>>>            If not (C_wqValidXmlChars contains Uppercase(Mid(sName, 1, i))) Move (Overstrike("_", sName, i)) to sName 
45497>>>>>        Loop
45498>>>>>>
45498>>>>>        
45498>>>>>        Function_Return sName
45499>>>>>    End_Function
45500>>>>>    
45500>>>>>    Function UpperChar String sData Integer iChar Returns String
45502>>>>>        Function_Return (Overstrike(Uppercase(Mid(sData, 1, iChar)), sData, iChar))
45503>>>>>    End_Function
45504>>>>>    
45504>>>>>    Function NiceFieldName Handle hTab Integer iCol Returns String
45506>>>>>        String  sName
45506>>>>>        Integer i
45506>>>>>        
45506>>>>>        Open hTab
45508>>>>>        Get_Attribute DF_FIELD_NAME of hTab iCol    to sName
45511>>>>>        Move (Replaces("_", sName, " "))            to sName
45512>>>>>        Move (Lowercase(sName))                     to sName
45513>>>>>        
45513>>>>>        For i from 1 to (Length(sName))
45519>>>>>>
45519>>>>>            If ((i = 1) or (Mid(sName, 1, (i - 1)) = " ")) Move (UpperChar(Self, sName, i)) to sName
45522>>>>>        Loop
45523>>>>>>
45523>>>>>        
45523>>>>>        Function_Return sName        
45524>>>>>    End_Function
45525>>>>>    
45525>>>>>    Function TableLoaded tWebRow[] ByRef aRows Handle hTab Returns Boolean
45527>>>>>        Integer i
45527>>>>>        
45527>>>>>        For i from 0 to (SizeOfArray(aRows) - 1)
45533>>>>>>
45533>>>>>            If (aRows[i].aValues[0] = hTab) Function_Return True
45536>>>>>        Loop
45537>>>>>>
45537>>>>>        
45537>>>>>        Function_Return False
45538>>>>>    End_Function
45539>>>>>    
45539>>>>>    Function TableMissing Handle hTab Returns Boolean
45541>>>>>        Handle hNext
45541>>>>>        
45541>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of (hTab - 1) to hNext
45544>>>>>        Function_Return (hNext = hTab)
45545>>>>>    End_Function
45546>>>>>    
45546>>>>>    Function ExcludedTable Handle hTable Returns Boolean
45548>>>>>        Handle[] ahExcluded
45549>>>>>        Integer  i
45549>>>>>        
45549>>>>>        Get pahExcludedTables to ahExcluded
45550>>>>>        
45550>>>>>        For i from 0 to (SizeOfArray(ahExcluded) - 1)
45556>>>>>>
45556>>>>>            If (hTable = ahExcluded[i]) Function_Return True
45559>>>>>        Loop
45560>>>>>>
45560>>>>>        
45560>>>>>        Function_Return False
45561>>>>>    End_Function
45562>>>>>    
45562>>>>>    Function ExcludedField Handle hTable Integer iField Returns Boolean
45564>>>>>        wqTableField[] atExcluded
45564>>>>>        wqTableField[] atExcluded
45565>>>>>        Integer i
45565>>>>>        
45565>>>>>        Get patExcludedFields to atExcluded
45566>>>>>        
45566>>>>>        For i from 0 to (SizeOfArray(atExcluded) - 1)
45572>>>>>>
45572>>>>>            If ((hTable = atExcluded[i].hTable) and ;                (iField = atExcluded[i].iField)) Function_Return True
45575>>>>>        Loop
45576>>>>>>
45576>>>>>        
45576>>>>>        Function_Return False
45577>>>>>    End_Function
45578>>>>>    
45578>>>>>    Procedure RelatedFiles tWebRow[] ByRef aRows Handle hTab
45580>>>>>        Integer iFlds iFld iNext
45580>>>>>        Handle  hRel
45580>>>>>        
45580>>>>>        If (hTab = 0)                 Procedure_Return
45583>>>>>        If (TableMissing(Self, hTab)) Procedure_Return
45586>>>>>        
45586>>>>>        Move (SizeOfArray(aRows)) to iNext
45587>>>>>    
45587>>>>>        Open hTab
45589>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTab to iFlds
45592>>>>>        Move hTab                                   to aRows[iNext].aValues[0]
45593>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTab to aRows[iNext].aValues[1]
45596>>>>>        
45596>>>>>        For iFld from 1 to iFlds
45602>>>>>>
45602>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTab iFld to hRel
45605>>>>>            If (hRel and not(TableLoaded(Self, &aRows, hRel)) and ;                         not(ExcludedTable(Self, hRel))) Send RelatedFiles (&aRows) hRel
45608>>>>>        Loop
45609>>>>>>
45609>>>>>    
45609>>>>>    End_Procedure
45610>>>>>    
45610>>>>>    Function TableOpened Handle hTab wqTableDetail[] ByRef ahOpened Returns Boolean
45612>>>>>        Integer i
45612>>>>>        
45612>>>>>        For i from 0 to (SizeOfArray(ahOpened) - 1)
45618>>>>>>
45618>>>>>            If (ahOpened[i].iTabNum = hTab) Function_Return True
45621>>>>>        Loop
45622>>>>>>
45622>>>>>        
45622>>>>>        Function_Return False
45623>>>>>    End_Function
45624>>>>>    
45624>>>>>    Procedure CollectColumns tWebRow[] ByRef aRows Handle hTab
45626>>>>>        Integer iCols iCol iType iIdx
45626>>>>>        String  sName
45626>>>>>        
45626>>>>>        If not hTab Procedure_Return
45629>>>>>        
45629>>>>>        Open hTab
45631>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTab to iCols
45634>>>>>        Move 0 to iIdx
45635>>>>>        
45635>>>>>        For iCol from 1 to iCols
45641>>>>>>
45641>>>>>            Get_Attribute DF_FIELD_NAME of hTab iCol to sName
45644>>>>>            Get_Attribute DF_FIELD_TYPE of hTab iCol to iType
45647>>>>>            
45647>>>>>            If ((Left(sName, 1) <> "@") and (iType <> DF_OVERLAP) and ;                (iType <> DF_BINARY) and not(ExcludedField(Self, hTab, iCol))) Begin
45649>>>>>                Move iCol                               to aRows[iIdx].aValues[0]
45650>>>>>                Move (NiceFieldName(Self, hTab, iCol))  to aRows[iIdx].aValues[1]
45651>>>>>                Increment iIdx
45652>>>>>            End
45652>>>>>>
45652>>>>>            
45652>>>>>        Loop
45653>>>>>>
45653>>>>>        
45653>>>>>    End_Procedure
45654>>>>>    
45654>>>>>    Function WebDataType Integer iType Returns Integer
45656>>>>>        If (iType = DF_BCD)         Function_Return typeNumber
45659>>>>>        If (iType = DF_DATE)        Function_Return typeDate
45662>>>>>        If (iType = DF_DATETIME)    Function_Return typeDateTime
45665>>>>>        Function_Return                             typeASCII
45666>>>>>    End_Function
45667>>>>>    
45667>>>>>    Function StorePath Returns String
45669>>>>>        String  sPath
45669>>>>>        
45669>>>>>        Get psStoreDirectory of ghoWebQry to sPath
45670>>>>>                
45670>>>>>        Function_Return sPath
45671>>>>>    End_Function
45672>>>>>    
45672>>>>>    Function PublicPath Returns String
45674>>>>>        Function_Return (StorePath(Self) + C_wqPublicDir)
45675>>>>>    End_Function
45676>>>>>    
45676>>>>>    Function PrivatePath Returns String
45678>>>>>        String  sUser
45678>>>>>        Boolean bLoggedIn
45678>>>>>        Handle  hoSess hLoggedInFunc hUserNameFunc
45678>>>>>        
45678>>>>>        Get phoSessionObj of ghoWebQry to hoSess
45679>>>>>        
45679>>>>>        If hoSess Begin
45681>>>>>            Get phLoggedInFunc of ghoWebQry to hLoggedInFunc
45682>>>>>            Get phUserNameFunc of ghoWebQry to hUserNameFunc
45683>>>>>            
45683>>>>>            If (hLoggedInFunc and hUserNameFunc) Begin
45685>>>>>                Get hLoggedInFunc of hoSess to bLoggedIn
45686>>>>>                
45686>>>>>                If bLoggedIn Begin
45688>>>>>                    Get hUserNameFunc of hoSess to sUser
45689>>>>>                    Move (Trim(sUser)) to sUser
45690>>>>>                    Function_Return (StorePath(Self) + "\" + sUser)
45691>>>>>                End
45691>>>>>>
45691>>>>>                
45691>>>>>            End
45691>>>>>>
45691>>>>>            
45691>>>>>        End
45691>>>>>>
45691>>>>>        
45691>>>>>        Function_Return ""
45692>>>>>    End_Function
45693>>>>>    
45693>>>>>    Procedure MakeDirectories
45695>>>>>        Integer iChn
45695>>>>>        String  sPrivPath
45695>>>>>        
45695>>>>>        Get Seq_New_Channel to iChn
45696>>>>>        
45696>>>>>        Direct_Input channel iChn  ("dir:" + StorePath(Self))
45698>>>>>        
45698>>>>>        If (SeqEof) Begin
45700>>>>>            Make_Directory (StorePath(Self))
45701>>>>>            Make_Directory (PublicPath(Self))
45702>>>>>        End
45702>>>>>>
45702>>>>>        
45702>>>>>        Close_Input channel iChn
45704>>>>>        
45704>>>>>        Get PrivatePath to sPrivPath
45705>>>>>        
45705>>>>>        If (sPrivPath <> "") Begin
45707>>>>>            Direct_Input channel iChn ("dir:" + PrivatePath(Self))
45709>>>>>        
45709>>>>>            If (SeqEof) Make_Directory (PrivatePath(Self))
45712>>>>>        
45712>>>>>            Close_Input channel iChn
45714>>>>>        End
45714>>>>>>
45714>>>>>        
45714>>>>>        Send Seq_Release_Channel iChn
45715>>>>>    End_Procedure
45716>>>>>    
45716>>>>>    Function FileMatch String sFile String sFilter Returns Boolean
45718>>>>>        Integer iPos
45718>>>>>        String  sName sExt sNSpec sESpec
45718>>>>>        
45718>>>>>        Move (Pos(".", sFile)) to iPos
45719>>>>>        
45719>>>>>        If iPos Begin
45721>>>>>            Move (Left(sFile, (iPos - 1)))              to sName
45722>>>>>            Move (Right(sFile, (Length(sFile) - iPos))) to sExt
45723>>>>>        End
45723>>>>>>
45723>>>>>        Else Begin
45724>>>>>            Move sFile to sName
45725>>>>>            Move ""    to sExt 
45726>>>>>        End
45726>>>>>>
45726>>>>>        
45726>>>>>        Move (Pos(".", sFilter)) to iPos
45727>>>>>        
45727>>>>>        If iPos Begin
45729>>>>>            Move (Left(sFilter, (iPos - 1)))                to sNSpec
45730>>>>>            Move (Right(sFilter, (Length(sFilter) - iPos))) to sESpec
45731>>>>>        End
45731>>>>>>
45731>>>>>        Else Begin
45732>>>>>            Move sFilter to sNSpec
45733>>>>>            Move ""      to sESpec
45734>>>>>        End
45734>>>>>>
45734>>>>>        
45734>>>>>        Function_Return ((sName matches sNSpec) and ((sExt matches sESpec) or (sESpec = ""))) 
45735>>>>>    End_Function
45736>>>>>    
45736>>>>>    Function DirectoryContents String sPath String sFilter Returns wqDir[]
45738>>>>>        Integer iChn i
45738>>>>>        String  sVal
45738>>>>>        Boolean bDir bMatch
45738>>>>>        wqDir[] aContents
45738>>>>>        wqDir[] aContents
45739>>>>>        
45739>>>>>        Get Seq_New_Channel to iChn
45740>>>>>        
45740>>>>>        Move 0 to i
45741>>>>>        Direct_Input channel iChn ("dir:" + sPath)
45743>>>>>        
45743>>>>>        While not (SeqEof)
45747>>>>>            Readln sVal
45748>>>>>            
45748>>>>>            If (not(SeqEof) and (sVal <> "[.]") and (sVal <> "[..]")) Begin
45750>>>>>                Move (Left(sVal, 1) = "[")    to bDir
45751>>>>>                Move (Replace("[", sVal, "")) to sVal
45752>>>>>                Move (Replace("]", sVal, "")) to sVal
45753>>>>>                
45753>>>>>                If not bDir Move (FileMatch(Self, sVal, sFilter)) to bMatch
45756>>>>>                
45756>>>>>                If (bDir or bMatch) Begin
45758>>>>>                    Move bDir to aContents[i].bDir
45759>>>>>                    Move sVal to aContents[i].sName
45760>>>>>                    Increment i
45761>>>>>                End
45761>>>>>>
45761>>>>>                
45761>>>>>            End
45761>>>>>>
45761>>>>>            
45761>>>>>        Loop
45762>>>>>>
45762>>>>>        
45762>>>>>        Close_Input
45763>>>>>        Send Seq_Release_Channel iChn
45764>>>>>        
45764>>>>>        Function_Return aContents
45765>>>>>    End_Function
45766>>>>>    
45766>>>>>    Function FilenameFromPath String sValue Returns String
45768>>>>>        Integer iPos
45768>>>>>        
45768>>>>>        Repeat
45768>>>>>>
45768>>>>>            Move (Pos("\", sValue)) to iPos
45769>>>>>            If iPos Move (Right(sValue, (Length(sValue) - iPos))) to sValue
45772>>>>>        Until (iPos <= 0)
45774>>>>>                
45774>>>>>        Function_Return sValue        
45775>>>>>    End_Function
45776>>>>>    
45776>>>>>    Function TableInfo Returns wqTableInfo[]
45778>>>>>        Handle  hTab
45778>>>>>        Integer i
45778>>>>>        String  sDisp
45778>>>>>        wqTableInfo[] tTabs
45778>>>>>        wqTableInfo[] tTabs
45779>>>>>        
45779>>>>>        Move 0 to hTab
45780>>>>>        Move 0 to i
45781>>>>>        
45781>>>>>        Repeat
45781>>>>>>
45781>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTab to hTab
45784>>>>>            
45784>>>>>            If hTab Begin
45786>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTab to sDisp
45789>>>>>                
45789>>>>>                If ((Left(sDisp, 1) <> "@") and not(ExcludedTable(Self, hTab))) Begin
45791>>>>>                    Move hTab                                   to tTabs[i].iNum
45792>>>>>                    Move sDisp                                  to tTabs[i].sDispName
45793>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTab  to tTabs[i].sDFName
45796>>>>>                    Get_Attribute DF_FILE_ROOT_NAME    of hTab  to tTabs[i].sRootName
45799>>>>>                    Increment i
45800>>>>>                End
45800>>>>>>
45800>>>>>                
45800>>>>>            End
45800>>>>>>
45800>>>>>            
45800>>>>>        Until not hTab
45802>>>>>        
45802>>>>>        Function_Return tTabs
45803>>>>>    End_Function
45804>>>>>    
45804>>>>>    Function SerializeField wqPrintField tField Returns String
45806>>>>>        String  sField
45806>>>>>        
45806>>>>>        Get VariantToString of oStructFunctions tField to sField
45807>>>>>        Function_Return sField
45808>>>>>    End_Function
45809>>>>>    
45809>>>>>    Function DeSerializeField String sField Returns wqPrintField
45811>>>>>        tValueTree tVT
45811>>>>>        tValueTree tVT
45811>>>>>        wqPrintField tField
45811>>>>>        wqPrintField tField
45811>>>>>        
45811>>>>>        Get StringToValueTree of oStructFunctions sField to tVT
45812>>>>>        ValueTreeDeserializeParameter tVT to tField
45813>>>>>        Function_Return tField
45814>>>>>    End_Function
45815>>>>>    
45815>>>>>    Function DeserializeFields String sData Returns wqPrintField[]
45817>>>>>        wqPrintField[] aFields
45817>>>>>        wqPrintField[] aFields
45818>>>>>        tValueTree tVT
45818>>>>>        tValueTree tVT
45818>>>>>        
45818>>>>>        Get StringToValueTree of oStructFunctions sData to tVT
45819>>>>>        ValueTreeDeserializeParameter tVT to aFields
45820>>>>>        
45820>>>>>        Function_Return aFields                
45821>>>>>    End_Function
45822>>>>>    
45822>>>>>    Procedure TableDetails Handle hTab wqTableDetail[] ByRef atTabDets
45824>>>>>        Integer iFlds iFld iIdx
45824>>>>>        Handle  hRel
45824>>>>>        
45824>>>>>        If (hTab = 0)                 Procedure_Return
45827>>>>>        If (TableMissing(Self, hTab)) Procedure_Return
45830>>>>>
45830>>>>>        Move (SizeOFArray(atTabDets)) to iIdx
45831>>>>>        
45831>>>>>        Open hTab
45833>>>>>        Move hTab                                  to atTabDets[iIdx].iTabNum
45834>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTab to atTabDets[iIdx].sName
45837>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTab to iFlds
45840>>>>>        
45840>>>>>        For iFld from 1 to iFlds
45846>>>>>>
45846>>>>>            Get_Attribute DF_FIELD_NAME         of hTab iFld to atTabDets[iIdx].asFieldNames[iFld]
45849>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTab iFld to hRel
45852>>>>>            If (hRel and not (TableOpened(Self, hRel, &atTabDets))) Send TableDetails hRel (&atTabDets)
45855>>>>>        Loop
45856>>>>>>
45856>>>>>        
45856>>>>>    End_Procedure
45857>>>>>    
45857>>>>>    Function TableIdx String sTab wqTableDetail[] ByRef atTabDets Returns Integer
45859>>>>>        Integer i
45859>>>>>        
45859>>>>>        For i from 0 to (SizeOFArray(atTabDets) - 1)
45865>>>>>>
45865>>>>>            If (Uppercase(sTab) = Uppercase(atTabDets[i].sName)) Function_Return i
45868>>>>>        Loop
45869>>>>>>
45869>>>>>        
45869>>>>>        Function_Return -1
45870>>>>>    End_Function
45871>>>>>
45871>>>>>    Function FieldIdx Integer iTab String sCol wqTableDetail[] ByRef atTabDets Returns Integer
45873>>>>>        Integer i
45873>>>>>        
45873>>>>>        For i from 0 to (SizeOFArray(atTabDets[iTab].asFieldNames) - 1)
45879>>>>>>
45879>>>>>            If (Uppercase(sCol) = Uppercase(atTabDets[iTab].asFieldNames[i])) Function_Return i
45882>>>>>        Loop
45883>>>>>>
45883>>>>>      
45883>>>>>        Function_Return -1
45884>>>>>    End_Function
45885>>>>>    
45885>>>>>    Function MilDate2Date String sDate Returns String
45887>>>>>        Integer iFmt iLen iSep
45887>>>>>        String  sRes sSep
45887>>>>>        
45887>>>>>        Get_Attribute DF_DATE_FORMAT    to iFmt
45890>>>>>        Get_Attribute DF_DATE_SEPARATOR to iSep
45893>>>>>        Move (Character(iSep))          to sSep
45894>>>>>        Move (Trim(sDate))              to sDate
45895>>>>>        Move (Length(sDate))            to iLen
45896>>>>>        
45896>>>>>        // Just not a valid length - return the input unchanged
45896>>>>>        If not ((iLen = 8) or (iLen = 10)) Function_Return sDate
45899>>>>>        
45899>>>>>        // If the format is military, just return the input
45899>>>>>        If (iFmt = DF_DATE_MILITARY) Function_Return sDate
45902>>>>>        
45902>>>>>        If (iFmt = DF_DATE_EUROPEAN) Begin
45904>>>>>            If (iLen = 10) Move (Right(sDate, 2) + sSep + Mid(sDate, 2, 6) + sSep + Left(sDate, 4)) to sRes
45907>>>>>            Else           Move (Right(sDate, 2) + sSep + Mid(sDate, 2, 4) + sSep + Left(sDate, 2)) to sRes
45909>>>>>        End
45909>>>>>>
45909>>>>>        Else If (iFmt = DF_DATE_USA) Begin
45912>>>>>            If (iLen = 10) Move (Mid(sDate, 2, 6) + sSep + Right(sDate, 2) + sSep + Left(sDate, 4)) to sRes
45915>>>>>            Else           Move (Mid(sDate, 2, 4) + sSep + Right(sDate, 2) + sSep + Left(sDate, 2)) to sRes
45917>>>>>        End
45917>>>>>>
45917>>>>>        
45917>>>>>        Function_Return sRes
45918>>>>>    End_Function
45919>>>>>    
45919>>>>>    Function Date2MilDate String sDate Returns String
45921>>>>>        Integer iFmt iLen
45921>>>>>        String  sRes sSep
45921>>>>>        
45921>>>>>        Get_Attribute DF_DATE_FORMAT    to iFmt
45924>>>>>        Move "-"                        to sSep
45925>>>>>        Move (Trim(sDate))              to sDate
45926>>>>>        Move (Length(sDate))            to iLen
45927>>>>>        
45927>>>>>        // Just not a valid length - return the input unchanged
45927>>>>>        If not ((iLen = 8) or (iLen = 10)) Function_Return sDate
45930>>>>>        
45930>>>>>        // If the format is military, just return the input
45930>>>>>        If (iFmt = DF_DATE_MILITARY) Function_Return sDate
45933>>>>>        
45933>>>>>        If (iFmt = DF_DATE_EUROPEAN) Begin
45935>>>>>            If (iLen = 10) Move (Right(sDate, 4) + sSep + Mid(sDate, 2, 4) + sSep + Left(sDate, 2)) to sRes
45938>>>>>            Else           Move (Right(sDate, 2) + sSep + Mid(sDate, 2, 4) + sSep + Left(sDate, 2)) to sRes
45940>>>>>        End
45940>>>>>>
45940>>>>>        Else If (iFmt = DF_DATE_USA) Begin
45943>>>>>            If (iLen = 10) Move (Right(sDate, 4) + sSep + Left(sDate, 2) + sSep + Mid(sDate, 2, 4)) to sRes
45946>>>>>            Else           Move (Right(sDate, 2) + sSep + Left(sDate, 2) + sSep + Mid(sDate, 2, 4)) to sRes
45948>>>>>        End
45948>>>>>>
45948>>>>>        
45948>>>>>        Function_Return sRes
45949>>>>>    End_Function
45950>>>>>        
45950>>>>>    Function NameToColour String sName Returns wqColour
45952>>>>>        wqColour tCol
45952>>>>>        wqColour tCol
45952>>>>>        
45952>>>>>        Move (Lowercase(sName)) to sName
45953>>>>>        
45953>>>>>        If (sName = "white") Begin
45955>>>>>            Move 255 to tCol.iRed
45956>>>>>            Move 255 to tCol.iGreen
45957>>>>>            Move 255 to tCol.iBlue
45958>>>>>        End
45958>>>>>>
45958>>>>>        Else If (sName = "silver") Begin
45961>>>>>            Move 192 to tCol.iRed
45962>>>>>            Move 192 to tCol.iGreen
45963>>>>>            Move 192 to tCol.iBlue
45964>>>>>        End
45964>>>>>>
45964>>>>>        Else If (sName = "gray") Begin
45967>>>>>            Move 128 to tCol.iRed
45968>>>>>            Move 128 to tCol.iGreen
45969>>>>>            Move 128 to tCol.iBlue
45970>>>>>        End
45970>>>>>>
45970>>>>>        Else If (sName = "red") Begin
45973>>>>>            Move 255 to tCol.iRed
45974>>>>>            Move   0 to tCol.iGreen
45975>>>>>            Move   0 to tCol.iBlue
45976>>>>>        End
45976>>>>>>
45976>>>>>        Else If (sName = "maroon") Begin
45979>>>>>            Move 128 to tCol.iRed
45980>>>>>            Move   0 to tCol.iGreen
45981>>>>>            Move   0 to tCol.iBlue
45982>>>>>        End
45982>>>>>>
45982>>>>>        Else If (sName = "yellow") Begin
45985>>>>>            Move 255 to tCol.iRed
45986>>>>>            Move 255 to tCol.iGreen
45987>>>>>            Move   0 to tCol.iBlue
45988>>>>>        End
45988>>>>>>
45988>>>>>        Else If (sName = "olive") Begin
45991>>>>>            Move 128 to tCol.iRed
45992>>>>>            Move 128 to tCol.iGreen
45993>>>>>            Move   0 to tCol.iBlue
45994>>>>>        End
45994>>>>>>
45994>>>>>        Else If (sName = "lime") Begin
45997>>>>>            Move   0 to tCol.iRed
45998>>>>>            Move 255 to tCol.iGreen
45999>>>>>            Move   0 to tCol.iBlue
46000>>>>>        End
46000>>>>>>
46000>>>>>        Else If (sName = "green") Begin
46003>>>>>            Move   0 to tCol.iRed
46004>>>>>            Move 128 to tCol.iGreen
46005>>>>>            Move   0 to tCol.iBlue
46006>>>>>        End
46006>>>>>>
46006>>>>>        Else If (sName = "aqua") Begin
46009>>>>>            Move   0 to tCol.iRed
46010>>>>>            Move 255 to tCol.iGreen
46011>>>>>            Move 255 to tCol.iBlue
46012>>>>>        End
46012>>>>>>
46012>>>>>        Else If (sName = "teal") Begin
46015>>>>>            Move   0 to tCol.iRed
46016>>>>>            Move 128 to tCol.iGreen
46017>>>>>            Move 128 to tCol.iBlue
46018>>>>>        End
46018>>>>>>
46018>>>>>        Else If (sName = "blue") Begin
46021>>>>>            Move   0 to tCol.iRed
46022>>>>>            Move   0 to tCol.iGreen
46023>>>>>            Move 255 to tCol.iBlue
46024>>>>>        End
46024>>>>>>
46024>>>>>        Else If (sName = "navy") Begin
46027>>>>>            Move   0 to tCol.iRed
46028>>>>>            Move   0 to tCol.iGreen
46029>>>>>            Move 128 to tCol.iBlue
46030>>>>>        End
46030>>>>>>
46030>>>>>        Else If (sName = "fushia") Begin
46033>>>>>            Move 255 to tCol.iRed
46034>>>>>            Move   0 to tCol.iGreen
46035>>>>>            Move 255 to tCol.iBlue
46036>>>>>        End
46036>>>>>>
46036>>>>>        Else If (sName = "purple") Begin
46039>>>>>            Move 128 to tCol.iRed
46040>>>>>            Move   0 to tCol.iGreen
46041>>>>>            Move 128 to tCol.iBlue
46042>>>>>        End
46042>>>>>>
46042>>>>>        Else Begin
46043>>>>>            Move   0 to tCol.iRed
46044>>>>>            Move   0 to tCol.iGreen
46045>>>>>            Move   0 to tCol.iBlue
46046>>>>>        End
46046>>>>>>
46046>>>>>        
46046>>>>>        Function_Return tCol
46047>>>>>    End_Function
46048>>>>>    
46048>>>>>//==============================================================================    
46048>>>>>// Report output methods
46048>>>>>//==============================================================================    
46048>>>>>    
46048>>>>>    Function OpenOutput Integer iDest Integer iFormat String ByRef sPath String ByRef sFile Returns Integer
46050>>>>>        Integer iChn
46050>>>>>        String  sDir
46050>>>>>        
46050>>>>>        Get Seq_New_Channel                                         to iChn
46051>>>>>        Get RandomHexUUID                                           to sFile
46052>>>>>        If      (iFormat = C_wqOutputHtml) Move (sFile + ".html")   to sFile
46055>>>>>        Else If (iFormat = C_wqOutputText) Move (sFile + ".txt")    to sFile
46059>>>>>        Else If (iFormat = C_wqOutputCSV)  Move (sFile + ".csv")    to sFile
46063>>>>>        Else If (iFormat = C_wqOutputXML)  Move (sFile + ".xml")    to sFile
46067>>>>>        
46067>>>>>        If (iDest = C_wqDownload) Begin
46069>>>>>            Get psDownloadDirectory of ghoWebQry                to sPath
46070>>>>>        End
46070>>>>>>
46070>>>>>        Else Begin
46071>>>>>            Get psAppHtmlPath of (phoWorkspace(oApplication))   to sPath
46072>>>>>            Get psOutputDirectory of ghoWebQry                  to sDir
46073>>>>>//        Get psHome of (phoWorkspace(oApplication))                  to sPath
46073>>>>>//        Get psOutputDirectory of ghoWebQry                          to sPath
46073>>>>>            Move (sPath + "/" + sDir)                           to sPath
46074>>>>>        End
46074>>>>>>
46074>>>>>        
46074>>>>>        Direct_Input channel iChn ("dir:" + sPath)
46076>>>>>        If (SeqEOF) Make_Directory sPath
46079>>>>>        Close_Input channel iChn
46081>>>>>        
46081>>>>>        Direct_Output channel iChn (sPath + "\" + sFile)
46083>>>>>        Set piChannel to iChn
46084>>>>>        
46084>>>>>        Function_Return iChn
46085>>>>>    End_Function
46086>>>>>    
46086>>>>>    Procedure CreateLayout wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay wqBreakpoint[] ByRef aBreaks
46088>>>>>        Integer i iFld iRow iCol iLen
46088>>>>>        
46088>>>>>        Move 0 to tLay.iMaxCols
46089>>>>>        Move 0 to tLay.iCount
46090>>>>>        Move 0 to iRow
46091>>>>>        Move 0 to iCol
46092>>>>>        
46092>>>>>        For iFld from 0 to (SizeOfArray(tQuery.aPrintFields) - 1)
46098>>>>>>
46098>>>>>            
46098>>>>>            If (tQuery.aPrintFields[iFld].bCR) Begin
46100>>>>>                Move 0 to iCol
46101>>>>>                Increment iRow
46102>>>>>            End
46102>>>>>>
46102>>>>>            
46102>>>>>            Move tQuery.aPrintFields[iFld].iTable       to tLay.aParts[iRow].aColumns[iCol].iTable
46103>>>>>            Move tQuery.aPrintFields[iFld].iColumn      to tLay.aParts[iRow].aColumns[iCol].iColumn
46104>>>>>            Move tQuery.aPrintFields[iFld].sUserName    to tLay.aParts[iRow].aColumns[iCol].sName
46105>>>>>            Move tQuery.aPrintFields[iFld].bCR          to tLay.aParts[iRow].aColumns[iCol].bCR
46106>>>>>            Move tQuery.aPrintFields[iFld].bSum         to tLay.aParts[iRow].aColumns[iCol].bSum
46107>>>>>            Move tQuery.aPrintFields[iFld].sExpression  to tLay.aParts[iRow].aColumns[iCol].sExpr
46108>>>>>            Move tQuery.aPrintFields[iFld].iType        to tLay.aParts[iRow].aColumns[iCol].iType
46109>>>>>            Move tQuery.aPrintFields[iFld].iWidth       to tLay.aParts[iRow].aColumns[iCol].iWidth
46110>>>>>            Move tQuery.aPrintFields[iFld].iDecimals    to tLay.aParts[iRow].aColumns[iCol].iDecimals
46111>>>>>            Move tQuery.aPrintFields[iFld].bCalc        to tLay.aParts[iRow].aColumns[iCol].bCalc
46112>>>>>            
46112>>>>>            If (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD) Begin
46114>>>>>                Move (tLay.aParts[iRow].aColumns[iCol].iWidth * 2)                      to iLen         // digits
46115>>>>>                If (tLay.aParts[iRow].aColumns[iCol].iDecimals > 0)                     Increment iLen  // point
46118>>>>>                Move (iLen + Integer(((tLay.aParts[iRow].aColumns[iCol].iWidth * 2) - ;                                      tLay.aParts[iRow].aColumns[iCol].iDecimals) / 3)) to iLen         // commas
46119>>>>>            End
46119>>>>>>
46119>>>>>            Else If (tLay.aParts[iRow].aColumns[iCol].iType = DF_DATE) Begin
46122>>>>>                Move 10 to iLen                                                                         // dates are 10 wide
46123>>>>>            End
46123>>>>>>
46123>>>>>            Else If (tLay.aParts[iRow].aColumns[iCol].iType = DF_TEXT) Begin
46126>>>>>                Move (tLay.aParts[iRow].aColumns[iCol].iWidth - 2) to iLen                              // Text is 2 bytes less than size
46127>>>>>            End
46127>>>>>>
46127>>>>>            Else Begin
46128>>>>>                Move tLay.aParts[iRow].aColumns[iCol].iWidth to iLen
46129>>>>>            End
46129>>>>>>
46129>>>>>            
46129>>>>>            Move (iLen max Length(tLay.aParts[iRow].aColumns[iCol].sName)) to tLay.aParts[iRow].aColumns[iCol].iPrintWidth
46130>>>>>            
46130>>>>>            For i from 0 to (SizeOfArray(aBreaks))  // Note: NOT -1, because 0 is the overall total
46136>>>>>>
46136>>>>>                Move 0                                  to tLay.aParts[iRow].aColumns[iCol].anSum[i]
46137>>>>>            Loop
46138>>>>>>
46138>>>>>            
46138>>>>>            Increment iCol
46139>>>>>            Move (tLay.iMaxCols max (iCol + 1)) to tLay.iMaxCols
46140>>>>>        Loop
46141>>>>>>
46141>>>>>        
46141>>>>>    End_Procedure
46142>>>>>    
46142>>>>>    Procedure AddTqRelations tTableQuery ByRef tTQ Handle hTab Handle[] ByRef ahTabs
46144>>>>>        Integer i iFields
46144>>>>>        Handle  hRel
46144>>>>>        
46144>>>>>        If not hTab                   Procedure_Return
46147>>>>>        If (TableMissing(Self, hTab)) Procedure_Return
46150>>>>>        
46150>>>>>        // Is this table already in the list?  If so, skip it
46150>>>>>        For i from 0 to (SizeOfArray(ahTabs) - 1)
46156>>>>>>
46156>>>>>            If (hTab = ahTabs[i]) Procedure_Return
46159>>>>>        Loop
46160>>>>>>
46160>>>>>        
46160>>>>>        // Now put it in the list
46160>>>>>        Move hTab to ahTabs[(SizeOfArray(ahTabs))]
46161>>>>>        
46161>>>>>        Open hTab
46163>>>>>        Send AddResultTable of oTQ (&tTQ) hTab                          // Put it here instead of in the loop (see below)
46164>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTab to iFields
46167>>>>>        
46167>>>>>        For i from 1 to iFields
46173>>>>>>
46173>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTab i to hRel
46176>>>>>            
46176>>>>>            If hRel Begin
46178>>>>>                Send AddTableRelationAuto of oTQ (&tTQ) hTab hRel
46179>>>>>//                Send AddResultTable of oTQ (&tTQ) hTab                // Remove from loop a put in body of procedure so that this is done for the main table as well
46179>>>>>                Send AddTqRelations              (&tTQ) hRel (&ahTabs)
46180>>>>>            End
46180>>>>>>
46180>>>>>            
46180>>>>>        Loop
46181>>>>>>
46181>>>>>        
46181>>>>>    End_Procedure  // AddTqRelations
46182>>>>>    
46182>>>>>    Function WqOpToTqOp String sWqOp Returns Integer
46184>>>>>        If (sWqOp = "<")  Function_Return tqLT
46187>>>>>        If (sWqOp = "<=") Function_Return tqLE
46190>>>>>        If (sWqOp = "=")  Function_Return tqEQ
46193>>>>>        If (sWqOp = ">=") Function_Return tqGE
46196>>>>>        If (sWqOp = ">")  Function_Return tqGT
46199>>>>>        If (sWqOp = "<>") Function_Return tqNE
46202>>>>>//        If (sWqOp = "IN") Function_Return tqIN
46202>>>>>        Function_Return -1
46203>>>>>    End_Function
46204>>>>>    
46204>>>>>    Procedure AddSelections wqWebQuery ByRef tQuery tTableQuery ByRef tTQ  wqSelsForTQ[] ByRef aTQSels
46206>>>>>        Integer i j iOp iPos
46206>>>>>        String  sList sRange
46206>>>>>        
46206>>>>>        // First move the selections to a different array, so that we can set
46206>>>>>        // a flag on it to see if (a) it is a filter that TableQuery will handle
46206>>>>>        // and (b) if there is more than one filter on the same field (which TQ
46206>>>>>        // does not allow.
46206>>>>>        //
46206>>>>>        // (Also, until Sture fixes it, if there is an "in list" filter on a
46206>>>>>        // related-to table rather than the main table.)
46206>>>>>        
46206>>>>>        For i from 0 to (SizeOfArray(tQuery.aSelections) - 1)
46212>>>>>>
46212>>>>>            Move tQuery.aSelections[i] to aTQSels[i].Selection
46213>>>>>            Move True to aTQSels[i].bUseTQ
46214>>>>>            Get WqOpToTqOp aTQSels[i].Selection.sType to iOp
46215>>>>>            If (iOp = -1) Move False to aTQSels[i].bUseTQ  // Not handled by TQ
46218>>>>>            
46218>>>>>            For j from 0 to (i - 1)
46224>>>>>>
46224>>>>>                If ((aTQSels[j].Selection.iTable  = aTQSels[i].Selection.iTable) and ;                    (aTQSels[j].Selection.iColumn = aTQSels[i].Selection.iColumn)) ;                    Move False to aTQSels[i].bUseTQ  // Only one filter per column in TQ
46227>>>>>            Loop
46228>>>>>>
46228>>>>>            
46228>>>>>// Sture says this should work - wonder what I'm doing wrong?
46228>>>>>//            If ((aTQSels[i].Selection.sType = "in list") and (aTQSels[i].Selection.iTable <> hMain)) ;
46228>>>>>//                    Move False to aTQSels[i].bUseTQ
46228>>>>>
46228>>>>>            Move (aTQSels[i].Selection.sType = "in list") to aTQSels[i].bInList
46229>>>>>            
46229>>>>>            If ((aTQSels[i].Selection.sType = "x-y") or ;                (aTQSels[i].Selection.sType = "CBT")) Begin
46231>>>>>                Move (Trim(Replace(" (both incl)", aTQSels[i].Selection.sValue, ""))) to sRange
46232>>>>>                Move (Pos(" - ", sRange))                           to iPos
46233>>>>>                Move (Left(sRange, (iPos - 1)))                     to aTQSels[i].sStartR
46234>>>>>                Move (Right(sRange, (Length(sRange) - iPos) - 2))   to aTQSels[i].sEndR
46235>>>>>            End
46235>>>>>>
46235>>>>>            
46235>>>>>            If (aTQSels[i].bInList) Begin
46237>>>>>                Move True to aTQSels[i].bUseTQ
46238>>>>>                Move 0 to j
46239>>>>>                Move aTQSels[i].Selection.sValue to sList
46240>>>>>                
46240>>>>>                Repeat
46240>>>>>>
46240>>>>>                    Move (Trim(sList)) to sList
46241>>>>>                    If (sList = "") Break
46244>>>>>                    
46244>>>>>                    Move (Pos(";", sList)) to iPos
46245>>>>>                    
46245>>>>>                    If (iPos > 0) Begin
46247>>>>>                        Move (Left(sList, (iPos - 1))) to aTQSels[i].aList[j]
46248>>>>>                        Move (Right(sList, (Length(sList) - iPos))) to sList
46249>>>>>                    End
46249>>>>>>
46249>>>>>                    Else If (sList <> "") Move sList to aTQSels[i].aList[j]
46253>>>>>                    
46253>>>>>                    Increment j
46254>>>>>                Until not iPos
46256>>>>>                    
46256>>>>>            End
46256>>>>>>
46256>>>>>            
46256>>>>>        Loop
46257>>>>>>
46257>>>>>        
46257>>>>>        // Add TQ Filters
46257>>>>>        For i from 0 to (SizeOfArray(aTQSels) - 1)
46263>>>>>>
46263>>>>>        
46263>>>>>            If (aTQSels[i].bUseTQ) Begin
46265>>>>>
46265>>>>>                If (aTQSels[i].bInList) Begin
46267>>>>>                    Send AddFilterOrList of oTQ (&tTQ) aTQSels[i].Selection.iTable ;                                                       aTQSels[i].Selection.iColumn ;                                                       aTQSels[i].aList
46268>>>>>                End
46268>>>>>>
46268>>>>>                Else Begin
46269>>>>>                    Send AddFilter of oTQ (&tTQ) aTQSels[i].Selection.iTable ;                                                 aTQSels[i].Selection.iColumn iOp ;                           (StrDelQuotes(Self, aTQSels[i].Selection.sValue))
46270>>>>>                End
46270>>>>>>
46270>>>>>                
46270>>>>>            End
46270>>>>>>
46270>>>>>            
46270>>>>>        Loop
46271>>>>>>
46271>>>>>    End_Procedure
46272>>>>>    
46272>>>>>    Procedure SetupBreaks wqWebQuery ByRef tQuery wqBreakpoint[] ByRef aBreaks
46274>>>>>        Integer i j k
46274>>>>>        
46274>>>>>        Move 0 to j
46275>>>>>        
46275>>>>>        For i from 0 to (SizeOfArray(tQuery.aSegments) - 1)
46281>>>>>>
46281>>>>>            
46281>>>>>            If (tQuery.aSegments[i].bBreak) Begin
46283>>>>>                Move tQuery.aSegments[i].iTable to aBreaks[j].iTable
46284>>>>>                Move tQuery.aSegments[i].iField to aBreaks[j].iColumn
46285>>>>>                Move tQuery.aSegments[i].sName  to aBreaks[j].sName
46286>>>>>                Move ""                         to aBreaks[j].sPrevValue
46287>>>>>                Increment j
46288>>>>>            End
46288>>>>>>
46288>>>>>            
46288>>>>>        Loop
46289>>>>>>
46289>>>>>        
46289>>>>>    End_Procedure
46290>>>>>    
46290>>>>>    Procedure AddOrdering wqIndexSeg[] ByRef atSegments tTableQuery ByRef tTQ
46292>>>>>        Integer i
46292>>>>>        
46292>>>>>        For i from 0 to (SizeOfArray(atSegments) - 1)
46298>>>>>>
46298>>>>>            Send AddOrderBy of oTQ (&tTQ) atSegments[i].iTable ;                                          atSegments[i].iField ;                                          atSegments[i].bDesc ;                                          atSegments[i].bUC
46299>>>>>        Loop
46300>>>>>>
46300>>>>>        
46300>>>>>    End_Procedure
46301>>>>>    
46301>>>>>    Procedure WriteHtmlStart wqWebQuery ByRef tQuery Integer iChn
46303>>>>>        String  sTitle
46303>>>>>        
46303>>>>>        If (tQuery.sTitle = "") Get_Attribute DF_FILE_DISPLAY_NAME of tQuery.hMainTable to sTitle
46308>>>>>        Else Move tQuery.sTitle                                                         to sTitle
46310>>>>>        
46310>>>>>        WriteLn channel iChn "<" (Character(33)) "DOCTYPE HTML>"
46315>>>>>        Send XmlToChannel of oWqXml iChn
46316>>>>>        Send AddOpenElement of oWqXml "html"
46317>>>>>        Send AddOpenElement of oWqXml "head"
46318>>>>>        Send AddElement of oWqXml "title" sTitle
46319>>>>>        Send CloseElement of oWqXml  // head
46320>>>>>        Send AddOpenElement of oWqXml "body"
46321>>>>>        Send AddAttribute of oWqXml "style" ("font-family:" * tQuery.sTypeface + ";" * ;                                             "font-size:" * tQuery.sFontSize + ";" * ;                                             "color:" * tQuery.sTextColour + ";" * ;                                             "background-color:" * tQuery.sBGColour + ";")
46322>>>>>        
46322>>>>>        If (tQuery.sTextBefore <> "") Send Stream of oWqXml ;                (Replaces(Character(10), tQuery.sTextBefore, "<br>"))
46325>>>>>        
46325>>>>>        Send AddElement of oWqXml "h1" sTitle
46326>>>>>        Send AddAttribute of oWqXml "align" "left"
46327>>>>>    End_Procedure
46328>>>>>    
46328>>>>>    Procedure WriteCSVStart wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46330>>>>>        Integer i
46330>>>>>        
46330>>>>>        If (tQuery.bColHeads) Begin
46332>>>>>            
46332>>>>>            For i from 0 to (SizeOfArray(tQuery.aPrintFields) - 1)
46338>>>>>>
46338>>>>>                If (i > 0) Write ","
46341>>>>>                Write '"' (Replaces('"', tQuery.aPrintFields[i].sUserName, "'")) '"'
46344>>>>>            Loop
46345>>>>>>
46345>>>>>            
46345>>>>>            WriteLn
46346>>>>>        End
46346>>>>>>
46346>>>>>        
46346>>>>>    End_Procedure
46347>>>>>    
46347>>>>>    Procedure WriteTextStart wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46349>>>>>        String  sTitle
46349>>>>>        Integer iRow iCol iLen
46349>>>>>        
46349>>>>>        If (tQuery.sTextBefore <> "") Begin
46351>>>>>            WriteLn channel iChn tQuery.sTextBefore
46354>>>>>            WriteLn
46355>>>>>        End
46355>>>>>>
46355>>>>>        
46355>>>>>        Move tQuery.sTitle to sTitle
46356>>>>>        
46356>>>>>        If (sTitle = "") Begin
46358>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of tQuery.hMainTable to sTitle
46361>>>>>        End
46361>>>>>>
46361>>>>>        
46361>>>>>        WriteLn sTitle
46363>>>>>        WriteLn (Repeat("=", Length(sTitle)))
46365>>>>>        WriteLn
46366>>>>>        
46366>>>>>        For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
46372>>>>>>
46372>>>>>            Write (Repeat("   ", iRow))
46373>>>>>        
46373>>>>>            For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
46379>>>>>>
46379>>>>>                If (iCol > 0) Write "  "
46382>>>>>                
46382>>>>>                If (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD) Begin
46384>>>>>                    Write (Repeat(" ", (tLay.aParts[iRow].aColumns[iCol].iPrintWidth - Length(tLay.aParts[iRow].aColumns[iCol].sName))))
46385>>>>>                    Write tLay.aParts[iRow].aColumns[iCol].sName
46386>>>>>                End
46386>>>>>>
46386>>>>>                Else Begin
46387>>>>>                    Write (Pad(tLay.aParts[iRow].aColumns[iCol].sName, tLay.aParts[iRow].aColumns[iCol].iPrintWidth))
46388>>>>>                End
46388>>>>>>
46388>>>>>                
46388>>>>>            Loop
46389>>>>>>
46389>>>>>            
46389>>>>>            WriteLn
46390>>>>>            
46390>>>>>            Write (Repeat("   ", iRow))
46391>>>>>        
46391>>>>>            For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
46397>>>>>>
46397>>>>>                If (iCol > 0) Write "  "
46400>>>>>                
46400>>>>>                If (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD) Begin
46402>>>>>                    Write (Repeat(" ", (tLay.aParts[iRow].aColumns[iCol].iPrintWidth - Length(tLay.aParts[iRow].aColumns[iCol].sName))))
46403>>>>>                    Write (Repeat("=", Length(tLay.aParts[iRow].aColumns[iCol].sName)))
46404>>>>>                End
46404>>>>>>
46404>>>>>                Else Begin
46405>>>>>                    Write (Pad(Repeat("=", Length(tLay.aParts[iRow].aColumns[iCol].sName)), tLay.aParts[iRow].aColumns[iCol].iPrintWidth))
46406>>>>>                End
46406>>>>>>
46406>>>>>                
46406>>>>>            Loop
46407>>>>>>
46407>>>>>            
46407>>>>>            WriteLn
46408>>>>>        Loop
46409>>>>>>
46409>>>>>        
46409>>>>>    End_Procedure
46410>>>>>    
46410>>>>>    Procedure WriteXmlStart wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46412>>>>>        String  sTitle
46412>>>>>        
46412>>>>>        
46412>>>>>        If (tQuery.sTitle = "") Get_Attribute DF_FILE_DISPLAY_NAME of tQuery.hMainTable to sTitle
46417>>>>>        Else Move tQuery.sTitle                                                         to sTitle
46419>>>>>        
46419>>>>>        Move (XmlTag(Self, sTitle)) to sTitle
46420>>>>>        
46420>>>>>        Write channel iChn '<?xml version="1.0" encoding="iso-8859-1"?>'
46422>>>>>        Send XmlToChannel of oWqXml iChn
46423>>>>>        Send AddOpenElement of oWqXml sTitle
46424>>>>>    End_Procedure
46425>>>>>    
46425>>>>>    Procedure WriteRemoveScript String sFile Integer iChn
46427>>>>>        Send Stream of oWqXml ""
46428>>>>>        WriteLn channel iChn
46430>>>>>        WriteLn '<script id="delRep">'
46432>>>>>        WriteLn 'var xmlHttpRequestFactory = null;'
46434>>>>>        WriteLn 'function createXMLHTTPObject() {'
46436>>>>>        WriteLn '   var xmlHttp = false;'
46438>>>>>        WriteLn '   if (! xmlHttpRequestFactory) {'
46440>>>>>        WriteLn '      var factories = ['
46442>>>>>        WriteLn '         function () {return new XMLHttpRequest(); },'
46444>>>>>        WriteLn '         function () {return new ActiveXObject("Msxml2.XMLHTTP"); },'
46446>>>>>        WriteLn '         function () {return new ActiveXObject("Msxml3.XMLHTTP"); },'
46448>>>>>        WriteLn '         function () {return new ActiveXObject("Microsoft.XMLHTTP"); }'
46450>>>>>        WriteLn '      ];'
46452>>>>>        WriteLn '      for (var i = 0; i < factories.length; i++) {'
46454>>>>>        WriteLn '         try {'
46456>>>>>        WriteLn '            xmlHttp = factories[i]();'
46458>>>>>        WriteLn '         }'
46460>>>>>        WriteLn '         catch (e) {'
46462>>>>>        WriteLn '            continue;'
46464>>>>>        WriteLn '         }'
46466>>>>>        WriteLn '         if (xmlHttp) {'
46468>>>>>        WriteLn '            xmlHttpRequestFactory = factories[i];'
46470>>>>>        WriteLn '         }'
46472>>>>>        WriteLn '         break;'
46474>>>>>        WriteLn '      }'
46476>>>>>        WriteLn '   }'
46478>>>>>        WriteLn '   return (xmlHttpRequestFactory) ? xmlHttpRequestFactory() : null;'
46480>>>>>        WriteLn '}'
46482>>>>>        WriteLn
46483>>>>>        WriteLn 'function removeFile() {'
46485>>>>>        WriteLn '   var arr = [], req;'
46487>>>>>        WriteLn '   arr.push("{\"ActionRequest\":{\"Header\":");'
46489>>>>>        WriteLn '   arr.push("{\"sSessionKey\": \"' (Trim(WebAppSession.SessionKey)) '\",");'
46493>>>>>        WriteLn '   arr.push("\"sFocus\": \"\",");'
46495>>>>>        WriteLn '   arr.push("\"aDDODefs\":[],");'
46497>>>>>        WriteLn '   arr.push("\"aSyncProps\":[]");'
46499>>>>>        WriteLn '   arr.push("},");'
46501>>>>>        WriteLn '   arr.push("\"aActions\":[{");'
46503>>>>>        WriteLn '   arr.push("\"sTarget\": \"oWebQuery\",");'
46505>>>>>        WriteLn '   arr.push("\"sAction\": \"RemoveReport\",");'
46507>>>>>        WriteLn '   arr.push("\"aParams\": [\"' sFile '\"],");'
46511>>>>>        WriteLn '   arr.push("\"aData\":[]}]");'
46513>>>>>        WriteLn '   arr.push("}");'
46515>>>>>        WriteLn '   arr.push("}");'
46517>>>>>        WriteLn '   req = createXMLHTTPObject();'
46519>>>>>        WriteLn '   req.open("POST", "../WebServiceDispatcher.wso/CallAction/JSON", true);'
46521>>>>>        WriteLn '   req.setRequestHeader("Content-Type", "application/json");'
46523>>>>>        WriteLn '   req.send(arr.join(""));'
46525>>>>>        WriteLn '   document.body.removeChild(document.getElementById("delRep"));'
46527>>>>>        WriteLn '}'
46529>>>>>        WriteLn 'window.onload=removeFile;'
46531>>>>>        WriteLn '</script>'
46533>>>>>        WriteLn
46534>>>>>    End_Procedure
46535>>>>>    
46535>>>>>    Procedure WriteStartTable wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46537>>>>>        Integer iRow iCol iPad
46537>>>>>        
46537>>>>>        Send AddOpenElement of oWqXml "table"
46538>>>>>        Send AddAttribute of oWqXml "style" ("width: 100%; border: none; font-size:" * tQuery.sFontSize)
46539>>>>>
46539>>>>>        For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
46545>>>>>>
46545>>>>>            Send AddOpenElement of oWqXml "tr"
46546>>>>>            Send AddAttribute of oWqXml "style" "font-weight: bold"
46547>>>>>            
46547>>>>>            For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
46553>>>>>>
46553>>>>>                Send AddElement of oWqXml "td" tLay.aParts[iRow].aColumns[iCol].sName
46554>>>>>                If      (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD)  Send AddAttribute of oWqXml "style" "text-align: right"
46557>>>>>                Else If (tLay.aParts[iRow].aColumns[iCol].iType = DF_DATE) Send AddAttribute of oWqXml "style" "text-align: center"
46561>>>>>            Loop
46562>>>>>>
46562>>>>>            
46562>>>>>            Move (tLay.iMaxCols - SizeOfArray(tLay.aParts[iRow].aColumns) - 1) to iPad
46563>>>>>            
46563>>>>>            If iPad Begin
46565>>>>>                Send AddElement of oWqXml "td" ""  // possibly "&nbsp;" is more correct, but also more HTML
46566>>>>>                Send AddAttribute of oWqXml "colspan" iPad
46567>>>>>            End
46567>>>>>>
46567>>>>>            
46567>>>>>            Send CloseElement of oWqXml  // tr        
46568>>>>>        Loop
46569>>>>>>
46569>>>>>        
46569>>>>>    End_Procedure
46570>>>>>    
46570>>>>>    Procedure WriteEndTable wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46572>>>>>        Integer iRow iCol iPad
46572>>>>>        Boolean bTots
46572>>>>>        String  sTot
46572>>>>>        
46572>>>>>        // Write Totals if present
46572>>>>>        Move False to bTots
46573>>>>>        
46573>>>>>        For iRow from 0 to (SizeOfArray(tQuery.aPrintFields) - 1)
46579>>>>>>
46579>>>>>            If (tQuery.aPrintFields[iRow].bSum) Move True to bTots
46582>>>>>            If bTots Break
46585>>>>>        Loop
46586>>>>>>
46586>>>>>        
46586>>>>>        If bTots Begin
46588>>>>>            
46588>>>>>            For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
46594>>>>>>
46594>>>>>                Send AddOpenElement of oWqXml "tr" ""
46595>>>>>                
46595>>>>>                For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
46601>>>>>>
46601>>>>>                    
46601>>>>>                    If (tLay.aParts[iRow].aColumns[iCol].bSum) Begin
46603>>>>>                        Move (NumberToString(oStringFunctions, ;                                             tLay.aParts[iRow].aColumns[iCol].anSum[0], ;                                             tLay.aParts[iRow].aColumns[iCol].iDecimals)) to sTot
46604>>>>>                        Send AddOpenElement of oWqXml "td"
46605>>>>>                        Send AddAttribute   of oWqXml "style" "text-align: right;"
46606>>>>>                        Send AddElement     of oWqXml "hr" ""
46607>>>>>                        Send AddElement     of oWqXml "b"  sTot
46608>>>>>                        Send CloseElement   of oWqXml  // b
46609>>>>>                    End
46609>>>>>>
46609>>>>>                    Else Send AddElement of oWqXml "td" ""
46611>>>>>                    
46611>>>>>                Loop
46612>>>>>>
46612>>>>>                
46612>>>>>                Move (tLay.iMaxCols - SizeOfArray(tLay.aParts[iRow].aColumns) - 1) to iPad
46613>>>>>                
46613>>>>>                If iPad Begin
46615>>>>>                    Send AddElement of oWqXml "td" ""
46616>>>>>                    Send AddAttribute of oWqXml "colspan" iPad
46617>>>>>                End
46617>>>>>>
46617>>>>>                
46617>>>>>                Send CloseElement of oWqXml  // tr
46618>>>>>            Loop
46619>>>>>>
46619>>>>>            
46619>>>>>        End
46619>>>>>>
46619>>>>>        
46619>>>>>        // Write end of table
46619>>>>>        Send CloseElement of oWqXml  // table
46620>>>>>    End_Procedure
46621>>>>>    
46621>>>>>    Procedure WriteTextTotals wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46623>>>>>        Integer iRow iCol iPad
46623>>>>>        Boolean bTots
46623>>>>>        String  sTot
46623>>>>>        
46623>>>>>        // Write Totals if present
46623>>>>>        Move False to bTots
46624>>>>>        
46624>>>>>        For iRow from 0 to (SizeOfArray(tQuery.aPrintFields) - 1)
46630>>>>>>
46630>>>>>            If (tQuery.aPrintFields[iRow].bSum) Move True to bTots
46633>>>>>            If bTots Break
46636>>>>>        Loop
46637>>>>>>
46637>>>>>        
46637>>>>>        If bTots Begin
46639>>>>>            
46639>>>>>            For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
46645>>>>>>
46645>>>>>                Write channel iChn (Repeat("   ", iRow))
46647>>>>>                
46647>>>>>                For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
46653>>>>>>
46653>>>>>                    If (iCol > 0) Write channel iChn "  "
46657>>>>>
46657>>>>>                    If (tLay.aParts[iRow].aColumns[iCol].bSum) Begin
46659>>>>>                        Write channel iChn (Repeat("=", tLay.aParts[iRow].aColumns[iCol].iPrintWidth))
46661>>>>>                    End
46661>>>>>>
46661>>>>>                    Else Write channel iChn (Repeat(" ", tLay.aParts[iRow].aColumns[iCol].iPrintWidth))
46664>>>>>                    
46664>>>>>                Loop
46665>>>>>>
46665>>>>>                
46665>>>>>                WriteLn channel iChn
46667>>>>>//            Loop
46667>>>>>//
46667>>>>>//            For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
46667>>>>>                Write channel iChn (Repeat("   ", iRow))
46669>>>>>                
46669>>>>>                For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
46675>>>>>>
46675>>>>>                    If (iCol > 0) Write channel iChn "  "
46679>>>>>
46679>>>>>                    If (tLay.aParts[iRow].aColumns[iCol].bSum) Begin
46681>>>>>                        Move (NumberToStringRTS(oStringFunctions, ;                                             tLay.aParts[iRow].aColumns[iCol].anSum[0], ;                                             tLay.aParts[iRow].aColumns[iCol].iDecimals, ;                                             tLay.aParts[iRow].aColumns[iCol].iPrintWidth)) to sTot
46682>>>>>                        Write channel iChn (Repeat(" ", (tLay.aParts[iRow].aColumns[iCol].iPrintWidth - Length(sTot))))
46684>>>>>                        Write channel iChn sTot
46686>>>>>                    End
46686>>>>>>
46686>>>>>                    Else Write channel iChn (Repeat(" ", (tLay.aParts[iRow].aColumns[iCol].iPrintWidth)))
46689>>>>>                    
46689>>>>>                Loop
46690>>>>>>
46690>>>>>                
46690>>>>>                WriteLn channel iChn
46692>>>>>            Loop
46693>>>>>>
46693>>>>>            
46693>>>>>        End
46693>>>>>>
46693>>>>>        
46693>>>>>    End_Procedure
46694>>>>>    
46694>>>>>    Procedure WriteHtmlEnd wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46696>>>>>        Integer i
46696>>>>>        
46696>>>>>        Send Stream of oWqXml ""
46697>>>>>        
46697>>>>>        If (tQuery.bPrintSels) Begin
46699>>>>>            
46699>>>>>            If ((SizeOFArray(tQuery.aSelections) = 0) and ;                (tQuery.sSelectExpression = "")) Begin
46701>>>>>                WriteLn "No selection criteria applied <br>"
46703>>>>>            End
46703>>>>>>
46703>>>>>            Else Begin
46704>>>>>                WriteLn channel iChn "<br>Selection criteria:<br>"
46707>>>>>                
46707>>>>>                For i from 0 to (SizeOfArray(tQuery.aSelections) - 1)
46713>>>>>>
46713>>>>>                    Write (tQuery.aSelections[i].sUserName + ", ")
46714>>>>>                    Write (Lowercase(SelDescFromType(oWqSelectionTypes, tQuery.aSelections[i].sType)))
46715>>>>>                    WriteLn (": " + tQuery.aSelections[i].sValue + "<br>")
46717>>>>>                Loop
46718>>>>>>
46718>>>>>                
46718>>>>>                If (tQuery.sSelectExpression <> "") WriteLn tQuery.sSelectExpression "<br>"
46723>>>>>            End
46723>>>>>>
46723>>>>>            
46723>>>>>        End
46723>>>>>>
46723>>>>>        
46723>>>>>        If (tQuery.bPrintCount) ;            WriteLn channel iChn ("<br>Records:" *  NumberToString(oStringFunctions, tLay.iCount, 0) + "<br>")
46728>>>>>                
46728>>>>>        If (tQuery.sTextAfter <> "") WriteLn channel iChn  ("<br>" + Replaces(Character(10), tQuery.sTextAfter, "<br>"))
46733>>>>>        
46733>>>>>        If (tQuery.bGeneratedLine) Begin
46735>>>>>            Send AddElement of oWqXml "p" ("Generated on:" * String(SystemDate(oDateFunctions)) + "," * SystemTimeString(oDateFunctions))
46736>>>>>            Send AddAttribute of oWqXml "style" "text-align: center; font-size: small"
46737>>>>>        End
46737>>>>>>
46737>>>>>        
46737>>>>>        Send CloseElement of oWqXml  // body
46738>>>>>        Send CloseElement of oWqXml  // html
46739>>>>>        Send EndXml       of oWqXml
46740>>>>>    End_Procedure
46741>>>>>    
46741>>>>>    Procedure WriteTextEnd wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46743>>>>>        Integer i
46743>>>>>        
46743>>>>>        If (tQuery.bPrintSels) Begin
46745>>>>>            WriteLn channel iChn
46747>>>>>            
46747>>>>>            If ((SizeOFArray(tQuery.aSelections) = 0) and ;                (tQuery.sSelectExpression = "")) Begin
46749>>>>>                WriteLn channel iChn "No selection criteria applied"
46752>>>>>            End
46752>>>>>>
46752>>>>>            Else Begin
46753>>>>>                WriteLn channel iChn "Selection criteria:"
46756>>>>>                
46756>>>>>                For i from 0 to (SizeOfArray(tQuery.aSelections) - 1)
46762>>>>>>
46762>>>>>                    Write channel iChn (tQuery.aSelections[i].sUserName + ", ")
46764>>>>>                    Write channel iChn (Lowercase(SelDescFromType(oWqSelectionTypes, tQuery.aSelections[i].sType)))
46766>>>>>                    WriteLn channel iChn (": " + tQuery.aSelections[i].sValue)
46769>>>>>                Loop
46770>>>>>>
46770>>>>>                
46770>>>>>                If (tQuery.sSelectExpression <> "") WriteLn channel iChn tQuery.sSelectExpression
46775>>>>>            End
46775>>>>>>
46775>>>>>            
46775>>>>>        End
46775>>>>>>
46775>>>>>        
46775>>>>>        If (tQuery.bPrintCount) Begin
46777>>>>>            WriteLn channel iChn 
46779>>>>>            WriteLn channel iChn ("Records:" *  NumberToString(oStringFunctions, tLay.iCount, 0))
46782>>>>>        End
46782>>>>>>
46782>>>>>        
46782>>>>>        If (tQuery.sTextAfter <> "") Begin
46784>>>>>            WriteLn channel iChn 
46786>>>>>            WriteLn channel iChn tQuery.sTextAfter
46789>>>>>        End
46789>>>>>>
46789>>>>>        
46789>>>>>        If (tQuery.bGeneratedLine) Begin
46791>>>>>            WriteLn channel iChn 
46793>>>>>            WriteLn channel iChn ("Generated on:" * String(SystemDate(oDateFunctions)) + "," * SystemTimeString(oDateFunctions))
46796>>>>>        End
46796>>>>>>
46796>>>>>        
46796>>>>>    End_Procedure
46797>>>>>    
46797>>>>>    Procedure WriteXmlEnd
46799>>>>>        Send CloseElement of oWqXml  // root
46800>>>>>        Send EndXml       of oWqXml
46801>>>>>    End_Procedure
46802>>>>>    
46802>>>>>    Procedure StartOutput wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46804>>>>>        
46804>>>>>        If (tQuery.iOutputFormat = C_wqOutputHtml) Begin
46806>>>>>            Send WriteHtmlStart (&tQuery) iChn
46807>>>>>            Send WriteStartTable (&tQuery) (&tLay) 
46808>>>>>        End
46808>>>>>>
46808>>>>>        Else If (tQuery.iOutputFormat = C_wqOutputCSV) Begin
46811>>>>>            Send WriteCSVStart (&tQuery) (&tLay) iChn
46812>>>>>        End
46812>>>>>>
46812>>>>>        Else If (tQuery.iOutputFormat = C_wqOutputText) Begin
46815>>>>>            Send WriteTextStart (&tQuery) (&tLay) iChn
46816>>>>>        End
46816>>>>>>
46816>>>>>        Else If (tQuery.iOutputFormat = C_wqOutputXML) Begin
46819>>>>>            Send WriteXmlStart (&tQuery) (&tLay) iChn
46820>>>>>        End
46820>>>>>>
46820>>>>>        
46820>>>>>    End_Procedure
46821>>>>>    
46821>>>>>    Function BreakLevel wqBreakpoint[] ByRef aBreaks Returns Integer
46823>>>>>        Integer i
46823>>>>>        String  sVal
46823>>>>>        
46823>>>>>        For i from 0 to (SizeOfArray(aBreaks) - 1)
46829>>>>>>
46829>>>>>            Get_Field_Value aBreaks[i].iTable aBreaks[i].iColumn to sVal
46832>>>>>            If (sVal <> aBreaks[i].sPrevValue) Function_Return i
46835>>>>>        Loop
46836>>>>>>
46836>>>>>        
46836>>>>>        Function_Return -1
46837>>>>>    End_Function
46838>>>>>    
46838>>>>>    Procedure HtmlBreak wqPrintRowLayout ByRef tLay String sOutput Integer iLevel
46840>>>>>        Send AddOpenElement of oWqXml "tr"
46841>>>>>        Send AddOpenElement of oWqXml "td"
46842>>>>>        Send AddAttribute   of oWqXml "colspan" tLay.iMaxCols
46843>>>>>        Send AddElement     of oWqXml ("h" + String(iLevel + 2)) sOutput
46844>>>>>        Send CloseElement   of oWqXml  // td
46845>>>>>        Send CloseElement   of oWqXml  // tr
46846>>>>>    End_Procedure
46847>>>>>    
46847>>>>>    Procedure TextBreak wqPrintRowLayout ByRef tLay String sOutput Integer iLevel
46849>>>>>        Integer iChn
46849>>>>>        
46849>>>>>        Get piChannel to iChn
46850>>>>>        Move (Trim(sOutput)) to sOutput
46851>>>>>        WriteLn
46852>>>>>        Write channel iChn (Repeat("   ", iLevel))
46854>>>>>        WriteLn channel iChn sOutput
46857>>>>>        Write channel iChn (Repeat("   ", iLevel))
46859>>>>>        WriteLn channel iChn (Repeat("=", Length(sOutput)))
46862>>>>>    End_Procedure
46863>>>>>    
46863>>>>>    Procedure DoBreaks wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay wqBreakpoint[] ByRef aBreaks Integer iLevel
46865>>>>>        Integer i j iPrev
46865>>>>>        String  sVal sName sOutput
46865>>>>>        Boolean bAddIn
46865>>>>>        wqBreakpoint tThisBreak tPrevBreak
46865>>>>>        wqBreakpoint tThisBreak tPrevBreak
46865>>>>>        
46865>>>>>        For i from iLevel to (SizeOfArray(aBreaks) - 1)
46871>>>>>>
46871>>>>>            
46871>>>>>            If (i > 0) Begin
46873>>>>>                Move aBreaks[i]     to tThisBreak
46874>>>>>                Move aBreaks[i - 1] to tPrevBreak
46875>>>>>                Move False          to bAddIn
46876>>>>>                Move ""             to sOutput
46877>>>>>                
46877>>>>>                For j from 0 to (SizeOfArray(tQuery.aSegments) - 1)
46883>>>>>>
46883>>>>>                    If (tQuery.aSegments[j].bBreak and ;                        (tQuery.aSegments[j].iTable = tThisBreak.iTable) and ;                        (tQuery.aSegments[j].iField = tThisBreak.iColumn)) Break
46886>>>>>                    
46886>>>>>                    If bAddIn Begin
46888>>>>>                        Get_Field_Value tQuery.aSegments[j].iTable tQuery.aSegments[j].iField to sVal
46891>>>>>                        If (sOutput <> "") Move (sOUtput + ", ") to sOutput
46894>>>>>                        Move (sOutput + tQuery.aSegments[j].sName * sVal) to sOutput
46895>>>>>                    End
46895>>>>>>
46895>>>>>                    
46895>>>>>                    If (tQuery.aSegments[j].bBreak and ;                        (tQuery.aSegments[j].iTable = tPrevBreak.iTable) and ;                        (tQuery.aSegments[j].iField = tPrevBreak.iColumn)) Move True to bAddIn
46898>>>>>                    
46898>>>>>                Loop
46899>>>>>>
46899>>>>>                
46899>>>>>            End
46899>>>>>>
46899>>>>>            
46899>>>>>            Get_Field_Value aBreaks[i].iTable aBreaks[i].iColumn to sVal
46902>>>>>            If (sOutput <> "") Move (sOutput + ", ") to sOutput
46905>>>>>            Move (sOutput + aBreaks[i].sName * sVal) to sOutput
46906>>>>>            
46906>>>>>            If (tQuery.iOutputFormat = C_wqOutputHtml) Begin
46908>>>>>                Send HtmlBreak (&tLay) sOutput i
46909>>>>>            End
46909>>>>>>
46909>>>>>            Else If (tQuery.iOutputFormat = C_wqOutputText) Begin
46912>>>>>                Send TextBreak (&tLay) sOutput i
46913>>>>>            End
46913>>>>>>
46913>>>>>            
46913>>>>>            Move sVal to aBreaks[i].sPrevValue
46914>>>>>        Loop
46915>>>>>>
46915>>>>>        
46915>>>>>    End_Procedure
46916>>>>>    
46916>>>>>    Procedure HtmlSubTotal wqPrintRowPart ByRef tRow Integer iLev
46918>>>>>        String  sTot
46918>>>>>        Integer iCol
46918>>>>>        
46918>>>>>        Send AddOpenElement of oWqXml "tr" ""
46919>>>>>            
46919>>>>>        For iCol from 0 to (SizeOfArray(tRow.aColumns) - 1)
46925>>>>>>
46925>>>>>            
46925>>>>>            If (tRow.aColumns[iCol].bSum) Begin
46927>>>>>                Move (NumberToString(oStringFunctions, ;                                     tRow.aColumns[iCol].anSum[iLev], ;                                     tRow.aColumns[iCol].iDecimals)) to sTot
46928>>>>>                Send AddOpenElement of oWqXml "td"
46929>>>>>                Send AddAttribute   of oWqXml "style" "text-align: right;"
46930>>>>>                Send AddElement     of oWqXml "hr" ""
46931>>>>>                Send AddElement     of oWqXml "b"  sTot
46932>>>>>                Move 0 to tRow.aColumns[iCol].anSum[iLev]
46933>>>>>                Send CloseElement   of oWqXml  // td
46934>>>>>            End
46934>>>>>>
46934>>>>>            Else Send AddElement of oWqXml "td" ""
46936>>>>>            
46936>>>>>        Loop
46937>>>>>>
46937>>>>>        
46937>>>>>        Send CloseElement of oWqXml  // tr
46938>>>>>    End_Procedure
46939>>>>>    
46939>>>>>    Procedure TextSubTotal wqPrintRowPart ByRef tRow Integer iLev Integer iRow
46941>>>>>        String  sTot
46941>>>>>        Integer iCol iChn
46941>>>>>        
46941>>>>>        Get piChannel to iChn
46942>>>>>        
46942>>>>>        Write Channel iChn (Repeat("   ", iRow))
46944>>>>>        
46944>>>>>        For iCol from 0 to (SizeOfArray(tRow.aColumns) - 1)
46950>>>>>>
46950>>>>>            
46950>>>>>            If (tRow.aColumns[iCol].bSum) Begin
46952>>>>>                Write channel iChn (Repeat("-", tRow.aColumns[iCol].iPrintWidth))
46954>>>>>            End
46954>>>>>>
46954>>>>>            Else Begin
46955>>>>>               Write channel iChn (Repeat(" ", (tRow.aColumns[iCol].iPrintWidth + 2)))
46957>>>>>            End
46957>>>>>>
46957>>>>>            
46957>>>>>        Loop
46958>>>>>>
46958>>>>>        
46958>>>>>        WriteLn channel iChn
46960>>>>>        Write Channel iChn (Repeat("   ", iRow))
46962>>>>>        
46962>>>>>        For iCol from 0 to (SizeOfArray(tRow.aColumns) - 1)
46968>>>>>>
46968>>>>>            
46968>>>>>            If (tRow.aColumns[iCol].bSum) Begin
46970>>>>>                Move (NumberToStringRTS(oStringFunctions, ;                                     tRow.aColumns[iCol].anSum[iLev], ;                                     tRow.aColumns[iCol].iDecimals, ;                                     tRow.aColumns[iCol].iPrintWidth)) to sTot
46971>>>>>                Write channel iChn (Repeat(" ", (tRow.aColumns[iCol].iPrintWidth - Length(sTot)))) sTot
46974>>>>>                Move 0 to tRow.aColumns[iCol].anSum[iLev]
46975>>>>>            End
46975>>>>>>
46975>>>>>            Else Begin 
46976>>>>>               Write channel iChn (Repeat(" ", (tRow.aColumns[iCol].iPrintWidth + 2)))
46978>>>>>            End
46978>>>>>>
46978>>>>>            
46978>>>>>        Loop
46979>>>>>>
46979>>>>>        
46979>>>>>        WriteLn channel iChn
46981>>>>>    End_Procedure
46982>>>>>
46982>>>>>    Procedure DoSubtotals wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay wqBreakpoint[] ByRef aBreaks Integer iLevel
46984>>>>>        Integer i iLast iLev iRow iCol
46984>>>>>        String  sTot
46984>>>>>        
46984>>>>>        Move (SizeOfArray(aBreaks) - 1) to iLast
46985>>>>>        
46985>>>>>        For i from 0 to (iLast - iLevel)
46991>>>>>>
46991>>>>>            Move (iLast - i + 1) to iLev
46992>>>>>            
46992>>>>>            For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
46998>>>>>>
46998>>>>>                
46998>>>>>                If (tQuery.iOutputFormat = C_wqOutputHtml) Begin
47000>>>>>                    Send AddOpenElement of oWqXml "tr" ""
47001>>>>>                    Send HtmlSubTotal (&tLay.aParts[iRow]) iLev
47002>>>>>                    Send CloseElement of oWqXml  // tr
47003>>>>>                End
47003>>>>>>
47003>>>>>                Else If (tQuery.iOutputFormat = C_wqOutputText) Begin
47006>>>>>                    Send TextSubTotal (&tLay.aParts[iRow]) iLev iRow
47007>>>>>                End
47007>>>>>>
47007>>>>>                
47007>>>>>            Loop
47008>>>>>>
47008>>>>>            
47008>>>>>        Loop
47009>>>>>>
47009>>>>>        
47009>>>>>    End_Procedure
47010>>>>>    
47010>>>>>    Procedure OutputHtmlRow wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Boolean bHighlight
47012>>>>>        Integer iRow iCol iPad iChn
47012>>>>>        String  sVal sText
47012>>>>>
47012>>>>>        Get piChannel to iChn
47013>>>>>        
47013>>>>>        For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
47019>>>>>>
47019>>>>>            Send AddOpenElement of oWqXml "tr"
47020>>>>>            If bHighlight Send AddAttribute of oWqXml "style" ("background-color:" * tQuery.sHighlightColour)
47023>>>>>            
47023>>>>>            For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
47029>>>>>>
47029>>>>>                Move tLay.aParts[iRow].aColumns[iCol].sCurVal to sVal
47030>>>>>                
47030>>>>>                If (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD) ;                     Move (NumberToString(oStringFunctions, sVal, tLay.aParts[iRow].aColumns[iCol].iDecimals))  to sText
47033>>>>>                Else Move sVal                                                                                  to sText
47035>>>>>                
47035>>>>>                If (pbAllowRawOutput(ghoWebQry)) Begin
47037>>>>>                    Send AddOpenElement of oWqXml "td"
47038>>>>>                    If      (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD)  Send AddAttribute of oWqXml "style" "text-align: right"
47041>>>>>                    Else If (tLay.aParts[iRow].aColumns[iCol].iType = DF_DATE) Send AddAttribute of oWqXml "style" "text-align: center"
47045>>>>>                    Send Stream of oWqXml ""
47046>>>>>                    Write channel iChn sText
47048>>>>>                    Send CloseElement of oWqXml
47049>>>>>                End
47049>>>>>>
47049>>>>>                Else Begin
47050>>>>>                    Send AddElement of oWqXml "td" sText
47051>>>>>                    If      (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD)  Send AddAttribute of oWqXml "style" "text-align: right"
47054>>>>>                    Else If (tLay.aParts[iRow].aColumns[iCol].iType = DF_DATE) Send AddAttribute of oWqXml "style" "text-align: center"
47058>>>>>                End
47058>>>>>>
47058>>>>>            Loop
47059>>>>>>
47059>>>>>            
47059>>>>>            Move (tLay.iMaxCols - SizeOfArray(tLay.aParts[iRow].aColumns) - 1) to iPad
47060>>>>>            
47060>>>>>            If iPad Begin
47062>>>>>                Send AddElement of oWqXml "td" ""  // possibly "&nbsp;" is more correct, but also more HTML
47063>>>>>                Send AddAttribute of oWqXml "colspan" iPad
47064>>>>>            End
47064>>>>>>
47064>>>>>            
47064>>>>>            Send CloseElement of oWqXml  // tr
47065>>>>>        Loop
47066>>>>>>
47066>>>>>        
47066>>>>>    End_Procedure
47067>>>>>    
47067>>>>>    Procedure OutputTextRow wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay
47069>>>>>        Integer iRow iCol iChn
47069>>>>>        
47069>>>>>        Get piChannel to iChn
47070>>>>>        
47070>>>>>        For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
47076>>>>>>
47076>>>>>            Write channel iChn (Repeat("   ", iRow))
47078>>>>>            
47078>>>>>            For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
47084>>>>>>
47084>>>>>                If (iCol > 0) Write channel iChn "  "
47088>>>>>                
47088>>>>>                If (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD) Begin
47090>>>>>                    Write channel iChn (NumberToStringRTS(oStringFunctions, ;                                                          tLay.aParts[iRow].aColumns[iCol].sCurVal, ;                                                          tLay.aParts[iRow].aColumns[iCol].iDecimals, ;                                                          tLay.aParts[iRow].aColumns[iCol].iPrintWidth))
47092>>>>>                End
47092>>>>>>
47092>>>>>                Else Begin
47093>>>>>                    Write channel iChn (Pad(tLay.aParts[iRow].aColumns[iCol].sCurVal, tLay.aParts[iRow].aColumns[iCol].iPrintWidth))
47095>>>>>                End
47095>>>>>>
47095>>>>>                    
47095>>>>>            Loop
47096>>>>>>
47096>>>>>            
47096>>>>>            WriteLn channel iChn
47098>>>>>        Loop
47099>>>>>>
47099>>>>>
47099>>>>>    End_Procedure
47100>>>>>    
47100>>>>>    Procedure OutputCSVRow wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay
47102>>>>>        Integer iRow iCol iChn
47102>>>>>        
47102>>>>>        Get piChannel to iChn
47103>>>>>        
47103>>>>>        For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
47109>>>>>>
47109>>>>>            
47109>>>>>            For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
47115>>>>>>
47115>>>>>                If (iCol > 0) Write channel iChn ","
47119>>>>>                
47119>>>>>                If ((tLay.aParts[iRow].aColumns[iCol].iType = DF_ASCII) or ;                    (tLay.aParts[iRow].aColumns[iCol].iType = DF_TEXT)) Begin
47121>>>>>                    Write channel iChn '"'
47123>>>>>                    Write channel iChn (Replaces('"', tLay.aParts[iRow].aColumns[iCol].sCurVal, "'"))
47125>>>>>                    Write channel iChn '"'
47127>>>>>                End
47127>>>>>>
47127>>>>>                Else Write channel iChn tLay.aParts[iRow].aColumns[iCol].sCurVal    
47130>>>>>            Loop
47131>>>>>>
47131>>>>>            
47131>>>>>            WriteLn channel iChn
47133>>>>>        Loop
47134>>>>>>
47134>>>>>
47134>>>>>    End_Procedure
47135>>>>>    
47135>>>>>    Procedure OutputXmlRow wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay
47137>>>>>        Integer iRow iCol
47137>>>>>        
47137>>>>>        For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
47143>>>>>>
47143>>>>>            Send AddOpenElement of oWqXml "record"
47144>>>>>            
47144>>>>>            For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
47150>>>>>>
47150>>>>>                Send AddElement of oWqXml (XmlTag(Self, tLay.aParts[iRow].aColumns[iCol].sName)) tLay.aParts[iRow].aColumns[iCol].sCurVal
47151>>>>>            Loop
47152>>>>>>
47152>>>>>            
47152>>>>>            Send CloseElement of oWqXml  // record
47153>>>>>        Loop
47154>>>>>>
47154>>>>>        
47154>>>>>    End_Procedure
47155>>>>>    
47155>>>>>    Procedure OutputRow wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay wqBreakpoint[] ByRef aBreaks Boolean bHighlight
47157>>>>>        Integer iRow iCol i iBrLev
47157>>>>>        String  sVal
47157>>>>>        tXPGrammar tExpGram
47157>>>>>        tXPGrammar tExpGram
47157>>>>>        tXPToken[] aExpSyms
47157>>>>>        tXPToken[] aExpSyms
47158>>>>>        tXPError   tExpErr
47158>>>>>        tXPError   tExpErr
47158>>>>>        tXPValue   tExpRes
47158>>>>>        tXPValue   tExpRes
47158>>>>>        
47158>>>>>        Get BreakLevel (&aBreaks) to iBrLev
47159>>>>>        
47159>>>>>        If (iBrLev > -1) Begin
47161>>>>>            If (tLay.iCount > 0) Send DoSubtotals (&tQuery) (&tLay) (&aBreaks) iBrLev
47164>>>>>            Send DoBreaks (&tQuery) (&tLay) (&aBreaks) iBrLev
47165>>>>>        End
47165>>>>>>
47165>>>>>
47165>>>>>        Increment tLay.iCount
47166>>>>>        
47166>>>>>        // Get values and add in to any totals
47166>>>>>        For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
47172>>>>>>
47172>>>>>            
47172>>>>>            For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
47178>>>>>>
47178>>>>>                
47178>>>>>                If (tLay.aParts[iRow].aColumns[iCol].bCalc) Begin
47180>>>>>                    Get NewGrammar            of oWqExprPar                              to tExpGram
47181>>>>>                    Get TokenizeString        of oWqExprPar tExpGram tLay.aParts[iRow].aColumns[iCol].sExpr (&tExpErr) ;                                                                                         to aExpSyms
47182>>>>>                    Get ReversePolishNotation of oWqExprPar tExpGram aExpSyms (&tExpErr) to aExpSyms
47183>>>>>                    Get Evaluate              of oWqExprPar tExpGram aExpSyms (&tExpErr) to tExpRes
47184>>>>>                    Move tExpRes.sValue                                                  to sVal
47185>>>>>                End
47185>>>>>>
47185>>>>>                Else Begin
47186>>>>>                    Get_Field_Value tLay.aParts[iRow].aColumns[iCol].iTable ;                                    tLay.aParts[iRow].aColumns[iCol].iColumn to sVal
47189>>>>>                End
47189>>>>>>
47189>>>>>                
47189>>>>>                Move (Trim(sVal)) to tLay.aParts[iRow].aColumns[iCol].sCurVal
47190>>>>>                
47190>>>>>                If ((tLay.aParts[iRow].aColumns[iCol].bSum) and ;                    (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD)) Begin
47192>>>>>                    
47192>>>>>                    For i from 0 to (SizeOfArray(aBreaks))  // NOT -1 because 0 is the overall total
47198>>>>>>
47198>>>>>                        Move (tLay.aParts[iRow].aColumns[iCol].anSum[i] + ;                              Number(tLay.aParts[iRow].aColumns[iCol].sCurVal)) to ;                              tLay.aParts[iRow].aColumns[iCol].anSum[i]
47199>>>>>                    Loop
47200>>>>>>
47200>>>>>                    
47200>>>>>                End
47200>>>>>>
47200>>>>>                    
47200>>>>>            Loop
47201>>>>>>
47201>>>>>            
47201>>>>>        Loop
47202>>>>>>
47202>>>>>        
47202>>>>>        If Not (tQuery.bTotalsOnly) Begin
47204>>>>>        
47204>>>>>            // For each row send the appropriate format start row
47204>>>>>            If (tQuery.iOutputFormat = C_wqOutputHtml) Begin
47206>>>>>                Send OutputHtmlRow (&tQuery) (&tLay) bHighlight
47207>>>>>            End
47207>>>>>>
47207>>>>>            Else If (tQuery.iOutputFormat = C_wqOutputText) Begin 
47210>>>>>                Send OutputTextRow (&tQuery) (&tLay)
47211>>>>>            End
47211>>>>>>
47211>>>>>            Else If (tQuery.iOutputFormat = C_wqOutputCSV) Begin
47214>>>>>                Send OutputCSVRow (&tQuery) (&tLay)
47215>>>>>            End
47215>>>>>>
47215>>>>>            Else If (tQuery.iOutputFormat = C_wqOutputXML) Begin
47218>>>>>                Send OutputXmlRow (&tQuery) (&tLay)
47219>>>>>            End
47219>>>>>>
47219>>>>>            
47219>>>>>        End
47219>>>>>>
47219>>>>>        
47219>>>>>    End_Procedure
47220>>>>>    
47220>>>>>    Procedure EndOutput wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn String sFile
47222>>>>>        
47222>>>>>        If (tQuery.iOutputFormat = C_wqOutputHtml) Begin
47224>>>>>            Send WriteEndTable (&tQuery) (&tLay)
47225>>>>>            If (tQuery.iDestination <> C_wqDownload) Send WriteRemoveScript sFile iChn
47228>>>>>            Send WriteHtmlEnd (&tQuery) (&tLay) iChn
47229>>>>>        End
47229>>>>>>
47229>>>>>        Else If (tQuery.iOutputFormat = C_wqOutputText) Begin
47232>>>>>            Send WriteTextTotals (&tQuery) (&tLay) iChn
47233>>>>>            Send WriteTextEnd    (&tQuery) (&tLay) iChn
47234>>>>>        End
47234>>>>>>
47234>>>>>        Else If (tQuery.iOutputFormat = C_wqOutputXML) Begin
47237>>>>>            Send WriteXmlEnd
47238>>>>>        End
47238>>>>>>
47238>>>>>    
47238>>>>>        Close_Output channel iChn
47240>>>>>        Send Seq_Release_Channel iChn
47241>>>>>    End_Procedure
47242>>>>>    
47242>>>>>    // This handles those filters which TableQuery does not.
47242>>>>>    Function IsExcluded wqWebQuery ByRef tQuery wqSelsForTQ[] ByRef aTQSels Returns Boolean
47244>>>>>        Integer i iType
47244>>>>>        String  sVal
47244>>>>>        
47244>>>>>        For i from 0 to (SizeOfArray(aTQSels) - 1)
47250>>>>>>
47250>>>>>            
47250>>>>>            If not (aTQSels[i].bUseTQ) Begin
47252>>>>>                Get_Field_Value aTQSels[i].Selection.iTable aTQSels[i].Selection.iColumn to sVal
47255>>>>>                
47255>>>>>                If (aTQSels[i].Selection.sType = "CIN") Begin
47257>>>>>                    If (aTQSels[i].Selection.sValue contains sVal) Function_Return True
47260>>>>>                End
47260>>>>>>
47260>>>>>                
47260>>>>>                If (aTQSels[i].Selection.sType = "x-y") Begin
47262>>>>>                    Move aTQSels[i].Selection.iType to iType
47263>>>>>                    
47263>>>>>                    If ((iType = DF_ASCII) or (iType = DF_TEXT)) Begin
47265>>>>>                        If ((sVal < aTQSels[i].sStartR) or ;                            (sVal > aTQSels[i].sEndR)) Function_Return True
47268>>>>>                    End
47268>>>>>>
47268>>>>>                    Else If (iType = DF_BCD) Begin
47271>>>>>                        If ((Number(sVal) < Number(aTQSels[i].sStartR)) or ;                            (Number(sVal) > Number(aTQSels[i].sEndR))) Function_Return True
47274>>>>>                    End
47274>>>>>>
47274>>>>>                    Else If ((iType = DF_DATE) or (iType = DF_DATETIME)) Begin
47277>>>>>                        If ((Date(sVal) < Date(aTQSels[i].sStartR)) or ;                            (Date(sVal) > Date(aTQSels[i].sEndR))) Function_Return True
47280>>>>>                    End
47280>>>>>>
47280>>>>>                    
47280>>>>>                End
47280>>>>>>
47280>>>>>                
47280>>>>>                If (aTQSels[i].Selection.sType = "CBT") Begin
47282>>>>>                    Move aTQSels[i].Selection.iType to iType
47283>>>>>                    
47283>>>>>                    If ((iType = DF_ASCII) or (iType = DF_TEXT)) Begin
47285>>>>>                        If ((sVal >= aTQSels[i].sStartR) or ;                            (sVal <= aTQSels[i].sEndR)) Function_Return True
47288>>>>>                    End
47288>>>>>>
47288>>>>>                    Else If (iType = DF_BCD) Begin
47291>>>>>                        If ((Number(sVal) >= Number(aTQSels[i].sStartR)) or ;                            (Number(sVal) <= Number(aTQSels[i].sEndR))) Function_Return True
47294>>>>>                    End
47294>>>>>>
47294>>>>>                    Else If ((iType = DF_DATE) or (iType = DF_DATETIME)) Begin
47297>>>>>                        If ((Date(sVal) >= Date(aTQSels[i].sStartR)) or ;                            (Date(sVal) <= Date(aTQSels[i].sEndR))) Function_Return True
47300>>>>>                    End
47300>>>>>>
47300>>>>>                    
47300>>>>>                End
47300>>>>>>
47300>>>>>                
47300>>>>>            End
47300>>>>>>
47300>>>>>            
47300>>>>>        Loop
47301>>>>>>
47301>>>>>        
47301>>>>>        Function_Return False
47302>>>>>    End_Function
47303>>>>>    
47303>>>>>    Procedure ProcessRecords wqWebQuery ByRef tQuery tTableQuery ByRef tTQ wqSelsForTQ[] ByRef aTQSels wqBreakpoint[] ByRef aBreaks wqPrintRowLayout ByRef tLay
47305>>>>>        Boolean bSkipRec bHighlight
47305>>>>>        tXPGrammar tSelGram
47305>>>>>        tXPGrammar tSelGram
47305>>>>>        tXPToken[] aSelSyms
47305>>>>>        tXPToken[] aSelSyms
47306>>>>>        tXPError   tSelErr
47306>>>>>        tXPError   tSelErr
47306>>>>>        tXPValue   tSelRes
47306>>>>>        tXPValue   tSelRes
47306>>>>>        
47306>>>>>        // Prepare select expression
47306>>>>>        If (tQuery.sSelectExpression <> "") Begin
47308>>>>>            Get NewGrammar of oWqExprPar                                                  to tSelGram
47309>>>>>            Get TokenizeString of oWqExprPar tSelGram tQuery.sSelectExpression (&tSelErr) to aSelSyms
47310>>>>>            Get ReversePolishNotation of oWqExprPar tSelGram aSelSyms  (&tSelErr)         to aSelSyms
47311>>>>>        End
47311>>>>>>
47311>>>>>
47311>>>>>        If not (tQuery.bUseSQL) Begin
47313>>>>>            Send ForceNoESQL of oTQ (&tTQ) 5000 5000
47314>>>>>        End
47314>>>>>>
47314>>>>>        
47314>>>>>        // The TableQuery loop
47314>>>>>        While (FindRecord(oTQ, &tTQ))
47318>>>>>            Move False to bSkipRec
47319>>>>>        
47319>>>>>            Get IsExcluded tQuery aTQSels to bSkipRec
47320>>>>>            
47320>>>>>            If (Not(bSkipRec) and  (tQuery.sSelectExpression <> "")) Begin
47322>>>>>                Get Evaluate of oWqExprPar tSelGram aSelSyms (&tSelErr) to tSelRes
47323>>>>>                Move (Not(tSelRes.sValue))                              to bSkipRec
47324>>>>>            End
47324>>>>>>
47324>>>>>            
47324>>>>>            If not bSkipRec Begin
47326>>>>>                Move (tQuery.bHighlightAlt and (Mod(tLay.iCount, 2) <> 0)) to bHighlight                
47327>>>>>                Send OutputRow (&tQuery) (&tLay) (&aBreaks) bHighlight
47328>>>>>            End
47328>>>>>>
47328>>>>>            
47328>>>>>        Loop
47329>>>>>>
47329>>>>>
47329>>>>>        Send DoSubtotals (&tQuery) (&tLay) (&aBreaks) 0
47330>>>>>    End_Procedure
47331>>>>>    
47331>>>>>    Function OutputReport wqWebQuery ByRef tQuery Returns String
47333>>>>>        String  sFile sPath
47333>>>>>        Integer iChn
47333>>>>>        Boolean bSkipRec
47333>>>>>        Handle[] ahTabs
47334>>>>>        wqPrintRowLayout tLay
47334>>>>>        wqPrintRowLayout tLay
47334>>>>>        tTableQuery tTQ
47334>>>>>        tTableQuery tTQ
47334>>>>>        wqTableDetail[] atTabDets
47334>>>>>        wqTableDetail[] atTabDets
47335>>>>>        wqSelsForTQ[] aTQSels
47335>>>>>        wqSelsForTQ[] aTQSels
47336>>>>>        wqBreakpoint[] aBreaks
47336>>>>>        wqBreakpoint[] aBreaks
47337>>>>>        
47337>>>>>        // Initalisation
47337>>>>>        Set _pbInsertThousandsSeparators of oStringFunctions to True
47338>>>>>        Get OpenOutput tQuery.iDestination tQuery.iOutputFormat (&sPath) (&sFile) to iChn
47339>>>>>        Send SetupBreaks (&tQuery) (&aBreaks)
47340>>>>>        Send CreateLayout (&tQuery) (&tLay) (&aBreaks)
47341>>>>>        Send TableDetails tQuery.hMainTable (&atTabDets) // Opens tables
47342>>>>>        
47342>>>>>        // TableQuery setup
47342>>>>>        Get NewQuery of oTQ tQuery.hMainTable to tTQ
47343>>>>>        Send AddTqRelations (&tTQ) tQuery.hMainTable (&ahTabs)
47344>>>>>        Send AddSelections (&tQuery) (&tTQ) (&aTQSels)
47345>>>>>        Send AddOrdering (&tQuery.aSegments) (&tTQ)
47346>>>>>        
47346>>>>>        // Output report
47346>>>>>        Send StartOutput (&tQuery) (&tLay) iChn
47347>>>>>        Send ProcessRecords (&tQuery) (&tTQ) (&aTQSels) (&aBreaks) (&tLay) iChn
47348>>>>>        Send EndOutput (&tQuery) (&tLay) iChn sFile
47349>>>>>        
47349>>>>>        // Return file for URL
47349>>>>>        Function_Return sFile
47350>>>>>    End_Function
47351>>>>>    
47351>>>>>End_Class
47352>>>>>
47352>>>>>Object oWQFuncs is a cWebQueryFunctions
47354>>>>>    Move Self to ghoWQF
47355>>>>>End_Object
47356>>>Use wqTableSelection.wo
Including file: wqTableSelection.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\wqTableSelection.wo)
47356>>>>>Use cWebModalDialog
47356>>>>>Use cWebPanel.pkg
47356>>>>>Use cWebButton.pkg
47356>>>>>Use cWebForm.pkg
47356>>>>>Use cWebList.pkg
47356>>>>>Use cWebColumn.pkg
47356>>>>>Use cWebQueryFunctions.pkg
47356>>>>>
47356>>>>>Object oWqTableSelection is a cWebModalDialog
47358>>>>>    Set psCaption to "Select Table"
47359>>>>>    Set piMinWidth to 800
47360>>>>>    Set piMinHeight to 500
47361>>>>>    Set pbServerOnSubmit to true    // enable the OnSubmit event
47362>>>>>    Set pbServerOnShow to True
47363>>>>>    
47363>>>>>    Object oMainPanel is a cWebPanel
47365>>>>>        Set piColumnCount to 10
47366>>>>>
47366>>>>>        Object oTablesList is a cWebList
47368>>>>>            Set pbFillHeight to True
47369>>>>>            Set pbDataAware  to False
47370>>>>>            
47370>>>>>            Object oNumCol is a cWebColumn
47372>>>>>                Set psCaption to "Num"
47373>>>>>                Set piWidth to 5
47374>>>>>                Set peDataType to typeNumber
47375>>>>>            End_Object
47376>>>>>            
47376>>>>>            Object oDipCol is a cWebColumn
47378>>>>>                Set psCaption to "Display Name"
47379>>>>>                Set piWidth to 45
47380>>>>>            End_Object
47381>>>>>            
47381>>>>>            Object oDFCol is a cWebColumn
47383>>>>>                Set psCaption to "DF Name"
47384>>>>>                Set piWidth to 15
47385>>>>>            End_Object
47386>>>>>            
47386>>>>>            Object oRootCol is a cWebColumn
47388>>>>>                Set psCaption to "Root Name"
47389>>>>>                Set piWidth to 35
47390>>>>>            End_Object
47391>>>>>            
47391>>>>>            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
47394>>>>>                wqTableInfo[] tTabs
47394>>>>>                wqTableInfo[] tTabs
47395>>>>>                Integer i
47395>>>>>                
47395>>>>>                Get TableInfo of ghoWQF to tTabs
47396>>>>>                
47396>>>>>                For i from 0 to (SizeOFArray(tTabs) - 1)
47402>>>>>>
47402>>>>>                    Move tTabs[i].iNum      to aTheRows[i].aValues[0]
47403>>>>>                    Move tTabs[i].iNum      to aTheRows[i].aValues[1]
47404>>>>>                    Move tTabs[i].sDispName to aTheRows[i].aValues[2]
47405>>>>>                    Move tTabs[i].sDFName   to aTheRows[i].aValues[3]
47406>>>>>                    Move tTabs[i].sRootName to aTheRows[i].aValues[4]
47407>>>>>                Loop
47408>>>>>>
47408>>>>>                
47408>>>>>            End_Procedure  // OnManualLoadData
47409>>>>>            
47409>>>>>        End_Object
47410>>>>>        
47410>>>>>    End_Object 
47411>>>>>    
47411>>>>>    Object oBottomPanel is a cWebPanel
47413>>>>>        Set piColumnCount to 6
47414>>>>>        Set peRegion to prBottom
47415>>>>>
47415>>>>>        Object oOkButton is a cWebButton
47417>>>>>            Set psCaption to C_$OK
47418>>>>>            Set piColumnSpan to 1
47419>>>>>            Set piColumnIndex to 4
47420>>>>>
47420>>>>>            Procedure OnClick
47423>>>>>                Send Ok
47424>>>>>            End_Procedure
47425>>>>>            
47425>>>>>        End_Object 
47426>>>>>
47426>>>>>        Object oCancelButton is a cWebButton
47428>>>>>            Set psCaption to C_$Cancel
47429>>>>>            Set piColumnSpan to 1
47430>>>>>            Set piColumnIndex to 5
47431>>>>>
47431>>>>>            Procedure OnClick
47434>>>>>                Send Cancel
47435>>>>>            End_Procedure
47436>>>>>        End_Object 
47437>>>>>    End_Object 
47438>>>>>
47438>>>>>    Procedure OnSubmit
47441>>>>>        Send Ok
47442>>>>>    End_Procedure
47443>>>>>    
47443>>>>>    Procedure Ok
47446>>>>>        //  Do some calculations / saves / validations here ..
47446>>>>>        Forward Send Ok
47448>>>>>    End_Procedure
47449>>>>>
47449>>>>>    Procedure Cancel
47452>>>>>        Forward Send Cancel
47454>>>>>    End_Procedure
47455>>>>>    
47455>>>>>    Procedure TabListPopup Handle hObj
47458>>>>>        Send Popup hObj
47459>>>>>    End_Procedure  //TabListPopup
47460>>>>>    
47460>>>>>    Procedure OnShow
47463>>>>>        Send GridRefresh of oTablesList
47464>>>>>    End_Procedure  // OnShow
47465>>>>>    
47465>>>>>    Function TableSelected Returns Handle
47468>>>>>        Handle  hTab
47468>>>>>        
47468>>>>>        WebGet psCurrentRowID of oTablesList to hTab
47469>>>>>        Function_Return hTab
47470>>>>>    End_Function  // TableSelected
47471>>>>>    
47471>>>>>End_Object
47472>>>Use wqSelectionOperators.wo
47472>>>Use wqSelectionValues.wo
Including file: wqSelectionValues.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\wqSelectionValues.wo)
47472>>>>>Use cWebModalDialog
47472>>>>>Use cWebPanel.pkg
47472>>>>>Use cWebButton.pkg
47472>>>>>Use cWebForm.pkg
47472>>>>>Use cWebQueryFunctions.pkg
47472>>>>>
47472>>>>>Object oWqSelectionValues is a cWebModalDialog
47474>>>>>    Set psCaption to "Selection Value"
47475>>>>>    Set piMinWidth to 400
47476>>>>>    Set piMinHeight to 60
47477>>>>>    Set pbServerOnSubmit to True
47478>>>>>    
47478>>>>>    Property Integer wpiType
47482>>>>>    
47482>>>>>    Object oMainPanel is a cWebPanel
47484>>>>>        Set piColumnCount to 10
47485>>>>>
47485>>>>>        Object oSelectionValue is a cWebForm
47487>>>>>            Set piColumnSpan to 0
47488>>>>>            Set psLabel to ":"
47489>>>>>            Set peLabelAlign to alignRight
47490>>>>>            Set piLabelOffset to 160
47491>>>>>        End_Object
47492>>>>>        
47492>>>>>    End_Object 
47493>>>>>    
47493>>>>>    Object oBottomPanel is a cWebPanel
47495>>>>>        Set piColumnCount to 6
47496>>>>>        Set peRegion to prBottom
47497>>>>>
47497>>>>>        Object oOkButton is a cWebButton
47499>>>>>            Set psCaption to C_$OK
47500>>>>>            Set piColumnSpan to 1
47501>>>>>            Set piColumnIndex to 4
47502>>>>>
47502>>>>>            Procedure OnClick
47505>>>>>                Send Ok
47506>>>>>            End_Procedure
47507>>>>>            
47507>>>>>        End_Object 
47508>>>>>
47508>>>>>        Object oCancelButton is a cWebButton
47510>>>>>            Set psCaption to C_$Cancel
47511>>>>>            Set piColumnSpan to 1
47512>>>>>            Set piColumnIndex to 5
47513>>>>>
47513>>>>>            Procedure OnClick
47516>>>>>                Send Cancel
47517>>>>>            End_Procedure
47518>>>>>            
47518>>>>>        End_Object
47519>>>>>        
47519>>>>>    End_Object
47520>>>>>
47520>>>>>    Procedure OnSubmit
47523>>>>>        Send Ok
47524>>>>>    End_Procedure
47525>>>>>    
47525>>>>>    Procedure Ok
47528>>>>>        Forward Send Ok
47530>>>>>    End_Procedure
47531>>>>>
47531>>>>>    Procedure Cancel
47534>>>>>        Forward Send Cancel
47536>>>>>    End_Procedure
47537>>>>>    
47537>>>>>    Procedure PopupGetValue Handle hoRetObj String sField String sOp String sCurVal Integer iType
47540>>>>>        WebSet psLabel    of oSelectionValue to (sField * "(" + sOp + "):")
47541>>>>>        If (iType = typeASCII) Move (StrDelQuotes(ghoWQF, sCurVal)) to sCurVal
47544>>>>>        If (iType = typeDate)  Move (Date2MilDate(ghoWQF, sCurVal)) to sCurVal
47547>>>>>        WebSet psValue    of oSelectionValue to sCurVal
47548>>>>>        WebSet peDataType of oSelectionValue to iType
47549>>>>>        
47549>>>>>        Send Popup hoRetObj
47550>>>>>    End_Procedure
47551>>>>>    
47551>>>>>    Function ValueSelected Returns String
47554>>>>>        String  sVal
47554>>>>>        Integer iType
47554>>>>>        
47554>>>>>        WebGet peDataType of oSelectionValue to iType
47555>>>>>        WebGet psValue    of oSelectionValue to sVal
47556>>>>>        If (iType = typeASCII) Move (StrAddQuotes(ghoWQF, sVal)) to sVal
47559>>>>>        If (iType = typeDate)  Move (MilDate2Date(ghoWQF, sVal)) to sVal
47562>>>>>        Function_Return sVal
47563>>>>>    End_Function
47564>>>>>    
47564>>>>>End_Object
47565>>>Use wqSelectionRanges.wo
Including file: wqSelectionRanges.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\wqSelectionRanges.wo)
47565>>>>>
47565>>>>>Use cWebModalDialog
47565>>>>>Use cWebPanel.pkg
47565>>>>>Use cWebButton.pkg
47565>>>>>Use cWebForm.pkg
47565>>>>>Use cWebQueryFunctions.pkg
47565>>>>>
47565>>>>>Object oWqSelectionRanges is a cWebModalDialog
47567>>>>>    Set psCaption to "Selection Range"
47568>>>>>    Set piMinWidth to 400
47569>>>>>    Set piMinHeight to 100
47570>>>>>    Set pbServerOnSubmit to True
47571>>>>>    
47571>>>>>    Object oMainPanel is a cWebPanel
47573>>>>>        Set piColumnCount to 10
47574>>>>>
47574>>>>>        Object oStartRange is a cWebForm
47576>>>>>            Set piColumnSpan to 0
47577>>>>>            Set psLabel to "from:"
47578>>>>>            Set peLabelAlign to alignRight
47579>>>>>            Set piLabelOffset to 180
47580>>>>>        End_Object
47581>>>>>
47581>>>>>        Object oEndRange is a cWebForm
47583>>>>>            Set piColumnSpan to 0
47584>>>>>            Set psLabel to "to:"
47585>>>>>            Set peLabelAlign to alignRight
47586>>>>>            Set piLabelOffset to 180
47587>>>>>        End_Object
47588>>>>>        
47588>>>>>    End_Object 
47589>>>>>    
47589>>>>>    Object oBottomPanel is a cWebPanel
47591>>>>>        Set piColumnCount to 6
47592>>>>>        Set peRegion to prBottom
47593>>>>>
47593>>>>>        Object oOkButton is a cWebButton
47595>>>>>            Set psCaption to C_$OK
47596>>>>>            Set piColumnSpan to 1
47597>>>>>            Set piColumnIndex to 4
47598>>>>>
47598>>>>>            Procedure OnClick
47601>>>>>                Send Ok
47602>>>>>            End_Procedure
47603>>>>>            
47603>>>>>        End_Object 
47604>>>>>
47604>>>>>        Object oCancelButton is a cWebButton
47606>>>>>            Set psCaption to C_$Cancel
47607>>>>>            Set piColumnSpan to 1
47608>>>>>            Set piColumnIndex to 5
47609>>>>>
47609>>>>>            Procedure OnClick
47612>>>>>                Send Cancel
47613>>>>>            End_Procedure
47614>>>>>            
47614>>>>>        End_Object
47615>>>>>        
47615>>>>>    End_Object
47616>>>>>
47616>>>>>    Procedure OnSubmit
47619>>>>>        Send Ok
47620>>>>>    End_Procedure
47621>>>>>    
47621>>>>>    Procedure Ok
47624>>>>>        Forward Send Ok
47626>>>>>    End_Procedure
47627>>>>>
47627>>>>>    Procedure Cancel
47630>>>>>        Forward Send Cancel
47632>>>>>    End_Procedure
47633>>>>>    
47633>>>>>    Procedure PopupGetRange Handle hoRetObj String sField String sOp String sCurVal Integer iType
47636>>>>>        Integer iPos
47636>>>>>        String  sStR sEndR
47636>>>>>        
47636>>>>>        WebSet psLabel of oStartRange to (sField * "(" + sOp + ") - from:")
47637>>>>>        
47637>>>>>        Move (Replace(" (both incl)", sCurVal, ""))  to sCurVal
47638>>>>>        Move (Replace("No limitation", sCurVal, "")) to sCurVal
47639>>>>>        Move (Pos("-", sCurVal)) to iPos
47640>>>>>        
47640>>>>>        If iPos Begin
47642>>>>>            Move (Left(sCurVal, (iPos - 2)))                    to sStR
47643>>>>>            Move (Right(sCurVal, (Length(sCurVal) - iPos - 1))) to sEndR
47644>>>>>        End
47644>>>>>>
47644>>>>>        
47644>>>>>        WebSet peDataType of oStartRange to iType
47645>>>>>        WebSet peDataType of oEndRange   to iType
47646>>>>>        
47646>>>>>        If (iType = typeASCII) Begin
47648>>>>>            Move (StrDelQuotes(ghoWQF, sStR))  to sStR
47649>>>>>            Move (StrDelQuotes(ghoWQF, sEndR)) to sEndR
47650>>>>>        End
47650>>>>>>
47650>>>>>        
47650>>>>>        If (iType = typeDate) Begin
47652>>>>>            Get Date2MilDate of ghoWQF sStR  to sStR
47653>>>>>            Get Date2MilDate of ghoWQF sEndR to sEndR
47654>>>>>        End
47654>>>>>>
47654>>>>>        
47654>>>>>        WebSet psValue of oStartRange to sStR
47655>>>>>        WebSet psValue of oEndRange   to sEndR
47656>>>>>        
47656>>>>>        Send Popup hoRetObj
47657>>>>>    End_Procedure
47658>>>>>    
47658>>>>>    Function RangeSelected Returns String
47661>>>>>        String  sStR sEndR sSep
47661>>>>>        Integer iType iDateF
47661>>>>>        
47661>>>>>        WebGet psValue    of oStartRange to sStR
47662>>>>>        WebGet psValue    of oEndRange   to sEndR
47663>>>>>        WebGet peDataType of oStartRange to iType
47664>>>>>        
47664>>>>>        If (iType = typeASCII) Move (StrAddQuotes(ghoWQF, sStR))    to sStR
47667>>>>>        If (iType = typeASCII) Move (StrAddQuotes(ghoWQF, sEndR))   to sEndR
47670>>>>>        
47670>>>>>        // Seems to return dates in military format, so...
47670>>>>>        If (iType = typeDate) Begin
47672>>>>>            Get MilDate2Date of ghoWQF sStR  to sStR
47673>>>>>            Get MilDate2Date of ghoWQF sEndR to sEndR
47674>>>>>        End
47674>>>>>>
47674>>>>>            
47674>>>>>        Function_Return (sStR + " - " + sEndR + " (both incl)")
47675>>>>>    End_Function
47676>>>>>    
47676>>>>>End_Object
47677>>>Use wqSelectionList.wo
Including file: wqSelectionList.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\wqSelectionList.wo)
47677>>>>>Use cWebModalDialog
47677>>>>>Use cWebPanel.pkg
47677>>>>>Use cWebButton.pkg
47677>>>>>Use cWebForm.pkg
47677>>>>>Use cWebGrid.pkg
47677>>>>>Use cWebColumn.pkg
47677>>>>>
47677>>>>>Object oWqSelectionList is a cWebModalDialog
47679>>>>>    Set psCaption to "Selection in List"
47680>>>>>    Set piMinWidth to 400
47681>>>>>    Set piMinHeight to 300
47682>>>>>    Set pbServerOnSubmit to True
47683>>>>>    Set pbServerOnShow   to True
47684>>>>>    
47684>>>>>    Property String  wpsList
47688>>>>>    
47688>>>>>    Object oMainPanel is a cWebPanel
47690>>>>>        Set piColumnCount to 10
47691>>>>>
47691>>>>>        Object oValueList is a cWebGrid
47693>>>>>            Set pbShowLabel         to True
47694>>>>>            Set peLabelPosition     to lpTop
47695>>>>>            Set peLabelAlign        to alignLeft
47696>>>>>            Set pbDataAware         to False
47697>>>>>            Set pbOfflineEditing    to True
47698>>>>>            Set psLabel             to ":"
47699>>>>>            Set pbFillHeight        to True
47700>>>>>            Set pbAllowAppendRow    to True
47701>>>>>                        
47701>>>>>            Object oValueCol is a cWebColumn
47703>>>>>                Set psCaption to "Values"
47704>>>>>            End_Object
47705>>>>>            
47705>>>>>            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
47708>>>>>                String  sList sVal
47708>>>>>                Integer i iPos iType
47708>>>>>                
47708>>>>>                WebGet wpsList of oWqSelectionList to sList
47709>>>>>                WebGet peDataType of oValueCol     to iType
47710>>>>>                Move 0 to i
47711>>>>>                
47711>>>>>                Repeat
47711>>>>>>
47711>>>>>                    Move (Trim(sList)) to sList
47712>>>>>                    If (sList = "") Break
47715>>>>>                    
47715>>>>>                    Move (Pos(";", sList)) to iPos
47716>>>>>                    
47716>>>>>                    If (iPos > 0) Begin
47718>>>>>                        Move (Left(sList, (iPos - 1))) to sVal
47719>>>>>                        Move (Right(sList, (Length(sList) - iPos))) to sList
47720>>>>>                    End
47720>>>>>>
47720>>>>>                    Else If (sList <> "") Move sList to sVal
47724>>>>>                    
47724>>>>>                    If (iType = typeDate) Move (Date2MilDate(ghoWQF, sVal)) to sVal
47727>>>>>                    
47727>>>>>                    If (sVal <> "") Begin
47729>>>>>                        Move i    to aTheRows[i].aValues[0]
47730>>>>>                        Move sVal to aTheRows[i].aValues[1]
47731>>>>>                        Increment i
47732>>>>>                    End
47732>>>>>>
47732>>>>>                    
47732>>>>>                Until (iPos < 1)
47734>>>>>                
47734>>>>>            End_Procedure
47735>>>>>            
47735>>>>>            Procedure OnProcessDataSet tWebRow[] aData Integer eOperation Integer iSelectedRowIndex
47738>>>>>                Integer i iType
47738>>>>>                String  sData sItem
47738>>>>>                
47738>>>>>                Move "" to sData
47739>>>>>                WebGet peDataType of oValueCol to iType
47740>>>>>                
47740>>>>>                For i from 0 to (SizeOFArray(aData) - 1)
47746>>>>>>
47746>>>>>                    If (i > 0) Move (sData + "; ") to sData
47749>>>>>                    Move aData[i].aValues[1] to sItem
47750>>>>>                    If (iType = typeDate) Move (MilDate2Date(ghoWQF, sItem)) to sItem
47753>>>>>                    Move (sData + sItem) to sData
47754>>>>>                Loop
47755>>>>>>
47755>>>>>                
47755>>>>>                WebSet wpsList of oWqSelectionList to sData
47756>>>>>                Send OK
47757>>>>>            End_Procedure
47758>>>>>            
47758>>>>>        End_Object
47759>>>>>        
47759>>>>>    End_Object 
47760>>>>>    
47760>>>>>    Object oBottomPanel is a cWebPanel
47762>>>>>        Set piColumnCount to 6
47763>>>>>        Set peRegion to prBottom
47764>>>>>
47764>>>>>        Object oOkButton is a cWebButton
47766>>>>>            Set psCaption to C_$OK
47767>>>>>            Set piColumnSpan to 1
47768>>>>>            Set piColumnIndex to 4
47769>>>>>
47769>>>>>            Procedure OnClick
47772>>>>>                Send ProcessDataSet of oValueList 0
47773>>>>>            End_Procedure
47774>>>>>            
47774>>>>>        End_Object
47775>>>>>
47775>>>>>        Object oCancelButton is a cWebButton
47777>>>>>            Set psCaption to C_$Cancel
47778>>>>>            Set piColumnSpan to 1
47779>>>>>            Set piColumnIndex to 5
47780>>>>>
47780>>>>>            Procedure OnClick
47783>>>>>                Send Cancel
47784>>>>>            End_Procedure
47785>>>>>            
47785>>>>>        End_Object
47786>>>>>        
47786>>>>>    End_Object 
47787>>>>>
47787>>>>>    Procedure OnSubmit
47790>>>>>        Send Ok
47791>>>>>    End_Procedure
47792>>>>>    
47792>>>>>    Procedure Ok
47795>>>>>        Forward Send Ok
47797>>>>>    End_Procedure
47798>>>>>
47798>>>>>    Procedure Cancel
47801>>>>>        Forward Send Cancel
47803>>>>>    End_Procedure
47804>>>>>    
47804>>>>>    Procedure OnShow
47807>>>>>        Send GridRefresh  of oValueList
47808>>>>>    End_Procedure
47809>>>>>
47809>>>>>    Procedure PopupGetList Handle hoRetObj String sField String sOp String sCurVal Integer iType
47812>>>>>        Integer iPos
47812>>>>>        
47812>>>>>        WebSet psLabel of oValueList to (sField * "is one of:")
47813>>>>>        WebSet peDataType of oValueCol to iType
47814>>>>>        If (iType = typeASCII) Move (StrDelQuotes(ghoWQF, sCurVal)) to sCurVal
47817>>>>>        WebSet wpsList to sCurVal
47818>>>>>        Send Popup hoRetObj
47819>>>>>    End_Procedure
47820>>>>>    
47820>>>>>    Function ListSelected Returns String
47823>>>>>        String  sVals
47823>>>>>        
47823>>>>>        WebGet wpsList to sVals
47824>>>>>        Function_Return sVals
47825>>>>>    End_Function
47826>>>>>
47826>>>>>End_Object
47827>>>Use wqExpressionPopup.wo
Including file: wqExpressionPopup.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\wqExpressionPopup.wo)
47827>>>>>Use cWebModalDialog
47827>>>>>Use cWebPanel.pkg
47827>>>>>Use cWebButton.pkg
47827>>>>>Use cWebForm.pkg
47827>>>>>Use cWebEdit.pkg
47827>>>>>Use cWebList.pkg
47827>>>>>Use cWebColumn.pkg
47827>>>>>
47827>>>>>Use cWqWebEdit.pkg
Including file: cWqWebEdit.pkg    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\cWqWebEdit.pkg)
47827>>>>>>>Use cWebEdit.pkg
47827>>>>>>>
47827>>>>>>>Class cWqWebEdit is a cWebEdit
47828>>>>>>>    
47828>>>>>>>    Procedure Construct_Object
47830>>>>>>>        Forward Send Construct_Object
47832>>>>>>>        
47832>>>>>>>        Property Integer piCaretPosition 0
47835>>>>>>>        
47835>>>>>>>        Set psJSClass to "df.wqWebEdit"
47836>>>>>>>    End_Procedure
47837>>>>>>>
47837>>>>>>>End_Class
47838>>>>>Use cWebQueryFunctions.pkg
47838>>>>>
47838>>>>>Struct wqExpressionReturn
47838>>>>>    String  sExpression
47838>>>>>    Integer iOp
47838>>>>>    Integer iField
47838>>>>>End_Struct
47838>>>>>
47838>>>>>Object oWqExpressionPopup is a cWebModalDialog
47840>>>>>    Set psCaption        to "Expression"
47841>>>>>    Set piMinWidth       to 800
47842>>>>>    Set piMinHeight      to 500
47843>>>>>    Set pbServerOnSubmit to True
47844>>>>>    Set pbServerOnShow   to True
47845>>>>>    
47845>>>>>    Property Integer wpiOp
47849>>>>>    Property Integer wpiField
47853>>>>>    Property Handle  wphMainTable
47857>>>>>    Property String  wpsExpression
47861>>>>>    Property String  wpsName
47865>>>>>    
47865>>>>>    Property Handle phSelectedTable
47867>>>>>    
47867>>>>>    Object oExprPanel is a cWebPanel
47869>>>>>        Set peRegion to prTop
47870>>>>>        Set piHeight to 200
47871>>>>>        
47871>>>>>        Object oExpression is a cWqWebEdit
47873>>>>>            Set piColumnSpan to 0
47874>>>>>            Set pbShowLabel to False
47875>>>>>            Set pbFillHeight to True
47876>>>>>        End_Object
47877>>>>>
47877>>>>>    End_Object
47878>>>>>
47878>>>>>    Object oListsPanel is a cWebPanel
47880>>>>>        Set pbFillHeight to True
47881>>>>>        Set piColumnCount to 20
47882>>>>>
47882>>>>>        Object oTablesList is a cWebList
47884>>>>>            Set piColumnIndex       to 0
47885>>>>>            Set piColumnSpan        to 4
47886>>>>>            Set pbFillHeight        to True
47887>>>>>            Set pbDataAware         to False
47888>>>>>            Set pbColumnSortable    to False
47889>>>>>            
47889>>>>>            Object oTableCol is a cWebColumn
47891>>>>>                Set psCaption to "Tables"
47892>>>>>            End_Object
47893>>>>>            
47893>>>>>            Procedure OnChangeCurrentRow String sFromRowID String sToRowID
47896>>>>>                Set phSelectedTable     to sToRowID
47897>>>>>                Send GridRefresh        of oFieldsList
47898>>>>>                WebSet psCurrentRowID   of oFieldsList to 1
47899>>>>>            End_Procedure  // OnChangeCurrentRow
47900>>>>>            
47900>>>>>            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
47903>>>>>                Handle hTab
47903>>>>>                
47903>>>>>                WebGet wphMainTable of oWqExpressionPopup to hTab                
47904>>>>>                Send RelatedFiles of ghoWQF (&aTheRows) hTab
47905>>>>>            End_Procedure
47906>>>>>            
47906>>>>>        End_Object
47907>>>>>
47907>>>>>        Object oFieldsList is a cWebList
47909>>>>>            Set piColumnIndex       to 4
47910>>>>>            Set piColumnSpan        to 6
47911>>>>>            Set pbFillHeight        to True
47912>>>>>            Set pbDataAware         to False
47913>>>>>            Set pbColumnSortable    to False
47914>>>>>            
47914>>>>>            Object oFieldCol is a cWebColumn
47916>>>>>                Set psCaption to "Fields"
47917>>>>>            End_Object
47918>>>>>            
47918>>>>>            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
47921>>>>>                Send CollectColumns of ghoWQF (&aTheRows) (phSelectedTable(oWqExpressionPopup))
47922>>>>>            End_Procedure
47923>>>>>            
47923>>>>>        End_Object
47924>>>>>
47924>>>>>        Object oFuncsList is a cWebList
47926>>>>>            Set piColumnIndex       to 10
47927>>>>>            Set piColumnSpan        to 0
47928>>>>>            Set pbFillHeight        to True
47929>>>>>            Set pbDataAware         to False
47930>>>>>            Set pbColumnSortable    to False
47931>>>>>            
47931>>>>>            Object oFuncCol is a cWebColumn
47933>>>>>                Set psCaption to "Functions"
47934>>>>>            End_Object
47935>>>>>            
47935>>>>>            Procedure OnManualLoadData tWebRow[] ByRef aRows String ByRef sCurrentRowID
47938>>>>>                Integer i
47938>>>>>                
47938>>>>>                Move "Mid(s, i, i)"         to aRows[(SizeOfArray(aRows))].aValues[1]
47939>>>>>                Move "Left(s, i)"           to aRows[(SizeOfArray(aRows))].aValues[1]
47940>>>>>                Move "Right(s, i)"          to aRows[(SizeOfArray(aRows))].aValues[1]
47941>>>>>                Move "Uppercase(s)"         to aRows[(SizeOfArray(aRows))].aValues[1]
47942>>>>>                Move "Lowercase(s)"         to aRows[(SizeOfArray(aRows))].aValues[1]
47943>>>>>                Move "Concat(s, s)"         to aRows[(SizeOfArray(aRows))].aValues[1]
47944>>>>>                Move "Length(s)"            to aRows[(SizeOfArray(aRows))].aValues[1]
47945>>>>>                Move "Trim(s)"              to aRows[(SizeOfArray(aRows))].aValues[1]
47946>>>>>                Move "Pos(s, s)"            to aRows[(SizeOfArray(aRows))].aValues[1]
47947>>>>>                Move "Today()"              to aRows[(SizeOfArray(aRows))].aValues[1]
47948>>>>>                Move "Month(d)"             to aRows[(SizeOfArray(aRows))].aValues[1]
47949>>>>>                Move "Week(d)"              to aRows[(SizeOfArray(aRows))].aValues[1]
47950>>>>>                Move "Year(d)"              to aRows[(SizeOfArray(aRows))].aValues[1]
47951>>>>>                Move "Day(d)"               to aRows[(SizeOfArray(aRows))].aValues[1]
47952>>>>>                Move "DayName(i)"           to aRows[(SizeOfArray(aRows))].aValues[1]
47953>>>>>                Move "MonthName(i)"         to aRows[(SizeOfArray(aRows))].aValues[1]
47954>>>>>//                Move "DateIncrement(d,i,i)" to aRows[(SizeOfArray(aRows))].aValues[1]
47954>>>>>                Move "FirstDayInMonth(d)"   to aRows[(SizeOfArray(aRows))].aValues[1]
47955>>>>>                Move "DateAsTextEU(d)"      to aRows[(SizeOfArray(aRows))].aValues[1]
47956>>>>>                Move "DateAsTextUS(d)"      to aRows[(SizeOfArray(aRows))].aValues[1]
47957>>>>>                Move "DateFormatText(d, s)" to aRows[(SizeOfArray(aRows))].aValues[1]
47958>>>>>//                Move "If_Int(i,i,i)"        to aRows[(SizeOfArray(aRows))].aValues[1]
47958>>>>>//                Move "If_Num(i,i,n)"        to aRows[(SizeOfArray(aRows))].aValues[1]
47958>>>>>//                Move "If_Str(i,s,s)"        to aRows[(SizeOfArray(aRows))].aValues[1]
47958>>>>>//                Move "If_Dat(i,d,d)"        to aRows[(SizeOfArray(aRows))].aValues[1]
47958>>>>>                Move "Integer(i)"           to aRows[(SizeOfArray(aRows))].aValues[1]
47959>>>>>                Move "String(s)"            to aRows[(SizeOfArray(aRows))].aValues[1]
47960>>>>>                Move "Number(n)"            to aRows[(SizeOfArray(aRows))].aValues[1]
47961>>>>>                Move "Date(d)"              to aRows[(SizeOfArray(aRows))].aValues[1]
47962>>>>>                Move "not(i)"               to aRows[(SizeOfArray(aRows))].aValues[1]
47963>>>>>                
47963>>>>>                For i from 0 to (SizeOfArray(aRows) - 1)
47969>>>>>>
47969>>>>>                    Move i to aRows[i].aValues[0]
47970>>>>>                Loop
47971>>>>>>
47971>>>>>                
47971>>>>>            End_Procedure
47972>>>>>            
47972>>>>>        End_Object
47973>>>>>            
47973>>>>>    End_Object
47974>>>>>    
47974>>>>>    Object oBottomPanel is a cWebPanel
47976>>>>>        Set piColumnCount to 8
47977>>>>>        Set peRegion to prBottom
47978>>>>>
47978>>>>>        Object oOkButton is a cWebButton
47980>>>>>            Set psCaption to C_$OK
47981>>>>>            Set piColumnSpan to 1
47982>>>>>            Set piColumnIndex to 5
47983>>>>>
47983>>>>>            Procedure OnClick
47986>>>>>                Send Ok
47987>>>>>            End_Procedure
47988>>>>>            
47988>>>>>        End_Object 
47989>>>>>
47989>>>>>        Object oClearButton is a cWebButton
47991>>>>>            Set psCaption to "Clear"
47992>>>>>            Set piColumnSpan to 1
47993>>>>>            Set piColumnIndex to 6
47994>>>>>
47994>>>>>            Procedure OnClick
47997>>>>>                Send ClearExpr
47998>>>>>            End_Procedure
47999>>>>>            
47999>>>>>        End_Object 
48000>>>>>
48000>>>>>        Object oCancelButton is a cWebButton
48002>>>>>            Set psCaption to C_$Cancel
48003>>>>>            Set piColumnSpan to 1
48004>>>>>            Set piColumnIndex to 7
48005>>>>>
48005>>>>>            Procedure OnClick
48008>>>>>                Send Cancel
48009>>>>>            End_Procedure
48010>>>>>            
48010>>>>>        End_Object 
48011>>>>>        
48011>>>>>    End_Object
48012>>>>>    
48012>>>>>    Procedure InsertFunction
48015>>>>>        Integer iPos iLen
48015>>>>>        String  sFunc sExpr
48015>>>>>        
48015>>>>>        WebGet psValue of oExpression to sExpr
48016>>>>>        WebGet piCaretPosition of oExpression to iPos
48017>>>>>        WebGet psValue of oFuncCol to sFunc
48018>>>>>        Move (Length(sExpr)) to iLen
48019>>>>>        
48019>>>>>        If (iPos > iLen) Move (sExpr + sFunc) to sExpr
48022>>>>>        Else Move (Left(sExpr, (iPos - 1)) + sFunc + Right(sExpr, (iLen - iPos + 1))) to sExpr
48024>>>>>        
48024>>>>>        WebSet psValue of oExpression to sExpr
48025>>>>>        WebSet piCaretPosition of oExpression to (iPos + Length(sFunc))
48026>>>>>    End_Procedure
48027>>>>>    
48027>>>>>    Procedure InsertField
48030>>>>>        Integer iPos iLen iFld
48030>>>>>        Handle  hTab
48030>>>>>        String  sExpr sTab sFld sFF
48030>>>>>        
48030>>>>>        WebGet psValue         of oExpression to sExpr
48031>>>>>        WebGet piCaretPosition of oExpression to iPos
48032>>>>>        WebGet psCurrentRowID  of oTablesList to hTab
48033>>>>>        WebGet psCurrentRowID  of oFieldsList to iFld
48034>>>>>        
48034>>>>>        Open hTab
48036>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTab      to sTab
48039>>>>>        Get_Attribute DF_FIELD_NAME        of hTab iFld to sFld
48042>>>>>        
48042>>>>>        Move (sTab + "." + sFld) to sFF        
48043>>>>>        Move (Length(sExpr))     to iLen
48044>>>>>        
48044>>>>>        If (iPos > iLen) Move (sExpr + sFF) to sExpr
48047>>>>>        Else Move (Left(sExpr, (iPos - 1)) + sFF + Right(sExpr, (iLen - iPos + 1))) to sExpr
48049>>>>>        
48049>>>>>        WebSet psValue of oExpression to sExpr
48050>>>>>        WebSet piCaretPosition of oExpression to (iPos + Length(sFF))
48051>>>>>    End_Procedure
48052>>>>>
48052>>>>>    Procedure OnSubmit
48055>>>>>        Handle  hoFoc
48055>>>>>        
48055>>>>>        Get FocusObject to hoFoc
48056>>>>>        
48056>>>>>        If (hoFoc = oFieldsList) Send InsertField
48059>>>>>        If (hoFoc = oFuncsList)  Send InsertFunction
48062>>>>>    End_Procedure
48063>>>>>    
48063>>>>>    Procedure ClearExpr
48066>>>>>        WebSet psValue of oExpression to ""
48067>>>>>    End_Procedure
48068>>>>>    
48068>>>>>    Procedure OnLoad
48071>>>>>        Send GridRefresh of oFuncsList
48072>>>>>    End_Procedure
48073>>>>>    
48073>>>>>    Procedure OnShow
48076>>>>>        String  sExpr sName
48076>>>>>        Integer iOp
48076>>>>>        
48076>>>>>        WebGet wpiOp   to iOp
48077>>>>>        WebGet wpsName to sName
48078>>>>>        
48078>>>>>        If (iOp = C_wqSelectExpr) WebSet psCaption to "Edit selection expression"
48081>>>>>        Else                      WebSet psCaption to ('Edit expression for calculated column "' + sName + '"')
48083>>>>>        
48083>>>>>        WebGet wpsExpression            to sExpr
48084>>>>>        WebSet psValue of oExpression   to sExpr
48085>>>>>        Send GridRefresh of oTablesList
48086>>>>>    End_Procedure
48087>>>>>    
48087>>>>>    Procedure Ok
48090>>>>>        String  sExpr
48090>>>>>        tXPGrammar tXPGram
48090>>>>>        tXPGrammar tXPGram
48090>>>>>        tXPToken[] aXPSyms
48090>>>>>        tXPToken[] aXPSyms
48091>>>>>        tXPError   tXPErr
48091>>>>>        tXPError   tXPErr
48091>>>>>        tXPValue   tXPRes
48091>>>>>        tXPValue   tXPRes
48091>>>>>        
48091>>>>>        WebGet psValue of oExpression to sExpr
48092>>>>>        
48092>>>>>        If (sExpr <> "") Begin
48094>>>>>            Get NewGrammar of oWqExprPar                                          to tXPGram
48095>>>>>            Get TokenizeString of oWqExprPar tXPGram sExpr (&tXPErr)              to aXPSyms
48096>>>>>            If (tXPErr.iPos = 0) ;                Get ReversePolishNotation of oWqExprPar tXPGram aXPSyms (&tXPErr) to aXPSyms
48099>>>>>        
48099>>>>>            If (tXPErr.iPos <> 0) Begin
48101>>>>>                Send ShowInfoBox ('Error in expression: "' + tXPErr.sErrorText + '"') "Expression Error"
48102>>>>>            End
48102>>>>>>
48102>>>>>            Else Forward Send Ok
48105>>>>>            
48105>>>>>        End
48105>>>>>>
48105>>>>>        Else Forward Send Ok
48108>>>>>        
48108>>>>>    End_Procedure
48109>>>>>
48109>>>>>    Procedure Cancel
48112>>>>>        Forward Send Cancel
48114>>>>>    End_Procedure
48115>>>>>    
48115>>>>>    Procedure DoPopup Handle hoObj String sExpr Integer iOp Integer iFld Handle hMainTab String sName
48118>>>>>        WebSet wpsExpression    to sExpr
48119>>>>>        WebSet wpiOp            to iOp
48120>>>>>        WebSet wpiField         to iFld  // ToDo: Don't think we need this...
48121>>>>>        WebSet wphMainTable     to hMainTab
48122>>>>>        WebSet wpsName          to sName
48123>>>>>                
48123>>>>>        Send Popup hoObj
48124>>>>>    End_Procedure
48125>>>>>    
48125>>>>>    Function ExprValue Returns wqExpressionReturn
48128>>>>>        wqExpressionReturn tExpr
48128>>>>>        wqExpressionReturn tExpr
48128>>>>>        
48128>>>>>        WebGet psValue of oExpression to tExpr.sExpression
48129>>>>>        WebGet wpiOp                  to tExpr.iOp
48130>>>>>        WebGet wpiField               to tExpr.iField
48131>>>>>        
48131>>>>>        Function_Return tExpr
48132>>>>>    End_Function
48133>>>>>    
48133>>>>>End_Object
48134>>>Use wqAddInsEdit.wo
Including file: wqAddInsEdit.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\wqAddInsEdit.wo)
48134>>>>>Use cWebModalDialog
48134>>>>>Use cWebPanel.pkg
48134>>>>>Use cWebButton.pkg
48134>>>>>Use cWebForm.pkg
48134>>>>>Use cWebMenuItem.pkg
48134>>>>>Use cWebMenuBar.pkg
48134>>>>>Use cWebImage.pkg
48134>>>>>Use cWebLabel.pkg
48134>>>>>Use cWebCommandbar.pkg
48134>>>>>
48134>>>>>Object oWqAddInsEdit is a cWebModalDialog
48136>>>>>    Property Integer piSelection
48138>>>>>    
48138>>>>>    Set psCaption           to "Expression"
48139>>>>>    Set piMinWidth          to 100
48140>>>>>    Set piMinHeight         to 100
48141>>>>>    Set pbShowClose         to False
48142>>>>>    Set pbResizable         to False
48143>>>>>    Set pbServerOnSubmit    to True    // enable the OnSubmit event
48144>>>>>    Set pbServerOnShow      to True
48145>>>>>
48145>>>>>    Object oAddButton is a cWebButton
48147>>>>>        Set piColumnSpan to 0
48148>>>>>        Set psCaption to "Add"
48149>>>>>    
48149>>>>>        Procedure OnClick
48152>>>>>            Set piSelection to C_wqAddExpression
48153>>>>>            Send Ok
48154>>>>>        End_Procedure
48155>>>>>    End_Object
48156>>>>>
48156>>>>>    Object oInsertButton is a cWebButton
48158>>>>>        Set piColumnSpan to 0
48159>>>>>        Set psCaption to "Insert"
48160>>>>>    
48160>>>>>        Procedure OnClick
48163>>>>>            Set piSelection to C_wqInsertExpression
48164>>>>>            Send Ok
48165>>>>>        End_Procedure
48166>>>>>    End_Object
48167>>>>>
48167>>>>>    Object oEditButton is a cWebButton
48169>>>>>        Set piColumnSpan to 0
48170>>>>>        Set psCaption to "Edit"
48171>>>>>    
48171>>>>>        Procedure OnClick
48174>>>>>            Set piSelection to C_wqEditExpression
48175>>>>>            Send Ok
48176>>>>>        End_Procedure
48177>>>>>    End_Object
48178>>>>>
48178>>>>>    Object oDismissButton is a cWebButton
48180>>>>>        Set piColumnSpan to 0
48181>>>>>        Set psCaption to "Dismiss"
48182>>>>>    
48182>>>>>        Procedure OnClick
48185>>>>>            Send Cancel
48186>>>>>        End_Procedure
48187>>>>>    End_Object
48188>>>>>
48188>>>>>//    Object oCmdBar is a cWebCommandBar
48188>>>>>//        
48188>>>>>//        Object oMenuBar is a cWebMenuBar
48188>>>>>//            
48188>>>>>//            Object oAddItem is a cWebMenuItem
48188>>>>>//                Set psCaption to "Add"
48188>>>>>//                
48188>>>>>//                Procedure OnClick
48188>>>>>//                    Set piSelection to C_wqAddExpression
48188>>>>>//                    Send Ok
48188>>>>>//                End_Procedure  // OnClick
48188>>>>>//                
48188>>>>>//            End_Object
48188>>>>>//            
48188>>>>>//            Object oInsertItem is a cWebMenuItem
48188>>>>>//                Set psCaption to "Insert"
48188>>>>>//                
48188>>>>>//                Procedure OnClick
48188>>>>>//                    Set piSelection to C_wqInsertExpression
48188>>>>>//                    Send Ok
48188>>>>>//                End_Procedure  // OnClick
48188>>>>>//                
48188>>>>>//            End_Object
48188>>>>>//            
48188>>>>>//            Object oEditItem is a cWebMenuItem
48188>>>>>//                Set psCaption to "Edit"
48188>>>>>//                
48188>>>>>//                Procedure OnClick
48188>>>>>//                    Set piSelection to C_wqEditExpression
48188>>>>>//                    Send Ok
48188>>>>>//                End_Procedure  // OnClick
48188>>>>>//                
48188>>>>>//            End_Object
48188>>>>>//            
48188>>>>>//            Object oExitItem is a cWebMenuItem
48188>>>>>//                Set psCaption to "Dismiss"
48188>>>>>//                
48188>>>>>//                Procedure OnClick
48188>>>>>//                    Send Cancel
48188>>>>>//                End_Procedure  // OnClick
48188>>>>>//                
48188>>>>>//            End_Object
48188>>>>>//            
48188>>>>>//        End_Object
48188>>>>>//        
48188>>>>>//    End_Object
48188>>>>>
48188>>>>>    Procedure OnSubmit
48191>>>>>        Send Ok
48192>>>>>    End_Procedure
48193>>>>>    
48193>>>>>    Procedure Ok
48196>>>>>        Forward Send Ok
48198>>>>>    End_Procedure
48199>>>>>
48199>>>>>    Procedure Cancel
48202>>>>>        Forward Send Cancel
48204>>>>>    End_Procedure
48205>>>>>    
48205>>>>>    Procedure OnEscape
48208>>>>>        Send Cancel
48209>>>>>    End_Procedure
48210>>>>>    
48210>>>>>    Procedure PopupOptions Handle hoObj Boolean bHaveRows Boolean bCalc
48213>>>>>        
48213>>>>>        WebSet pbEnabled of oEditButton   to (bHaveRows and bCalc)
48214>>>>>        WebSet pbEnabled of oInsertButton to bHaveRows
48215>>>>>        
48215>>>>>        Send Popup hoObj
48216>>>>>    End_Procedure  // PopupOptions
48217>>>>>    
48217>>>>>    Function ActionSelected Returns Integer
48220>>>>>        Function_Return (piSelection(Self))
48221>>>>>    End_Function  // Action_Selected
48222>>>>>    
48222>>>>>End_Object
48223>>>Use wqOpenQuery.wo
Including file: wqOpenQuery.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\wqOpenQuery.wo)
48223>>>>>Use cWebModalDialog
48223>>>>>Use cWebPanel.pkg
48223>>>>>Use cWebButton.pkg
48223>>>>>Use cWebForm.pkg
48223>>>>>Use cWebTreeView.pkg
48223>>>>>Use cWebCombo.pkg
48223>>>>>Use seq_chnl.pkg
48223>>>>>Use wqCreateDirectory.wo
Including file: wqCreateDirectory.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\wqCreateDirectory.wo)
48223>>>>>>>Use cWebModalDialog
48223>>>>>>>Use cWebPanel.pkg
48223>>>>>>>Use cWebButton.pkg
48223>>>>>>>Use cWebForm.pkg
48223>>>>>>>Use cWebQueryFunctions.pkg
48223>>>>>>>
48223>>>>>>>Object oWqCreateDirectory is a cWebModalDialog
48225>>>>>>>    Property String  wpsPath ""
48229>>>>>>>    
48229>>>>>>>    Set psCaption to "Create Directory"
48230>>>>>>>    Set piMinWidth to 500
48231>>>>>>>    Set piMinHeight to 80
48232>>>>>>>    Set pbServerOnSubmit to true    // enable the OnSubmit event
48233>>>>>>>    
48233>>>>>>>    Object oMainPanel is a cWebPanel
48235>>>>>>>        Set piColumnCount to 10
48236>>>>>>>
48236>>>>>>>        Object oDirName is a cWebForm
48238>>>>>>>            Set piColumnSpan to 0
48239>>>>>>>            Set psLabel to "Directory name:"
48240>>>>>>>        End_Object
48241>>>>>>>        
48241>>>>>>>    End_Object 
48242>>>>>>>    
48242>>>>>>>    Object oBottomPanel is a cWebPanel
48244>>>>>>>        Set piColumnCount to 6
48245>>>>>>>        Set peRegion to prBottom
48246>>>>>>>
48246>>>>>>>        Object oOkButton is a cWebButton
48248>>>>>>>            Set psCaption to C_$OK
48249>>>>>>>            Set piColumnSpan to 1
48250>>>>>>>            Set piColumnIndex to 4
48251>>>>>>>
48251>>>>>>>            Procedure OnClick
48254>>>>>>>                Send Ok
48255>>>>>>>            End_Procedure
48256>>>>>>>            
48256>>>>>>>        End_Object 
48257>>>>>>>
48257>>>>>>>        Object oCancelButton is a cWebButton
48259>>>>>>>            Set psCaption to C_$Cancel
48260>>>>>>>            Set piColumnSpan to 1
48261>>>>>>>            Set piColumnIndex to 5
48262>>>>>>>
48262>>>>>>>            Procedure OnClick
48265>>>>>>>                Send Cancel
48266>>>>>>>            End_Procedure
48267>>>>>>>            
48267>>>>>>>        End_Object
48268>>>>>>>        
48268>>>>>>>    End_Object 
48269>>>>>>>
48269>>>>>>>    Procedure OnSubmit
48272>>>>>>>        Send Ok
48273>>>>>>>    End_Procedure
48274>>>>>>>    
48274>>>>>>>    Procedure Ok
48277>>>>>>>        String  sName sPath
48277>>>>>>>        Integer i
48277>>>>>>>        Boolean bExists
48277>>>>>>>        
48277>>>>>>>        // 1. Check all characteras are legal
48277>>>>>>>        WebGet psValue of oDirName to sName
48278>>>>>>>        Move (Trim(sName))         to sName
48279>>>>>>>        
48279>>>>>>>        For i from 1 to (Length(sName))
48285>>>>>>>>
48285>>>>>>>            
48285>>>>>>>            If (C_wqInvalidDirChars contains Mid(sName, 1, i)) Begin
48287>>>>>>>                Send ShowInfoBox ("Directory name may not contain '" + Mid(sName, 1, i) + "'") "Invalid Character"
48288>>>>>>>                Procedure_Return
48289>>>>>>>            End
48289>>>>>>>>
48289>>>>>>>            
48289>>>>>>>        Loop
48290>>>>>>>>
48290>>>>>>>        
48290>>>>>>>        // 2. Check it doesn't already exist
48290>>>>>>>        WebGet wpsPath to sPath
48291>>>>>>>        Move (sPath + "\" + sName) to sPath
48292>>>>>>>        
48292>>>>>>>        File_Exist sPath bExists
48293>>>>>>>        
48293>>>>>>>        If bExists Begin
48295>>>>>>>            Send ShowInfoBox (sName * "already exists") "Cannot Create"
48296>>>>>>>            Procedure_Return
48297>>>>>>>        End
48297>>>>>>>>
48297>>>>>>>        
48297>>>>>>>        Forward Send Ok
48299>>>>>>>    End_Procedure
48300>>>>>>>    
48300>>>>>>>    Procedure Cancel
48303>>>>>>>        Forward Send Cancel
48305>>>>>>>    End_Procedure
48306>>>>>>>    
48306>>>>>>>    Procedure DoPopup Handle hoObj String sPath
48309>>>>>>>        WebSet wpsPath to sPath
48310>>>>>>>        
48310>>>>>>>        Send Popup hoObj
48311>>>>>>>    End_Procedure
48312>>>>>>>    
48312>>>>>>>    Function EnteredName Returns String
48315>>>>>>>        String  sName
48315>>>>>>>        
48315>>>>>>>        WebGet psValue of oDirName to sName
48316>>>>>>>        Function_Return sName
48317>>>>>>>    End_Function
48318>>>>>>>
48318>>>>>>>End_Object
48319>>>>>
48319>>>>>Enum_List
48319>>>>>    Define C_wqOpenQuery for 1
48319>>>>>    Define C_wqSaveQuery
48319>>>>>End_Enum_List
48319>>>>>
48319>>>>>Object oWqOpenQuery is a cWebModalDialog
48321>>>>>    Property Integer wpiMode
48325>>>>>    Property String  wpsSelection
48329>>>>>    Property String  wpsDefault
48333>>>>>    Property Integer wpiNextID
48337>>>>>    
48337>>>>>    Set psCaption           to "Open Query"
48338>>>>>    Set piMinWidth          to 500
48339>>>>>    Set piMinHeight         to 400
48340>>>>>    Set pbServerOnSubmit    to True
48341>>>>>    Set pbServerOnShow      to True
48342>>>>>    
48342>>>>>    Object oMainPanel is a cWebPanel
48344>>>>>        Set piColumnCount to 10
48345>>>>>
48345>>>>>        Object oDirectories is a cWebTreeView
48347>>>>>            Set piColumnSpan to 0
48348>>>>>            Set pbServerOnSelect to True
48349>>>>>            
48349>>>>>            Function OnLoadChildNodes String sId String sValue Integer iLevel Returns tWebTreeItem[]
48352>>>>>                tWebTreeItem[] aItems
48352>>>>>                tWebTreeItem[] aItems
48353>>>>>                wqDir[] aContents
48353>>>>>                wqDir[] aContents
48354>>>>>                Integer i iID
48354>>>>>                String  sFilter
48354>>>>>                
48354>>>>>                If (iLevel = 0) Begin
48356>>>>>                    Move "1d"                       to aItems[0].sId
48357>>>>>                    Move sId                        to aItems[0].sParentId
48358>>>>>                    Move "Public Queries"           to aItems[0].sName
48359>>>>>                    Move True                       to aItems[0].bLoadChildren
48360>>>>>                    Move True                       to aItems[0].bFolder
48361>>>>>                    Move (PublicPath(ghoWQF))       to aItems[0].sValue
48362>>>>>                    
48362>>>>>                    If (PrivatePath(ghoWQF) <> "") Begin
48364>>>>>                        Move "2d"                   to aItems[1].sId
48365>>>>>                        Move sId                    to aItems[1].sParentId
48366>>>>>                        Move "My Queries"           to aItems[1].sName
48367>>>>>                        Move True                   to aItems[1].bLoadChildren
48368>>>>>                        Move True                   to aItems[1].bFolder
48369>>>>>                        Move (PrivatePath(ghoWQF))  to aItems[1].sValue
48370>>>>>                        WebSet wpiNextID of oWqOpenQuery   to 3
48371>>>>>                    End
48371>>>>>>
48371>>>>>                    Else WebSet wpiNextID of oWqOpenQuery to 2
48373>>>>>                    
48373>>>>>                End
48373>>>>>>
48373>>>>>                Else Begin
48374>>>>>                    WebGet psValue        of oFileType              to sFilter
48375>>>>>                    Get DirectoryContents of ghoWQF sValue sFilter  to aContents
48376>>>>>                    WebGet wpiNextID of oWqOpenQuery                to iID
48377>>>>>                    
48377>>>>>                    For i from 0 to (SizeOfArray(aContents) - 1)
48383>>>>>>
48383>>>>>                        Move (String(iID) + If(aContents[i].bDir, "d", "f"))    to aItems[i].sId
48384>>>>>                        Move sID                                                to aItems[i].sParentId
48385>>>>>                        Move aContents[i].sName                                 to aItems[i].sName
48386>>>>>                        Move aContents[i].bDir                                  to aItems[i].bLoadChildren
48387>>>>>                        Move aContents[i].bDir                                  to aItems[i].bFolder
48388>>>>>                        If (not(aContents[i].bDir) and (Right(aContents[i].sName, 4) = ".wqr")) ;                            Move "Custom/report.png"                            to aItems[i].sIcon
48391>>>>>                        Move (sValue + "\" + aContents[i].sName)                to aItems[i].sValue
48392>>>>>                        Increment iID
48393>>>>>                    Loop
48394>>>>>>
48394>>>>>                    
48394>>>>>                    WebSet wpiNextID of oWqOpenQuery to iID
48395>>>>>                End
48395>>>>>>
48395>>>>>                
48395>>>>>                Function_Return aItems
48396>>>>>            End_Function
48397>>>>>            
48397>>>>>            Procedure OnSelect String sId String sValue Integer iLevel
48400>>>>>                Integer iMode
48400>>>>>                String  sFile
48400>>>>>                Boolean bDir
48400>>>>>                
48400>>>>>                Move (Right(sId, 1) = "d") to bDir
48401>>>>>                WebSet pbEnabled of oDeleteButton to (iLevel > 1)
48402>>>>>                WebSet pbEnabled of oCreateButton to (iLevel > 0)
48403>>>>>                WebGet wpiMode of oWqOpenQuery to iMode
48404>>>>>                
48404>>>>>                If (iMode = C_wqOpenQuery) Begin
48406>>>>>                    If bDir Procedure_Return
48409>>>>>                    
48409>>>>>                    WebSet wpsSelection of oWqOpenQuery     to sValue
48410>>>>>                    Get FilenameFromPath of ghoWQF sValue   to sFile
48411>>>>>                    WebSet psValue of oFileName             to sFile
48412>>>>>                End
48412>>>>>>
48412>>>>>                Else Begin
48413>>>>>                    If bDir WebSet wpsSelection of oWqOpenQuery to (sValue + "\")
48416>>>>>                    Else    WebSet wpsSelection of oWqOpenQuery to sValue
48418>>>>>                End
48418>>>>>>
48418>>>>>                
48418>>>>>            End_Procedure
48419>>>>>            
48419>>>>>        End_Object
48420>>>>>        
48420>>>>>    End_Object 
48421>>>>>    
48421>>>>>    Object oBottomPanel is a cWebPanel
48423>>>>>        Set piColumnCount to 6
48424>>>>>        Set peRegion to prBottom
48425>>>>>
48425>>>>>        Object oFileName is a cWebForm
48427>>>>>            Set piColumnSpan to 5
48428>>>>>            Set psLabel to "File name:"
48429>>>>>        End_Object
48430>>>>>
48430>>>>>        Object oOkButton is a cWebButton
48432>>>>>            Set psCaption to C_$OK
48433>>>>>            Set piColumnSpan to 1
48434>>>>>            Set piColumnIndex to 5
48435>>>>>
48435>>>>>            Procedure OnClick
48438>>>>>                Send Ok
48439>>>>>            End_Procedure
48440>>>>>            
48440>>>>>        End_Object 
48441>>>>>
48441>>>>>        Object oFileType is a cWebCombo
48443>>>>>            Set pbServerOnChange to True
48444>>>>>            Set piColumnSpan to 5
48445>>>>>            Set psLabel to "Files of type:"
48446>>>>>            
48446>>>>>            Procedure OnFill
48449>>>>>                Send AddComboItem "*.wqr" "Web Query Files (*.wqr)"
48450>>>>>                Send AddComboItem "*.*" "All Files (*.*)"
48451>>>>>            End_Procedure
48452>>>>>            
48452>>>>>            Procedure OnChange String sNewValue String sOldValue
48455>>>>>                
48455>>>>>                If (sNewValue <> sOldValue) Begin
48457>>>>>                    Send FullRefresh of oDirectories
48458>>>>>                    WebSet pbEnabled of oDeleteButton to False
48459>>>>>                    WebSet pbEnabled of oCreateButton to False
48460>>>>>                End
48460>>>>>>
48460>>>>>                
48460>>>>>            End_Procedure
48461>>>>>            
48461>>>>>        End_Object
48462>>>>>
48462>>>>>        Object oCancelButton is a cWebButton
48464>>>>>            Set psCaption to C_$Cancel
48465>>>>>            Set piColumnSpan to 1
48466>>>>>            Set piColumnIndex to 5
48467>>>>>
48467>>>>>            Procedure OnClick
48470>>>>>                Send Cancel
48471>>>>>            End_Procedure
48472>>>>>            
48472>>>>>        End_Object 
48473>>>>>
48473>>>>>        Object oCreateButton is a cWebButton
48475>>>>>            Set piColumnSpan  to 2
48476>>>>>            Set piColumnIndex to 3 
48477>>>>>            Set psCaption     to "Create Directory"
48478>>>>>            Set pbEnabled     to False
48479>>>>>        
48479>>>>>            Procedure OnClick
48482>>>>>                Send CreateDirectory
48483>>>>>            End_Procedure
48484>>>>>            
48484>>>>>        End_Object
48485>>>>>        
48485>>>>>        Object oDeleteButton is a cWebButton
48487>>>>>            Set piColumnSpan  to 0
48488>>>>>            Set psCaption     to "Delete"
48489>>>>>            Set piColumnSpan  to 1
48490>>>>>            Set piColumnIndex to 5
48491>>>>>            Set pbEnabled     to False
48492>>>>>        
48492>>>>>            Procedure OnClick
48495>>>>>                Send DeleteQuery
48496>>>>>            End_Procedure
48497>>>>>            
48497>>>>>        End_Object
48498>>>>>
48498>>>>>    End_Object 
48499>>>>>
48499>>>>>    Procedure OnSubmit
48502>>>>>        Send Ok
48503>>>>>    End_Procedure
48504>>>>>    
48504>>>>>    Procedure OverwriteCallback Integer eConfMode
48507>>>>>        If (eConfMode = cmYes) Forward Send Ok
48511>>>>>    End_Procedure
48512>>>>>    
48512>>>>>    WebPublishProcedure OverwriteCallback
48513>>>>>    
48513>>>>>    Procedure DeleteCallback Integer eConfMode
48516>>>>>        Boolean bExist
48516>>>>>        String  sFile
48516>>>>>        
48516>>>>>        If (eConfMode = cmYes) Begin
48518>>>>>            WebGet psSelectedValue of oDirectories to sFile
48519>>>>>            File_Exist sFile bExist
48520>>>>>            If bExist EraseFile sFile
48523>>>>>            Set pbEnabled of oDeleteButton to False
48524>>>>>            Set pbEnabled of oCreateButton to False
48525>>>>>            Send FullRefresh of oDirectories
48526>>>>>        End
48526>>>>>>
48526>>>>>        
48526>>>>>    End_Procedure
48527>>>>>
48527>>>>>    WebPublishProcedure DeleteCallback
48528>>>>>    
48528>>>>>    Procedure RemoveCallBack Integer eConfMode
48531>>>>>        String  sFile
48531>>>>>        Boolean bExist
48531>>>>>        wqDir[] aContents
48531>>>>>        wqDir[] aContents
48532>>>>>        
48532>>>>>        If (eConfMode = cmYes) Begin
48534>>>>>            WebGet psSelectedValue of oDirectories to sFile
48535>>>>>            File_Exist sFile bExist
48536>>>>>            If not bExist Procedure_Return
48539>>>>>            Get DirectoryContents of ghoWQF sFile "*"  to aContents
48540>>>>>            If (SizeOfArray(aContents) > 0) Procedure_Return            
48543>>>>>            Remove_Directory sFile
48544>>>>>            Set pbEnabled of oDeleteButton to False
48545>>>>>            Set pbEnabled of oCreateButton to False
48546>>>>>            Send FullRefresh of oDirectories
48547>>>>>        End        
48547>>>>>>
48547>>>>>                
48547>>>>>    End_Procedure
48548>>>>>    
48548>>>>>    WebPublishProcedure RemoveCallBack
48549>>>>>    
48549>>>>>    Procedure DeleteQuery
48552>>>>>        Boolean bExist bPub
48552>>>>>        String  sFile sName sPath sDir sID
48552>>>>>        Integer iPos
48552>>>>>        wqDir[] aContents
48552>>>>>        wqDir[] aContents
48553>>>>>        
48553>>>>>        WebGet psSelectedValue of oDirectories to sFile
48554>>>>>        WebGet psSelectedId    of oDirectories to sID
48555>>>>>        
48555>>>>>        If (Right(sID, 1) = "d") Begin
48557>>>>>            File_Exist sFile bExist
48558>>>>>            
48558>>>>>            If bExist Begin
48560>>>>>                Get StorePath of ghoWQF             to sPath
48561>>>>>                Move (Replace(sPath, sFile, ""))    to sName
48562>>>>>                Move (Pos("\", sName, 2))           to iPos
48563>>>>>                
48563>>>>>                If iPos Begin
48565>>>>>                    Move (Left(sName, (iPos - 1)))              to sDir
48566>>>>>                    Move (sDir = C_wqPublicDir)                 to bPub
48567>>>>>                    Move (Right(sName, (Length(sName) - iPos))) to sName
48568>>>>>                End
48568>>>>>>
48568>>>>>                
48568>>>>>                Get DirectoryContents of ghoWQF sFile "*"  to aContents
48569>>>>>                
48569>>>>>                If (SizeOfArray(aContents) > 0) Begin
48571>>>>>                    Send ShowInfoBox ;                        ("Cannot remove" * If(bPub, "public", "private") * ;                         "directory <<" *  sName * ">> as it has contents.\n\r" + ;                         "Delete the contents first.") ;                         "Cannot Remove"
48572>>>>>                    Procedure_Return
48573>>>>>                End
48573>>>>>>
48573>>>>>                Else Begin
48574>>>>>                    Send ShowYesNo Self ;                        (RefProc(RemoveCallBack)) ;                        ("Do you wish to REMOVE the" * If(bPub, "public", "private") * ;                        'directory <<' + sName + '>>?') "Remove directory?"
48575>>>>>                End
48575>>>>>>
48575>>>>>                
48575>>>>>            End
48575>>>>>>
48575>>>>>            
48575>>>>>        End
48575>>>>>>
48575>>>>>        Else Begin
48576>>>>>        
48576>>>>>            File_Exist sFile bExist
48577>>>>>            
48577>>>>>            If bExist Begin
48579>>>>>                // ToDo: This approach might not work with queries in subdirectories...
48579>>>>>                
48579>>>>>                Get StorePath of ghoWQF             to sPath
48580>>>>>                Move (Replace(sPath, sFile, ""))    to sName
48581>>>>>                Move (Pos("\", sName, 2))           to iPos
48582>>>>>                
48582>>>>>                If iPos Begin
48584>>>>>                    Move (Left(sName, (iPos - 1)))              to sDir
48585>>>>>                    Move (sDir = C_wqPublicDir)                 to bPub
48586>>>>>                    Move (Right(sName, (Length(sName) - iPos))) to sName
48587>>>>>                End
48587>>>>>>
48587>>>>>                
48587>>>>>                Send ShowYesNo Self (RefProc(DeleteCallback)) ;                                    ("Do you wish to DELETE the" * If(bPub, "public", "private") * 'saved query <<' + sName + '>>?') ;                                    "Delete?"
48588>>>>>            End
48588>>>>>>
48588>>>>>            
48588>>>>>        End
48588>>>>>>
48588>>>>>        
48588>>>>>    End_Procedure
48589>>>>>    
48589>>>>>    Function CurrentPath Returns String
48592>>>>>        String  sPath sID
48592>>>>>        Integer iPos
48592>>>>>        
48592>>>>>        WebGet psSelectedValue of oDirectories to sPath
48593>>>>>        WebGet psSelectedId    of oDirectories to sId
48594>>>>>        
48594>>>>>        If (Right(sId, 1) = "d") Begin
48596>>>>>            If (Right(sPath, 1) <> "\") Move (sPath + "\") to sPath
48599>>>>>        End
48599>>>>>>
48599>>>>>        Else Begin
48600>>>>>            Move (rPos(oStringFunctions, "\", sPath)) to iPos
48601>>>>>            If iPos Move (Left(sPath, iPos)) to sPath
48604>>>>>        End
48604>>>>>>
48604>>>>>        
48604>>>>>        Function_Return sPath
48605>>>>>    End_Function
48606>>>>>    
48606>>>>>    Procedure CreateDirectory
48609>>>>>        String  sPath
48609>>>>>        
48609>>>>>        Get CurrentPath to sPath
48610>>>>>        Send DoPopup of oWqCreateDirectory Self sPath
48611>>>>>    End_Procedure
48612>>>>>    
48612>>>>>    Procedure DoCreateDirectory
48615>>>>>        String  sName sPath
48615>>>>>        
48615>>>>>        Get EnteredName of oWqCreateDirectory to sName
48616>>>>>        Get CurrentPath                       to sPath
48617>>>>>        Make_Directory (sPath + sName)
48618>>>>>        Set pbEnabled of oDeleteButton to False
48619>>>>>        Set pbEnabled of oCreateButton to False
48620>>>>>        Send FullRefresh of oDirectories
48621>>>>>    End_Procedure
48622>>>>>    
48622>>>>>    Procedure OnCloseModalDialog Handle hoMD
48625>>>>>        If (hoMD = oWqCreateDirectory) Send DoCreateDirectory
48628>>>>>    End_Procedure
48629>>>>>    
48629>>>>>    Procedure Ok
48632>>>>>        Integer iMode
48632>>>>>        String  sFile sSel sId sPath
48632>>>>>        Boolean bExist
48632>>>>>        
48632>>>>>        WebGet wpiMode                          to iMode
48633>>>>>        WebGet psSelectedValue  of oDirectories to sSel
48634>>>>>        WebGet psSelectedId     of oDirectories to sID
48635>>>>>        WebGet psValue          of oFileName    to sFile
48636>>>>>        
48636>>>>>        If (sId = "") Begin
48638>>>>>            Send ShowInfoBox "No directory selected" "Select directory"
48639>>>>>            Procedure_Return
48640>>>>>        End
48640>>>>>>
48640>>>>>        
48640>>>>>        If (iMode = C_wqOpenQuery) Begin
48642>>>>>            
48642>>>>>            If (Right(sId, 1) = "d") Begin
48644>>>>>                Move (sSel + "\" + sFile)   to sPath
48645>>>>>                
48645>>>>>                File_Exist sPath bExist
48646>>>>>                
48646>>>>>                If bExist Begin
48648>>>>>                    WebSet wpsSelection to sPath
48649>>>>>                    Forward Send Ok
48651>>>>>                End
48651>>>>>>
48651>>>>>                Else Begin
48652>>>>>                    Send ShowInfoBox "No file selected" "Select file"
48653>>>>>                    Procedure_Return
48654>>>>>                End
48654>>>>>>
48654>>>>>                
48654>>>>>            End
48654>>>>>>
48654>>>>>            Else Begin
48655>>>>>                File_Exist sSel bExist
48656>>>>>                
48656>>>>>                If bExist Begin
48658>>>>>                    WebSet wpsSelection to sSel
48659>>>>>                    Forward Send Ok
48661>>>>>                End
48661>>>>>>
48661>>>>>                Else Begin
48662>>>>>                    Send ShowInfoBox "No file selected" "Select file"
48663>>>>>                    Procedure_Return
48664>>>>>                End
48664>>>>>>
48664>>>>>                
48664>>>>>            End
48664>>>>>>
48664>>>>>
48664>>>>>        End
48664>>>>>>
48664>>>>>        Else Begin
48665>>>>>            
48665>>>>>            If (Right(sId, 1) = "d") Begin
48667>>>>>                
48667>>>>>                If (sFile = "") Begin
48669>>>>>                    Send ShowInfoBox "No filename entered" "Enter filename"
48670>>>>>                    Procedure_Return
48671>>>>>                End
48671>>>>>>
48671>>>>>                
48671>>>>>                Move (sSel + "\" + sFile) to sPath
48672>>>>>            End
48672>>>>>>
48672>>>>>            Else Move sSel to sPath
48674>>>>>            
48674>>>>>            File_Exist sPath bExist
48675>>>>>            WebSet wpsSelection to sPath
48676>>>>>            
48676>>>>>            If bExist ;                Send ShowYesNo Self (RefProc(OverwriteCallback)) ;                                    ("File" * sFile * "already exists - do you wish to overwrite it?") ;                                    "Overwrite?"
48679>>>>>            Else Forward Send Ok
48682>>>>>            
48682>>>>>        End
48682>>>>>>
48682>>>>>                
48682>>>>>    End_Procedure
48683>>>>>    
48683>>>>>    Procedure Cancel
48686>>>>>        Forward Send Cancel
48688>>>>>    End_Procedure
48689>>>>>    
48689>>>>>    Procedure OnShow
48692>>>>>        Integer iMode
48692>>>>>        String  sDefault sFilename
48692>>>>>        
48692>>>>>        Send FullRefresh of oDirectories
48693>>>>>        WebSet pbEnabled of oDeleteButton to False
48694>>>>>        WebSet pbEnabled of oCreateButton to False
48695>>>>>        WebSet psValue   of oFileName     to ""
48696>>>>>        
48696>>>>>        WebGet wpiMode to iMode
48697>>>>>        
48697>>>>>        If (iMode = C_wqSaveQuery) Begin
48699>>>>>            WebGet psValue of oFileName to sFilename
48700>>>>>            WebGet wpsDefault to sDefault
48701>>>>>            If (sFilename = "") WebSet psValue of oFileName to (sDefault + ".wqr")
48704>>>>>        End
48704>>>>>>
48704>>>>>            
48704>>>>>    End_Procedure
48705>>>>>    
48705>>>>>    Procedure PopupDialog Handle hoObj Integer iMode String sDefault
48708>>>>>        
48708>>>>>        If (iMode = C_wqOpenQuery) WebSet psCaption to "Open Query"
48711>>>>>        If (iMode = C_wqSaveQuery) WebSet psCaption to "Save Query"
48714>>>>>        
48714>>>>>        Send MakeDirectories of ghoWQF
48715>>>>>        WebSet wpiMode    to iMode
48716>>>>>        WebSet wpsDefault to sDefault
48717>>>>>        WebSet wpiNextID  to 0
48718>>>>>        Send Popup hoObj
48719>>>>>    End_Procedure
48720>>>>>    
48720>>>>>    Function FileOpened Returns String
48723>>>>>        String  sFile
48723>>>>>        
48723>>>>>        WebGet wpsSelection to sFile
48724>>>>>        
48724>>>>>        Function_Return sFile
48725>>>>>    End_Function
48726>>>>>    
48726>>>>>    Procedure Clear
48729>>>>>        WebSet psValue of oFileName to ""
48730>>>>>        WebSet psValue of oFileType to "*.wqr"
48731>>>>>    End_Procedure
48732>>>>>    
48732>>>>>End_Object
48733>>>Use wqOutputModal.wo
Including file: wqOutputModal.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\wqOutputModal.wo)
48733>>>>>Use cWebModalDialog
48733>>>>>Use cWebPanel.pkg
48733>>>>>Use cWebButton.pkg
48733>>>>>Use cWebForm.pkg
48733>>>>>Use cWebHtmlBox.pkg
48733>>>>>
48733>>>>>Use StructFunctions.pkg
48733>>>>>Use cWebIFrame.pkg
48733>>>>>
48733>>>>>//Enum_List
48733>>>>>//    Define C_wqFirstPage for  1
48733>>>>>//    Define C_wqLastPage  for -1
48733>>>>>//End_Enum_List
48733>>>>>
48733>>>>>Object oWqOutputModal is a cWebModalDialog
48735>>>>>    Set psCaption           to "Report"
48736>>>>>    Set piMinWidth          to 800
48737>>>>>    Set piMinHeight         to 600
48738>>>>>    Set pbResizable         to True
48739>>>>>    
48739>>>>>    Object oMainPanel is a cWebPanel
48741>>>>>        Set piColumnCount to 10
48742>>>>>
48742>>>>>        Object oReportFrame is a cWebIFrame
48744>>>>>            Set pbFillHeight to True
48745>>>>>        End_Object  // oReportFrame
48746>>>>>
48746>>>>>    End_Object
48747>>>>>    
48747>>>>>    Object oBottomPanel is a cWebPanel
48749>>>>>        Set piColumnCount to 12
48750>>>>>        Set peRegion to prBottom
48751>>>>>
48751>>>>>        Object oCloseButton is a cWebButton
48753>>>>>            Set psCaption to C_$Close
48754>>>>>            Set piColumnSpan to 1
48755>>>>>            Set piColumnIndex to 11
48756>>>>>
48756>>>>>            Procedure OnClick
48759>>>>>                Send Ok
48760>>>>>            End_Procedure
48761>>>>>            
48761>>>>>        End_Object  // oCloseButton
48762>>>>>        
48762>>>>>    End_Object
48763>>>>>    
48763>>>>>    Procedure PopupOutput Handle hoObj String sFile String sTitle
48766>>>>>        WebSet psCaption to ("WebQuery:" * sTitle)
48767>>>>>        WebSet psUrl of oReportFrame to sFile
48768>>>>>        Send Popup hoObj
48769>>>>>    End_Procedure  //PopupReport
48770>>>>>    
48770>>>>>End_Object
48771>>>Use wqAdHocIndex.wo
Including file: wqAdHocIndex.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\wqAdHocIndex.wo)
48771>>>>>Use cWebModalDialog
48771>>>>>Use cWebPanel.pkg
48771>>>>>Use cWebButton.pkg
48771>>>>>Use cWebForm.pkg
48771>>>>>Use cWebQueryFunctions.pkg
48771>>>>>Use cWebHorizontalLine.pkg
48771>>>>>Use cWebList.pkg
48771>>>>>Use cWebGrid.pkg
48771>>>>>Use cWebColumn.pkg
48771>>>>>Use cWebColumnCheckbox.pkg
48771>>>>>
48771>>>>>Use StructFunctions.pkg
48771>>>>>
48771>>>>>Object oWqAdHocIndex is a cWebModalDialog
48773>>>>>    Property Handle  wphMainTable
48777>>>>>    Property Handle  wphNewTab
48781>>>>>    Property Integer wpiNewCol
48785>>>>>    Property String  wpsSegments
48789>>>>>    
48789>>>>>    Property Handle  phSelectedTable
48791>>>>>    Property wqIndexSeg[] paSegments
48793>>>>>    
48793>>>>>    Set psCaption to "Specify ad hoc index"
48794>>>>>    Set piMinWidth to 600
48795>>>>>    Set piMinHeight to 400
48796>>>>>    Set pbServerOnSubmit to True    // enable the OnSubmit event
48797>>>>>    Set pbServerOnShow   to True
48798>>>>>    
48798>>>>>    Object oMainPanel is a cWebPanel
48800>>>>>        Set piColumnCount to 10
48801>>>>>
48801>>>>>        Object oSelPanel is a cWebPanel
48803>>>>>            Set piColumnCount to 10
48804>>>>>            Set peRegion to prCenter
48805>>>>>            
48805>>>>>            Object oTabsList is a cWebList
48807>>>>>                Set pbFillHeight to True
48808>>>>>                Set pbDataAware to False
48809>>>>>                Set pbColumnSortable to False
48810>>>>>                
48810>>>>>                Object oTabCol is a cWebColumn
48812>>>>>                    Set psCaption to "Table"
48813>>>>>                End_Object
48814>>>>>                
48814>>>>>                Procedure OnChangeCurrentRow String sFromRowID String sToRowID
48817>>>>>                    Set phSelectedTable     to sToRowID
48818>>>>>                    Send GridRefresh        of oColList
48819>>>>>                    WebSet psCurrentRowID   of oColList to 1
48820>>>>>                End_Procedure  // OnChangeCurrentRow
48821>>>>>                
48821>>>>>                Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
48824>>>>>                    Handle hTab
48824>>>>>                    
48824>>>>>                    WebGet wphMainTable of oWqAdHocIndex to hTab
48825>>>>>                    Send RelatedFiles of ghoWQF (&aTheRows) hTab
48826>>>>>                End_Procedure  // OnManualLoadData
48827>>>>>            
48827>>>>>            End_Object  // oTabsList
48828>>>>>        
48828>>>>>            Object oColList is a cWebList
48830>>>>>                Set pbFillHeight to True
48831>>>>>                Set pbDataAware to False
48832>>>>>                Set pbColumnSortable to False
48833>>>>>                
48833>>>>>                Object oFldCol is a cWebColumn
48835>>>>>                    Set psCaption to "Fields"
48836>>>>>                End_Object
48837>>>>>                
48837>>>>>                Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
48840>>>>>                    Send CollectColumns of ghoWQF (&aTheRows) (phSelectedTable(oWqAdHocIndex))
48841>>>>>                End_Procedure  // OnManualLoadData
48842>>>>>            
48842>>>>>            End_Object  // oColList
48843>>>>>        
48843>>>>>        End_Object  // oSelPanel
48844>>>>>        
48844>>>>>        Object oIndexPanel is a cWebPanel
48846>>>>>            Set peRegion to prRight
48847>>>>>            Set piWidth to 400
48848>>>>>
48848>>>>>            Object oSelectedList is a cWebGrid
48850>>>>>                Set pbFillHeight        to True
48851>>>>>                Set pbDataAware         to False
48852>>>>>                Set pbOfflineEditing    to True
48853>>>>>                Set pbAllowAppendRow    to False
48854>>>>>                Set pbAllowInsertRow    to False
48855>>>>>                Set pbAllowDeleteRow    to False
48856>>>>>                
48856>>>>>                Object oNumCol is a cWebColumn
48858>>>>>                    Set psCaption to "Num"
48859>>>>>                    Set piWidth to 8
48860>>>>>                    Set pbEnabled to False
48861>>>>>                End_Object
48862>>>>>                
48862>>>>>                Object oNameCol is a cWebColumn
48864>>>>>                    Set psCaption to "Field"
48865>>>>>                    Set piWidth to 65
48866>>>>>                    Set pbEnabled to False
48867>>>>>                End_Object
48868>>>>>                
48868>>>>>                Object oCapsCol is a cWebColumnCheckbox
48870>>>>>                    Set psCaption to "Caps"
48871>>>>>                    Set piWidth to 12
48872>>>>>                End_Object
48873>>>>>                
48873>>>>>                Object oRevCol is a cWebColumnCheckbox
48875>>>>>                    Set psCaption to "Reverse"
48876>>>>>                    Set piWidth to 15
48877>>>>>                End_Object
48878>>>>>                
48878>>>>>                Object oTabCol is a cWebColumn
48880>>>>>                    Set pbRender to False
48881>>>>>                End_Object  // oTabCol
48882>>>>>                
48882>>>>>                Object oColCol is a cWebColumn
48884>>>>>                    Set pbRender to False
48885>>>>>                End_Object  // oColCol
48886>>>>>                
48886>>>>>                Procedure OnProcessDataSet tWebRow[] aData Integer eOp Integer iSelRow
48889>>>>>                    Send StoreTheData aData eOp iSelRow
48890>>>>>                End_Procedure  // OnProcessDataSet
48891>>>>>                
48891>>>>>                Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
48894>>>>>                    Send LoadTheData (&aTheRows) (&sCurrentRowID)
48895>>>>>                End_Procedure  // OnManualLoadData
48896>>>>>
48896>>>>>            End_Object
48897>>>>>            
48897>>>>>        End_Object  // oSelectedList
48898>>>>>        
48898>>>>>    End_Object  // oIndexPanel
48899>>>>>    
48899>>>>>    Object oBottomPanel is a cWebPanel
48901>>>>>        Set piColumnCount to 16
48902>>>>>        Set peRegion to prBottom
48903>>>>>        
48903>>>>>        Object oAddSegBut is a cWebButton
48905>>>>>            Set psCaption to "Add"
48906>>>>>            Set piColumnSpan to 2
48907>>>>>            Set piColumnIndex to 6
48908>>>>>            
48908>>>>>            Procedure OnClick
48911>>>>>                Send AddSegment
48912>>>>>            End_Procedure
48913>>>>>            
48913>>>>>        End_Object  // oAddSegBut
48914>>>>>
48914>>>>>        Object oMoveUpBut is a cWebButton
48916>>>>>            Set psCaption to "Move up"
48917>>>>>            Set piColumnSpan to 3
48918>>>>>            Set piColumnIndex to 8
48919>>>>>
48919>>>>>            Procedure OnClick
48922>>>>>                Send MoveSegUp
48923>>>>>            End_Procedure
48924>>>>>            
48924>>>>>        End_Object // oMoveUpBut
48925>>>>>
48925>>>>>        Object oMoveDownBut is a cWebButton
48927>>>>>            Set psCaption to "Move down"
48928>>>>>            Set piColumnSpan to 3
48929>>>>>            Set piColumnIndex to 11
48930>>>>>
48930>>>>>            Procedure OnClick
48933>>>>>                Send MoveSegDown
48934>>>>>            End_Procedure
48935>>>>>            
48935>>>>>        End_Object // oMoveDownBut
48936>>>>>
48936>>>>>        Object oDeleteBut is a cWebButton
48938>>>>>            Set psCaption to "Delete"
48939>>>>>            Set piColumnSpan to 3
48940>>>>>            Set piColumnIndex to 14
48941>>>>>
48941>>>>>            Procedure OnClick
48944>>>>>                Send DeleteSegment
48945>>>>>            End_Procedure
48946>>>>>            
48946>>>>>        End_Object 
48947>>>>>
48947>>>>>        Object oWebHorizontalLine1 is a cWebHorizontalLine
48949>>>>>        End_Object
48950>>>>>
48950>>>>>        Object oOkButton is a cWebButton
48952>>>>>            Set psCaption to C_$OK
48953>>>>>            Set piColumnSpan to 3
48954>>>>>            Set piColumnIndex to 11
48955>>>>>
48955>>>>>            Procedure OnClick
48958>>>>>                Send Ok
48959>>>>>            End_Procedure
48960>>>>>            
48960>>>>>        End_Object  // oDeleteBut
48961>>>>>
48961>>>>>        Object oCancelButton is a cWebButton
48963>>>>>            Set psCaption to C_$Cancel
48964>>>>>            Set piColumnSpan to 3
48965>>>>>            Set piColumnIndex to 14
48966>>>>>
48966>>>>>            Procedure OnClick
48969>>>>>                Send Cancel
48970>>>>>            End_Procedure
48971>>>>>            
48971>>>>>        End_Object 
48972>>>>>        
48972>>>>>    End_Object
48973>>>>>    
48973>>>>>    Procedure AddSegment
48976>>>>>        Integer iCol
48976>>>>>        Handle  hTab
48976>>>>>        
48976>>>>>        WebGet psCurrentRowID of oTabsList to hTab
48977>>>>>        WebGet psCurrentRowID of oColList  to iCol
48978>>>>>        
48978>>>>>        If hTab Begin
48980>>>>>            WebSet wphNewTab to hTab
48981>>>>>            WebSet wpiNewCol to iCol
48982>>>>>            Send ProcessDataSet of oSelectedList C_wqAppendRow
48983>>>>>        End
48983>>>>>>
48983>>>>>        
48983>>>>>    End_Procedure  // AddSegment
48984>>>>>    
48984>>>>>    Procedure DeleteSegment
48987>>>>>        Send ProcessDataSet of oSelectedList C_wqDeleteRow
48988>>>>>    End_Procedure  // DeleteSegment
48989>>>>>    
48989>>>>>    Procedure MoveSegUp
48992>>>>>        Send ProcessDataSet of oSelectedList C_wqMoveRowUp
48993>>>>>    End_Procedure  // MoveSegUp
48994>>>>>    
48994>>>>>    Procedure MoveSegDown
48997>>>>>        Send ProcessDataSet of oSelectedList C_wqMoveRowDown
48998>>>>>    End_Procedure  // MoveSegDown
48999>>>>>
48999>>>>>    Procedure OnSubmit
49002>>>>>        Handle  hoFoc
49002>>>>>        
49002>>>>>        Get FocusObject to hoFoc
49003>>>>>        
49003>>>>>        If (hoFoc = oColList) Send AddSegment
49006>>>>>    End_Procedure
49007>>>>>    
49007>>>>>    Procedure StoreTheData tWebRow[] aData Integer eOp Integer iSelRow
49010>>>>>        wqIndexSeg[] aSegs
49010>>>>>        wqIndexSeg[] aSegs
49011>>>>>        wqIndexSeg   tSeg
49011>>>>>        wqIndexSeg   tSeg
49011>>>>>        Integer i iCol iRow iMax
49011>>>>>        Handle  hTab
49011>>>>>        String  sName sSegs
49011>>>>>        
49011>>>>>        For i from 0 to (SizeOfArray(aData) - 1)
49017>>>>>>
49017>>>>>            Move aData[i].aValues[2] to aSegs[i].sName
49018>>>>>            Move aData[i].aValues[3] to aSegs[i].bUC
49019>>>>>            Move aData[i].aValues[4] to aSegs[i].bDesc
49020>>>>>            Move aData[i].aValues[5] to aSegs[i].iTable
49021>>>>>            Move aData[i].aValues[6] to aSegs[i].iField
49022>>>>>        Loop
49023>>>>>>
49023>>>>>        
49023>>>>>        If (eOp = C_wqAppendRow) Begin
49025>>>>>            WebGet wphNewTab to hTab
49026>>>>>            WebGet wpiNewCol to iCol
49027>>>>>            
49027>>>>>            If hTab Begin
49029>>>>>                Move hTab                                       to tSeg.iTable
49030>>>>>                Move iCol                                       to tSeg.iField
49031>>>>>                Move False                                      to tSeg.bBreak
49032>>>>>                Move False                                      to tSeg.bUC
49033>>>>>                Move False                                      to tSeg.bDesc
49034>>>>>                Move (NiceFieldName(ghoWQF, hTab, iCol) + ": ") to tSeg.sName
49035>>>>>                Move tSeg                                       to aSegs[(SizeOfArray(aSegs))]
49036>>>>>
49036>>>>>                WebGet piCurrentRowIndex of oColList to iRow
49037>>>>>                WebGet piRowCount        of oColList to iMax
49038>>>>>                If (iRow < (iMax - 1)) Send MoveToRow of oColList (iRow + 1)
49041>>>>>            End
49041>>>>>>
49041>>>>>            
49041>>>>>        End
49041>>>>>>
49041>>>>>        Else If (eOp = C_wqDeleteRow) Begin
49044>>>>>            If ((iSelRow => 0) and (iSelRow < SizeOfArray(aSegs))) ;                Move (RemoveFromArray(aSegs, iSelRow))                  to aSegs
49047>>>>>        End
49047>>>>>>
49047>>>>>        Else If (eOp = C_wqMoveRowUp) Begin
49050>>>>>            
49050>>>>>            If (iSelRow > 0) Begin
49052>>>>>                Move aSegs[iSelRow]                                     to tSeg
49053>>>>>                Move (RemoveFromArray(aSegs, iSelRow))                  to aSegs
49054>>>>>                Move (InsertInArray(aSegs, (iSelRow - 1), tSeg))        to aSegs
49055>>>>>                WebSet psCurrentRowID of oSelectedList                  to (iSelRow - 1)
49056>>>>>            End
49056>>>>>>
49056>>>>>            
49056>>>>>        End
49056>>>>>>
49056>>>>>        Else If (eOp = C_wqMoveRowDown) Begin
49059>>>>>            
49059>>>>>            If (iSelRow < (SizeOfArray(aData) - 1)) Begin
49061>>>>>                Move aSegs[iSelRow]                                     to tSeg
49062>>>>>                Move (RemoveFromArray(aSegs, iSelRow))                  to aSegs
49063>>>>>                If ((iSelRow + 1) => SizeOfArray(aSegs)) ;                     Move tSeg                                          to aSegs[(SizeOfArray(aSegs))]
49066>>>>>                Else Move (InsertInArray(aSegs, (iSelRow + 1), tSeg))   to aSegs
49068>>>>>                WebSet psCurrentRowID of oSelectedList                  to (iSelRow + 1)
49069>>>>>            End
49069>>>>>>
49069>>>>>            
49069>>>>>        End
49069>>>>>>
49069>>>>>        
49069>>>>>        Set paSegments to aSegs
49070>>>>>        If (SizeOFArray(aSegs)) ;            Get VariantToString of oStructFunctions aSegs to sSegs
49073>>>>>        WebSet wpsSegments to sSegs
49074>>>>>        If (eOp = C_wqSaveData) Forward Send Ok
49078>>>>>        Else                            Send GridRefresh of oSelectedList
49080>>>>>    End_Procedure  // StoreTheData
49081>>>>>    
49081>>>>>    Procedure LoadTheData tWebRow[] ByRef aRows String ByRef sCurrRowID
49084>>>>>        wqIndexSeg[] aSegs
49084>>>>>        wqIndexSeg[] aSegs
49085>>>>>        Integer i
49085>>>>>        String  sSegs
49085>>>>>        tValueTree tVT
49085>>>>>        tValueTree tVT
49085>>>>>        
49085>>>>>        WebGet wpsSegments to sSegs
49086>>>>>        
49086>>>>>        If (sSegs <> "") Begin
49088>>>>>            Get StringToValueTree of oStructFunctions sSegs to tVT
49089>>>>>            ValueTreeDeserializeParameter tVT to aSegs
49090>>>>>        End
49090>>>>>>
49090>>>>>        
49090>>>>>        For i from 0 to (SizeOfArray(aSegs) - 1)
49096>>>>>>
49096>>>>>            Move i                  to aRows[i].aValues[0]
49097>>>>>            Move (i + 1)            to aRows[i].aValues[1]
49098>>>>>            Move aSegs[i].sName     to aRows[i].aValues[2]
49099>>>>>            Move aSegs[i].bUC       to aRows[i].aValues[3]
49100>>>>>            Move aSegs[i].bDesc     to aRows[i].aValues[4]
49101>>>>>            Move aSegs[i].iTable    to aRows[i].aValues[5]
49102>>>>>            Move aSegs[i].iField    to aRows[i].aValues[6]
49103>>>>>        Loop
49104>>>>>>
49104>>>>>    
49104>>>>>    End_Procedure  // LoadTheData
49105>>>>>    
49105>>>>>    Procedure Ok
49108>>>>>        Send ProcessDataSet of oSelectedList C_wqSaveData
49109>>>>>    End_Procedure
49110>>>>>
49110>>>>>    Procedure Cancel
49113>>>>>        Forward Send Cancel
49115>>>>>    End_Procedure
49116>>>>>
49116>>>>>    Procedure OnShow
49119>>>>>        Send GridRefresh of oTabsList
49120>>>>>        Send GridRefresh of oSelectedList
49121>>>>>    End_Procedure  // OnLoad
49122>>>>>    
49122>>>>>    Procedure PopupAdHoc Handle hoObj Handle hMainTab wqIndexSeg[] aSegs
49125>>>>>        Integer i
49125>>>>>        String  sSegs
49125>>>>>        
49125>>>>>        If (SizeOfArray(aSegs)) ;            Get VariantToString of oStructFunctions aSegs to sSegs
49128>>>>>        WebSet wpsSegments to sSegs
49129>>>>>        WebSet wphMainTable             to hMainTab
49130>>>>>        
49130>>>>>        Send Popup hoObj
49131>>>>>    End_Procedure  // DoPopup
49132>>>>>
49132>>>>>    Function AdHocSegments Returns wqIndexSeg[]
49135>>>>>        wqIndexSeg[] aSegs
49135>>>>>        wqIndexSeg[] aSegs
49136>>>>>        tValueTree tVT
49136>>>>>        tValueTree tVT
49136>>>>>        String  sSegs
49136>>>>>        
49136>>>>>//        Get paSegments to aSegs
49136>>>>>        WebGet wpsSegments to sSegs
49137>>>>>        
49137>>>>>        If (sSegs <> "") Begin
49139>>>>>            Get StringToValueTree of oStructFunctions sSegs to tVT
49140>>>>>            ValueTreeDeserializeParameter tVT to aSegs
49141>>>>>        End
49141>>>>>>
49141>>>>>        
49141>>>>>        Function_Return aSegs
49142>>>>>    End_Function  // AdHocSegments
49143>>>>>    
49143>>>>>End_Object
49144>>>Use wqCalcColumn.wo
Including file: wqCalcColumn.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\wqCalcColumn.wo)
49144>>>>>Use cWebModalDialog
49144>>>>>Use cWebPanel.pkg
49144>>>>>Use cWebButton.pkg
49144>>>>>Use cWebForm.pkg
49144>>>>>Use cWebLabel.pkg
49144>>>>>Use cWebCombo.pkg
49144>>>>>Use cWebSpacer.pkg
49144>>>>>
49144>>>>>Define C_wqTypeText for -1
49144>>>>>
49144>>>>>Object oWqCalcColumn is a cWebModalDialog
49146>>>>>    Property Handle  wphMainTable
49150>>>>>    Property String  wpsExpression
49154>>>>>    Property Integer wpiAction
49158>>>>>    
49158>>>>>    Property Integer piOperation
49160>>>>>    Property Integer piField
49162>>>>>    
49162>>>>>    Set psCaption to "Calculated column"
49163>>>>>    Set piMinWidth to 400
49164>>>>>    Set piMinHeight to 180
49165>>>>>    Set pbServerOnSubmit to True
49166>>>>>    
49166>>>>>    Object oMainPanel is a cWebPanel
49168>>>>>        Set piColumnCount to 10
49169>>>>>
49169>>>>>        Object oLongLab is a cWebForm
49171>>>>>            Set piColumnSpan to 0
49172>>>>>            Set psLabel to "Long label:"
49173>>>>>            Set piLabelOffset to 90
49174>>>>>            Set pbServerOnChange to True
49175>>>>>            
49175>>>>>            
49175>>>>>            Procedure OnChange String sNewValue String sOldValue
49178>>>>>                String  sShort
49178>>>>>                
49178>>>>>                WebGet psValue of oShortLab to sShort
49179>>>>>                If ((sNewValue <> "") and (sShort = "")) WebSet psValue of oShortLab to sNewValue
49182>>>>>            End_Procedure
49183>>>>>            
49183>>>>>            
49183>>>>>        End_Object
49184>>>>>
49184>>>>>        Object oShortLab is a cWebForm
49186>>>>>            Set piColumnSpan to 0
49187>>>>>            Set psLabel to "Short label:"
49188>>>>>            Set piColumnSpan to 6
49189>>>>>            Set piLabelOffset to 90
49190>>>>>        End_Object
49191>>>>>
49191>>>>>        Object oWidth is a cWebForm
49193>>>>>            Set piColumnSpan to 0
49194>>>>>            Set psLabel to "Width:"
49195>>>>>            Set piColumnSpan to 4
49196>>>>>            Set peDataType to typeNumber
49197>>>>>            Set psValue to 10
49198>>>>>            Set piLabelOffset to 90
49199>>>>>        End_Object
49200>>>>>
49200>>>>>        Object oCharLab is a cWebLabel
49202>>>>>            Set psCaption to "characters"
49203>>>>>            Set piColumnIndex to 4
49204>>>>>            Set piColumnSpan to 0
49205>>>>>        End_Object
49206>>>>>
49206>>>>>        Object oRetType is a cWebCombo
49208>>>>>            Set piColumnSpan to 0
49209>>>>>            Set psLabel to "Return type:"
49210>>>>>            Set piColumnSpan to 5
49211>>>>>            Set piLabelOffset to 90
49212>>>>>            Set pbServerOnChange to True
49213>>>>>            
49213>>>>>            Procedure OnChange String sNewValue String sOldValue
49216>>>>>                WebSet pbEnabled of oDecimals to (sNewValue = typeNumber)
49217>>>>>            End_Procedure
49218>>>>>            
49218>>>>>            Procedure OnFill
49221>>>>>                Send AddComboItem typeNumber   "Numeric"
49222>>>>>                Send AddComboItem typeASCII    "String"
49223>>>>>                Send AddComboItem C_wqTypeText "Text"
49224>>>>>                Send AddComboItem typeDate     "Date"
49225>>>>>                Send AddComboItem typeDateTime "DateTime"
49226>>>>>            End_Procedure
49227>>>>>            
49227>>>>>        End_Object
49228>>>>>
49228>>>>>        Object oDecimals is a cWebForm
49230>>>>>            Set piColumnSpan to 0
49231>>>>>            Set psLabel to "Decimal places:"
49232>>>>>            Set piColumnIndex to 6
49233>>>>>            Set piColumnSpan to 4
49234>>>>>            Set peDataType to typeNumber
49235>>>>>            Set piLabelOffset to 100
49236>>>>>            Set psValue to 0
49237>>>>>        End_Object
49238>>>>>
49238>>>>>        Object oEditButton is a cWebButton
49240>>>>>            Set piColumnSpan to 0
49241>>>>>            Set psCaption to "Edit"
49242>>>>>            Set piColumnSpan to 2
49243>>>>>            Set piColumnIndex to 4
49244>>>>>        
49244>>>>>            Procedure OnClick
49247>>>>>                wqPrintField tField
49247>>>>>                wqPrintField tField
49247>>>>>                Handle  hTab
49247>>>>>                String  sExpr sName
49247>>>>>                Integer iAction
49247>>>>>                
49247>>>>>                WebGet wpsExpression of oWqCalcColumn to sExpr
49248>>>>>                WebGet wphMainTable  of oWqCalcColumn to hTab
49249>>>>>                WebGet wpiAction     of oWqCalcColumn to iAction
49250>>>>>                WebGet psValue       of oShortLab     to sName
49251>>>>>                
49251>>>>>                Send DoPopup of oWqExpressionPopup oWqCalcColumn sExpr iAction 0 hTab sName
49252>>>>>            End_Procedure
49253>>>>>            
49253>>>>>        End_Object
49254>>>>>        
49254>>>>>    End_Object 
49255>>>>>    
49255>>>>>    Object oBottomPanel is a cWebPanel
49257>>>>>        Set piColumnCount to 6
49258>>>>>        Set peRegion to prBottom
49259>>>>>
49259>>>>>        Object oOkButton is a cWebButton
49261>>>>>            Set psCaption to C_$OK
49262>>>>>            Set piColumnSpan to 1
49263>>>>>            Set piColumnIndex to 4
49264>>>>>
49264>>>>>            Procedure OnClick
49267>>>>>                Send Ok
49268>>>>>            End_Procedure
49269>>>>>        End_Object 
49270>>>>>
49270>>>>>        Object oCancelButton is a cWebButton
49272>>>>>            Set psCaption to C_$Cancel
49273>>>>>            Set piColumnSpan to 1
49274>>>>>            Set piColumnIndex to 5
49275>>>>>
49275>>>>>            Procedure OnClick
49278>>>>>                Send Cancel
49279>>>>>            End_Procedure
49280>>>>>        End_Object 
49281>>>>>        
49281>>>>>    End_Object 
49282>>>>>
49282>>>>>    Procedure OnSubmit
49285>>>>>        Send Ok
49286>>>>>    End_Procedure
49287>>>>>    
49287>>>>>    Procedure Ok
49290>>>>>        Forward Send Ok
49292>>>>>    End_Procedure
49293>>>>>
49293>>>>>    Procedure Cancel
49296>>>>>        Forward Send Cancel
49298>>>>>    End_Procedure
49299>>>>>    
49299>>>>>    Procedure OnCloseModalDialog Handle hoMD
49302>>>>>        wqExpressionReturn tExpr
49302>>>>>        wqExpressionReturn tExpr
49302>>>>>        
49302>>>>>        Get ExprValue of hoMD   to tExpr
49303>>>>>        Set piOperation         to tExpr.iOp
49304>>>>>        Set piField             to tExpr.iField
49305>>>>>        WebSet wpsExpression    to tExpr.sExpression
49306>>>>>        WebSet pbEnabled of oOkButton to (tExpr.sExpression <> "")
49307>>>>>    End_Procedure
49308>>>>>    
49308>>>>>    Procedure PopupCalcCol Handle hoObj wqPrintField tField Integer iAction Handle hMainTable
49311>>>>>        WebSet wphMainTable to hMainTable
49312>>>>>        WebSet wpiAction    to iAction
49313>>>>>        
49313>>>>>        If (iAction = C_wqEditExpression) Begin
49315>>>>>            WebSet wpsExpression            to tField.sExpression
49316>>>>>            WebSet psValue of   oLongLab    to tField.sLongLabel
49317>>>>>            WebSet psValue of   oShortLab   to tField.sUserName
49318>>>>>            WebSet psValue of   oWidth      to tField.iWidth
49319>>>>>            WebSet psValue of   oRetType    to tField.iType
49320>>>>>            WebSet psValue of   oDecimals   to tField.iDecimals
49321>>>>>            WebSet pbEnabled of oOkButton   to (tField.sExpression <> "")  // Probably certain to be True here
49322>>>>>        End
49322>>>>>>
49322>>>>>        Else Begin
49323>>>>>            WebSet wpsExpression            to ""
49324>>>>>            WebSet psValue   of oLongLab    to ""
49325>>>>>            WebSet psValue   of oShortLab   to ""
49326>>>>>            WebSet psValue   of oWidth      to 10
49327>>>>>            WebSet psValue   of oRetType    to "Numeric"
49328>>>>>            WebSet psValue   of oDecimals   to 0
49329>>>>>            WebSet pbEnabled of oOkButton   to False
49330>>>>>        End
49330>>>>>>
49330>>>>>        
49330>>>>>        If      (iAction = C_wqAddExpression)    WebSet psCaption to "Create calculated column"
49333>>>>>        Else If (iAction = C_wqInsertExpression) WebSet psCaption to "Create calculated column"
49337>>>>>        Else If (iAction = C_wqEditExpression)   WebSet psCaption to ('Edit calculated column "' * tField.sUserName + '"')
49341>>>>>        
49341>>>>>        Send Popup hoObj
49342>>>>>    End_Procedure
49343>>>>>    
49343>>>>>    Function CalcColInfo Returns wqPrintField
49346>>>>>        wqPrintField tField
49346>>>>>        wqPrintField tField
49346>>>>>        Integer iOp
49346>>>>>        
49346>>>>>        WebGet psValue of oLongLab  to tField.sLongLabel
49347>>>>>        WebGet psValue of oShortLab to tField.sUserName
49348>>>>>        WebGet psValue of oWidth    to tField.iWidth
49349>>>>>        WebGet psValue of oRetType  to tField.iType
49350>>>>>        WebGet psValue of oDecimals to tField.iDecimals
49351>>>>>        WebGet wpsExpression        to tField.sExpression
49352>>>>>        Move True                   to tField.bCalc
49353>>>>>        
49353>>>>>        WebGet wpiAction to iOp
49354>>>>>        Set piOperation  to iOp
49355>>>>>        
49355>>>>>        Function_Return tField
49356>>>>>    End_Function
49357>>>>>    
49357>>>>>End_Object
49358>>>Use wqColourPicker.wo
Including file: wqColourPicker.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\wqColourPicker.wo)
49358>>>>>Use cWebModalDialog
49358>>>>>Use cWebPanel.pkg
49358>>>>>Use cWebButton.pkg
49358>>>>>Use cWebForm.pkg
49358>>>>>Use cWebHtmlBox.pkg
49358>>>>>Use cWebSlider.pkg
49358>>>>>Use cWebQueryFunctions.pkg
49358>>>>>
49358>>>>>Object oWqColourPicker is a cWebModalDialog
49360>>>>>    Set psCaption to "Select Colour"
49361>>>>>    Set piMinWidth to 500
49362>>>>>    Set piMinHeight to 200
49363>>>>>    Set pbServerOnSubmit to true    // enable the OnSubmit event
49364>>>>>    Set pbServerOnShow   to True
49365>>>>>    
49365>>>>>    Property Handle  wphoTarget
49369>>>>>    Property Integer wpiRed
49373>>>>>    Property Integer wpiGreen
49377>>>>>    Property Integer wpiBlue
49381>>>>>    
49381>>>>>    Object oMainPanel is a cWebPanel
49383>>>>>        Set piColumnCount to 10
49384>>>>>        
49384>>>>>        Object oRedSlider is a cWebSlider
49386>>>>>            Set psLabel             to "Red:"
49387>>>>>            Set piColumnSpan        to 0
49388>>>>>            Set piLabelOffset       to 50
49389>>>>>            Set piMinValue          to 0
49390>>>>>            Set piMaxValue          to 255
49391>>>>>            Set pbShowValue         to True
49392>>>>>            Set piInterval          to 1
49393>>>>>            Set pbShowMarkers       to True
49394>>>>>            Set psValue             to 0
49395>>>>>            Set pbServerOnChange    to True
49396>>>>>            
49396>>>>>            Procedure OnChange String sNewValue String sOldValue
49399>>>>>                Send AdjustColour
49400>>>>>            End_Procedure  // EndProcedure
49401>>>>>            
49401>>>>>            Procedure OnFillLabels
49404>>>>>                Send AddLabel  0    0
49405>>>>>                Send AddLabel  32  32
49406>>>>>                Send AddLabel  64  64
49407>>>>>                Send AddLabel  96  96
49408>>>>>                Send AddLabel 128 128
49409>>>>>                Send AddLabel 160 160
49410>>>>>                Send AddLabel 192 192
49411>>>>>                Send AddLabel 224 224
49412>>>>>                Send AddLabel 255 255
49413>>>>>            End_Procedure
49414>>>>>            
49414>>>>>        End_Object               
49415>>>>>                
49415>>>>>        Object oGreenSlider is a cWebSlider
49417>>>>>            Set psLabel       to "Green:"
49418>>>>>            Set piColumnSpan  to 0
49419>>>>>            Set piLabelOffset to 50
49420>>>>>            Set piMinValue    to 0
49421>>>>>            Set piMaxValue    to 255
49422>>>>>            Set piInterval    to 1
49423>>>>>            Set pbShowValue   to True
49424>>>>>            Set pbShowMarkers to True
49425>>>>>            Set psValue       to 0
49426>>>>>            Set pbServerOnChange    to True
49427>>>>>            
49427>>>>>            Procedure OnChange String sNewValue String sOldValue
49430>>>>>                Send AdjustColour
49431>>>>>            End_Procedure  // EndProcedure
49432>>>>>            
49432>>>>>            Procedure OnFillLabels
49435>>>>>                Send AddLabel  0    0
49436>>>>>                Send AddLabel  32  32
49437>>>>>                Send AddLabel  64  64
49438>>>>>                Send AddLabel  96  96
49439>>>>>                Send AddLabel 128 128
49440>>>>>                Send AddLabel 160 160
49441>>>>>                Send AddLabel 192 192
49442>>>>>                Send AddLabel 224 224
49443>>>>>                Send AddLabel 255 255
49444>>>>>            End_Procedure
49445>>>>>            
49445>>>>>        End_Object               
49446>>>>>                
49446>>>>>        Object oBlueSlider is a cWebSlider
49448>>>>>            Set psLabel to "Blue:"
49449>>>>>            Set piColumnSpan to 0
49450>>>>>            Set piLabelOffset to 50
49451>>>>>            Set piMinValue    to 0
49452>>>>>            Set piMaxValue    to 255
49453>>>>>            Set piInterval    to 1
49454>>>>>            Set pbShowValue   to True
49455>>>>>            Set pbShowMarkers to True
49456>>>>>            Set psValue       to 0
49457>>>>>            Set pbServerOnChange    to True
49458>>>>>            
49458>>>>>            Procedure OnChange String sNewValue String sOldValue
49461>>>>>                Send AdjustColour
49462>>>>>            End_Procedure  // EndProcedure
49463>>>>>            
49463>>>>>            Procedure OnFillLabels
49466>>>>>                Send AddLabel  0    0
49467>>>>>                Send AddLabel  32  32
49468>>>>>                Send AddLabel  64  64
49469>>>>>                Send AddLabel  96  96
49470>>>>>                Send AddLabel 128 128
49471>>>>>                Send AddLabel 160 160
49472>>>>>                Send AddLabel 192 192
49473>>>>>                Send AddLabel 224 224
49474>>>>>                Send AddLabel 255 255
49475>>>>>            End_Procedure
49476>>>>>            
49476>>>>>        End_Object
49477>>>>>
49477>>>>>        Object oColourBox is a cWebHtmlBox
49479>>>>>            Set piColumnSpan to 4
49480>>>>>            Set piColumnIndex to 0
49481>>>>>            Set piHeight to 70
49482>>>>>            Set psHtml to "<br><div style='text-align: center; text-color: #000000; bgcolor: #FFFFFF'>#FFFFFF</div>"
49483>>>>>            Set psBackgroundColor to "#FFFFFF"
49484>>>>>            Set psLabel to "Colour:"
49485>>>>>            Set pbShowLabel to True
49486>>>>>            Set piLabelOffset to 60
49487>>>>>        End_Object
49488>>>>>        
49488>>>>>    End_Object 
49489>>>>>    
49489>>>>>    Object oBottomPanel is a cWebPanel
49491>>>>>        Set piColumnCount to 6
49492>>>>>        Set peRegion to prBottom
49493>>>>>
49493>>>>>        Object oOkButton is a cWebButton
49495>>>>>            Set psCaption to C_$OK
49496>>>>>            Set piColumnSpan to 1
49497>>>>>            Set piColumnIndex to 4
49498>>>>>
49498>>>>>            Procedure OnClick
49501>>>>>                Send Ok
49502>>>>>            End_Procedure
49503>>>>>        End_Object 
49504>>>>>
49504>>>>>        Object oCancelButton is a cWebButton
49506>>>>>            Set psCaption to C_$Cancel
49507>>>>>            Set piColumnSpan to 1
49508>>>>>            Set piColumnIndex to 5
49509>>>>>
49509>>>>>            Procedure OnClick
49512>>>>>                Send Cancel
49513>>>>>            End_Procedure
49514>>>>>        End_Object 
49515>>>>>        
49515>>>>>    End_Object 
49516>>>>>
49516>>>>>    Procedure OnSubmit
49519>>>>>        Send Ok
49520>>>>>    End_Procedure
49521>>>>>    
49521>>>>>    Procedure Ok
49524>>>>>        Forward Send Ok
49526>>>>>    End_Procedure
49527>>>>>
49527>>>>>    Procedure Cancel
49530>>>>>        Forward Send Cancel
49532>>>>>    End_Procedure
49533>>>>>    
49533>>>>>    Procedure AdjustColour
49536>>>>>        Integer iRed iGreen iBlue
49536>>>>>        String  sBG sText
49536>>>>>        
49536>>>>>        WebGet piSliderValue of oRedSlider   to iRed
49537>>>>>        WebGet piSliderValue of oGreenSlider to iGreen
49538>>>>>        WebGet piSliderValue of oBlueSlider  to iBlue
49539>>>>>        Move ("#" + ByteToHex(oStringFunctions, iRed) + ;                    ByteToHex(oStringFunctions, iGreen) + ;                    ByteToHex(oStringFunctions, iBlue)) to sBG
49540>>>>>        If (((iRed + iGreen + iBlue) / 3) > 128) Move "#000000" to sText
49543>>>>>        Else                                     Move "#FFFFFF" to sText
49545>>>>>        
49545>>>>>        WebSet psBackgroundColor of oColourBox to sBG
49546>>>>>        Send UpdateHtml of oColourBox ('<br><div style="text-align: center; color: ' + sText + '; font-size: x-large;">' + sBG + '</div>')
49547>>>>>    End_Procedure  // AdjustColour
49548>>>>>        
49548>>>>>    Procedure OnShow
49551>>>>>        Integer iRed iGreen iBlue
49551>>>>>        
49551>>>>>        WebGet wpiRed   to iRed
49552>>>>>        WebGet wpiGreen to iGreen
49553>>>>>        WebGet wpiBlue  to iBlue
49554>>>>>        
49554>>>>>        WebSet piSliderValue of oRedSlider      to iRed
49555>>>>>        WebSet piSliderValue of oGreenSlider    to iGreen
49556>>>>>        WebSet piSliderValue of oBlueSlider     to iBlue
49557>>>>>        Send AdjustColour
49558>>>>>    End_Procedure  // OnShow
49559>>>>>    
49559>>>>>    Procedure ColourPopup Handle hoObj String sVal Handle hoTarg
49562>>>>>        String  sRed sGreen sBlue
49562>>>>>        Integer iRed iGreen iBlue
49562>>>>>        wqColour tCol
49562>>>>>        wqColour tCol
49562>>>>>        
49562>>>>>        WebSet wphoTarget to hoTarg
49563>>>>>        
49563>>>>>        If (Left(sVal, 1) = "#") Begin
49565>>>>>            Move (Mid(sVal, 2, 2)) to sRed
49566>>>>>            Move (Mid(sVal, 2, 4)) to sGreen
49567>>>>>            Move (Mid(sVal, 2, 6)) to sBlue
49568>>>>>            Move (HexToByte(oStringFunctions, sRed))    to iRed
49569>>>>>            Move (HexToByte(oStringFunctions, sGreen))  to iGreen
49570>>>>>            Move (HexToByte(oStringFunctions, sBlue))   to iBlue
49571>>>>>        End
49571>>>>>>
49571>>>>>        Else Begin
49572>>>>>            Get NameToColour of ghoWQF sVal to tCol
49573>>>>>            Move tCol.iRed   to iRed
49574>>>>>            Move tCol.iGreen to iGreen
49575>>>>>            Move tCol.iBlue  to iBlue
49576>>>>>        End
49576>>>>>>
49576>>>>>        
49576>>>>>        WebSet wpiRed   to iRed
49577>>>>>        WebSet wpiGreen to iGreen
49578>>>>>        WebSet wpiBlue  to iBlue
49579>>>>>        
49579>>>>>        Send Popup hoObj
49580>>>>>    End_Procedure  // ColourPopup
49581>>>>>    
49581>>>>>    Function ColourValue Returns String
49584>>>>>        Integer iRed iGreen iBlue
49584>>>>>        String  sVal
49584>>>>>        
49584>>>>>        WebGet piSliderValue of oRedSlider   to iRed
49585>>>>>        WebGet piSliderValue of oGreenSlider to iGreen
49586>>>>>        WebGet piSliderValue of oBlueSlider  to iBlue
49587>>>>>        Move ("#" + ByteToHex(oStringFunctions, iRed) + ;                    ByteToHex(oStringFunctions, iGreen) + ;                    ByteToHex(oStringFunctions, iBlue)) to sVal
49588>>>>>                    
49588>>>>>        Function_Return sVal
49589>>>>>    End_Function  // ColourValue
49590>>>>>    
49590>>>>>    Function TargetObject Returns Handle
49593>>>>>        Handle hoObj
49593>>>>>        
49593>>>>>        WebGet wphoTarget to hoObj
49594>>>>>        Function_Return hoObj
49595>>>>>    End_Function  // TargetObject
49596>>>>>    
49596>>>>>End_Object
49597>>>Use wqDownload.wo
Including file: wqDownload.wo    (\\vmware-host\Shared Folders\VmShare\Projects\WebQuery\AppSrc\wqDownload.wo)
49597>>>>>Use cWebModalDialog
49597>>>>>Use cWebPanel.pkg
49597>>>>>Use cWebButton.pkg
49597>>>>>Use cWebIFrame.pkg
49597>>>>>
49597>>>>>Object oWqDownload is a cWebModalDialog
49599>>>>>    Set psCaption        to "Downloading Report..."
49600>>>>>    Set piMinWidth       to 200
49601>>>>>    Set piMinHeight      to 99
49602>>>>>    Set pbResizable      to False
49603>>>>>    Set pbShowClose      to False
49604>>>>>    Set pbServerOnSubmit to True
49605>>>>>    
49605>>>>>    Property String  wpsFile
49609>>>>>    
49609>>>>>    Object oMainPanel is a cWebPanel
49611>>>>>        Set piColumnCount to 5
49612>>>>>
49612>>>>>        Object oDownloadFrame is a cWebIFrame
49614>>>>>            Set piColumnIndex to 0
49615>>>>>            Set piColumnSpan  to 0
49616>>>>>            Set pbShowBorder  to False
49617>>>>>            Set piHeight      to 30
49618>>>>>        End_Object
49619>>>>>
49619>>>>>        Object oOkButton is a cWebButton
49621>>>>>            Set psCaption to "Click when done"
49622>>>>>            Set piColumnSpan to 3
49623>>>>>            Set piColumnIndex to 1
49624>>>>>
49624>>>>>            Procedure OnClick
49627>>>>>                Send Ok
49628>>>>>            End_Procedure
49629>>>>>            
49629>>>>>        End_Object 
49630>>>>>
49630>>>>>    End_Object 
49631>>>>>    
49631>>>>>    Procedure DoPopup Handle hoObj String sUrl String sFile
49634>>>>>        WebSet psUrl of oDownloadFrame to sUrl
49635>>>>>        WebSet wpsFile                 to sFile
49636>>>>>        Send Popup hoObj
49637>>>>>    End_Procedure
49638>>>>>    
49638>>>>>End_Object
49639>>>
49639>>>//==============================================================================
49639>>>//  The view
49639>>>//==============================================================================
49639>>>
49639>>>Object oWebQuery is a cWebView
49641>>>
49641>>>    //==========================================================================
49641>>>    //  Web properties
49641>>>    //==========================================================================
49641>>>    
49641>>>    Property String  wpsQuery
49645>>>    Property Handle  wphMainTable
49649>>>    Property Integer wpiIndex
49653>>>    Property String  wpsSegmentData
49657>>>    Property String  wpsFieldsData
49661>>>    Property String  wpsSaveFilename
49665>>>    Property String  wpsSelectExpression
49669>>>    Property String  wpsIndexSegments
49673>>>    
49673>>>    // Web properties used for inserting new rows in
49673>>>    // the Print Fields and Selection tables
49673>>>    Property String  wpsNewField    
49677>>>    Property Handle  wphNewTable
49681>>>    Property Integer wpiNewColumn
49685>>>    Property Integer wpiNewDataType
49689>>>    Property Boolean wpbNewAppend
49693>>>    Property Integer wpiNewOperator
49697>>>    
49697>>>    //==========================================================================
49697>>>    //  Normal properties
49697>>>    //==========================================================================
49697>>>    
49697>>>    Property String         psVersion "0.4 - beta 2"
49699>>>    
49699>>>    Property Handle         phSelectedTable
49701>>>    Property wqPrintField[] paFields
49703>>>    Property wqSelections[] paSelections
49705>>>    Property wqWebQuery     pQuery
49707>>>    Property Handle         phoSessionObj       ghoWebSessionManager
49709>>>    Property Handle         phLoggedInFunc      (RefFunc(IsLoggedIn))
49711>>>    Property Handle         phUserNameFunc      (RefFunc(psLoginName))
49713>>>    Property String         psOutputDirectory   "WebQuery"                                          // Where reports are written
49715>>>    Property String         psStoreDirectory    (psHome(phoWorkspace(oApplication)) + "WebQuery")   // Where queries are saved
49717>>>    Property String         psDownloadDirectory (psHome(phoWorkspace(oApplication)) + "WebQuery")   // Where downloads are written
49719>>>    Property Boolean        pbAllowRawOutput    False
49721>>>    Property Boolean        pbUseSqlDefault     False
49723>>>    
49723>>>    //==========================================================================
49723>>>    //  Initialisation
49723>>>    //==========================================================================
49723>>>    
49723>>>    Set piWidth             to 800
49724>>>    Set psCaption           to "WebQuery Definition"
49725>>>    Set pbFillHeight        to True
49726>>>    Set pbServerOnSubmit    to True
49727>>>    Set pbServerOnShow      to True
49728>>>    
49728>>>    Move Self to ghoWebQry
49729>>>    
49729>>>    //==========================================================================
49729>>>    //  Start of methods
49729>>>    //==========================================================================
49729>>>    
49729>>>    Procedure ExcludeTable Handle hTable
49732>>>        Handle[] ahExcluded
49733>>>        
49733>>>        Get pahExcludedTables of ghoWQF to ahExcluded
49734>>>        Move hTable to ahExcluded[(SizeOfArray(ahExcluded))]
49735>>>        Set pahExcludedTables of ghoWQF to ahExcluded
49736>>>    End_Procedure
49737>>>
49737>>>    Procedure ClearExcludedTables
49740>>>        Handle[] ahExcluded
49741>>>        
49741>>>        Set pahExcludedTables to ahExcluded
49742>>>    End_Procedure
49743>>>    
49743>>>    Procedure ExcludeField Handle hTable Integer iField
49746>>>        wqTableField[] atExcluded
49746>>>        wqTableField[] atExcluded
49747>>>        Integer i
49747>>>        
49747>>>        Get patExcludedFields of ghoWQF to atExcluded
49748>>>        Move (SizeOfArray(atExcluded))  to i
49749>>>        Move hTable to atExcluded[i].hTable
49750>>>        Move iField to atExcluded[i].iField
49751>>>        Set patExcludedFields of ghoWQF to atExcluded
49752>>>    End_Procedure
49753>>>    
49753>>>    Procedure ClearExcludedFields
49756>>>        wqTableField[] atExcluded
49756>>>        wqTableField[] atExcluded
49757>>>        
49757>>>        Set patExcludedFields of ghoWQF to atExcluded
49758>>>    End_Procedure
49759>>>    
49759>>>    Function PublicPath Returns String
49762>>>        Function_Return (PublicPath(ghoWQF))
49763>>>    End_Function
49764>>>    
49764>>>    Function PrivatePath Returns String
49767>>>        Function_Return (PrivatePath(ghoWQF))
49768>>>    End_Function
49769>>>    
49769>>>    Procedure Enableling
49772>>>        Handle  hTab
49772>>>        Boolean bEn
49772>>>        wqPrintField[] aFields
49772>>>        wqPrintField[] aFields
49773>>>        
49773>>>        WebGet wphMainTable to hTab
49774>>>        Move (hTab > 0)     to bEn
49775>>>        Get paFields        to aFields
49776>>>        
49776>>>        WebSet pbEnabled of oRunButton      to (bEn and (SizeOfArray(aFields) > 0))
49777>>>        WebSet pbEnabled of oQueryTitle     to bEn
49778>>>        WebSet pbEnabled of oTablesPage     to bEn
49779>>>        WebSet pbEnabled of oSelectionPage  to bEn
49780>>>        WebSet pbEnabled of oOrderingPage   to bEn
49781>>>        WebSet pbEnabled of oTextsPage      to bEn
49782>>>        WebSet pbEnabled of oOrderingPage   to bEn
49783>>>        WebSet pbEnabled of oOutputPage     to bEn
49784>>>        WebSet pbEnabled of oAddField       to bEn
49785>>>        WebSet pbEnabled of oInsertField    to bEn
49786>>>        WebSet pbEnabled of oDeleteField    to bEn
49787>>>        WebSet pbEnabled of oExprnField     to bEn
49788>>>//        WebSet pbEnabled of oAdjustField    to bEn
49788>>>        WebSet pbEnabled of oSelAddBtn      to bEn
49789>>>        WebSet pbEnabled of oSelInsertBtn   to bEn
49790>>>        WebSet pbEnabled of oSelDeleteBtn   to bEn
49791>>>        WebSet pbEnabled of oSelValueBtn    to bEn
49792>>>        WebSet pbEnabled of oSaveQry        to bEn
49793>>>        WebSet pbEnabled of oTablesList     to bEn
49794>>>        WebSet pbEnabled of oColumnsList    to bEn
49795>>>        WebSet pbEnabled of oPrintedFields  to bEn
49796>>>        WebSet pbEnabled of oSelTablesList  to bEn
49797>>>        WebSet pbEnabled of oSelColumnsList to bEn
49798>>>        WebSet pbEnabled of oSelections     to bEn
49799>>>        WebSet pbEnabled of oSelTables      to bEn
49800>>>        WebSet pbEnabled of oSelColumns     to bEn
49801>>>        WebSet pbEnabled of oFieldCol       to bEn
49802>>>        WebSet pbEnabled of oSumCol         to bEn
49803>>>        WebSet pbEnabled of oCRCol          to bEn
49804>>>    End_Procedure
49805>>>
49805>>>    // This is just a wrapper for RelatedFiles in cWebQueryFunctions 
49805>>>    // to kick it off with the correct main table
49805>>>    Procedure CollectRelated tWebRow[] ByRef aRows
49808>>>        Handle  hTab
49808>>>        
49808>>>        WebGet wphMainTable to hTab
49809>>>        If hTab Send RelatedFiles of ghoWQF (&aRows) hTab
49812>>>    End_Procedure
49813>>>    
49813>>>    // This is here to catch double-click events on the columns tables and use
49813>>>    // them to trigger "Add" events on the fields and selections.
49813>>>    Procedure OnSubmit
49816>>>        String  sFoc
49816>>>        Handle  hoFoc
49816>>>        
49816>>>        Get FocusObject to hoFoc
49817>>>        
49817>>>        If (hoFoc = oColumnsList)    Send AddPrintField True
49820>>>        If (hoFoc = oSelColumnsList) Send AddSelField   True
49823>>>    End_Procedure
49824>>>    
49824>>>    Procedure OnLoad
49827>>>        Send ClearQuery
49828>>>    End_Procedure
49829>>>
49829>>>// I don't think we really want to do this:    
49829>>>//    Procedure OnShow
49829>>>//        Send ClearQuery
49829>>>//    End_Procedure
49829>>>    
49829>>>    Procedure ClearDependant
49832>>>        wqPrintField[] aFields
49832>>>        wqPrintField[] aFields
49833>>>        wqSelections[] aSels
49833>>>        wqSelections[] aSels
49834>>>
49834>>>        Set paFields                        to aFields
49835>>>        Set paSelections                    to aSels
49836>>>        Set phSelectedTable                 to 0
49837>>>        Send GridRefresh of oTablesList
49838>>>        Send GridRefresh of oSelTablesList
49839>>>        Send GridRefresh of oPrintedFields
49840>>>        Send GridRefresh of oSelections
49841>>>        Send GridRefresh of oColumnsList
49842>>>        Send GridRefresh of oSelColumnsList
49843>>>        WebSet wpsSelectExpression          to ""
49844>>>        Send Refill      of oOrder
49845>>>        WebSet wpsIndexSegments to ""
49846>>>        Send GridRefresh of oSegments
49847>>>        Send Clear       of oWqOpenQuery
49848>>>    End_Procedure
49849>>>    
49849>>>    Procedure ClearQuery
49852>>>        WebSet wphMainTable                 to 0
49853>>>        WebSet psValue of oMainFile         to 0
49854>>>        
49854>>>        Send Show of oTablesPage
49855>>>        Send ClearDependant
49856>>>        
49856>>>        WebSet wpiIndex                         to 0
49857>>>        Set phSelectedTable                     to 0
49858>>>        WebSet psValue of oQueryTitle           to ""
49859>>>        WebSet psValue of oTextBefore           to ""
49860>>>        WebSet psValue of oTextAfter            to ""
49861>>>        WebSet psValue of oFontCombo            to "Arial, Helvetica, sans-serif"
49862>>>        WebSet psValue of oFontSizeCombo        to "medium"
49863>>>        WebSet psValue of oIncSelections        to False
49864>>>        WebSet psValue of oTotalsOnly           to False
49865>>>        WebSet psValue of oPrintCount           to True
49866>>>        WebSet psValue of oTextColour           to "black"
49867>>>        WebSet psBackgroundColor of oTextCol    to "black"
49868>>>        WebSet psValue of oBGColour             to "white"
49869>>>        WebSet psBackgroundColor of oBGCol      to "white"
49870>>>        WebSet psValue of oAltRowHighlight      to True
49871>>>        WebSet psValue of oHighlightColour      to "#AAFFFF"
49872>>>        WebSet psBackgroundColor of oHLCol      to "#AAFFFF"
49873>>>        Send SetSelected of oOutModal
49874>>>        Send SetSelected of oViewOutput
49875>>>        Send SetSelected of oOutHTML
49876>>>        WebSet psValue   of oColHeads           to False
49877>>>        WebSet psValue   of oPrintGenLine       to True
49878>>>        WebSet psValue   of oUseSQL             to (pbUseSqlDefault(Self))
49879>>>        
49879>>>        Send ChangeOutput C_wqModalWin
49880>>>        
49880>>>//        Send Show of oTablesPage   // This does not work as advertised in the current situation
49880>>>//        Send Focus of oTablesPage  // And neither does this
49880>>>        
49880>>>        Send Enableling
49881>>>    End_Procedure
49882>>>    
49882>>>    Procedure MainTableSelected Handle hTab
49885>>>        Integer iIdx
49885>>>        
49885>>>        Send ClearDependant
49886>>>        
49886>>>        WebSet wphMainTable                             to hTab
49887>>>        
49887>>>        If hTab Begin
49889>>>            Send GridRefresh        of oTablesList
49890>>>            WebSet psCurrentRowID   of oTablesList      to hTab
49891>>>            Send FieldsTableSelected                       hTab
49892>>>            
49892>>>            Send GridRefresh        of oSelTablesList
49893>>>            WebSet psCurrentRowID   of oSelTablesList   to hTab
49894>>>            Send SelTableSelected                          hTab
49895>>>            
49895>>>            Send Refill             of oOrder
49896>>>            WebGet wpiIndex                             to iIdx
49897>>>            Send GridRefresh        of oSegments
49898>>>            WebSet psValue          of oOrder           to iIdx
49899>>>//            Send Refill of oSearchOrd
49899>>>        End
49899>>>>
49899>>>        
49899>>>        Send Enableling
49900>>>    End_Procedure
49901>>>        
49901>>>    Procedure FieldsTableSelected Handle hTab
49904>>>        Set phSelectedTable     to hTab
49905>>>        Send GridRefresh        of oColumnsList
49906>>>        WebSet psCurrentRowID   of oColumnsList to 1
49907>>>    End_Procedure
49908>>>    
49908>>>    Procedure SelTableSelected Handle hTab
49911>>>        Set phSelectedTable     to hTab
49912>>>        Send GridRefresh        of oSelColumnsList
49913>>>        WebSet psCurrentRowID   of oSelColumnsList to 1
49914>>>    End_Procedure
49915>>>    
49915>>>    Procedure IndexSelected Integer iIndex
49918>>>        wqIndexSeg[] aSegs
49918>>>        wqIndexSeg[] aSegs
49919>>>        String  sSegs
49919>>>        
49919>>>        WebSet wpiIndex to iIndex
49920>>>        Send GridRefresh of oSegments
49921>>>    End_Procedure
49922>>>
49922>>>    Procedure AddPrintField Boolean bAppend
49925>>>        Handle  hTable
49925>>>        Integer iColumn iRow
49925>>>        wqPrintField tField
49925>>>        wqPrintField tField
49925>>>        String  sField
49925>>>        
49925>>>        WebGet psCurrentRowID of oColumnsList to tField.iColumn
49926>>>        WebGet psCurrentRowID of oTablesList  to tField.iTable
49927>>>        Move False                            to tField.bCalc
49928>>>        
49928>>>        Open tField.iTable
49930>>>        Get_Attribute DF_FIELD_TYPE      of tField.iTable tField.iColumn to tField.iType
49933>>>        Get_Attribute DF_FIELD_LENGTH    of tField.iTable tField.iColumn to tField.iWidth
49936>>>        Get_Attribute DF_FIELD_PRECISION of tField.iTable tField.iColumn to tField.iDecimals
49939>>>        
49939>>>        Get VariantToString of oStructFunctions tField to sField
49940>>>        WebSet wpsNewField to sField
49941>>>        
49941>>>        Send ProcessDataSet of oPrintedFields (If(bAppend, C_wqAppendRow, C_wqInsertRow))
49942>>>    End_Procedure
49943>>>    
49943>>>    Procedure DeletePrintField
49946>>>        Send ProcessDataSet of oPrintedFields C_wqDeleteRow
49947>>>    End_Procedure
49948>>>    
49948>>>    Procedure FieldListReturned tWebRow[] ByRef aRows Integer eOp Integer iCurrRow
49951>>>        wqPrintField[] aFields
49951>>>        wqPrintField[] aFields
49952>>>        wqPrintField newField
49952>>>        wqPrintField newField
49952>>>        Integer i iRows iRowPos iRow iMax
49952>>>        String  sField
49952>>>        tValueTree tVT
49952>>>        tValueTree tVT
49952>>>        
49952>>>        Move (SizeOfArray(aRows)) to iRows
49953>>>        
49953>>>        For i from 0 to (iRows - 1)
49959>>>>
49959>>>            Move aRows[i].aValues[4]  to sField
49960>>>            Get DeSerializeField of ghoWQF sField to aFields[i]
49961>>>            
49961>>>            Move aRows[i].aValues[1]  to aFields[i].sUserName
49962>>>            Move aRows[i].aValues[2]  to aFields[i].bSum
49963>>>            Move aRows[i].aValues[3]  to aFields[i].bCR
49964>>>        Loop
49965>>>>
49965>>>        
49965>>>        WebGet wpsNewField to sField
49966>>>        Get StringToValueTree of oStructFunctions sField to tVT
49967>>>        ValueTreeDeserializeParameter tVT to newField
49968>>>        
49968>>>        If ((eOp = C_wqAppendRow) or (eOp = C_wqInsertRow)) Begin
49970>>>            Move False  to newField.bSum
49971>>>            Move False  to newField.bCR
49972>>>            Move (NiceFieldName(ghoWQF, newField.iTable, newField.iColumn)) ;                        to newField.sUserName
49973>>>                        
49973>>>            WebGet piCurrentRowIndex of oColumnsList to iRow
49974>>>            WebGet piRowCount        of oColumnsList to iMax
49975>>>            If (iRow < (iMax - 1)) Send MoveToRow of oColumnsList (iRow + 1)
49978>>>        End
49978>>>>
49978>>>        Else If ((eOp = C_wqAddExpression) or (eOp = C_wqInsertExpression)) Begin
49981>>>            Move False  to newField.bSum
49982>>>            Move False  to newField.bCR
49983>>>        End
49983>>>>
49983>>>        
49983>>>        If      (eOp = C_wqAppendRow) Begin
49985>>>            Move newField to aFields[iRows]
49986>>>        End
49986>>>>
49986>>>        Else If (eOp = C_wqInsertRow) Begin
49989>>>            If ((iCurrRow => 0) and (iCurrRow < iRows)) ;                Move (InsertInArray(aFields, iCurrRow, newField)) to aFields
49992>>>        End
49992>>>>
49992>>>        Else If (eOp = C_wqDeleteRow) Begin
49995>>>            If ((iCurrRow => 0) and (iCurrRow < iRows)) ;                Move (RemoveFromArray(aFields, iCurrRow)) to aFields
49998>>>        End
49998>>>>
49998>>>        Else If (eOp = C_wqAddExpression) Begin
50001>>>            Move newField to aFields[iRows]
50002>>>        End
50002>>>>
50002>>>        Else If (eOp = C_wqInsertExpression) Begin
50005>>>            If ((iCurrRow => 0) and (iCurrRow < iRows)) ;                Move (InsertInArray(aFields, iCurrRow, newField)) to aFields
50008>>>        End
50008>>>>
50008>>>        Else If (eOp = C_wqEditExpression) Begin
50011>>>            Move newField to aFields[iCurrRow]
50012>>>        End
50012>>>>
50012>>>        
50012>>>        Set paFields to aFields
50013>>>        Send Enableling
50014>>>        Send GridRefresh of oPrintedFields
50015>>>    End_Procedure
50016>>>    
50016>>>    Procedure AddSelField Boolean bAppend
50019>>>        Handle  hTable
50019>>>        Integer iColumn iRow iType
50019>>>        
50019>>>        WebGet psCurrentRowID of oSelTablesList  to hTable
50020>>>        WebGet psCurrentRowID of oSelColumnsList to iColumn
50021>>>        
50021>>>        If not hTable Procedure_Return
50024>>>        
50024>>>        Open hTable
50026>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
50029>>>        
50029>>>        WebSet wphNewTable      to hTable
50030>>>        WebSet wpiNewColumn     to iColumn
50031>>>        WebSet wpiNewDataType   to iType
50032>>>        WebSet wpbNewAppend     to bAppend
50033>>>        
50033>>>        Send DoPopup of oWqSelectionOperators Self (If(bAppend, C_wqAppendRow, C_wqInsertRow))
50034>>>    End_Procedure
50035>>>    
50035>>>    Procedure LoadPrintFields tWebRow[] ByRef aRows String ByRef sCurrentRowID
50038>>>        Integer i
50038>>>        wqPrintField[] aFields
50038>>>        wqPrintField[] aFields
50039>>>        String  sField
50039>>>        
50039>>>        Get paFields to aFields
50040>>>        
50040>>>        For i from 0 to (SizeOfArray(aFields) - 1)
50046>>>>
50046>>>            Move i                      to aRows[i].aValues[0]
50047>>>            Move aFields[i].sUserName   to aRows[i].aValues[1]
50048>>>            Move aFields[i].bSum        to aRows[i].aValues[2]
50049>>>            Move aFields[i].bCR         to aRows[i].aValues[3]
50050>>>            Get SerializeField of ghoWQF aFields[i] to sField
50051>>>            Move sField                 to aRows[i].aValues[4]
50052>>>        Loop
50053>>>>
50053>>>        
50053>>>    End_Procedure
50054>>>    
50054>>>    Procedure LoadSelections tWebRow[] ByRef aRows String ByRef sCurrentRowID
50057>>>        Integer iRows i
50057>>>        wqSelections[] aSels
50057>>>        wqSelections[] aSels
50058>>>        
50058>>>        Get paSelections of ghoWebQry to aSels
50059>>>        
50059>>>        For i from 0 to (SizeOfArray(aSels) - 1)
50065>>>>
50065>>>            Move i                  to aRows[i].aValues[0]
50066>>>            Move aSels[i].sUserName to aRows[i].aValues[1]
50067>>>            Move aSels[i].sType     to aRows[i].aValues[2]
50068>>>            Move aSels[i].sValue    to aRows[i].aValues[3]
50069>>>            Move aSels[i].iTable    to aRows[i].aValues[4]
50070>>>            Move aSels[i].iColumn   to aRows[i].aValues[5]
50071>>>            Move aSels[i].iType     to aRows[i].aValues[6]
50072>>>        Loop
50073>>>>
50073>>>        
50073>>>    End_Procedure
50074>>>    
50074>>>    Procedure TableSelected Handle hoObj
50077>>>        Handle  hTab
50077>>>        
50077>>>        Get TableSelected of oWqTableSelection to hTab
50078>>>        WebSet psValue of oMainFile to hTab
50079>>>        Send MainTableSelected hTab
50080>>>    End_Procedure
50081>>>    
50081>>>    Procedure SelsListReturned tWebRow[] ByRef aRows Integer eOp Integer iCurrRow
50084>>>        wqSelections[] aSels
50084>>>        wqSelections[] aSels
50085>>>        wqSelections   newSel
50085>>>        wqSelections   newSel
50085>>>        Integer i iRows iOp iType iCurr iRow iMax
50085>>>        Boolean bAppend
50085>>>                                
50085>>>        Move (SizeOfArray(aRows)) to iRows
50086>>>        
50086>>>        For i from 0 to (iRows - 1)
50092>>>>
50092>>>            Move aRows[i].aValues[1] to aSels[i].sUserName
50093>>>            Move aRows[i].aValues[2] to aSels[i].sType
50094>>>            Move aRows[i].aValues[3] to aSels[i].sValue                                    
50095>>>            Move aRows[i].aValues[4] to aSels[i].iTable
50096>>>            Move aRows[i].aValues[5] to aSels[i].iColumn
50097>>>            Move aRows[i].aValues[6] to aSels[i].iType
50098>>>        Loop
50099>>>>
50099>>>        
50099>>>        If ((eOp = C_wqAppendRow) or (eOp = C_wqInsertRow)) Begin
50101>>>            WebGet wphNewTable                      to newSel.iTable
50102>>>            WebGet wpiNewColumn                     to newSel.iColumn
50103>>>            WebGet wpiNewDataType                   to newSel.iType
50104>>>            WebGet wpiNewOperator                   to iOp
50105>>>            Move (SelCode(oWqSelectionTypes, iOp))  to newSel.sType
50106>>>            WebGet wpbNewAppend                     to bAppend
50107>>>        
50107>>>            Move "No limitation"                    to newSel.sValue
50108>>>            
50108>>>            Move (NiceFieldName(ghoWQF, newSel.iTable, newSel.iColumn)) to newSel.sUserName
50109>>>            
50109>>>            WebGet piCurrentRowIndex of oSelColumnsList to iRow
50110>>>            WebGet piRowCount        of oSelColumnsList to iMax
50111>>>            If (iRow < (iMax - 1)) Send MoveToRow of oSelColumnsList (iRow + 1)
50114>>>        End
50114>>>>
50114>>>        
50114>>>        WebGet piCurrentRowIndex of oSelections to iCurr
50115>>>        
50115>>>        If (eOp = C_wqAppendRow) Begin
50117>>>            Move newSel to aSels[iRows]
50118>>>        End
50118>>>>
50118>>>        Else If (eOp = C_wqInsertRow) Begin
50121>>>            If ((iCurr => 0) and (iCurr < iRows)) ;                Move (InsertInArray(aSels, iCurr, newSel)) to aSels
50124>>>        End
50124>>>>
50124>>>        Else If (eOp = C_wqDeleteRow) Begin
50127>>>            If ((iCurr => 0) and (iCurr < iRows)) ;                Move (RemoveFromArray(aSels, iCurr)) to aSels
50130>>>        End
50130>>>>
50130>>>        
50130>>>        Set paSelections to aSels
50131>>>        Send GridRefresh of oSelections
50132>>>    End_Procedure
50133>>>    
50133>>>    Procedure SelOpSelected Handle hoObj
50136>>>        Integer iOp eOp
50136>>>        
50136>>>        Get SelectedOperator of hoObj to iOp
50137>>>        Get Operation        of hoObj to eOp
50138>>>        WebSet wpiNewOperator to iOp
50139>>>        Send ProcessDataSet of oSelections eOp
50140>>>    End_Procedure
50141>>>    
50141>>>    Procedure SelectValue
50144>>>        Handle  hTab
50144>>>        Integer iCol iDT
50144>>>        String  sOp sName sVal
50144>>>        
50144>>>        WebGet psValue of oSelTabCol    to hTab
50145>>>        WebGet psValue of oSelColCol    to iCol
50146>>>        WebGet psValue of oSelType      to sOp
50147>>>        WebGet psValue of oSelField     to sName
50148>>>        WebGet psValue of oSelValue     to sVal
50149>>>        WebGet psValue of oSelDataType  to iDT
50150>>>        
50150>>>        Get WebDataType of ghoWQF iDT   to iDT
50151>>>        
50151>>>        If (sOp = "in list")                     Send PopupGetList  of oWqSelectionList   Self sName sOp sVal iDT
50154>>>        Else If ((sOp = "x-y") or (sOp = "CBT")) Send PopupGetRange of oWqSelectionRanges Self sName sOp sVal iDT
50158>>>        Else                                     Send PopupGetValue of oWqSelectionValues Self sName sOp sVal iDT
50160>>>    End_Procedure
50161>>>    
50161>>>    Procedure LoadSegments tWebRow[] ByRef aRows String ByRef sRowID
50164>>>        Handle  hTab
50164>>>        Integer iIdx iSegs i iFld iUC iDirn
50164>>>        String  sSegs
50164>>>        wqIndexSeg[] aSegs
50164>>>        wqIndexSeg[] aSegs
50165>>>        tValueTree tVT
50165>>>        tValueTree tVT
50165>>>        
50165>>>        WebGet wphMainTable to hTab
50166>>>        
50166>>>        If not hTab Procedure_Return
50169>>>        
50169>>>        Open hTab
50171>>>        WebGet wpiIndex             to iIdx
50172>>>        WebSet psValue of oOrder    to iIdx
50173>>>                
50173>>>        WebSet pbEnabled of oAdHocButton to (iIdx = -1)
50174>>>        
50174>>>        WebGet wpsIndexSegments to sSegs
50175>>>        
50175>>>        If (sSegs <> "") Begin
50177>>>            Get StringToValueTree of oStructFunctions sSegs to tVT
50178>>>            ValueTreeDeserializeParameter tVT to aSegs
50179>>>        
50179>>>            For i from 0 to (SizeOfArray(aSegs) - 1)
50185>>>>
50185>>>                Move i               to aRows[i].aValues[0]
50186>>>                Move aSegs[i].bBreak to aRows[i].aValues[1]
50187>>>                Move aSegs[i].sName  to aRows[i].aValues[2]
50188>>>                Move aSegs[i].iTable to aRows[i].aValues[3]
50189>>>                Move aSegs[i].iField to aRows[i].aValues[4]
50190>>>                Move aSegs[i].bUC    to aRows[i].aValues[5]
50191>>>                Move aSegs[i].bDesc  to aRows[i].aValues[6]
50192>>>            Loop
50193>>>>
50193>>>            
50193>>>        End
50193>>>>
50193>>>        Else If (iIdx <> -1) Begin
50196>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTab iIdx to iSegs
50199>>>            
50199>>>            For i from 1 to iSegs
50205>>>>
50205>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTab iIdx i to iFld
50208>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTab iIdx i to iUC
50211>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTab iIdx i to iDirn
50214>>>                
50214>>>                If (iFld > 0) Begin  // Don't add recnum to the segments...
50216>>>                    Move i                                          to aRows[i - 1].aValues[0]
50217>>>                    Move False                                      to aRows[i - 1].aValues[1]
50218>>>                    Move (NiceFieldName(ghoWQF, hTab, iFld) + ": ") to aRows[i - 1].aValues[2]
50219>>>                    WebGet wphMainTable                             to aRows[i - 1].aValues[3]
50220>>>                    Move iFld                                       to aRows[i - 1].aValues[4]
50221>>>                    Move (iUC = DF_CASE_IGNORED)                    to aRows[i - 1].aValues[5]
50222>>>                    Move (iDirn = DF_DESCENDING)                    to aRows[i - 1].aValues[6]
50223>>>                End
50223>>>>
50223>>>                
50223>>>            Loop
50224>>>>
50224>>>            
50224>>>        End
50224>>>>
50224>>>        
50224>>>        WebSet psValue of oOrder to iIdx
50225>>>    End_Procedure
50226>>>    
50226>>>    Procedure CalcField
50229>>>        Boolean bCalc bHaveRows
50229>>>        Integer iRows
50229>>>        String  sField
50229>>>        wqPrintField tField
50229>>>        wqPrintField tField
50229>>>
50229>>>        WebGet psValue of oFieldData to sField
50230>>>        If (sField <> "") Get DeSerializeField of ghoWQF sField to tField
50233>>>        WebGet piRowCount           of oPrintedFields   to iRows
50234>>>        
50234>>>        Move (iRows > 0) to bHaveRows
50235>>>        
50235>>>        Send PopupOptions of oWqAddInsEdit Self bHaveRows tField.bCalc
50236>>>    End_Procedure
50237>>>    
50237>>>    Procedure ExprAction
50240>>>        Integer iAct iRows
50240>>>        wqPrintField tField
50240>>>        wqPrintField tField
50240>>>        Handle  hTab
50240>>>        String  sField
50240>>>        
50240>>>        Get ActionSelected          of oWqAddInsEdit    to iAct
50241>>>        WebGet piRowCount           of oPrintedFields   to iRows        
50242>>>        WebGet wphMainTable                             to hTab
50243>>>        WebGet psValue              of oFieldData       to sField
50244>>>        If (sField <> "") Get DeSerializeField of ghoWQF sField to tField
50247>>>        
50247>>>        If (iAct = C_wqAddExpression) Begin
50249>>>            Send PopupCalcCol of oWqCalcColumn Self tField iAct hTab
50250>>>        End
50250>>>>
50250>>>        Else If (iAct = C_wqInsertExpression) Begin
50253>>>            If (iRows < 1) Procedure_Return
50256>>>            Send PopupCalcCol of oWqCalcColumn Self tField iAct hTab
50257>>>        End
50257>>>>
50257>>>        Else If (iAct = C_wqEditExpression) Begin
50260>>>            If (iRows < 1)        Procedure_Return
50263>>>            If not (tField.bCalc) Procedure_Return  // Shouldn't happen!
50266>>>            Send PopupCalcCol of oWqCalcColumn Self tField iAct hTab
50267>>>        End
50267>>>>
50267>>>        
50267>>>    End_Procedure
50268>>>    
50268>>>    Procedure CalcColReturn Handle hoObj
50271>>>        wqPrintField tField
50271>>>        wqPrintField tField
50271>>>        String  sField
50271>>>        Integer iOp iFld
50271>>>        
50271>>>        Get CalcColInfo of oWqCalcColumn to tField
50272>>>        Get piOperation of oWqCalcColumn to iOp
50273>>>        
50273>>>        Get VariantToString of oStructFunctions tField to sField
50274>>>        WebSet wpsNewField to sField
50275>>>        
50275>>>        Send ProcessDataSet of oPrintedFields iOp
50276>>>    End_Procedure
50277>>>    
50277>>>    Procedure EnterSelExpr
50280>>>        String  sExpr
50280>>>        Handle  hTab
50280>>>        
50280>>>        WebGet wpsSelectExpression to sExpr
50281>>>        WebGet wphMainTable        to hTab
50282>>>        
50282>>>        Send DoPopup of oWqExpressionPopup Self sExpr C_wqSelectExpr 0 hTab ""
50283>>>    End_Procedure
50284>>>    
50284>>>    Procedure ExprReturned  Handle hoExpr
50287>>>        wqExpressionReturn tExpr
50287>>>        wqExpressionReturn tExpr
50287>>>        wqPrintField tField
50287>>>        wqPrintField tField
50287>>>        String  sField
50287>>>        
50287>>>        Get ExprValue of hoExpr to tExpr
50288>>>        
50288>>>        If (tExpr.iOp = C_wqSelectExpr) WebSet wpsSelectExpression to tExpr.sExpression
50291>>>    End_Procedure
50292>>>    
50292>>>    Procedure SpecAdHoc
50295>>>        Send ProcessDataSet of oSegments C_wqGetIndexInfo
50296>>>    End_Procedure
50297>>>    
50297>>>    Procedure IndexDataReceived tWebRow[] ByRef aData Integer eOp Integer iSelRow
50300>>>        Handle  hTab
50300>>>        Integer i
50300>>>        String  sSegs
50300>>>        wqIndexSeg[] aSegs
50300>>>        wqIndexSeg[] aSegs
50301>>>        tValueTree tVT
50301>>>        tValueTree tVT
50301>>>        
50301>>>        WebGet wphMainTable  to hTab
50302>>>            
50302>>>        For i from 0 to (SizeOfArray(aData) - 1)
50308>>>>
50308>>>            Move aData[i].aValues[1] to aSegs[i].bBreak
50309>>>            Move aData[i].aValues[2] to aSegs[i].sName
50310>>>            Move aData[i].aValues[3] to aSegs[i].iTable
50311>>>            Move aData[i].aValues[4] to aSegs[i].iField
50312>>>            Move aData[i].aValues[5] to aSegs[i].bUC
50313>>>            Move aData[i].aValues[6] to aSegs[i].bDesc
50314>>>        Loop
50315>>>>
50315>>>        
50315>>>        Send PopupAdHoc of oWqAdHocIndex Self hTab aSegs
50316>>>    End_Procedure
50317>>>    
50317>>>    Procedure AdHocDefined Handle hObj
50320>>>        wqIndexSeg[] aSegs
50320>>>        wqIndexSeg[] aSegs
50321>>>        String  sSegs
50321>>>        
50321>>>        Get AdHocSegments of hObj to aSegs
50322>>>        Get VariantToString of oStructFunctions aSegs to sSegs
50323>>>        WebSet wpsIndexSegments to sSegs
50324>>>        Send GridRefresh of oSegments
50325>>>    End_Procedure
50326>>>    
50326>>>    Procedure ColourSelected Handle hoObj
50329>>>        String  sColour
50329>>>        Handle  hoTarg
50329>>>        
50329>>>        Get ColourValue  of hoObj  to sColour
50330>>>        Get TargetObject of hoObj  to hoTarg
50331>>>        WebSet psValue   of hoTarg to sColour
50332>>>        
50332>>>        If      (hoTarg = oTextColour)      WebSet psBackgroundColor of oTextCol to sColour
50335>>>        Else If (hoTarg = oBGColour)        WebSet psBackgroundColor of oBGCol   to sColour
50339>>>        Else If (hoTarg = oHighlightColour) WebSet psBackgroundColor of oHLCol   to sColour
50343>>>        
50343>>>    End_Procedure
50344>>>    
50344>>>    Procedure ChangeOutput String sVal
50347>>>        String  sFormat
50347>>>        
50347>>>        If (sVal = C_wqViewOutput) Begin
50349>>>            WebSet pbRender of oLabFormat   to False
50350>>>            WebSet pbRender of oOutHTML     to False
50351>>>            WebSet pbRender of oOutText     to False
50352>>>            WebSet pbRender of oOutCSV      to False
50353>>>            WebSet pbRender of oOutXML      to False
50354>>>            WebSet pbRender of oColHeads    to False
50355>>>            WebSet pbRender of oOutputLab   to True
50356>>>            WebSet pbRender of oOutModal    to True
50357>>>            WebSet pbRender of oOutTab      to True
50358>>>            WebSet pbRender of oOutWin      to True
50359>>>            WebSet pbRender of oNewWarning  to True
50360>>>        End
50360>>>>
50360>>>        Else Begin
50361>>>            WebSet pbRender of oOutputLab   to False
50362>>>            WebSet pbRender of oOutModal    to False
50363>>>            WebSet pbRender of oOutTab      to False
50364>>>            WebSet pbRender of oOutWin      to False
50365>>>            WebSet pbRender of oNewWarning  to False
50366>>>            WebSet pbRender of oLabFormat   to True
50367>>>            WebSet pbRender of oOutHTML     to True
50368>>>            WebSet pbRender of oOutText     to True
50369>>>            WebSet pbRender of oOutCSV      to True
50370>>>            WebSet pbRender of oOutXML      to True
50371>>>            WebSet pbRender of oColHeads    to True
50372>>>            WebGet psValue  of oOutCSV      to sFormat
50373>>>            WebSet pbEnabled of oColHeads   to (sFormat = C_wqOutputCSV)
50374>>>        End
50374>>>>
50374>>>        
50374>>>    End_Procedure
50375>>>    
50375>>>    Procedure ChangeFormat String sFormat
50378>>>        WebSet pbEnabled of oColHeads to (sFormat = C_wqOutputCSV)
50379>>>    End_Procedure
50380>>>    
50380>>>    Procedure OpenQuery
50383>>>        Send PopupDialog of oWqOpenQuery Self C_wqOpenQuery ""
50384>>>    End_Procedure
50385>>>    
50385>>>    Function QueryFileError String sFile Returns Boolean
50388>>>        String sFName
50388>>>        
50388>>>        Get FilenameFromPath of ghoWQF sFile to sFName
50389>>>        
50389>>>        Send ShowInfoBox ("The file" * sFName * "does not appear to be valid") "Invalid Query File"
50390>>>    End_Function
50391>>>    
50391>>>    Procedure PopulateUI
50394>>>        wqWebQuery tQuery
50394>>>        wqWebQuery tQuery
50394>>>        tValueTree tVT
50394>>>        tValueTree tVT
50394>>>        String  sSegs
50394>>>        Boolean bView
50394>>>        
50394>>>        Get pQuery to tQuery
50395>>>        
50395>>>        WebSet psValue      of oQueryTitle      to tQuery.sTitle
50396>>>        WebSet psValue      of oMainFile        to tQuery.hMainTable
50397>>>        Send MainTableSelected tQuery.hMainTable
50398>>>        Set paFields                            to tQuery.aPrintFields
50399>>>        Send GridRefresh    of oPrintedFields
50400>>>        Set paSelections                        to tQuery.aSelections
50401>>>        Send GridRefresh    of oSelections
50402>>>        WebSet psValue      of oOrder           to tQuery.iIndex
50403>>>        WebSet wpsSelectExpression              to tQuery.sSelectExpression
50404>>>        Send IndexSelected                         tQuery.iIndex
50405>>>        
50405>>>        Get VariantToString of oStructFunctions tQuery.aSegments to sSegs
50406>>>        WebSet wpsIndexSegments             to sSegs
50407>>>        
50407>>>        Send GridRefresh    of oSegments
50408>>>//        WebSet psValue      of oSearchOrd       to tQuery.iSearchOrd
50408>>>        WebSet psValue      of oTextBefore      to tQuery.sTextBefore
50409>>>        WebSet psValue      of oTextAfter       to tQuery.sTextAfter
50410>>>        WebSet psValue      of oFontCombo       to tQuery.sTypeface
50411>>>        WebSet psValue      of oFontSizeCombo   to tQuery.sFontSize
50412>>>        WebSet psValue      of oIncSelections   to tQuery.bPrintSels
50413>>>        WebSet psValue      of oTotalsOnly      to tQuery.bTotalsOnly
50414>>>        WebSet psValue      of oPrintCount      to tQuery.bPrintCount
50415>>>        WebSet psValue      of oTextColour      to tQuery.sTextColour
50416>>>        WebSet psBackgroundColor of oTextCol    to tQuery.sTextColour
50417>>>        WebSet psValue      of oBGColour        to tQuery.sBGColour
50418>>>        WebSet psBackgroundColor of oBGCol      to tQuery.sBGColour
50419>>>        WebSet psValue      of oAltRowHighlight to tQuery.bHighlightAlt
50420>>>        WebSet psValue      of oHighlightColour to tQuery.sHighlightColour
50421>>>        WebSet psBackgroundColor of oHLCol      to tQuery.sHighlightColour
50422>>>        WebSet psValue      of oOutModal        to tQuery.iDestination
50423>>>        WebSet psValue      of oOutHTML         to tQuery.iOutputFormat
50424>>>        
50424>>>        If (tQuery.iDestination = C_wqDownload) Begin
50426>>>            WebSet psValue  of oViewOutput      to C_wqDownloadOutput
50427>>>            Send ChangeOutput C_wqDownloadOutput
50428>>>        End
50428>>>>
50428>>>        Else Begin
50429>>>            WebSet psValue  of oViewOutput      to C_wqViewOutput
50430>>>            Send ChangeOutput C_wqViewOutput
50431>>>        End
50431>>>>
50431>>>        
50431>>>        WebSet psValue      of oColHeads        to tQuery.bColHeads
50432>>>        WebSet psValue      of oPrintGenLine    to tQuery.bGeneratedLine
50433>>>        WebSet psValue      of oUseSQL          to tQuery.bUseSQL
50434>>>        
50434>>>        Send Enableling
50435>>>    End_Procedure
50436>>>    
50436>>>    Procedure QueryOpened Handle hoObj
50439>>>        wqWebQuery tQuery
50439>>>        wqWebQuery tQuery
50439>>>        tValueTree tVT
50439>>>        tValueTree tVT
50439>>>        String  sFile String sFName
50439>>>        Integer iChn
50439>>>        Boolean bOK
50439>>>        
50439>>>        Get FileOpened of hoObj to sFile
50440>>>        Get FilenameFromPath of ghoWQF sFile to sFName
50441>>>        Get Seq_New_Channel     to iChn
50442>>>        Direct_Input channel iChn sFile
50444>>>        Move (not(SeqEof)) to bOK
50445>>>
50445>>>        If bOK Begin
50447>>>            Send ReadValueTree of oStructFunctions iChn (&tVT)
50448>>>            ValueTreeDeserializeParameter tVT to tQuery
50449>>>            Close_Input channel iChn
50451>>>            Send Seq_Release_Channel iChn
50452>>>            Set pQuery to tQuery
50453>>>            Send PopulateUI
50454>>>        End
50454>>>>
50454>>>        Else Begin
50455>>>            Close_Input channel iChn
50457>>>            Send Seq_Release_Channel iChn
50458>>>            Procedure_Return (QueryFileError(Self, sFile))
50459>>>        End
50459>>>>
50459>>>        
50459>>>    End_Procedure
50460>>>    
50460>>>    Procedure FileReturned Handle hoObj
50463>>>        Integer iMode
50463>>>        
50463>>>        WebGet wpiMode of hoObj to iMode
50464>>>        
50464>>>        If (iMode = C_wqOpenQuery) Send QueryOpened hoObj
50467>>>        If (iMode = C_wqSaveQuery) Send DoSave      hoObj
50470>>>    End_Procedure
50471>>>    
50471>>>    Procedure SaveQuery
50474>>>        String sDefault
50474>>>        Handle hTable
50474>>>        
50474>>>        WebGet psValue of oQueryTitle to sDefault
50475>>>        
50475>>>        If (sDefault = "") Begin
50477>>>            WebGet wphMainTable to hTable
50478>>>            Open hTable
50480>>>            Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDefault
50483>>>            If (sDefault = "") Procedure_Return
50486>>>        End
50486>>>>
50486>>>        
50486>>>        Send PopupDialog of oWqOpenQuery Self C_wqSaveQuery sDefault
50487>>>    End_Procedure
50488>>>    
50488>>>    Procedure DoSave Handle hoObj
50491>>>        String  sFile
50491>>>        
50491>>>//        Send SetActionMode (RefProcDoSave)) scModeProgress "Your report is being processed"
50491>>>        
50491>>>        Get FileOpened of hoObj to sFile
50492>>>        WebSet wpsSaveFilename  to sFile
50493>>>        Send AssembleQuery C_wqAssembleSave
50494>>>    End_Procedure
50495>>>    
50495>>>    Procedure DoSaveQuery
50498>>>        wqWebQuery tQuery
50498>>>        wqWebQuery tQuery
50498>>>        String  sFile
50498>>>        Integer iChn
50498>>>        
50498>>>        WebGet wpsSaveFilename          to sFile
50499>>>        Get Seq_New_Channel to iChn
50500>>>        Direct_Output channel iChn sFile
50502>>>        Get pQuery to tQuery
50503>>>        Send WriteVariant of oStructFunctions iChn tQuery
50504>>>        Close_Output channel iChn
50506>>>        Send Seq_Release_Channel iChn
50507>>>    End_Procedure
50508>>>    
50508>>>    Procedure RunQuery
50511>>>        wqWebQuery tQuery
50511>>>        wqWebQuery tQuery
50511>>>        String   sFile sTitle sPath sDir sExt sUrl
50511>>>        String[] aParams
50512>>>        Handle   hTab
50512>>>
50512>>>        Get pQuery                              to tQuery
50513>>>        Get OutputReport of ghoWQF (&tQuery)    to sFile
50514>>>        
50514>>>        Move tQuery.sTitle to sTitle
50515>>>        
50515>>>        If (Trim(sTitle) = "") Begin
50517>>>            Move tQuery.hMainTable to hTab
50518>>>            Open hTab
50520>>>            Get_Attribute DF_FILE_DISPLAY_NAME of hTab to sTitle
50523>>>        End
50523>>>>
50523>>>        
50523>>>        If (tQuery.iDestination = C_wqDownload) Begin
50525>>>            If      (tQuery.iOutputFormat = C_wqOutputHtml) Move ".html"            to sExt
50528>>>            Else If (tQuery.iOutputFormat = C_wqOutputCSV)  Move ".csv"             to sExt
50532>>>            Else If (tQuery.iOutputFormat = C_wqOutputText) Move ".txt"             to sExt
50536>>>            Else If (tQuery.iOutputFormat = C_wqOutputXML)  Move ".xml"             to sExt
50540>>>            Else                                            Move ""                 to sExt
50542>>>            Move (sTitle - sExt)                                                    to sTitle
50543>>>            Get psDownloadDirectory                                                 to sDir
50544>>>            Move (sDir + "\" + sFile)                                               to sDir
50545>>>            Get CustomDownloadURL of ghoWebResourceManager sDir True sTitle True 0  to sUrl
50546>>>        End
50546>>>>
50546>>>        Else Begin
50547>>>            Get psOutputDirectory                                                   to sDir
50548>>>            Move (sDir + "/" + sFile)                                               to sPath
50549>>>        End
50549>>>>
50549>>>        
50549>>>        If (tQuery.iDestination = C_wqModalWin) Begin
50551>>>            Send PopupOutput of oWqOutputModal Self sPath sTitle
50552>>>        End
50552>>>>
50552>>>        Else If (tQuery.iDestination = C_wqNewTab) Begin
50555>>>            Send NavigateToPage of oWebApp sPath btNewTab
50556>>>        End
50556>>>>
50556>>>        Else If (tQuery.iDestination = C_wqNewWin) Begin
50559>>>            Set NewWindowOption to C_nwMenuBar    True
50560>>>            Set NewWindowOption to C_nwScrollBars True
50561>>>            Set NewWindowOption to C_nwStatusBar  False
50562>>>            Set NewWindowOption to C_nwTitleBar   True
50563>>>            Set NewWindowOption to C_nwToolBar    True
50564>>>            Set NewWindowOption to C_nwResizable  True
50565>>>            Send NavigateNewWindow  of oWebApp sPath 600 400
50566>>>        End
50566>>>>
50566>>>        Else If (tQuery.iDestination = C_wqDownload) Begin
50569>>>            Send DoPopup of oWqDownload Self sUrl sDir
50570>>>        End
50570>>>>
50570>>>        
50570>>>    End_Procedure
50571>>>    
50571>>>    Procedure LoadAndRun String sQueryFile
50574>>>        Integer iChn
50574>>>        Boolean bOK
50574>>>        tValueTree tVT
50574>>>        tValueTree tVT
50574>>>        wqWebQuery tQuery
50574>>>        wqWebQuery tQuery
50574>>>        
50574>>>        Get Seq_New_Channel     to iChn
50575>>>        Direct_Input channel iChn sQueryFile
50577>>>        Move (not(SeqEof)) to bOK
50578>>>
50578>>>        If bOK Begin
50580>>>            Send ReadValueTree of oStructFunctions iChn (&tVT)
50581>>>            ValueTreeDeserializeParameter tVT to tQuery
50582>>>            Close_Input channel iChn
50584>>>            Send Seq_Release_Channel iChn
50585>>>            Set pQuery to tQuery
50586>>>//            Send PopulateUI
50586>>>        End
50586>>>>
50586>>>        Else Begin
50587>>>            Close_Input channel iChn
50589>>>            Send Seq_Release_Channel iChn
50590>>>            Procedure_Return (QueryFileError(Self, sQueryFile))
50591>>>        End
50591>>>>
50591>>>        
50591>>>        Send RunQuery
50592>>>    End_Procedure
50593>>>    
50593>>>    //==========================================================================
50593>>>    //
50593>>>    // Assemble query process:
50593>>>    //
50593>>>    // Assemble Query involves a multi-step process because we have three sets
50593>>>    // of grid data to get back: Fields, Selections and Ordering, which we will
50593>>>    // do by serializing the index segment and print fields into web property
50593>>>    // strings before going onto the next step.
50593>>>    
50593>>>    Function SerializeSegments tWebRow[] ByRef aData Returns String
50596>>>        wqIndexSeg[] aSegs
50596>>>        wqIndexSeg[] aSegs
50597>>>        Integer i
50597>>>        String  sData
50597>>>        
50597>>>        For i from 0 to (SizeOfArray(aData) - 1)
50603>>>>
50603>>>            Move aData[i].aValues[1] to aSegs[i].bBreak
50604>>>            Move aData[i].aValues[2] to aSegs[i].sName
50605>>>            Move aData[i].aValues[3] to aSegs[i].iTable
50606>>>            Move aData[i].aValues[4] to aSegs[i].iField
50607>>>            Move aData[i].aValues[5] to aSegs[i].bUC
50608>>>            Move aData[i].aValues[6] to aSegs[i].bDesc
50609>>>        Loop
50610>>>>
50610>>>        
50610>>>        Get VariantToString of oStructFunctions aSegs to sData
50611>>>        
50611>>>        Function_Return sData
50612>>>    End_Function
50613>>>    
50613>>>    Function DeserializeSegments String sData Returns wqIndexSeg[]
50616>>>        wqIndexSeg[] aSegs
50616>>>        wqIndexSeg[] aSegs
50617>>>        tValueTree tVT
50617>>>        tValueTree tVT
50617>>>
50617>>>        Get StringToValueTree of oStructFunctions sData to tVT
50618>>>        ValueTreeDeserializeParameter tVT to aSegs
50619>>>        Function_Return aSegs
50620>>>    End_Function
50621>>>    
50621>>>    Function SerializeFields tWebRow[] ByRef aData Returns String
50624>>>        wqPrintField[] aFields
50624>>>        wqPrintField[] aFields
50625>>>        Integer i
50625>>>        String  sData
50625>>>        tValueTree tVT
50625>>>        tValueTree tVT
50625>>>
50625>>>        For i from 0 to (SizeOfArray(aData) - 1)
50631>>>>
50631>>>            Get DeSerializeField of ghoWQF aData[i].aValues[4] to aFields[i]
50632>>>            Move aData[i].aValues[1]  to aFields[i].sUserName
50633>>>            Move aData[i].aValues[2]  to aFields[i].bSum
50634>>>            Move aData[i].aValues[3]  to aFields[i].bCR
50635>>>        Loop
50636>>>>
50636>>>        
50636>>>        Get VariantToString of oStructFunctions aFields to sData
50637>>>        
50637>>>        Function_Return sData
50638>>>    End_Function
50639>>>    
50639>>>    Procedure AssembleQuery Integer eOp
50642>>>        Send ProcessDataSet of oSegments eOp
50643>>>    End_Procedure
50644>>>    
50644>>>    Procedure AssembleQuery2 tWebRow[] aData Integer eOp Integer iSelRowIndex
50647>>>        Integer i
50647>>>        String  sData
50647>>>        
50647>>>        Get SerializeSegments (&aData) to sData
50648>>>        WebSet wpsSegmentData to sData
50649>>>        Send ProcessDataSet of oPrintedFields eOp
50650>>>    End_Procedure
50651>>>    
50651>>>    Procedure AssembleQuery3 tWebRow[] ByRef aData Integer eOp Integer iSelRowIndex
50654>>>        String  sData
50654>>>        
50654>>>        Get SerializeFields (&aData) to sData
50655>>>        WebSet wpsFieldsData to sData
50656>>>        Send ProcessDataSet of oSelections eOp
50657>>>    End_Procedure
50658>>>    
50658>>>    Procedure AssembleQuery4 tWebRow[] ByRef aData Integer eOp Integer iSelRowIndex
50661>>>        wqWebQuery tQuery
50661>>>        wqWebQuery tQuery
50661>>>        Integer i iView
50661>>>        String  sData
50661>>>        
50661>>>        // Get the selection data first:
50661>>>        For i from 0 to (SizeOfArray(aData) - 1)
50667>>>>
50667>>>            Move aData[i].aValues[1]            to tQuery.aSelections[i].sUserName
50668>>>            Move aData[i].aValues[2]            to tQuery.aSelections[i].sType
50669>>>            Move aData[i].aValues[3]            to tQuery.aSelections[i].sValue
50670>>>            Move aData[i].aValues[4]            to tQuery.aSelections[i].iTable
50671>>>            Move aData[i].aValues[5]            to tQuery.aSelections[i].iColumn
50672>>>            Move aData[i].aValues[6]            to tQuery.aSelections[i].iType
50673>>>        Loop
50674>>>>
50674>>>        
50674>>>        WebGet wpsFieldsData                    to sData
50675>>>        Get DeserializeFields of ghoWQF sData   to tQuery.aPrintFields
50676>>>        WebGet wpsSegmentData                   to sData
50677>>>        Get DeserializeSegments sData           to tQuery.aSegments
50678>>>        WebGet wphMainTable                     to tQuery.hMainTable
50679>>>        WebGet psValue of oQueryTitle           to tQuery.sTitle
50680>>>        WebGet wpsSelectExpression              to tQuery.sSelectExpression
50681>>>        WebGet psValue of oOrder                to tQuery.iIndex
50682>>>//        WebGet psValue of oSearchOrd            to tQuery.iSearchOrd
50682>>>        WebGet psValue of oTextBefore           to tQuery.sTextBefore
50683>>>        WebGet psValue of oTextAfter            to tQuery.sTextAfter
50684>>>        WebGet psValue of oFontCombo            to tQuery.sTypeface
50685>>>        WebGet psValue of oFontSizeCombo        to tQuery.sFontSize
50686>>>        WebGet psValue of oAltRowHighlight      to tQuery.bHighlightAlt
50687>>>        WebGet psValue of oHighlightColour      to tQuery.sHighlightColour
50688>>>        WebGet psValue of oIncSelections        to tQuery.bPrintSels
50689>>>        WebGet psValue of oTotalsOnly           to tQuery.bTotalsOnly
50690>>>        WebGet psValue of oPrintCount           to tQuery.bPrintCount
50691>>>        WebGet psValue of oTextColour           to tQuery.sTextColour
50692>>>        WebGet psValue of oBGColour             to tQuery.sBGColour
50693>>>        
50693>>>        WebGet psValue of oViewOutput           to iView
50694>>>        
50694>>>        If (iView = C_wqDownloadOutput) Begin
50696>>>            Move   C_wqDownload                 to tQuery.iDestination
50697>>>            WebGet psValue of oOutHTML          to tQuery.iOutputFormat
50698>>>        End
50698>>>>
50698>>>        Else WebGet psValue of oOutModal        to tQuery.iDestination
50700>>>        
50700>>>        WebGet psValue of oColHeads             to tQuery.bColHeads
50701>>>        WebGet psValue of oPrintGenLine         to tQuery.bGeneratedLine
50702>>>        WebGet psValue of oUseSQL               to tQuery.bUseSQL
50703>>>        
50703>>>        Set pQuery to tQuery
50704>>>        
50704>>>        If (eOp = C_wqAssembleSave) Send DoSaveQuery
50707>>>        If (eOp = C_wqAssembleRun)  Send RunQuery
50710>>>    End_Procedure
50711>>>    
50711>>>    Function SerializeQuery Returns String
50714>>>        wqWebQuery tQuery
50714>>>        wqWebQuery tQuery
50714>>>        String  sQuery
50714>>>        
50714>>>        Get pQuery to tQuery
50715>>>        Get VariantToString of oStructFunctions tQuery to sQuery
50716>>>        
50716>>>        Function_Return sQuery
50717>>>    End_Procedure
50718>>>    
50718>>>    Procedure DeserializeQuery String sQuery
50721>>>        wqWebQuery tQuery
50721>>>        wqWebQuery tQuery
50721>>>        tValueTree tVT
50721>>>        tValueTree tVT
50721>>>        Boolean bOK
50721>>>        
50721>>>        Get StringToValueTree of oStructFunctions sQuery to tVT
50722>>>        ValueTreeDeserializeParameter tVT to tQuery
50723>>>        Set pQuery to tQuery
50724>>>    End_Procedure
50725>>>
50725>>>    Procedure RemoveReport String sFile
50728>>>        Boolean bExists
50728>>>        String  sPath sDir
50728>>>        
50728>>>        Move (psAppHtmlPath(phoWorkspace(oApplication)))    to sPath
50729>>>        Get  psOutputDirectory                              to sDir
50730>>>        Move (sPath + "\" + sDir + "\" + sFile)             to sPath
50731>>>
50731>>>        File_Exist sPath bExists
50732>>>        If bExists EraseFile sPath        
50735>>>    End_Procedure
50736>>>    
50736>>>    WebPublishProcedure RemoveReport
50737>>>    
50737>>>    Procedure DoneDownload Handle hoObj
50740>>>        String  sFile
50740>>>        Boolean bExists
50740>>>        
50740>>>        WebGet wpsFile of hoObj to sFile
50741>>>        File_Exist sFile bExists
50742>>>        If bExists EraseFile sFile
50745>>>    End_Procedure
50746>>>    
50746>>>    //==========================================================================
50746>>>    
50746>>>    // Here we handle the return call from all modal dialogs, dispatching
50746>>>    // them to the correct method depending on the returned object handle.
50746>>>    Procedure OnCloseModalDialog Handle hoMD
50749>>>        If (hoMD = oWqSelectionOperators) Send SelOpSelected  hoMD
50752>>>        If (hoMD = oWqTableSelection)     Send TableSelected  hoMD
50755>>>        If (hoMD = oWqAddInsEdit)         Send ExprAction     hoMD
50758>>>        If (hoMD = oWqCalcColumn)         Send CalcColReturn  hoMD
50761>>>        If (hoMD = oWqSelectionValues)    WebSet psValue of oSelValue to (ValueSelected(hoMD))
50764>>>        If (hoMD = oWqSelectionRanges)    WebSet psValue of oSelValue to (RangeSelected(hoMD))
50767>>>        If (hoMD = oWqSelectionList)      WebSet psValue of oSelValue to (ListSelected(hoMD))
50770>>>        If (hoMD = oWqExpressionPopup)    Send ExprReturned   hoMD
50773>>>        If (hoMD = oWqAdHocIndex)         Send AdHocDefined   hoMD
50776>>>        If (hoMD = oWqOpenQuery)          Send FileReturned   hoMD
50779>>>        If (hoMD = oWqColourPicker)       Send ColourSelected hoMD
50782>>>        If (hoMD = oWqDownload)           Send DoneDownload   hoMD
50785>>>    End_Procedure
50786>>>    
50786>>>    //==========================================================================
50786>>>    //  End of methods
50786>>>    //==========================================================================
50786>>>    
50786>>>    //==========================================================================
50786>>>    //
50786>>>    //  User interfasce objects (try to keep logic code out of these where 
50786>>>    //  possible)
50786>>>    //
50786>>>    //==========================================================================
50786>>>
50786>>>    Object oWebMainPanel is a cWebPanel
50788>>>        Set piColumnCount to 20
50789>>>        Set pbFillHeight to True
50790>>>        
50790>>>        Object oMainFile is a cWebCombo
50792>>>            Set piColumnSpan            to 15
50793>>>            Set psLabel                 to "Main Table:"
50794>>>            Set peLabelAlign            to alignRight
50795>>>            Set pbServerOnChange        to True
50796>>>            
50796>>>            Procedure OnChange String sNewValue String sOldValue
50799>>>                If (sNewValue <> sOldValue) Send MainTableSelected sNewValue
50802>>>            End_Procedure
50803>>>            
50803>>>            Procedure OnFill
50806>>>                wqTableInfo[] tTabs
50806>>>                wqTableInfo[] tTabs
50807>>>                Integer i
50807>>>                
50807>>>                Send AddComboItem 0 ""
50808>>>                Get TableInfo of ghoWQF to tTabs
50809>>>                
50809>>>                For i from 0 to (SizeOfArray(tTabs) - 1)
50815>>>>
50815>>>                    Send AddComboItem tTabs[i].iNum tTabs[i].sDispName
50816>>>                Loop
50817>>>>
50817>>>                
50817>>>            End_Procedure
50818>>>            
50818>>>        End_Object
50819>>>        
50819>>>        Object oTabSel is a cWebButton
50821>>>            Set piColumnSpan  to 1
50822>>>            Set piColumnIndex to 16
50823>>>            Set piHeight      to 30
50824>>>            Set piWidth       to 24
50825>>>            Set psCaption     to " "
50826>>>            Set psTooltip     to "Table selector"
50827>>>            Set psTextColor   to (psBackgroundColor(Self))
50828>>>            Set psHtmlId      to "wqTabSelButton"
50829>>>        
50829>>>            Procedure OnClick
50832>>>                Send TabListPopup of oWqTableSelection ghoWebQry
50833>>>            End_Procedure
50834>>>            
50834>>>        End_Object
50835>>>
50835>>>        Object oOpenQry is a cWebButton
50837>>>            Set piColumnSpan  to 1
50838>>>            Set piColumnIndex to 17
50839>>>            Set piHeight      to 30
50840>>>            Set piWidth       to 24
50841>>>            Set psCaption     to " "
50842>>>            Set psTooltip     to "Open query definition"
50843>>>            Set psHtmlId      to "wqOpenQueryButton"
50844>>>        
50844>>>            Procedure OnClick
50847>>>                Send OpenQuery
50848>>>            End_Procedure
50849>>>            
50849>>>        End_Object
50850>>>
50850>>>        Object oSaveQry is a cWebButton
50852>>>            Set piColumnSpan  to 1
50853>>>            Set piColumnIndex to 18
50854>>>            Set piHeight      to 30
50855>>>            Set piWidth       to 24
50856>>>            Set psCaption     to " "
50857>>>            Set psTooltip     to "Save query definition"
50858>>>            Set psHtmlId      to "wqSaveQueryButton"
50859>>>            
50859>>>            Procedure OnClick
50862>>>                Send SaveQuery
50863>>>            End_Procedure
50864>>>            
50864>>>        End_Object
50865>>>
50865>>>        Object oNewQry is a cWebButton
50867>>>            Set piColumnSpan  to 1
50868>>>            Set piColumnIndex to 19
50869>>>            Set piHeight      to 30
50870>>>            Set piWidth       to 24
50871>>>            Set psCaption     to " "
50872>>>            Set psTooltip     to "Clear query"
50873>>>            Set psHtmlId      to "wqClearQueryButton"
50874>>>            
50874>>>            Procedure OnClick
50877>>>                Send ClearQuery
50878>>>            End_Procedure  // OnClick
50879>>>            
50879>>>        End_Object
50880>>>
50880>>>        Object oQueryTitle is a cWebForm
50882>>>            Set psCSSClass to "KeyField"
50883>>>            Set piColumnSpan to 15
50884>>>            Set psLabel to "Query Title:"
50885>>>            Set peLabelAlign to alignRight
50886>>>        End_Object
50887>>>
50887>>>        Object oQueryCriteria is a cWebTabContainer
50889>>>            Set pbFillHeight to True
50890>>>            
50890>>>            Object oTablesPage is a cWebTabPage
50892>>>                Set psCaption to "Fields"
50893>>>                Set piColumnCount to 10
50894>>>                
50894>>>                Object oFieldsPanel is a cWebPanel
50896>>>                    Set piHeight to 250
50897>>>                    
50897>>>                    Object oFieldSelect is a cWebPanel
50899>>>                        Set peRegion to prLeft
50900>>>                        Set piWidth  to 300
50901>>>
50901>>>                        Object oTablesList is a cWebList
50903>>>                            Set pbDataAware         to False
50904>>>                            Set piColumnIndex       to 0
50905>>>                            Set piColumnSpan        to 0
50906>>>                            Set pbFillHeight        to True
50907>>>                            Set pbColumnSortable    to False
50908>>>                            
50908>>>                            Object oFieldTables is a cWebColumn
50910>>>                                Set psCaption to "Tables"
50911>>>                            End_Object
50912>>>                            
50912>>>                            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
50915>>>                                Send CollectRelated of ghoWebQry (&aTheRows)  
50916>>>                            End_Procedure  // OnManualLoadData
50917>>>                            
50917>>>                            Procedure OnChangeCurrentRow String sFromRowID String sToRowID
50920>>>                                Send FieldsTableSelected sToRowID
50921>>>                            End_Procedure  // OnChangeCurrentRow
50922>>>                            
50922>>>                        End_Object
50923>>>        
50923>>>                        Object oColumnsList is a cWebList
50925>>>                            Property Handle  phTable 0
50927>>>                            
50927>>>                            Set pbDataAware         to False
50928>>>                            Set piColumnIndex       to 0
50929>>>                            Set piColumnSpan        to 0
50930>>>                            Set pbFillHeight        to True
50931>>>                            Set pbColumnSortable    to False
50932>>>                            
50932>>>                            Object oFieldsCol is a cWebColumn
50934>>>                                Set psCaption to "Fields"
50935>>>                            End_Object
50936>>>                            
50936>>>                            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
50939>>>                                Forward Send OnManualLoadData (&aTheRows) (&sCurrentRowID)
50941>>>                                Send CollectColumns of ghoWQF (&aTheRows) (phSelectedTable(ghoWebQry))
50942>>>                            End_Procedure
50943>>>                            
50943>>>                        End_Object
50944>>>
50944>>>                    End_Object
50945>>>                    
50945>>>                    Object oPrintFields is a cWebPanel
50947>>>                        Set peRegion to prCenter
50948>>>                        Set piColumnCount to 30
50949>>>                        
50949>>>                        Object oPrintedFields is a cWebGrid
50951>>>                            Set psLabel             to "Printed Fields:"
50952>>>                            Set peLabelPosition     to lpTop
50953>>>                            Set pbShowLabel         to True
50954>>>                            Set piColumnIndex       to 0
50955>>>                            Set piColumnSpan        to 0
50956>>>                            Set pbFillHeight        to True
50957>>>                            Set pbDataAware         to False
50958>>>                            Set pbOfflineEditing    to True
50959>>>                            Set pbAllowAppendRow    to False
50960>>>                            Set pbAllowInsertRow    to False
50961>>>                            Set pbAllowDeleteRow    to False
50962>>>                            
50962>>>                            Object oFieldCol is a cWebColumn
50964>>>                                Set psCaption           to "Field name"
50965>>>                                Set piWidth             to 120
50966>>>                                Set pbServerOnChange    to True
50967>>>                                
50967>>>                                Procedure OnChange String sNewValue String sOldValue
50970>>>                                    String  sField
50970>>>                                    wqPrintField tField
50970>>>                                    wqPrintField tField
50970>>>                                    
50970>>>                                    WebGet psValue of oFieldData to sField
50971>>>                                    
50971>>>                                    If (sField <> "") Begin
50973>>>                                        Get DeSerializeField of ghoWQF sField to tField
50974>>>                                        Move sNewValue to tField.sUserName
50975>>>                                        Get SerializeField of ghoWQF tField to sField
50976>>>                                        WebSet psValue of oFieldData to sField
50977>>>                                    End
50977>>>>
50977>>>                                    
50977>>>                                End_Procedure
50978>>>                                
50978>>>                            End_Object                                
50979>>>                            
50979>>>                            Object oSumCol is a cWebColumnCheckbox
50981>>>                                Set psCaption           to "Sum"
50982>>>                                Set piWidth             to 12
50983>>>                                Set pbServerOnChange    to True
50984>>>                                
50984>>>                                Procedure OnChange String sNewValue String sOldValue
50987>>>                                    String  sField
50987>>>                                    wqPrintField tField
50987>>>                                    wqPrintField tField
50987>>>                                    
50987>>>                                    WebGet psValue of oFieldData to sField
50988>>>                                    Get DeSerializeField of ghoWQF sField to tField
50989>>>                                    If (tField.iType <> DF_BCD) WebSet psValue to False
50992>>>                                End_Procedure
50993>>>                                
50993>>>                            End_Object                                
50994>>>                            
50994>>>                            Object oCRCol is a cWebColumnCheckbox
50996>>>                                Set psCaption           to "CR"
50997>>>                                Set piWidth             to 12
50998>>>                            End_Object
50999>>>                            
50999>>>                            // Hidden columns:
50999>>>                            Object oFieldData is a cWebColumn
51001>>>                                Set pbRender to False
51002>>>                            End_Object
51003>>>                            
51003>>>                            Procedure OnProcessDataSet tWebRow[] aData Integer eOp Integer iSelectedRowIndex
51006>>>                                If ((eOp = C_wqAssembleSave) or (eOp = C_wqAssembleRun)) ;                                     Send AssembleQuery3 (&aData) eOp iSelectedRowIndex
51009>>>                                Else Send FieldListReturned of ghoWebQry (&aData) eOp iSelectedRowIndex
51011>>>                            End_Procedure
51012>>>                            
51012>>>                            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
51015>>>                                Send LoadPrintFields of ghoWebQry (&aTheRows) (&sCurrentRowID)
51016>>>                            End_Procedure
51017>>>                            
51017>>>                        End_Object
51018>>>                        
51018>>>                        Object oAddField is a cWebButton
51020>>>                            Set piColumnIndex to 3
51021>>>                            Set piColumnSpan to 4
51022>>>                            Set psCaption to "Add"
51023>>>                        
51023>>>                            Procedure OnClick
51026>>>                                Send AddPrintField True
51027>>>                            End_Procedure
51028>>>                            
51028>>>                        End_Object
51029>>>                        
51029>>>                        Object oInsertField is a cWebButton
51031>>>                            Set piColumnIndex to 7
51032>>>                            Set piColumnSpan to 5
51033>>>                            Set psCaption to "Insert"
51034>>>                        
51034>>>                            Procedure OnClick
51037>>>                                Send AddPrintField False
51038>>>                            End_Procedure
51039>>>                            
51039>>>                        End_Object
51040>>>                        
51040>>>                        Object oDeleteField is a cWebButton
51042>>>                            Set piColumnIndex to 12
51043>>>                            Set piColumnSpan to 5
51044>>>                            Set psCaption to "Delete"
51045>>>                        
51045>>>                            Procedure OnClick
51048>>>                                Send DeletePrintField
51049>>>                            End_Procedure
51050>>>                            
51050>>>                        End_Object
51051>>>                        
51051>>>                        Object oExprnField is a cWebButton
51053>>>                            Set piColumnIndex to 17
51054>>>                            Set piColumnSpan to 6
51055>>>                            Set psCaption to "Expression"
51056>>>                        
51056>>>                            Procedure OnClick
51059>>>                                Send CalcField
51060>>>                            End_Procedure
51061>>>                            
51061>>>                        End_Object
51062>>>                        
51062>>>//                        Object oAdjustField is a cWebButton
51062>>>//                            Set piColumnIndex to 23
51062>>>//                            Set piColumnSpan to 7
51062>>>//                            Set psCaption to "Adjust Below"
51062>>>//                        
51062>>>//                            Procedure OnClick
51062>>>//                            End_Procedure
51062>>>//                            
51062>>>//                        End_Object
51062>>>                        
51062>>>                    End_Object
51063>>>
51063>>>                End_Object
51064>>>                
51064>>>            End_Object
51065>>>            
51065>>>            Object oSelectionPage is a cWebTabPage
51067>>>                Set psCaption to "Selection"
51068>>>                
51068>>>                Object oSelectPanel is a cWebPanel
51070>>>                    Set piHeight to 250
51071>>>                    
51071>>>                    Object oSelectionPanel is a cWebPanel
51073>>>                        Set peRegion to prLeft
51074>>>                        Set piWidth  to 300
51075>>>
51075>>>                        Object oSelTablesList is a cWebList
51077>>>                            Set pbDataAware         to False
51078>>>                            Set piColumnIndex       to 0
51079>>>                            Set piColumnSpan        to 0
51080>>>                            Set pbFillHeight        to True
51081>>>                            Set pbColumnSortable    to False
51082>>>                            
51082>>>                            Object oSelTables is a cWebColumn
51084>>>                                Set psCaption to "Tables"
51085>>>                            End_Object
51086>>>                            
51086>>>                            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
51089>>>                                Send CollectRelated of ghoWebQry (&aTheRows)  
51090>>>                            End_Procedure
51091>>>                            
51091>>>                            Procedure OnChangeCurrentRow String sFromRowID String sToRowID
51094>>>                                Send SelTableSelected of ghoWebQry sToRowID
51095>>>                            End_Procedure
51096>>>                            
51096>>>                        End_Object
51097>>>        
51097>>>                        Object oSelColumnsList is a cWebList
51099>>>                            Property Handle  phTable 0
51101>>>                            
51101>>>                            Set pbDataAware         to False
51102>>>                            Set piColumnIndex       to 0
51103>>>                            Set piColumnSpan        to 0
51104>>>                            Set pbFillHeight        to True
51105>>>                            Set pbColumnSortable    to False
51106>>>                            
51106>>>                            Object oSelColumns is a cWebColumn
51108>>>                                Set psCaption to "Fields"
51109>>>                            End_Object
51110>>>                            
51110>>>                            Procedure TableSelected Handle hTab
51113>>>                                Set phTable to hTab
51114>>>                                Send GridRefresh
51115>>>                                WebSet psCurrentRowID to 0
51116>>>                            End_Procedure
51117>>>                            
51117>>>                            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
51120>>>                                Forward Send OnManualLoadData (&aTheRows) (&sCurrentRowID)
51122>>>                                Send CollectColumns of ghoWQF (&aTheRows) (phSelectedTable(ghoWebQry))
51123>>>                            End_Procedure
51124>>>                            
51124>>>                       End_Object
51125>>>
51125>>>                    End_Object
51126>>>                    
51126>>>                    Object oSelectPanel is a cWebPanel
51128>>>                        Set peRegion to prCenter
51129>>>                        Set piColumnCount to 30
51130>>>                        
51130>>>                        Object oSelections is a cWebGrid
51132>>>                            Set piColumnIndex       to 0
51133>>>                            Set piColumnSpan        to 0
51134>>>                            Set pbFillHeight        to True
51135>>>                            Set pbDataAware         to False                            
51136>>>                            Set psLabel             to "Selections:"
51137>>>                            Set peLabelPosition     to lpTop
51138>>>                            Set pbShowLabel         to True
51139>>>                            Set pbOfflineEditing    to True
51140>>>                            Set pbAllowAppendRow    to False
51141>>>                            Set pbAllowInsertRow    to False
51142>>>                            Set pbAllowDeleteRow    to False
51143>>>                            
51143>>>                            Object oSelField is a cWebColumn
51145>>>                                Set psCaption to "Field name"
51146>>>                                Set piWidth   to 60
51147>>>                                Set pbEnabled to False
51148>>>                            End_Object                                
51149>>>                            
51149>>>                            Object oSelType is a cWebColumn
51151>>>                                Set psCaption to "Type"
51152>>>                                Set piWidth   to 15
51153>>>                                Set pbEnabled to False
51154>>>                            End_Object                                
51155>>>                            
51155>>>                            Object oSelValue is a cWebColumn
51157>>>                                Set psCaption to "Value"
51158>>>                                Set piWidth   to 60
51159>>>                                Set pbEnabled to False
51160>>>                            End_Object
51161>>>                            
51161>>>                            Object oSelTabCol is a cWebColumn
51163>>>                                Set pbRender to False
51164>>>                            End_Object
51165>>>                            
51165>>>                            Object oSelColCol is a cWebColumn
51167>>>                                Set pbRender to False
51168>>>                            End_Object
51169>>>                            
51169>>>                            Object oSelDataType is a cWebColumn
51171>>>                                Set pbRender to False
51172>>>                            End_Object
51173>>>                            
51173>>>                            Procedure OnProcessDataSet tWebRow[] aData Integer eOp Integer iSelectedRowIndex
51176>>>                                If ((eOp = C_wqAssembleRun) or (eOp = C_wqAssembleSave)) ;                                     Send AssembleQuery4   of ghoWebQry (&aData) eOp iSelectedRowIndex
51179>>>                                Else Send SelsListReturned of ghoWebQry (&aData) eOp iSelectedRowIndex
51181>>>                            End_Procedure
51182>>>                            
51182>>>                            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
51185>>>                                Send LoadSelections (&aTheRows) (sCurrentRowID)
51186>>>                            End_Procedure
51187>>>                            
51187>>>                        End_Object
51188>>>                        
51188>>>                        Object oSelAddBtn is a cWebButton
51190>>>                            Set piColumnIndex to 2
51191>>>                            Set piColumnSpan to 4
51192>>>                            Set psCaption to "Add"
51193>>>                        
51193>>>                            Procedure OnClick
51196>>>                                Send AddSelField True
51197>>>                            End_Procedure
51198>>>                            
51198>>>                        End_Object
51199>>>                        
51199>>>                        Object oSelInsertBtn is a cWebButton
51201>>>                            Set piColumnIndex to 6
51202>>>                            Set piColumnSpan to 5
51203>>>                            Set psCaption to "Insert"
51204>>>                        
51204>>>                            Procedure OnClick
51207>>>                                Send AddSelField False
51208>>>                            End_Procedure
51209>>>                            
51209>>>                        End_Object
51210>>>                        
51210>>>                        Object oSelDeleteBtn is a cWebButton
51212>>>                            Set piColumnIndex to 11
51213>>>                            Set piColumnSpan to 5
51214>>>                            Set psCaption to "Delete"
51215>>>                        
51215>>>                            Procedure OnClick
51218>>>                                Send ProcessDataSet of oSelections C_wqDeleteRow
51219>>>                            End_Procedure
51220>>>                            
51220>>>                        End_Object
51221>>>                        
51221>>>                        Object oSelExpressionBtn is a cWebButton
51223>>>                            Set piColumnIndex to 16
51224>>>                            Set piColumnSpan to 6
51225>>>                            Set psCaption to "Expression"
51226>>>                        
51226>>>                            Procedure OnClick
51229>>>                                Send EnterSelExpr
51230>>>                            End_Procedure
51231>>>                            
51231>>>                        End_Object
51232>>>                        
51232>>>                        Object oSelValueBtn is a cWebButton
51234>>>                            Set piColumnIndex to 22
51235>>>                            Set piColumnSpan to 8
51236>>>                            Set psCaption to "Default value"
51237>>>                        
51237>>>                            Procedure OnClick
51240>>>                                Send SelectValue of ghoWebQry
51241>>>                            End_Procedure
51242>>>                            
51242>>>                        End_Object
51243>>>                        
51243>>>                    End_Object
51244>>>                
51244>>>                End_Object
51245>>>                
51245>>>            End_Object
51246>>>            
51246>>>            Object oOrderingPage is a cWebTabPage
51248>>>                Set psCaption to "Ordering"
51249>>>                Set piColumnCount to 9
51250>>>                Set pbServerOnShow to True
51251>>>                
51251>>>                // Work-around for the psValue in oOrdering not getting set properly
51251>>>                //    see: http://support.dataaccess.com/Forums/showthread.php?51906-Setting-selected-value-in-a-cWebCombo                   
51251>>>                Procedure OnShow
51254>>>                    Integer  iIndex
51254>>>                    
51254>>>                    WebGet wpiIndex of ghoWebQry to iIndex
51255>>>                    WebSet psValue  of oOrder    to iIndex
51256>>>                End_Procedure
51257>>>                
51257>>>                Object oOrder is a cWebCombo
51259>>>                    Set piColumnIndex       to 0
51260>>>                    Set piColumnSpan        to 8
51261>>>                    Set psLabel             to "Ordering:"
51262>>>                    Set peLabelAlign        to alignRight
51263>>>                    Set piLabelOffset       to 100
51264>>>                    Set pbServerOnChange    to True
51265>>>                    Set pbServerOnShow      to True
51266>>>                
51266>>>                    Procedure OnChange String sNewValue String sOldValue
51269>>>                        If (sNewValue <> sOldValue) Send IndexSelected of ghoWebQry sNewValue
51272>>>                    End_Procedure  // OnChange
51273>>>                    
51273>>>                    Procedure OnFill
51276>>>                        Integer i j iInds iSegs iFld iFirst
51276>>>                        String  sDesc
51276>>>                        Handle  hTab
51276>>>                        Boolean bRNTab
51276>>>                        
51276>>>                        WebGet wphMainTable of ghoWebQry to hTab
51277>>>                        If not hTab Procedure_Return
51280>>>                        
51280>>>                        Open hTab
51282>>>                        Move 0 to iFirst
51283>>>                        
51283>>>                        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTab to iInds
51286>>>                        Get_Attribute DF_FILE_RECNUM_TABLE      of hTab to bRNTab
51289>>>                        
51289>>>                        For i from 1 to iInds
51295>>>>
51295>>>                            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTab i to iSegs
51298>>>                            
51298>>>                            Move "" to sDesc
51299>>>                        
51299>>>                            For j from 1 to iSegs
51305>>>>
51305>>>                                Get_Attribute DF_INDEX_SEGMENT_FIELD of hTab i j    to iFld
51308>>>                                If (j > 1) Move (sDesc + ", ")                      to sDesc
51311>>>                                Move (sDesc + NiceFieldName(ghoWQF, hTab, iFld))    to sDesc
51312>>>                            Loop
51313>>>>
51313>>>                            
51313>>>                            If (Length(sDesc)) Begin
51315>>>                                Send AddComboItem i sDesc
51316>>>                                If not iFirst Move i to iFirst
51319>>>                            End
51319>>>>
51319>>>                            
51319>>>                        Loop
51320>>>>
51320>>>                        
51320>>>                        If bRNTab Send AddComboItem i "Recnum"
51323>>>                        Send AddComboItem -1 "Ad hoc index"
51324>>>                        WebSet psValue               to iFirst
51325>>>                        WebSet wpiIndex of ghoWebQry to iFirst
51326>>>//                        WebSet psValue of oSearchOrd to iFirst
51326>>>                    End_Procedure
51327>>>                    
51327>>>                End_Object
51328>>>
51328>>>                Object oAdHocButton is a cWebButton
51330>>>                    Set piColumnSpan  to 0
51331>>>                    Set piColumnIndex to 8
51332>>>                    Set piColumnSpan  to 1
51333>>>                    Set psCaption     to "Ad hoc"
51334>>>                    Set pbEnabled     to False
51335>>>                
51335>>>                    Procedure OnClick
51338>>>                        Send SpecAdHoc
51339>>>                    End_Procedure
51340>>>                    
51340>>>                End_Object
51341>>>                
51341>>>                Object oSegments is a cWebGrid
51343>>>                    Set piColumnIndex       to 2
51344>>>                    Set piColumnSpan        to 5
51345>>>                    Set pbFillHeight        to True
51346>>>                    Set pbDataAware         to False
51347>>>                    Set pbOfflineEditing    to True
51348>>>                    Set pbAllowAppendRow    to False
51349>>>                    Set pbAllowInsertRow    to False
51350>>>                    Set pbAllowDeleteRow    to False
51351>>>                    
51351>>>                    Object oIdxBreakCol is a cWebColumnCheckbox
51353>>>                        Set psCaption to "Break"
51354>>>                        Set piWidth to 15
51355>>>                    End_Object
51356>>>                    
51356>>>                    Object oIdxDescCol is a cWebColumn
51358>>>                        Set psCaption to "Field name"
51359>>>                        Set piWidth to 100
51360>>>//                        Set pbEnabled to False
51360>>>                    End_Object
51361>>>                    
51361>>>                    Object oIdxTableCol is a cWebColumn
51363>>>                        Set pbRender to False
51364>>>                    End_Object
51365>>>                    
51365>>>                    Object oIdxFieldCol is a cWebColumn
51367>>>                        Set pbRender to False
51368>>>                    End_Object
51369>>>                    
51369>>>                    Object oIdxUCCol is a cWebColumn
51371>>>                        Set pbRender to False
51372>>>                    End_Object
51373>>>                    
51373>>>                    Object oIdxRevCol is a cWebColumn
51375>>>                        Set pbRender to False
51376>>>                    End_Object
51377>>>                    
51377>>>                    Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
51380>>>                        Send LoadSegments (&aTheRows) (&sCurrentRowID)
51381>>>                    End_Procedure
51382>>>                    
51382>>>                    Procedure OnProcessDataSet tWebRow[] aData Integer eOp Integer iSelRowIndex
51385>>>                        If ((eOp = C_wqAssembleSave) or (eOp = C_wqAssembleRun)) ;                             Send AssembleQuery2 of ghoWebQry (&aData) eOp iSelRowIndex
51388>>>                        Else If (eOp = C_wqGetIndexInfo) Send IndexDataReceived of ghoWebQry (&aData) eOp iSelRowIndex
51392>>>                    End_Procedure
51393>>>                    
51393>>>                End_Object
51394>>>
51394>>>//                Object oWebSpacer1 is a cWebSpacer
51394>>>//                    Set piHeight to 10
51394>>>//                End_Object
51394>>>//                
51394>>>//                Object oSearchOrd is a cWebCombo
51394>>>//                    Set piColumnSpan  to 8
51394>>>//                    Set psLabel       to "Search order:"
51394>>>//                    Set peLabelAlign  to alignRight
51394>>>//                    Set piLabelOffset to 100
51394>>>//                    Set pbEnabled     to False
51394>>>//                    
51394>>>//                    Procedure OnFill
51394>>>//                        Integer i j iInds iSegs iFld
51394>>>//                        String  sDesc
51394>>>//                        Handle  hTab
51394>>>//                        Boolean bRNTab
51394>>>//                        
51394>>>//                        WebGet wphMainTable of ghoWebQry to hTab
51394>>>//                        If not hTab Procedure_Return
51394>>>//                        
51394>>>//                        Open hTab
51394>>>//                        
51394>>>//                        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTab to iInds
51394>>>//                        Get_Attribute DF_FILE_RECNUM_TABLE      of hTab to bRNTab
51394>>>//                        If bRNTab Send AddComboItem 0 "Recnum"
51394>>>//                        
51394>>>//                        For i from 1 to iInds
51394>>>//                            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTab i to iSegs
51394>>>//                            Move "" to sDesc
51394>>>//                            
51394>>>//                            For j from 1 to iSegs
51394>>>//                                Get_Attribute DF_INDEX_SEGMENT_FIELD of hTab i j    to iFld
51394>>>//                                If (j > 1) Move (sDesc + ", ")                      to sDesc
51394>>>//                                Move (sDesc + NiceFieldName(ghoWQF, hTab, iFld))    to sDesc
51394>>>//                            Loop
51394>>>//                            
51394>>>//                            If (Length(sDesc)) Send AddComboItem i sDesc
51394>>>//                        Loop
51394>>>//                        
51394>>>//                    End_Procedure  // OnFill
51394>>>//                    
51394>>>//                End_Object  // oSearchOrd
51394>>>                
51394>>>            End_Object
51395>>>            
51395>>>            Object oTextsPage is a cWebTabPage
51397>>>                Set psCaption to "Texts"
51398>>>                Set piColumnCount to 10
51399>>>                
51399>>>                Object oLineBreakNote is a cWebLabel
51401>>>                    Set piColumnSpan to 0
51402>>>                    Set psCaption to "(Note: To insert line-breaks in the texts, use Shift-Enter)"
51403>>>                    Set psTextColor to "blue"
51404>>>                    Set peAlign to alignCenter
51405>>>                End_Object
51406>>>                
51406>>>                Object oTextBefore is a cWebEdit
51408>>>                    Set piColumnSpan to 0
51409>>>                    Set psLabel to "Before report:"
51410>>>                    Set peLabelAlign to alignRight
51411>>>                    Set piLabelOffset to 90
51412>>>                    Set pbFillHeight to True
51413>>>                    Set piHeight to 50
51414>>>                End_Object
51415>>>                
51415>>>                Object oTextAfter is a cWebEdit
51417>>>                    Set piColumnSpan to 0
51418>>>                    Set psLabel to "After report:"
51419>>>                    Set peLabelAlign to alignRight
51420>>>                    Set piLabelOffset to 90
51421>>>                    Set pbFillHeight to True
51422>>>                    Set piHeight to 50
51423>>>                End_Object
51424>>>                
51424>>>            End_Object
51425>>>            
51425>>>            Object oOutputPage is a cWebTabPage
51427>>>                Set psCaption to "Output"
51428>>>                Set piColumnCount to 20
51429>>>
51429>>>                Object oFontCombo is a cWebCombo
51431>>>                    Set piColumnIndex to 0
51432>>>                    Set piColumnSpan to 9
51433>>>                    Set psLabel to "Font: "
51434>>>                    Set piLabelOffset to 110
51435>>>                    Set peLabelAlign to alignRight
51436>>>                    
51436>>>                    Procedure OnFill
51439>>>                        Send AddComboItem "Arial, Helvetica, sans-serif"                         "Arial"
51440>>>                        Send AddComboItem "'Arial Black', Gadget, sans-serif"                    "Arial Black"
51441>>>                        Send AddComboItem "'Courier New', Courier, monospace"                    "Courier New"
51442>>>                        Send AddComboItem "Impact, Charcoal, sans-serif"                         "Impact"
51443>>>                        Send AddComboItem "'Lucinda Console', Monaco, monospace"                 "Lucinda Console"
51444>>>                        Send AddComboItem "'Lucinda Sans Unicode', 'Lucinda Grande', sans-serif" "Lucinda Sans"
51445>>>                        Send AddComboItem "'Palatino Linotype', 'Book Antiqua', Palation, serif" "Palatino Linotype"
51446>>>                        Send AddComboItem "Tahoma, Geneva, sans-serif"                           "Tahoma"
51447>>>                        Send AddComboItem "'Times New Roman', Times, serif"                      "Times New Roman"
51448>>>                        Send AddComboItem "'Trebuchet MS', Helvetica, sans-serif"                "Trebuchet"
51449>>>                        Send AddComboItem "Verdana, Geneva, sans-serif"                          "Verdana"
51450>>>                        
51450>>>                        WebSet psValue to "Ariel, Helvetica, sans-serif"
51451>>>                    End_Procedure
51452>>>                    
51452>>>                End_Object
51453>>>
51453>>>                Object oFontSizeCombo is a cWebCombo
51455>>>                    Set piColumnIndex to 10
51456>>>                    Set piColumnSpan to 3
51457>>>                    Set pbShowLabel to False
51458>>>                    
51458>>>                    Procedure OnFill
51461>>>                        Send AddComboItem "xx-small" "xx-small"
51462>>>                        Send AddComboItem "x-small"  "x-small"
51463>>>                        Send AddComboItem "small"    "small"
51464>>>                        Send AddComboItem "medium"   "medium"
51465>>>                        Send AddComboItem "large"    "large"
51466>>>                        Send AddComboItem "x-large"  "x-large"
51467>>>                        Send AddComboItem "xx-large" "xx-large"
51468>>>                        
51468>>>                        WebSet psValue to "medium"
51469>>>                    End_Procedure
51470>>>                    
51470>>>                End_Object
51471>>>                
51471>>>                Object oIncSelections is a cWebCheckbox
51473>>>                    Set piColumnSpan to 0
51474>>>                    Set piColumnIndex to 3
51475>>>                    Set psCaption to "Include selection criteria in printed report"
51476>>>                End_Object
51477>>>
51477>>>                Object oTotalsOnly is a cWebCheckbox
51479>>>                    Set piColumnSpan to 0
51480>>>                    Set piColumnIndex to 3
51481>>>                    Set psCaption to "Print totals only"
51482>>>                End_Object
51483>>>                
51483>>>                Object oPrintCount is a cWebCheckbox
51485>>>                    Set piColumnSpan  to 0
51486>>>                    Set piColumnIndex to 3
51487>>>                    Set psCaption     to "Print record count"
51488>>>                    Set psValue       to True
51489>>>                End_Object
51490>>>                
51490>>>                Object oPrintGenLine is a cWebCheckbox
51492>>>                    Set piColumnSpan  to 7
51493>>>                    Set piColumnIndex to 3
51494>>>                    Set psCaption     to "Print generated date/time"
51495>>>                    Set psValue       to True
51496>>>                End_Object
51497>>>
51497>>>                Object oUseSQL is a cWebCheckbox
51499>>>                    Set piColumnSpan  to 5
51500>>>                    Set piColumnIndex to 10
51501>>>                    Set psCaption     to "Use SQL"
51502>>>                    Set psValue       to (pbUseSqlDefault(ghoWebQry))
51503>>>                End_Object
51504>>>                
51504>>>                Object oTextColour is a cWebForm
51506>>>                    Set piColumnIndex    to 0
51507>>>                    Set piColumnSpan     to 6
51508>>>                    Set psLabel          to "Text colour:"
51509>>>                    Set peLabelAlign     to alignRight
51510>>>                    Set pbPromptButton   to True
51511>>>                    Set pbServerOnPrompt to True
51512>>>                    Set psValue          to "black"
51513>>>                    Set piLabelOffset    to 110
51514>>>                    Set pbServerOnChange to True
51515>>>                    
51515>>>                    Procedure OnPrompt
51518>>>                        String sVal
51518>>>                        
51518>>>                        WebGet psValue to sVal
51519>>>                        Send ColourPopup of oWqColourPicker ghoWebQry sVal Self
51520>>>                    End_Procedure
51521>>>                    
51521>>>                    Procedure OnChange String sNewValue String sOldValue
51524>>>                        WebSet psBackgroundColor of oTextCol to sNewValue
51525>>>                    End_Procedure
51526>>>                    
51526>>>                End_Object
51527>>>
51527>>>                Object oTextCol is a cWebButton
51529>>>                    Set psCaption to " "
51530>>>                    Set pbShowBorder to False
51531>>>                    Set piColumnIndex to 6
51532>>>                    Set piColumnSpan  to 1
51533>>>                    Set psBackgroundColor to "black"
51534>>>                    
51534>>>                    Procedure OnClick
51537>>>                        Send OnPrompt of oTextColour
51538>>>                    End_Procedure  // OnClick
51539>>>                    
51539>>>                End_Object
51540>>>
51540>>>                Object oBGColour is a cWebForm
51542>>>                    Set piColumnIndex    to 9
51543>>>                    Set piColumnSpan     to 6
51544>>>                    Set psLabel          to "Background colour:"
51545>>>                    Set peLabelAlign     to alignRight
51546>>>                    Set pbPromptButton   to True
51547>>>                    Set pbServerOnPrompt to True
51548>>>                    Set psValue          to "white"
51549>>>                    Set pbServerOnChange to True
51550>>>                    
51550>>>                    Procedure OnPrompt
51553>>>                        String sVal
51553>>>                        
51553>>>                        WebGet psValue to sVal
51554>>>                        Send ColourPopup of oWqColourPicker ghoWebQry sVal Self
51555>>>                    End_Procedure
51556>>>                    
51556>>>                    Procedure OnChange String sNewValue String sOldValue
51559>>>                        WebSet psBackgroundColor of oBGCol to sNewValue
51560>>>                    End_Procedure
51561>>>                    
51561>>>                End_Object
51562>>>
51562>>>                Object oBGCol is a cWebButton
51564>>>                    Set psCaption to " "
51565>>>                    Set pbShowBorder to True
51566>>>                    Set piColumnIndex to 15
51567>>>                    Set piColumnSpan  to 1
51568>>>                    Set psBackgroundColor to "white"
51569>>>                    
51569>>>                    Procedure OnClick
51572>>>                        Send OnPrompt of oBGColour
51573>>>                    End_Procedure
51574>>>                    
51574>>>                End_Object
51575>>>
51575>>>                Object oAltRowHighlight is a cWebCheckbox
51577>>>                    Set piColumnIndex    to 3
51578>>>                    Set piColumnSpan     to 6
51579>>>                    Set psCaption        to "Use alternate row highlighting"
51580>>>                    Set pbServerOnChange to True
51581>>>                    Set psValue          to True
51582>>>                    
51582>>>                    Procedure OnChange
51585>>>                        Boolean bOn
51585>>>                        
51585>>>                        WebGet psValue to bOn
51586>>>                        WebSet pbEnabled of oHighlightColour to bOn
51587>>>                    End_Procedure
51588>>>                    
51588>>>                End_Object
51589>>>
51589>>>                Object oHighlightColour is a cWebForm
51591>>>                    Set piColumnIndex    to 9
51592>>>                    Set piColumnSpan     to 6
51593>>>                    Set psLabel          to "Highlight colour:"
51594>>>                    Set peLabelAlign     to alignRight
51595>>>                    Set pbPromptButton   to True
51596>>>                    Set pbServerOnPrompt to True
51597>>>                    Set psValue          to "#AAFFFF"
51598>>>                    Set pbServerOnChange to True
51599>>>                    
51599>>>                    Procedure OnPrompt
51602>>>                        String sVal
51602>>>                        
51602>>>                        WebGet psValue to sVal
51603>>>                        Send ColourPopup of oWqColourPicker ghoWebQry sVal Self
51604>>>                    End_Procedure
51605>>>                    
51605>>>                    Procedure OnChange String sNewValue String sOldValue
51608>>>                        WebSet psBackgroundColor of oHLCol to sNewValue
51609>>>                    End_Procedure
51610>>>                    
51610>>>                End_Object
51611>>>
51611>>>                Object oHLCol is a cWebButton
51613>>>                    Set psCaption to " "
51614>>>                    Set pbShowBorder to True
51615>>>                    Set piColumnIndex to 15
51616>>>                    Set piColumnSpan  to 1
51617>>>                    Set psBackgroundColor to "#AAFFFF"
51618>>>                    
51618>>>                    Procedure OnClick
51621>>>                        Send OnPrompt of oHighlightColour
51622>>>                    End_Procedure
51623>>>                    
51623>>>                End_Object
51624>>>                
51624>>>                Object oViewOutput is a cWebRadio
51626>>>                    Set piColumnIndex to 3
51627>>>                    Set piColumnSpan  to 6
51628>>>                    Set psCaption to "View output in browser"
51629>>>                    Set psRadioValue to C_wqViewOutput
51630>>>                    Set pbServerOnChange to True
51631>>>                    Set psGroupName to "Output"
51632>>>                    Send SetSelected
51633>>>                    
51633>>>                    Procedure OnChange String sNewValue String sOldValue
51636>>>                        Send ChangeOutput sNewValue
51637>>>                    End_Procedure
51638>>>                    
51638>>>                End_Object
51639>>>                
51639>>>                Object oDownloadOutput is a cWebRadio
51641>>>                    Set piColumnIndex to 9
51642>>>                    Set piColumnSpan  to 5
51643>>>                    Set psCaption to "Download output to file"
51644>>>                    Set psRadioValue to C_wqDownloadOutput
51645>>>                    Set psGroupName to "Output"
51646>>>                End_Object
51647>>>
51647>>>                Object oOutputLab is a cWebLabel
51649>>>                    Set piColumnIndex to 1
51650>>>                    Set piColumnSpan  to 4
51651>>>                    Set psCaption to "Output destination: "
51652>>>                End_Object
51653>>>
51653>>>                Object oOutModal is a cWebRadio
51655>>>                    Set piColumnIndex to 5
51656>>>                    Set piColumnSpan  to 4
51657>>>                    Set psCaption to "Pop-up window"
51658>>>                    Set psRadioValue to C_wqModalWin
51659>>>                    Set psGroupName to "Destination"
51660>>>                End_Object
51661>>>                
51661>>>                Object oOutTab is a cWebRadio
51663>>>                    Set piColumnIndex to 9
51664>>>                    Set piColumnSpan  to 4
51665>>>                    Set psCaption to "New browser tab"
51666>>>                    Set psRadioValue to C_wqNewTab
51667>>>                    Set psGroupName to "Destination"
51668>>>                End_Object
51669>>>                
51669>>>                Object oOutWin is a cWebRadio
51671>>>                    Set piColumnIndex to 13
51672>>>                    Set piColumnSpan  to 5
51673>>>                    Set psCaption to "New browser window"
51674>>>                    Set psRadioValue to C_wqNewWin
51675>>>                    Set psGroupName to "Destination"
51676>>>                End_Object
51677>>>
51677>>>                Object oNewWarning is a cWebLabel
51679>>>                    Set piColumnIndex to 9
51680>>>                    Set piColumnSpan to 0
51681>>>                    Set psCaption to "Note: a new browser tab or window may be blocked by your browser settings or popup blocker - you should adjust them accordingly"
51682>>>                    Set psTextColor to "blue"
51683>>>                End_Object
51684>>>                
51684>>>                Object oLabFormat is a cWebLabel
51686>>>                    Set piColumnIndex to 1
51687>>>                    Set piColumnSpan  to 4
51688>>>                    Set psCaption to "Download format:"
51689>>>                    Set pbRender to False
51690>>>                End_Object
51691>>>
51691>>>                Object oOutHTML is a cWebRadio
51693>>>                    Set piColumnIndex to 5
51694>>>                    Set piColumnSpan  to 3
51695>>>                    Set psCaption to "HTML"
51696>>>                    Set psRadioValue to C_wqOutputHtml
51697>>>                    Set psGroupName to "Format"
51698>>>                    Set pbRender to False
51699>>>                    Set pbServerOnChange to True
51700>>>                    
51700>>>                    Procedure OnChange String sNewValue String sOldValue
51703>>>                        Send ChangeFormat sNewValue
51704>>>                    End_Procedure
51705>>>                    
51705>>>                End_Object
51706>>>                
51706>>>                Object oOutText is a cWebRadio
51708>>>                    Set piColumnIndex to 8
51709>>>                    Set piColumnSpan  to 3
51710>>>                    Set psCaption to "Text"
51711>>>                    Set psRadioValue to C_wqOutputText
51712>>>                    Set psGroupName to "Format"
51713>>>                    Set pbRender to False
51714>>>                End_Object
51715>>>                
51715>>>                Object oOutCSV is a cWebRadio
51717>>>                    Set piColumnIndex to 11
51718>>>                    Set piColumnSpan  to 3
51719>>>                    Set psCaption to "CSV"
51720>>>                    Set psRadioValue to C_wqOutputCSV
51721>>>                    Set psGroupName to "Format"
51722>>>                    Set pbRender to False
51723>>>                End_Object
51724>>>                
51724>>>                Object oOutXML is a cWebRadio
51726>>>                    Set piColumnIndex to 14
51727>>>                    Set piColumnSpan  to 3
51728>>>                    Set psCaption to "XML"
51729>>>                    Set psRadioValue to C_wqOutputXML
51730>>>                    Set psGroupName to "Format"
51731>>>                    Set pbRender to False
51732>>>                End_Object
51733>>>
51733>>>                Object oColHeads is a cWebCheckbox
51735>>>                    Set piColumnIndex to 11
51736>>>                    Set piColumnSpan to 4
51737>>>                    Set psCaption to "Include column headers in CSV"
51738>>>                    Set pbRender to False
51739>>>                    Set pbEnabled to False
51740>>>                End_Object
51741>>>
51741>>>            End_Object
51742>>>
51742>>>        End_Object
51743>>>
51743>>>        Object oRunButton is a cWebButton
51745>>>            Set piColumnSpan to 2
51746>>>            Set piColumnIndex to 16
51747>>>            Set psCaption to "Run"
51748>>>            Set pbShowWaitDialog to True
51749>>>            Set pbEnabled to False
51750>>>            
51750>>>            Procedure OnClick
51753>>>                Send AssembleQuery C_wqAssembleRun
51754>>>            End_Procedure
51755>>>            
51755>>>        End_Object
51756>>>
51756>>>        Object oCloseButton is a cWebButton
51758>>>            Set piColumnSpan to 2
51759>>>            Set piColumnIndex to 18
51760>>>            Set psCaption to "Close"
51761>>>        
51761>>>            Procedure OnClick
51764>>>                Send Hide
51765>>>            End_Procedure
51766>>>            
51766>>>        End_Object
51767>>>        
51767>>>    End_Object
51768>>>    
51768>>>End_Object
51769>
51769>    // This allows raw HTML output in reports, which permits interesting
51769>    // effects... but you may not want that.  It is false by default.
51769>    Set pbAllowRawOutput of oWebQuery to True
51770>    
51770>    // Fields (columns) can be excluded thus:
51770>    Send ExcludeField of ghoWebQry File_Field WebAppUser.Password
51771>    // Obviously we can't have the users seeing all the passwords!    
51771>    // The tables must be opened before such use, but WebAppUser will be
51771>    // opened by the WebApp itself.
51771>
51771>    // Tables can also be excluded (although this will break any relational
51771>    // chains which pass through them). Tables must be opened before these
51771>    // exclusions on them or their columns, otherwise errors will result.
51771> 
51771>    // The WebAppSession will automatically be open:
51771>    Send ExcludeTable of ghoWebQry WebAppSession.File_Number
51772>    // It is a VERY good idea to exclude this table since reading from it
51772>    // will cause a session timeout error!
51772>
51772>    // The OrderHea table needs to be opened before we can exclude it:
51772>    // Open OrderHea
51772>    // Send ExcludeTable of ghoWebQry OrderHea.File_Number
51772>    
51772>    // Setting pbUseSqlDefault will determine whether the "Use SQL" checkbox
51772>    // on the Output tab is checked by default.
51772>    // Set pbUseSqlDefault of oWebQuery to True
51772>End_Object
51773>
51773>Send StartWebApp of oWebApp
51774>
Summary
Memory Available: 939491328
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 29488
Total Resources: 0
Total Commands : 51773
Total Windows  : 1
Total Pages    : 1
Static Data    : 662407
Message area   : 302220
Total Blocks   : 20866
